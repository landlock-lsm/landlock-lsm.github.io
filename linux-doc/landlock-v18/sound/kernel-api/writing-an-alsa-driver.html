

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing an ALSA Driver &mdash; The Linux Kernel 5.7.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Designs and Implementations" href="../designs/index.html" />
    <link rel="prev" title="The ALSA Driver API" href="alsa-driver-api.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Sound Subsystem Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">ALSA Kernel API Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="alsa-driver-api.html">The ALSA Driver API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Writing an ALSA Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#preface">Preface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file-tree-structure">File Tree Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-flow-for-pci-drivers">Basic Flow for PCI Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#management-of-cards-and-components">Management of Cards and Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pci-resource-management">PCI Resource Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pcm-interface">PCM Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-interface">Control Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-for-ac97-codec">API for AC97 Codec</a></li>
<li class="toctree-l4"><a class="reference internal" href="#midi-mpu401-uart-interface">MIDI (MPU401-UART) Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rawmidi-interface">RawMIDI Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#miscellaneous-devices">Miscellaneous Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proc-interface">Proc Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-management">Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parameters">Module Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-put-your-driver-into-alsa-tree">How To Put Your Driver Into ALSA Tree</a></li>
<li class="toctree-l4"><a class="reference internal" href="#useful-functions">Useful Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../designs/index.html">Designs and Implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soc/index.html">ALSA SoC Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../alsa-configuration.html">Advanced Linux Sound Architecture - Driver Configuration guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hd-audio/index.html">HD-Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cards/index.html">Card-Specific Information</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Sound Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="index.html">ALSA Kernel API Documentation</a> &raquo;</li>
        
      <li>Writing an ALSA Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/sound/kernel-api/writing-an-alsa-driver.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-an-alsa-driver">
<h1>Writing an ALSA Driver<a class="headerlink" href="#writing-an-alsa-driver" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Takashi Iwai &lt;<a class="reference external" href="mailto:tiwai&#37;&#52;&#48;suse&#46;de">tiwai<span>&#64;</span>suse<span>&#46;</span>de</a>&gt;</p>
</dd>
</dl>
<div class="section" id="preface">
<h2>Preface<a class="headerlink" href="#preface" title="Permalink to this headline">¶</a></h2>
<p>This document describes how to write an <a class="reference external" href="http://www.alsa-project.org/">ALSA (Advanced Linux Sound
Architecture)</a> driver. The document
focuses mainly on PCI soundcards. In the case of other device types, the
API might be different, too. However, at least the ALSA kernel API is
consistent, and therefore it would be still a bit help for writing them.</p>
<p>This document targets people who already have enough C language skills
and have basic linux kernel programming knowledge. This document doesn’t
explain the general topic of linux kernel coding and doesn’t cover
low-level driver implementation details. It only describes the standard
way to write a PCI sound driver on ALSA.</p>
<p>This document is still a draft version. Any feedback and corrections,
please!!</p>
</div>
<div class="section" id="file-tree-structure">
<h2>File Tree Structure<a class="headerlink" href="#file-tree-structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general">
<h3>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<p>The file tree structure of ALSA driver is depicted below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sound
        /core
                /oss
                /seq
                        /oss
        /include
        /drivers
                /mpu401
                /opl3
        /i2c
        /synth
                /emux
        /pci
                /(cards)
        /isa
                /(cards)
        /arm
        /ppc
        /sparc
        /usb
        /pcmcia /(cards)
        /soc
        /oss
</pre></div>
</div>
</div>
<div class="section" id="core-directory">
<h3>core directory<a class="headerlink" href="#core-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the middle layer which is the heart of ALSA
drivers. In this directory, the native ALSA modules are stored. The
sub-directories contain different modules and are dependent upon the
kernel config.</p>
<div class="section" id="core-oss">
<h4>core/oss<a class="headerlink" href="#core-oss" title="Permalink to this headline">¶</a></h4>
<p>The codes for PCM and mixer OSS emulation modules are stored in this
directory. The rawmidi OSS emulation is included in the ALSA rawmidi
code since it’s quite small. The sequencer code is stored in
<code class="docutils literal notranslate"><span class="pre">core/seq/oss</span></code> directory (see <a class="reference external" href="#core-seq-oss">below</a>).</p>
</div>
<div class="section" id="core-seq">
<h4>core/seq<a class="headerlink" href="#core-seq" title="Permalink to this headline">¶</a></h4>
<p>This directory and its sub-directories are for the ALSA sequencer. This
directory contains the sequencer core and primary sequencer modules such
like snd-seq-midi, snd-seq-virmidi, etc. They are compiled only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_SEQUENCER</span></code> is set in the kernel config.</p>
</div>
<div class="section" id="core-seq-oss">
<h4>core/seq/oss<a class="headerlink" href="#core-seq-oss" title="Permalink to this headline">¶</a></h4>
<p>This contains the OSS sequencer emulation codes.</p>
</div>
</div>
<div class="section" id="include-directory">
<h3>include directory<a class="headerlink" href="#include-directory" title="Permalink to this headline">¶</a></h3>
<p>This is the place for the public header files of ALSA drivers, which are
to be exported to user-space, or included by several files at different
directories. Basically, the private header files should not be placed in
this directory, but you may still find files there, due to historical
reasons :)</p>
</div>
<div class="section" id="drivers-directory">
<h3>drivers directory<a class="headerlink" href="#drivers-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains code shared among different drivers on different
architectures. They are hence supposed not to be architecture-specific.
For example, the dummy pcm driver and the serial MIDI driver are found
in this directory. In the sub-directories, there is code for components
which are independent from bus and cpu architectures.</p>
<div class="section" id="drivers-mpu401">
<h4>drivers/mpu401<a class="headerlink" href="#drivers-mpu401" title="Permalink to this headline">¶</a></h4>
<p>The MPU401 and MPU401-UART modules are stored here.</p>
</div>
<div class="section" id="drivers-opl3-and-opl4">
<h4>drivers/opl3 and opl4<a class="headerlink" href="#drivers-opl3-and-opl4" title="Permalink to this headline">¶</a></h4>
<p>The OPL3 and OPL4 FM-synth stuff is found here.</p>
</div>
</div>
<div class="section" id="i2c-directory">
<h3>i2c directory<a class="headerlink" href="#i2c-directory" title="Permalink to this headline">¶</a></h3>
<p>This contains the ALSA i2c components.</p>
<p>Although there is a standard i2c layer on Linux, ALSA has its own i2c
code for some cards, because the soundcard needs only a simple operation
and the standard i2c API is too complicated for such a purpose.</p>
</div>
<div class="section" id="synth-directory">
<h3>synth directory<a class="headerlink" href="#synth-directory" title="Permalink to this headline">¶</a></h3>
<p>This contains the synth middle-level modules.</p>
<p>So far, there is only Emu8000/Emu10k1 synth driver under the
<code class="docutils literal notranslate"><span class="pre">synth/emux</span></code> sub-directory.</p>
</div>
<div class="section" id="pci-directory">
<h3>pci directory<a class="headerlink" href="#pci-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory and its sub-directories hold the top-level card modules
for PCI soundcards and the code specific to the PCI BUS.</p>
<p>The drivers compiled from a single file are stored directly in the pci
directory, while the drivers with several source files are stored on
their own sub-directory (e.g. emu10k1, ice1712).</p>
</div>
<div class="section" id="isa-directory">
<h3>isa directory<a class="headerlink" href="#isa-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory and its sub-directories hold the top-level card modules
for ISA soundcards.</p>
</div>
<div class="section" id="arm-ppc-and-sparc-directories">
<h3>arm, ppc, and sparc directories<a class="headerlink" href="#arm-ppc-and-sparc-directories" title="Permalink to this headline">¶</a></h3>
<p>They are used for top-level card modules which are specific to one of
these architectures.</p>
</div>
<div class="section" id="usb-directory">
<h3>usb directory<a class="headerlink" href="#usb-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the USB-audio driver. In the latest version, the
USB MIDI driver is integrated in the usb-audio driver.</p>
</div>
<div class="section" id="pcmcia-directory">
<h3>pcmcia directory<a class="headerlink" href="#pcmcia-directory" title="Permalink to this headline">¶</a></h3>
<p>The PCMCIA, especially PCCard drivers will go here. CardBus drivers will
be in the pci directory, because their API is identical to that of
standard PCI cards.</p>
</div>
<div class="section" id="soc-directory">
<h3>soc directory<a class="headerlink" href="#soc-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the codes for ASoC (ALSA System on Chip)
layer including ASoC core, codec and machine drivers.</p>
</div>
<div class="section" id="oss-directory">
<h3>oss directory<a class="headerlink" href="#oss-directory" title="Permalink to this headline">¶</a></h3>
<p>Here contains OSS/Lite codes.
All codes have been deprecated except for dmasound on m68k as of
writing this.</p>
</div>
</div>
<div class="section" id="basic-flow-for-pci-drivers">
<h2>Basic Flow for PCI Drivers<a class="headerlink" href="#basic-flow-for-pci-drivers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="outline">
<h3>Outline<a class="headerlink" href="#outline" title="Permalink to this headline">¶</a></h3>
<p>The minimum flow for PCI soundcards is as follows:</p>
<ul class="simple">
<li><p>define the PCI ID table (see the section <a class="reference internal" href="#pci-entries">PCI Entries</a>).</p></li>
<li><p>create <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback.</p></li>
<li><p>create <code class="docutils literal notranslate"><span class="pre">remove</span></code> callback.</p></li>
<li><p>create a <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a> structure
containing the three pointers above.</p></li>
<li><p>create an <code class="docutils literal notranslate"><span class="pre">init</span></code> function just calling the
<code class="xref c c-func docutils literal notranslate"><span class="pre">pci_register_driver()</span></code> to register the pci_driver
table defined above.</p></li>
<li><p>create an <code class="docutils literal notranslate"><span class="pre">exit</span></code> function to call the
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_unregister_driver" title="pci_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_unregister_driver()</span></code></a> function.</p></li>
</ul>
</div>
<div class="section" id="full-code-example">
<h3>Full Code Example<a class="headerlink" href="#full-code-example" title="Permalink to this headline">¶</a></h3>
<p>The code example is shown below. Some parts are kept unimplemented at
this moment but will be filled in the next sections. The numbers in the
comment lines of the <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_probe()</span></code> function refer
to details explained in the following section.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/init.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;sound/core.h&gt;
#include &lt;sound/initval.h&gt;

/* module parameters (see &quot;Module Parameters&quot;) */
/* SNDRV_CARDS: maximum number of cards supported by this module */
static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;

/* definition of the chip-specific record */
struct mychip {
        struct snd_card *card;
        /* the rest of the implementation will be in section
         * &quot;PCI Resource Management&quot;
         */
};

/* chip-specific destructor
 * (see &quot;PCI Resource Management&quot;)
 */
static int snd_mychip_free(struct mychip *chip)
{
        .... /* will be implemented later... */
}

/* component-destructor
 * (see &quot;Management of Cards and Components&quot;)
 */
static int snd_mychip_dev_free(struct snd_device *device)
{
        return snd_mychip_free(device-&gt;device_data);
}

/* chip-specific constructor
 * (see &quot;Management of Cards and Components&quot;)
 */
static int snd_mychip_create(struct snd_card *card,
                             struct pci_dev *pci,
                             struct mychip **rchip)
{
        struct mychip *chip;
        int err;
        static const struct snd_device_ops ops = {
               .dev_free = snd_mychip_dev_free,
        };

        *rchip = NULL;

        /* check PCI availability here
         * (see &quot;PCI Resource Management&quot;)
         */
        ....

        /* allocate a chip-specific data with zero filled */
        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        if (chip == NULL)
                return -ENOMEM;

        chip-&gt;card = card;

        /* rest of initialization here; will be implemented
         * later, see &quot;PCI Resource Management&quot;
         */
        ....

        err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
        if (err &lt; 0) {
                snd_mychip_free(chip);
                return err;
        }

        *rchip = chip;
        return 0;
}

/* constructor -- see &quot;Driver Constructor&quot; sub-section */
static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        static int dev;
        struct snd_card *card;
        struct mychip *chip;
        int err;

        /* (1) */
        if (dev &gt;= SNDRV_CARDS)
                return -ENODEV;
        if (!enable[dev]) {
                dev++;
                return -ENOENT;
        }

        /* (2) */
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           0, &amp;card);
        if (err &lt; 0)
                return err;

        /* (3) */
        err = snd_mychip_create(card, pci, &amp;chip);
        if (err &lt; 0)
                goto error;

        /* (4) */
        strcpy(card-&gt;driver, &quot;My Chip&quot;);
        strcpy(card-&gt;shortname, &quot;My Own Chip 123&quot;);
        sprintf(card-&gt;longname, &quot;%s at 0x%lx irq %i&quot;,
                card-&gt;shortname, chip-&gt;port, chip-&gt;irq);

        /* (5) */
        .... /* implemented later */

        /* (6) */
        err = snd_card_register(card);
        if (err &lt; 0)
                goto error;

        /* (7) */
        pci_set_drvdata(pci, card);
        dev++;
        return 0;

error:
        snd_card_free(card);
        return err;
}

/* destructor -- see the &quot;Destructor&quot; sub-section */
static void snd_mychip_remove(struct pci_dev *pci)
{
        snd_card_free(pci_get_drvdata(pci));
}
</pre></div>
</div>
</div>
<div class="section" id="driver-constructor">
<h3>Driver Constructor<a class="headerlink" href="#driver-constructor" title="Permalink to this headline">¶</a></h3>
<p>The real constructor of PCI drivers is the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback. The
<code class="docutils literal notranslate"><span class="pre">probe</span></code> callback and other component-constructors which are called
from the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback cannot be used with the <code class="docutils literal notranslate"><span class="pre">__init</span></code> prefix
because any PCI device could be a hotplug device.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback, the following scheme is often used.</p>
<div class="section" id="check-and-increment-the-device-index">
<h4>1) Check and increment the device index.<a class="headerlink" href="#check-and-increment-the-device-index" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int dev;
....
if (dev &gt;= SNDRV_CARDS)
        return -ENODEV;
if (!enable[dev]) {
        dev++;
        return -ENOENT;
}
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">enable[dev]</span></code> is the module option.</p>
<p>Each time the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback is called, check the availability of
the device. If not available, simply increment the device index and
returns. dev will be incremented also later (<a class="reference external" href="#set-the-pci-driver-data-and-return-zero">step 7</a>).</p>
</div>
<div class="section" id="create-a-card-instance">
<h4>2) Create a card instance<a class="headerlink" href="#create-a-card-instance" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
int err;
....
err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   0, &amp;card);
</pre></div>
</div>
<p>The details will be explained in the section <a class="reference internal" href="#management-of-cards-and-components">Management of Cards and
Components</a>.</p>
</div>
<div class="section" id="create-a-main-component">
<h4>3) Create a main component<a class="headerlink" href="#create-a-main-component" title="Permalink to this headline">¶</a></h4>
<p>In this part, the PCI resources are allocated.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip *chip;
....
err = snd_mychip_create(card, pci, &amp;chip);
if (err &lt; 0)
        goto error;
</pre></div>
</div>
<p>The details will be explained in the section <a class="reference internal" href="#pci-resource-management">PCI Resource
Management</a>.</p>
<p>When something goes wrong, the probe function needs to deal with the
error.  In this example, we have a single error handling path placed
at the end of the function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>error:
        snd_card_free(card);
        return err;
</pre></div>
</div>
<p>Since each component can be properly freed, the single
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> call should suffice in most cases.</p>
</div>
<div class="section" id="set-the-driver-id-and-name-strings">
<h4>4) Set the driver ID and name strings.<a class="headerlink" href="#set-the-driver-id-and-name-strings" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>strcpy(card-&gt;driver, &quot;My Chip&quot;);
strcpy(card-&gt;shortname, &quot;My Own Chip 123&quot;);
sprintf(card-&gt;longname, &quot;%s at 0x%lx irq %i&quot;,
        card-&gt;shortname, chip-&gt;port, chip-&gt;irq);
</pre></div>
</div>
<p>The driver field holds the minimal ID string of the chip. This is used
by alsa-lib’s configurator, so keep it simple but unique. Even the
same driver can have different driver IDs to distinguish the
functionality of each chip type.</p>
<p>The shortname field is a string shown as more verbose name. The longname
field contains the information shown in <code class="docutils literal notranslate"><span class="pre">/proc/asound/cards</span></code>.</p>
</div>
<div class="section" id="create-other-components-such-as-mixer-midi-etc">
<h4>5) Create other components, such as mixer, MIDI, etc.<a class="headerlink" href="#create-other-components-such-as-mixer-midi-etc" title="Permalink to this headline">¶</a></h4>
<p>Here you define the basic components such as <a class="reference external" href="#PCM-Interface">PCM</a>,
mixer (e.g. <a class="reference external" href="#API-for-AC97-Codec">AC97</a>), MIDI (e.g.
<a class="reference external" href="#MIDI-MPU401-UART-Interface">MPU-401</a>), and other interfaces.
Also, if you want a <a class="reference external" href="#Proc-Interface">proc file</a>, define it here,
too.</p>
</div>
<div class="section" id="register-the-card-instance">
<h4>6) Register the card instance.<a class="headerlink" href="#register-the-card-instance" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_card_register(card);
if (err &lt; 0)
        goto error;
</pre></div>
</div>
<p>Will be explained in the section <a class="reference internal" href="#management-of-cards-and-components">Management of Cards and
Components</a>, too.</p>
</div>
<div class="section" id="set-the-pci-driver-data-and-return-zero">
<h4>7) Set the PCI driver data and return zero.<a class="headerlink" href="#set-the-pci-driver-data-and-return-zero" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_set_drvdata(pci, card);
dev++;
return 0;
</pre></div>
</div>
<p>In the above, the card record is stored. This pointer is used in the
remove callback and power-management callbacks, too.</p>
</div>
</div>
<div class="section" id="destructor">
<h3>Destructor<a class="headerlink" href="#destructor" title="Permalink to this headline">¶</a></h3>
<p>The destructor, remove callback, simply releases the card instance. Then
the ALSA middle layer will release all the attached components
automatically.</p>
<p>It would be typically just <code class="xref c c-func docutils literal notranslate"><span class="pre">calling</span> <span class="pre">snd_card_free()</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_mychip_remove(struct pci_dev *pci)
{
        snd_card_free(pci_get_drvdata(pci));
}
</pre></div>
</div>
<p>The above code assumes that the card pointer is set to the PCI driver
data.</p>
</div>
<div class="section" id="header-files">
<h3>Header Files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h3>
<p>For the above example, at least the following include files are
necessary.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/init.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;sound/core.h&gt;
#include &lt;sound/initval.h&gt;
</pre></div>
</div>
<p>where the last one is necessary only when module options are defined
in the source file. If the code is split into several files, the files
without module options don’t need them.</p>
<p>In addition to these headers, you’ll need <code class="docutils literal notranslate"><span class="pre">&lt;linux/interrupt.h&gt;</span></code> for
interrupt handling, and <code class="docutils literal notranslate"><span class="pre">&lt;linux/io.h&gt;</span></code> for I/O access. If you use the
<code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> functions, you’ll need
to include <code class="docutils literal notranslate"><span class="pre">&lt;linux/delay.h&gt;</span></code> too.</p>
<p>The ALSA interfaces like the PCM and control APIs are defined in other
<code class="docutils literal notranslate"><span class="pre">&lt;sound/xxx.h&gt;</span></code> header files. They have to be included after
<code class="docutils literal notranslate"><span class="pre">&lt;sound/core.h&gt;</span></code>.</p>
</div>
</div>
<div class="section" id="management-of-cards-and-components">
<h2>Management of Cards and Components<a class="headerlink" href="#management-of-cards-and-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="card-instance">
<h3>Card Instance<a class="headerlink" href="#card-instance" title="Permalink to this headline">¶</a></h3>
<p>For each soundcard, a “card” record must be allocated.</p>
<p>A card record is the headquarters of the soundcard. It manages the whole
list of devices (components) on the soundcard, such as PCM, mixers,
MIDI, synthesizer, and so on. Also, the card record holds the ID and the
name strings of the card, manages the root of proc files, and controls
the power-management states and hotplug disconnections. The component
list on the card record is used to manage the correct release of
resources at destruction.</p>
<p>As mentioned above, to create a card instance, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
int err;
err = snd_card_new(&amp;pci-&gt;dev, index, id, module, extra_size, &amp;card);
</pre></div>
</div>
<p>The function takes six arguments: the parent device pointer, the
card-index number, the id string, the module pointer (usually
<code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code>), the size of extra-data space, and the pointer to
return the card instance. The extra_size argument is used to allocate
card-&gt;private_data for the chip-specific data. Note that these data are
allocated by <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.</p>
<p>The first argument, the pointer of struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>, specifies the parent device. For PCI devices, typically
<code class="docutils literal notranslate"><span class="pre">&amp;pci-&gt;</span></code> is passed there.</p>
</div>
<div class="section" id="components">
<h3>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h3>
<p>After the card is created, you can attach the components (devices) to
the card instance. In an ALSA driver, a component is represented as a
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_device</span></code> object. A component
can be a PCM instance, a control interface, a raw MIDI interface, etc.
Each such instance has one component entry.</p>
<p>A component can be created via <a class="reference internal" href="../../driver-api/sound.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a>
function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_device_new(card, SNDRV_DEV_XXX, chip, &amp;ops);
</pre></div>
</div>
<p>This takes the card pointer, the device-level (<code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_XXX</span></code>), the
data pointer, and the callback pointers (<code class="docutils literal notranslate"><span class="pre">&amp;ops</span></code>). The device-level
defines the type of components and the order of registration and
de-registration. For most components, the device-level is already
defined. For a user-defined component, you can use
<code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_LOWLEVEL</span></code>.</p>
<p>This function itself doesn’t allocate the data space. The data must be
allocated manually beforehand, and its pointer is passed as the
argument. This pointer (<code class="docutils literal notranslate"><span class="pre">chip</span></code> in the above example) is used as the
identifier for the instance.</p>
<p>Each pre-defined ALSA component such as ac97 and pcm calls
<a class="reference internal" href="../../driver-api/sound.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a> inside its constructor. The destructor
for each component is defined in the callback pointers. Hence, you don’t
need to take care of calling a destructor for such a component.</p>
<p>If you wish to create your own component, you need to set the destructor
function to the dev_free callback in the <code class="docutils literal notranslate"><span class="pre">ops</span></code>, so that it can be
released automatically via <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>. The next
example will show an implementation of chip-specific data.</p>
</div>
<div class="section" id="chip-specific-data">
<h3>Chip-Specific Data<a class="headerlink" href="#chip-specific-data" title="Permalink to this headline">¶</a></h3>
<p>Chip-specific information, e.g. the I/O port address, its resource
pointer, or the irq number, is stored in the chip-specific record.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
};
</pre></div>
</div>
<p>In general, there are two ways of allocating the chip record.</p>
<div class="section" id="allocating-via-snd-card-new">
<h4>1. Allocating via <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.<a class="headerlink" href="#allocating-via-snd-card-new" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, you can pass the extra-data-length to the 5th
argument of <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>, i.e.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   sizeof(struct mychip), &amp;card);
</pre></div>
</div>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mychip</span></code> is the type of the chip record.</p>
<p>In return, the allocated record can be accessed as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip *chip = card-&gt;private_data;
</pre></div>
</div>
<p>With this method, you don’t have to allocate twice. The record is
released together with the card instance.</p>
</div>
<div class="section" id="allocating-an-extra-device">
<h4>2. Allocating an extra device.<a class="headerlink" href="#allocating-an-extra-device" title="Permalink to this headline">¶</a></h4>
<p>After allocating a card instance via <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>
(with <code class="docutils literal notranslate"><span class="pre">0</span></code> on the 4th arg), call <a class="reference internal" href="../../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
struct mychip *chip;
err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   0, &amp;card);
.....
chip = kzalloc(sizeof(*chip), GFP_KERNEL);
</pre></div>
</div>
<p>The chip record should have the field to hold the card pointer at least,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;
        ....
};
</pre></div>
</div>
<p>Then, set the card pointer in the returned chip instance.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>chip-&gt;card = card;
</pre></div>
</div>
<p>Next, initialize the fields, and register this chip record as a
low-level device with a specified <code class="docutils literal notranslate"><span class="pre">ops</span></code>,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct snd_device_ops ops = {
        .dev_free =        snd_mychip_dev_free,
};
....
snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
</pre></div>
</div>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_dev_free()</span></code> is the device-destructor
function, which will call the real destructor.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_dev_free(struct snd_device *device)
{
        return snd_mychip_free(device-&gt;device_data);
}
</pre></div>
</div>
<p>where <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_free()</span></code> is the real destructor.</p>
<p>The demerit of this method is the obviously more amount of codes.
The merit is, however, you can trigger the own callback at registering
and disconnecting the card via setting in snd_device_ops.
About the registering and disconnecting the card, see the subsections
below.</p>
</div>
</div>
<div class="section" id="registration-and-release">
<h3>Registration and Release<a class="headerlink" href="#registration-and-release" title="Permalink to this headline">¶</a></h3>
<p>After all components are assigned, register the card instance by calling
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>. Access to the device files is
enabled at this point. That is, before
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> is called, the components are safely
inaccessible from external side. If this call fails, exit the probe
function after releasing the card via <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>.</p>
<p>For releasing the card instance, you can call simply
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>. As mentioned earlier, all components
are released automatically by this call.</p>
<p>For a device which allows hotplugging, you can use
<a class="reference internal" href="../../driver-api/sound.html#c.snd_card_free_when_closed" title="snd_card_free_when_closed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_when_closed()</span></code></a>. This one will postpone
the destruction until all devices are closed.</p>
</div>
</div>
<div class="section" id="pci-resource-management">
<h2>PCI Resource Management<a class="headerlink" href="#pci-resource-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Full Code Example<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In this section, we’ll complete the chip-specific constructor,
destructor and PCI entries. Example code is shown first, below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;
        struct pci_dev *pci;

        unsigned long port;
        int irq;
};

static int snd_mychip_free(struct mychip *chip)
{
        /* disable hardware here if any */
        .... /* (not implemented in this document) */

        /* release the irq */
        if (chip-&gt;irq &gt;= 0)
                free_irq(chip-&gt;irq, chip);
        /* release the I/O ports &amp; memory */
        pci_release_regions(chip-&gt;pci);
        /* disable the PCI entry */
        pci_disable_device(chip-&gt;pci);
        /* release the data */
        kfree(chip);
        return 0;
}

/* chip-specific constructor */
static int snd_mychip_create(struct snd_card *card,
                             struct pci_dev *pci,
                             struct mychip **rchip)
{
        struct mychip *chip;
        int err;
        static const struct snd_device_ops ops = {
               .dev_free = snd_mychip_dev_free,
        };

        *rchip = NULL;

        /* initialize the PCI entry */
        err = pci_enable_device(pci);
        if (err &lt; 0)
                return err;
        /* check PCI availability (28bit DMA) */
        if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||
            pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {
                printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
                pci_disable_device(pci);
                return -ENXIO;
        }

        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        if (chip == NULL) {
                pci_disable_device(pci);
                return -ENOMEM;
        }

        /* initialize the stuff */
        chip-&gt;card = card;
        chip-&gt;pci = pci;
        chip-&gt;irq = -1;

        /* (1) PCI resource allocation */
        err = pci_request_regions(pci, &quot;My Chip&quot;);
        if (err &lt; 0) {
                kfree(chip);
                pci_disable_device(pci);
                return err;
        }
        chip-&gt;port = pci_resource_start(pci, 0);
        if (request_irq(pci-&gt;irq, snd_mychip_interrupt,
                        IRQF_SHARED, KBUILD_MODNAME, chip)) {
                printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&gt;irq);
                snd_mychip_free(chip);
                return -EBUSY;
        }
        chip-&gt;irq = pci-&gt;irq;
        card-&gt;sync_irq = chip-&gt;irq;

        /* (2) initialization of the chip hardware */
        .... /*   (not implemented in this document) */

        err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
        if (err &lt; 0) {
                snd_mychip_free(chip);
                return err;
        }

        *rchip = chip;
        return 0;
}

/* PCI IDs */
static struct pci_device_id snd_mychip_ids[] = {
        { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
        ....
        { 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);

/* pci_driver definition */
static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_mychip_ids,
        .probe = snd_mychip_probe,
        .remove = snd_mychip_remove,
};

/* module initialization */
static int __init alsa_card_mychip_init(void)
{
        return pci_register_driver(&amp;driver);
}

/* module clean up */
static void __exit alsa_card_mychip_exit(void)
{
        pci_unregister_driver(&amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)

EXPORT_NO_SYMBOLS; /* for old kernels only */
</pre></div>
</div>
</div>
<div class="section" id="some-hafta-s">
<h3>Some Hafta’s<a class="headerlink" href="#some-hafta-s" title="Permalink to this headline">¶</a></h3>
<p>The allocation of PCI resources is done in the <code class="docutils literal notranslate"><span class="pre">probe</span></code> function, and
usually an extra <code class="xref c c-func docutils literal notranslate"><span class="pre">xxx_create()</span></code> function is written for this
purpose.</p>
<p>In the case of PCI devices, you first have to call the
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a> function before allocating
resources. Also, you need to set the proper PCI DMA mask to limit the
accessed I/O range. In some cases, you might need to call
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_set_master" title="pci_set_master"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_master()</span></code></a> function, too.</p>
<p>Suppose the 28bit mask, and the code to be added would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_enable_device(pci);
if (err &lt; 0)
        return err;
if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||
    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {
        printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
        pci_disable_device(pci);
        return -ENXIO;
}
</pre></div>
</div>
</div>
<div class="section" id="resource-allocation">
<h3>Resource Allocation<a class="headerlink" href="#resource-allocation" title="Permalink to this headline">¶</a></h3>
<p>The allocation of I/O ports and irqs is done via standard kernel
functions.  These resources must be released in the destructor
function (see below).</p>
<p>Now assume that the PCI device has an I/O port with 8 bytes and an
interrupt. Then <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mychip</span></code> will have the
following fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;

        unsigned long port;
        int irq;
};
</pre></div>
</div>
<p>For an I/O port (and also a memory region), you need to have the
resource pointer for the standard resource management. For an irq, you
have to keep only the irq number (integer). But you need to initialize
this number as -1 before actual allocation, since irq 0 is valid. The
port address and its resource pointer can be initialized as null by
<a class="reference internal" href="../../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> automatically, so you don’t have to take care of
resetting them.</p>
<p>The allocation of an I/O port is done like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        pci_disable_device(pci);
        return err;
}
chip-&gt;port = pci_resource_start(pci, 0);
</pre></div>
</div>
<p>It will reserve the I/O port region of 8 bytes of the given PCI device.
The returned value, <code class="docutils literal notranslate"><span class="pre">chip-&gt;res_port</span></code>, is allocated via
<a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> by <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code>. The pointer
must be released via <a class="reference internal" href="../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>, but there is a problem with
this. This issue will be explained later.</p>
<p>The allocation of an interrupt source is done like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (request_irq(pci-&gt;irq, snd_mychip_interrupt,
                IRQF_SHARED, KBUILD_MODNAME, chip)) {
        printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&gt;irq);
        snd_mychip_free(chip);
        return -EBUSY;
}
chip-&gt;irq = pci-&gt;irq;
</pre></div>
</div>
<p>where <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_interrupt()</span></code> is the interrupt handler
defined <a class="reference external" href="#pcm-interface-interrupt-handler">later</a>. Note that
<code class="docutils literal notranslate"><span class="pre">chip-&gt;irq</span></code> should be defined only when <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>
succeeded.</p>
<p>On the PCI bus, interrupts can be shared. Thus, <code class="docutils literal notranslate"><span class="pre">IRQF_SHARED</span></code> is used
as the interrupt flag of <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>.</p>
<p>The last argument of <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> is the data pointer
passed to the interrupt handler. Usually, the chip-specific record is
used for that, but you can use what you like, too.</p>
<p>I won’t give details about the interrupt handler at this point, but at
least its appearance can be explained now. The interrupt handler looks
usually like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        ....
        return IRQ_HANDLED;
}
</pre></div>
</div>
<p>After requesting the IRQ, you can passed it to <code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code>
field:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>card-&gt;irq = chip-&gt;irq;
</pre></div>
</div>
<p>This allows PCM core automatically performing
<a class="reference internal" href="../../core-api/kernel-api.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> at the necessary timing like <code class="docutils literal notranslate"><span class="pre">hw_free</span></code>.
See the later section <a class="reference internal" href="#sync-stop-callback">sync_stop callback</a> for details.</p>
<p>Now let’s write the corresponding destructor for the resources above.
The role of destructor is simple: disable the hardware (if already
activated) and release the resources. So far, we have no hardware part,
so the disabling code is not written here.</p>
<p>To release the resources, the “check-and-release” method is a safer way.
For the interrupt, do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (chip-&gt;irq &gt;= 0)
        free_irq(chip-&gt;irq, chip);
</pre></div>
</div>
<p>Since the irq number can start from 0, you should initialize
<code class="docutils literal notranslate"><span class="pre">chip-&gt;irq</span></code> with a negative value (e.g. -1), so that you can check
the validity of the irq number as above.</p>
<p>When you requested I/O ports or memory regions via
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a> or
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a> like in this example, release the
resource(s) using the corresponding function,
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_release_region" title="pci_release_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_release_region()</span></code></a> or
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_release_regions" title="pci_release_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_release_regions()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_release_regions(chip-&gt;pci);
</pre></div>
</div>
<p>When you requested manually via <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">request_mem_region()</span></code>, you can release it via
<a class="reference internal" href="../../core-api/kernel-api.html#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_resource()</span></code></a>. Suppose that you keep the resource
pointer returned from <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code> in
chip-&gt;res_port, the release procedure looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>release_and_free_resource(chip-&gt;res_port);
</pre></div>
</div>
<p>Don’t forget to call <a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_disable_device" title="pci_disable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_device()</span></code></a> before the
end.</p>
<p>And finally, release the chip-specific record.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kfree(chip);
</pre></div>
</div>
<p>We didn’t implement the hardware disabling part in the above. If you
need to do this, please note that the destructor may be called even
before the initialization of the chip is completed. It would be better
to have a flag to skip hardware disabling if the hardware was not
initialized yet.</p>
<p>When the chip-data is assigned to the card using
<a class="reference internal" href="../../driver-api/sound.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_LOWLELVEL</span></code> , its
destructor is called at the last. That is, it is assured that all other
components like PCMs and controls have already been released. You don’t
have to stop PCMs, etc. explicitly, but just call low-level hardware
stopping.</p>
<p>The management of a memory-mapped region is almost as same as the
management of an I/O port. You’ll need three fields like the
following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
        unsigned long iobase_phys;
        void __iomem *iobase_virt;
};
</pre></div>
</div>
<p>and the allocation would be like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        return err;
}
chip-&gt;iobase_phys = pci_resource_start(pci, 0);
chip-&gt;iobase_virt = ioremap(chip-&gt;iobase_phys,
                                    pci_resource_len(pci, 0));
</pre></div>
</div>
<p>and the corresponding destructor would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_free(struct mychip *chip)
{
        ....
        if (chip-&gt;iobase_virt)
                iounmap(chip-&gt;iobase_virt);
        ....
        pci_release_regions(chip-&gt;pci);
        ....
}
</pre></div>
</div>
<p>Of course, a modern way with <a class="reference internal" href="../../driver-api/device-io.html#c.pci_iomap" title="pci_iomap"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_iomap()</span></code></a> will make things a
bit easier, too.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        return err;
}
chip-&gt;iobase_virt = pci_iomap(pci, 0, 0);
</pre></div>
</div>
<p>which is paired with <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_iounmap()</span></code> at destructor.</p>
</div>
<div class="section" id="pci-entries">
<h3>PCI Entries<a class="headerlink" href="#pci-entries" title="Permalink to this headline">¶</a></h3>
<p>So far, so good. Let’s finish the missing PCI stuff. At first, we need a
<a class="reference internal" href="../../driver-api/basics.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> table for
this chipset. It’s a table of PCI vendor/device ID number, and some
masks.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct pci_device_id snd_mychip_ids[] = {
        { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
        ....
        { 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);
</pre></div>
</div>
<p>The first and second fields of the <a class="reference internal" href="../../driver-api/basics.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> structure are the vendor and device IDs. If you
have no reason to filter the matching devices, you can leave the
remaining fields as above. The last field of the <a class="reference internal" href="../../driver-api/basics.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">pci_device_id</span></code></a> struct contains private data
for this entry. You can specify any value here, for example, to define
specific operations for supported device IDs. Such an example is found
in the intel8x0 driver.</p>
<p>The last entry of this list is the terminator. You must specify this
all-zero entry.</p>
<p>Then, prepare the <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a>
record:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_mychip_ids,
        .probe = snd_mychip_probe,
        .remove = snd_mychip_remove,
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">probe</span></code> and <code class="docutils literal notranslate"><span class="pre">remove</span></code> functions have already been defined in
the previous sections. The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is the name string of this
device. Note that you must not use a slash “/” in this string.</p>
<p>And at last, the module entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __init alsa_card_mychip_init(void)
{
        return pci_register_driver(&amp;driver);
}

static void __exit alsa_card_mychip_exit(void)
{
        pci_unregister_driver(&amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)
</pre></div>
</div>
<p>Note that these module entries are tagged with <code class="docutils literal notranslate"><span class="pre">__init</span></code> and <code class="docutils literal notranslate"><span class="pre">__exit</span></code>
prefixes.</p>
<p>That’s all!</p>
</div>
</div>
<div class="section" id="pcm-interface">
<h2>PCM Interface<a class="headerlink" href="#pcm-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>General<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The PCM middle layer of ALSA is quite powerful and it is only necessary
for each driver to implement the low-level functions to access its
hardware.</p>
<p>For accessing to the PCM layer, you need to include <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>
first. In addition, <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm_params.h&gt;</span></code> might be needed if you
access to some functions related with hw_param.</p>
<p>Each card device can have up to four pcm instances. A pcm instance
corresponds to a pcm device file. The limitation of number of instances
comes only from the available bit size of the Linux’s device numbers.
Once when 64bit device number is used, we’ll have more pcm instances
available.</p>
<p>A pcm instance consists of pcm playback and capture streams, and each
pcm stream consists of one or more pcm substreams. Some soundcards
support multiple playback functions. For example, emu10k1 has a PCM
playback of 32 stereo substreams. In this case, at each open, a free
substream is (usually) automatically chosen and opened. Meanwhile, when
only one substream exists and it was already opened, the successful open
will either block or error with <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> according to the file open
mode. But you don’t have to care about such details in your driver. The
PCM middle layer will take care of such work.</p>
</div>
<div class="section" id="id3">
<h3>Full Code Example<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The example code below does not include any hardware access routines but
shows only the skeleton, how to build up the PCM interfaces.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;sound/pcm.h&gt;
....

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_playback_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_capture_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};

/* open callback */
static int snd_mychip_playback_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_playback_hw;
        /* more hardware-initialization will be done here */
        ....
        return 0;
}

/* close callback */
static int snd_mychip_playback_close(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        /* the hardware-specific codes will be here */
        ....
        return 0;

}

/* open callback */
static int snd_mychip_capture_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_capture_hw;
        /* more hardware-initialization will be done here */
        ....
        return 0;
}

/* close callback */
static int snd_mychip_capture_close(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* hw_params callback */
static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream,
                             struct snd_pcm_hw_params *hw_params)
{
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* hw_free callback */
static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream)
{
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* prepare callback */
static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        /* set up the hardware with the current configuration
         * for example...
         */
        mychip_set_sample_format(chip, runtime-&gt;format);
        mychip_set_sample_rate(chip, runtime-&gt;rate);
        mychip_set_channels(chip, runtime-&gt;channels);
        mychip_set_dma_setup(chip, runtime-&gt;dma_addr,
                             chip-&gt;buffer_size,
                             chip-&gt;period_size);
        return 0;
}

/* trigger callback */
static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream,
                                  int cmd)
{
        switch (cmd) {
        case SNDRV_PCM_TRIGGER_START:
                /* do something to start the PCM engine */
                ....
                break;
        case SNDRV_PCM_TRIGGER_STOP:
                /* do something to stop the PCM engine */
                ....
                break;
        default:
                return -EINVAL;
        }
}

/* pointer callback */
static snd_pcm_uframes_t
snd_mychip_pcm_pointer(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        unsigned int current_ptr;

        /* get the current hardware pointer */
        current_ptr = mychip_get_hw_pointer(chip);
        return current_ptr;
}

/* operators */
static struct snd_pcm_ops snd_mychip_playback_ops = {
        .open =        snd_mychip_playback_open,
        .close =       snd_mychip_playback_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};

/* operators */
static struct snd_pcm_ops snd_mychip_capture_ops = {
        .open =        snd_mychip_capture_open,
        .close =       snd_mychip_capture_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};

/*
 *  definitions of capture are omitted here...
 */

/* create a pcm device */
static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        int err;

        err = snd_pcm_new(chip-&gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;pcm);
        if (err &lt; 0)
                return err;
        pcm-&gt;private_data = chip;
        strcpy(pcm-&gt;name, &quot;My Chip&quot;);
        chip-&gt;pcm = pcm;
        /* set operators */
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                        &amp;snd_mychip_playback_ops);
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                        &amp;snd_mychip_capture_ops);
        /* pre-allocation of buffers */
        /* NOTE: this may fail */
        snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                                       &amp;chip-&gt;pci-&gt;dev,
                                       64*1024, 64*1024);
        return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="pcm-constructor">
<h3>PCM Constructor<a class="headerlink" href="#pcm-constructor" title="Permalink to this headline">¶</a></h3>
<p>A pcm instance is allocated by the <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a>
function. It would be better to create a constructor for pcm, namely,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        int err;

        err = snd_pcm_new(chip-&gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;pcm);
        if (err &lt; 0)
                return err;
        pcm-&gt;private_data = chip;
        strcpy(pcm-&gt;name, &quot;My Chip&quot;);
        chip-&gt;pcm = pcm;
        ....
        return 0;
}
</pre></div>
</div>
<p>The <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a> function takes four arguments. The
first argument is the card pointer to which this pcm is assigned, and
the second is the ID string.</p>
<p>The third argument (<code class="docutils literal notranslate"><span class="pre">index</span></code>, 0 in the above) is the index of this new
pcm. It begins from zero. If you create more than one pcm instances,
specify the different numbers in this argument. For example, <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">=</span>
<span class="pre">1</span></code> for the second PCM device.</p>
<p>The fourth and fifth arguments are the number of substreams for playback
and capture, respectively. Here 1 is used for both arguments. When no
playback or capture substreams are available, pass 0 to the
corresponding argument.</p>
<p>If a chip supports multiple playbacks or captures, you can specify more
numbers, but they must be handled properly in open/close, etc.
callbacks. When you need to know which substream you are referring to,
then it can be obtained from <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span></code> data passed to each callback as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_pcm_substream *substream;
int index = substream-&gt;number;
</pre></div>
</div>
<p>After the pcm is created, you need to set operators for each pcm stream.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                &amp;snd_mychip_playback_ops);
snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                &amp;snd_mychip_capture_ops);
</pre></div>
</div>
<p>The operators are defined typically like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_pcm_ops snd_mychip_playback_ops = {
        .open =        snd_mychip_pcm_open,
        .close =       snd_mychip_pcm_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};
</pre></div>
</div>
<p>All the callbacks are described in the <a class="reference internal" href="#operators">Operators</a> subsection.</p>
<p>After setting the operators, you probably will want to pre-allocate the
buffer and set up the managed allocation mode.
For that, simply call the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                               &amp;chip-&gt;pci-&gt;dev,
                               64*1024, 64*1024);
</pre></div>
</div>
<p>It will allocate a buffer up to 64kB as default. Buffer management
details will be described in the later section <a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory
Management</a>.</p>
<p>Additionally, you can set some extra information for this pcm in
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;info_flags</span></code>. The available values are defined as
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_XXX</span></code> in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound.h&gt;</span></code>, which is used for the
hardware definition (described later). When your soundchip supports only
half-duplex, specify like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pcm-&gt;info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
</pre></div>
</div>
</div>
<div class="section" id="and-the-destructor">
<h3>… And the Destructor?<a class="headerlink" href="#and-the-destructor" title="Permalink to this headline">¶</a></h3>
<p>The destructor for a pcm instance is not always necessary. Since the pcm
device will be released by the middle layer code automatically, you
don’t have to call the destructor explicitly.</p>
<p>The destructor would be necessary if you created special records
internally and needed to release them. In such a case, set the
destructor function to <code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_free</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void mychip_pcm_free(struct snd_pcm *pcm)
{
        struct mychip *chip = snd_pcm_chip(pcm);
        /* free your own data */
        kfree(chip-&gt;my_private_pcm_data);
        /* do what you like else */
        ....
}

static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        ....
        /* allocate your own data */
        chip-&gt;my_private_pcm_data = kmalloc(...);
        /* set the destructor */
        pcm-&gt;private_data = chip;
        pcm-&gt;private_free = mychip_pcm_free;
        ....
}
</pre></div>
</div>
</div>
<div class="section" id="runtime-pointer-the-chest-of-pcm-information">
<h3>Runtime Pointer - The Chest of PCM Information<a class="headerlink" href="#runtime-pointer-the-chest-of-pcm-information" title="Permalink to this headline">¶</a></h3>
<p>When the PCM substream is opened, a PCM runtime instance is allocated
and assigned to the substream. This pointer is accessible via
<code class="docutils literal notranslate"><span class="pre">substream-&gt;runtime</span></code>. This runtime pointer holds most information you
need to control the PCM: the copy of hw_params and sw_params
configurations, the buffer pointers, mmap records, spinlocks, etc.</p>
<p>The definition of runtime instance is found in <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>. Here
are the contents of this file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct _snd_pcm_runtime {
        /* -- Status -- */
        struct snd_pcm_substream *trigger_master;
        snd_timestamp_t trigger_tstamp;       /* trigger timestamp */
        int overrange;
        snd_pcm_uframes_t avail_max;
        snd_pcm_uframes_t hw_ptr_base;        /* Position at buffer restart */
        snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/

        /* -- HW params -- */
        snd_pcm_access_t access;      /* access mode */
        snd_pcm_format_t format;      /* SNDRV_PCM_FORMAT_* */
        snd_pcm_subformat_t subformat;        /* subformat */
        unsigned int rate;            /* rate in Hz */
        unsigned int channels;                /* channels */
        snd_pcm_uframes_t period_size;        /* period size */
        unsigned int periods;         /* periods */
        snd_pcm_uframes_t buffer_size;        /* buffer size */
        unsigned int tick_time;               /* tick time */
        snd_pcm_uframes_t min_align;  /* Min alignment for the format */
        size_t byte_align;
        unsigned int frame_bits;
        unsigned int sample_bits;
        unsigned int info;
        unsigned int rate_num;
        unsigned int rate_den;

        /* -- SW params -- */
        struct timespec tstamp_mode;  /* mmap timestamp is updated */
        unsigned int period_step;
        unsigned int sleep_min;               /* min ticks to sleep */
        snd_pcm_uframes_t start_threshold;
        snd_pcm_uframes_t stop_threshold;
        snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
                                                noise is nearest than this */
        snd_pcm_uframes_t silence_size;       /* Silence filling size */
        snd_pcm_uframes_t boundary;   /* pointers wrap point */

        snd_pcm_uframes_t silenced_start;
        snd_pcm_uframes_t silenced_size;

        snd_pcm_sync_id_t sync;               /* hardware synchronization ID */

        /* -- mmap -- */
        volatile struct snd_pcm_mmap_status *status;
        volatile struct snd_pcm_mmap_control *control;
        atomic_t mmap_count;

        /* -- locking / scheduling -- */
        spinlock_t lock;
        wait_queue_head_t sleep;
        struct timer_list tick_timer;
        struct fasync_struct *fasync;

        /* -- private section -- */
        void *private_data;
        void (*private_free)(struct snd_pcm_runtime *runtime);

        /* -- hardware description -- */
        struct snd_pcm_hardware hw;
        struct snd_pcm_hw_constraints hw_constraints;

        /* -- timer -- */
        unsigned int timer_resolution;        /* timer resolution */

        /* -- DMA -- */
        unsigned char *dma_area;      /* DMA area */
        dma_addr_t dma_addr;          /* physical bus address (not accessible from main CPU) */
        size_t dma_bytes;             /* size of DMA area */

        struct snd_dma_buffer *dma_buffer_p;  /* allocated buffer */

#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
        /* -- OSS things -- */
        struct snd_pcm_oss_runtime oss;
#endif
};
</pre></div>
</div>
<p>For the operators (callbacks) of each sound driver, most of these
records are supposed to be read-only. Only the PCM middle-layer changes
/ updates them. The exceptions are the hardware description (hw) DMA
buffer information and the private data. Besides, if you use the
standard managed buffer allocation mode, you don’t need to set the
DMA buffer information by yourself.</p>
<p>In the sections below, important records are explained.</p>
<div class="section" id="hardware-description">
<h4>Hardware Description<a class="headerlink" href="#hardware-description" title="Permalink to this headline">¶</a></h4>
<p>The hardware descriptor (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span></code>) contains the definitions of the fundamental
hardware configuration. Above all, you’ll need to define this in the
<a class="reference internal" href="#pcm-open-callback">PCM open callback</a>. Note that the runtime instance holds the copy of
the descriptor, not the pointer to the existing descriptor. That is,
in the open callback, you can modify the copied descriptor
(<code class="docutils literal notranslate"><span class="pre">runtime-&gt;hw</span></code>) as you need. For example, if the maximum number of
channels is 1 only on some chip models, you can still use the same
hardware descriptor and change the channels_max later:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_pcm_runtime *runtime = substream-&gt;runtime;
...
runtime-&gt;hw = snd_mychip_playback_hw; /* common definition */
if (chip-&gt;model == VERY_OLD_ONE)
        runtime-&gt;hw.channels_max = 1;
</pre></div>
</div>
<p>Typically, you’ll have a hardware descriptor as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_pcm_hardware snd_mychip_playback_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};
</pre></div>
</div>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">info</span></code> field contains the type and capabilities of this
pcm. The bit flags are defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound.h&gt;</span></code> as
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_XXX</span></code>. Here, at least, you have to specify whether
the mmap is supported and which interleaved format is
supported. When the hardware supports mmap, add the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_MMAP</span></code> flag here. When the hardware supports the
interleaved or the non-interleaved formats,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_INTERLEAVED</span></code> or <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_NONINTERLEAVED</span></code>
flag must be set, respectively. If both are supported, you can set
both, too.</p>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">MMAP_VALID</span></code> and <code class="docutils literal notranslate"><span class="pre">BLOCK_TRANSFER</span></code> are
specified for the OSS mmap mode. Usually both are set. Of course,
<code class="docutils literal notranslate"><span class="pre">MMAP_VALID</span></code> is set only if the mmap is really supported.</p>
<p>The other possible flags are <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_PAUSE</span></code> and
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code>. The <code class="docutils literal notranslate"><span class="pre">PAUSE</span></code> bit means that the pcm
supports the “pause” operation, while the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> bit means that
the pcm supports the full “suspend/resume” operation. If the
<code class="docutils literal notranslate"><span class="pre">PAUSE</span></code> flag is set, the <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback below must handle
the corresponding (pause push/release) commands. The suspend/resume
trigger commands can be defined even without the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code>
flag. See <a class="reference internal" href="#power-management">Power Management</a> section for details.</p>
<p>When the PCM substreams can be synchronized (typically,
synchronized start/stop of a playback and a capture streams), you
can give <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_SYNC_START</span></code>, too. In this case, you’ll
need to check the linked-list of PCM substreams in the trigger
callback. This will be described in the later section.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">formats</span></code> field contains the bit-flags of supported formats
(<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_FMTBIT_XXX</span></code>). If the hardware supports more than one
format, give all or’ed bits. In the example above, the signed 16bit
little-endian format is specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rates</span></code> field contains the bit-flags of supported rates
(<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_RATE_XXX</span></code>). When the chip supports continuous rates,
pass <code class="docutils literal notranslate"><span class="pre">CONTINUOUS</span></code> bit additionally. The pre-defined rate bits are
provided only for typical rates. If your chip supports
unconventional rates, you need to add the <code class="docutils literal notranslate"><span class="pre">KNOT</span></code> bit and set up
the hardware constraint manually (explained later).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rate_min</span></code> and <code class="docutils literal notranslate"><span class="pre">rate_max</span></code> define the minimum and maximum sample
rate. This should correspond somehow to <code class="docutils literal notranslate"><span class="pre">rates</span></code> bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_min</span></code> and <code class="docutils literal notranslate"><span class="pre">channel_max</span></code> define, as you might already
expected, the minimum and maximum number of channels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer_bytes_max</span></code> defines the maximum buffer size in
bytes. There is no <code class="docutils literal notranslate"><span class="pre">buffer_bytes_min</span></code> field, since it can be
calculated from the minimum period size and the minimum number of
periods. Meanwhile, <code class="docutils literal notranslate"><span class="pre">period_bytes_min</span></code> and define the minimum and
maximum size of the period in bytes. <code class="docutils literal notranslate"><span class="pre">periods_max</span></code> and
<code class="docutils literal notranslate"><span class="pre">periods_min</span></code> define the maximum and minimum number of periods in
the buffer.</p>
<p>The “period” is a term that corresponds to a fragment in the OSS
world. The period defines the size at which a PCM interrupt is
generated. This size strongly depends on the hardware. Generally,
the smaller period size will give you more interrupts, that is,
more controls. In the case of capture, this size defines the input
latency. On the other hand, the whole buffer size defines the
output latency for the playback direction.</p>
</li>
<li><p>There is also a field <code class="docutils literal notranslate"><span class="pre">fifo_size</span></code>. This specifies the size of the
hardware FIFO, but currently it is neither used in the driver nor
in the alsa-lib. So, you can ignore this field.</p></li>
</ul>
</div>
<div class="section" id="pcm-configurations">
<h4>PCM Configurations<a class="headerlink" href="#pcm-configurations" title="Permalink to this headline">¶</a></h4>
<p>Ok, let’s go back again to the PCM runtime records. The most
frequently referred records in the runtime instance are the PCM
configurations. The PCM configurations are stored in the runtime
instance after the application sends <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> data via
alsa-lib. There are many fields copied from hw_params and sw_params
structs. For example, <code class="docutils literal notranslate"><span class="pre">format</span></code> holds the format type chosen by the
application. This field contains the enum value
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_FORMAT_XXX</span></code>.</p>
<p>One thing to be noted is that the configured buffer and period sizes
are stored in “frames” in the runtime. In the ALSA world, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">frame</span> <span class="pre">=</span>
<span class="pre">channels</span> <span class="pre">\*</span> <span class="pre">samples-size</span></code>. For conversion between frames and bytes,
you can use the <a class="reference internal" href="../../driver-api/sound.html#c.frames_to_bytes" title="frames_to_bytes"><code class="xref c c-func docutils literal notranslate"><span class="pre">frames_to_bytes()</span></code></a> and
<a class="reference internal" href="../../driver-api/sound.html#c.bytes_to_frames" title="bytes_to_frames"><code class="xref c c-func docutils literal notranslate"><span class="pre">bytes_to_frames()</span></code></a> helper functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>period_bytes = frames_to_bytes(runtime, runtime-&gt;period_size);
</pre></div>
</div>
<p>Also, many software parameters (sw_params) are stored in frames, too.
Please check the type of the field. <code class="docutils literal notranslate"><span class="pre">snd_pcm_uframes_t</span></code> is for the
frames as unsigned integer while <code class="docutils literal notranslate"><span class="pre">snd_pcm_sframes_t</span></code> is for the
frames as signed integer.</p>
</div>
<div class="section" id="dma-buffer-information">
<h4>DMA Buffer Information<a class="headerlink" href="#dma-buffer-information" title="Permalink to this headline">¶</a></h4>
<p>The DMA buffer is defined by the following four fields, <code class="docutils literal notranslate"><span class="pre">dma_area</span></code>,
<code class="docutils literal notranslate"><span class="pre">dma_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">dma_private</span></code>. The <code class="docutils literal notranslate"><span class="pre">dma_area</span></code>
holds the buffer pointer (the logical address). You can call
<a class="reference internal" href="../../core-api/kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a> from/to this pointer. Meanwhile, <code class="docutils literal notranslate"><span class="pre">dma_addr</span></code> holds
the physical address of the buffer. This field is specified only when
the buffer is a linear buffer. <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> holds the size of buffer
in bytes. <code class="docutils literal notranslate"><span class="pre">dma_private</span></code> is used for the ALSA DMA allocator.</p>
<p>If you use either the managed buffer allocation mode or the standard
API function <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> for allocating the buffer,
these fields are set by the ALSA middle layer, and you should <em>not</em>
change them by yourself. You can read them but not write them. On the
other hand, if you want to allocate the buffer by yourself, you’ll
need to manage it in hw_params callback. At least, <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> is
mandatory. <code class="docutils literal notranslate"><span class="pre">dma_area</span></code> is necessary when the buffer is mmapped. If
your driver doesn’t support mmap, this field is not
necessary. <code class="docutils literal notranslate"><span class="pre">dma_addr</span></code> is also optional. You can use dma_private as
you like, too.</p>
</div>
<div class="section" id="running-status">
<h4>Running Status<a class="headerlink" href="#running-status" title="Permalink to this headline">¶</a></h4>
<p>The running status can be referred via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;status</span></code>. This is
the pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_mmap_status</span></code> record. For example, you can get the current
DMA hardware pointer via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;status-&gt;hw_ptr</span></code>.</p>
<p>The DMA application pointer can be referred via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;control</span></code>,
which points to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_mmap_control</span></code> record. However, accessing directly to
this value is not recommended.</p>
</div>
<div class="section" id="private-data">
<h4>Private Data<a class="headerlink" href="#private-data" title="Permalink to this headline">¶</a></h4>
<p>You can allocate a record for the substream and store it in
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;private_data</span></code>. Usually, this is done in the <a class="reference internal" href="#pcm-open-callback">PCM open
callback</a>. Don’t mix this with <code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code>. The
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code> usually points to the chip instance assigned
statically at the creation of PCM, while the <code class="docutils literal notranslate"><span class="pre">runtime-&gt;private_data</span></code>
points to a dynamic data structure created at the PCM open
callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream)
{
        struct my_pcm_data *data;
        ....
        data = kmalloc(sizeof(*data), GFP_KERNEL);
        substream-&gt;runtime-&gt;private_data = data;
        ....
}
</pre></div>
</div>
<p>The allocated object must be released in the <a class="reference internal" href="#close-callback">close callback</a>.</p>
</div>
</div>
<div class="section" id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<p>OK, now let me give details about each pcm callback (<code class="docutils literal notranslate"><span class="pre">ops</span></code>). In
general, every callback must return 0 if successful, or a negative
error number such as <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>. To choose an appropriate error
number, it is advised to check what value other parts of the kernel
return when the same kind of request fails.</p>
<p>The callback function takes at least the argument with <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_pcm_substream</span></code> pointer. To retrieve the chip
record from the given substream instance, you can use the following
macro.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int xxx() {
        struct mychip *chip = snd_pcm_substream_chip(substream);
        ....
}
</pre></div>
</div>
<p>The macro reads <code class="docutils literal notranslate"><span class="pre">substream-&gt;private_data</span></code>, which is a copy of
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code>. You can override the former if you need to
assign different data records per PCM substream. For example, the
cmi8330 driver assigns different <code class="docutils literal notranslate"><span class="pre">private_data</span></code> for playback and
capture directions, because it uses two different codecs (SB- and
AD-compatible) for different directions.</p>
<div class="section" id="pcm-open-callback">
<h4>PCM open callback<a class="headerlink" href="#pcm-open-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This is called when a pcm substream is opened.</p>
<p>At least, here you have to initialize the <code class="docutils literal notranslate"><span class="pre">runtime-&gt;hw</span></code>
record. Typically, this is done by like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_playback_hw;
        return 0;
}
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">snd_mychip_playback_hw</span></code> is the pre-defined hardware
description.</p>
<p>You can allocate a private data in this callback, as described in
<a class="reference internal" href="#private-data">Private Data</a> section.</p>
<p>If the hardware configuration needs more constraints, set the hardware
constraints here, too. See <a class="reference internal" href="#constraints">Constraints</a> for more details.</p>
</div>
<div class="section" id="close-callback">
<h4>close callback<a class="headerlink" href="#close-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>Obviously, this is called when a pcm substream is closed.</p>
<p>Any private instance for a pcm substream allocated in the <code class="docutils literal notranslate"><span class="pre">open</span></code>
callback will be released here.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_pcm_substream *substream)
{
        ....
        kfree(substream-&gt;runtime-&gt;private_data);
        ....
}
</pre></div>
</div>
</div>
<div class="section" id="ioctl-callback">
<h4>ioctl callback<a class="headerlink" href="#ioctl-callback" title="Permalink to this headline">¶</a></h4>
<p>This is used for any special call to pcm ioctls. But usually you can
leave it as NULL, then PCM core calls the generic ioctl callback
function <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_ioctl" title="snd_pcm_lib_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_ioctl()</span></code></a>.  If you need to deal with the
unique setup of channel info or reset procedure, you can pass your own
callback function here.</p>
</div>
<div class="section" id="hw-params-callback">
<h4>hw_params callback<a class="headerlink" href="#hw-params-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_hw_params(struct snd_pcm_substream *substream,
                             struct snd_pcm_hw_params *hw_params);
</pre></div>
</div>
<p>This is called when the hardware parameter (<code class="docutils literal notranslate"><span class="pre">hw_params</span></code>) is set up
by the application, that is, once when the buffer size, the period
size, the format, etc. are defined for the pcm substream.</p>
<p>Many hardware setups should be done in this callback, including the
allocation of buffers.</p>
<p>Parameters to be initialized are retrieved by
<code class="xref c c-func docutils literal notranslate"><span class="pre">params_xxx()</span></code> macros.</p>
<p>When you set up the managed buffer allocation mode for the substream,
a buffer is already allocated before this callback gets
called. Alternatively, you can call a helper function below for
allocating the buffer, too.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
</pre></div>
</div>
<p><a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> is available only when the
DMA buffers have been pre-allocated. See the section <a class="reference internal" href="#buffer-types">Buffer Types</a>
for more details.</p>
<p>Note that this and <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callbacks may be called multiple times
per initialization. For example, the OSS emulation may call these
callbacks at each change via its ioctl.</p>
<p>Thus, you need to be careful not to allocate the same buffers many
times, which will lead to memory leaks! Calling the helper function
above many times is OK. It will release the previous buffer
automatically when it was already allocated.</p>
<p>Another note is that this callback is non-atomic (schedulable) as
default, i.e. when no <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code> flag set. This is important,
because the <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback is atomic (non-schedulable). That is,
mutexes or any schedule-related functions are not available in
<code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback. Please see the subsection <a class="reference internal" href="#atomicity">Atomicity</a> for
details.</p>
</div>
<div class="section" id="hw-free-callback">
<h4>hw_free callback<a class="headerlink" href="#hw-free-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_hw_free(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This is called to release the resources allocated via
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code>.</p>
<p>This function is always called before the close callback is called.
Also, the callback may be called multiple times, too. Keep track
whether the resource was already released.</p>
<p>When you have set up the managed buffer allocation mode for the PCM
substream, the allocated PCM buffer will be automatically released
after this callback gets called.  Otherwise you’ll have to release the
buffer manually.  Typically, when the buffer was allocated from the
pre-allocated pool, you can use the standard API function
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_free_pages(substream);
</pre></div>
</div>
</div>
<div class="section" id="prepare-callback">
<h4>prepare callback<a class="headerlink" href="#prepare-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_prepare(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This callback is called when the pcm is “prepared”. You can set the
format type, sample rate, etc. here. The difference from <code class="docutils literal notranslate"><span class="pre">hw_params</span></code>
is that the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callback will be called each time
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_prepare" title="snd_pcm_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_prepare()</span></code></a> is called, i.e. when recovering after
underruns, etc.</p>
<p>Note that this callback is now non-atomic. You can use
schedule-related functions safely in this callback.</p>
<p>In this and the following callbacks, you can refer to the values via
the runtime record, <code class="docutils literal notranslate"><span class="pre">substream-&gt;runtime</span></code>. For example, to get the
current rate, format or channels, access to <code class="docutils literal notranslate"><span class="pre">runtime-&gt;rate</span></code>,
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;format</span></code> or <code class="docutils literal notranslate"><span class="pre">runtime-&gt;channels</span></code>, respectively. The
physical address of the allocated buffer is set to
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;dma_area</span></code>. The buffer and period sizes are in
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;buffer_size</span></code> and <code class="docutils literal notranslate"><span class="pre">runtime-&gt;period_size</span></code>, respectively.</p>
<p>Be careful that this callback will be called many times at each setup,
too.</p>
</div>
<div class="section" id="trigger-callback">
<h4>trigger callback<a class="headerlink" href="#trigger-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_trigger(struct snd_pcm_substream *substream, int cmd);
</pre></div>
</div>
<p>This is called when the pcm is started, stopped or paused.</p>
<p>Which action is specified in the second argument,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_XXX</span></code> in <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>. At least, the <code class="docutils literal notranslate"><span class="pre">START</span></code>
and <code class="docutils literal notranslate"><span class="pre">STOP</span></code> commands must be defined in this callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (cmd) {
case SNDRV_PCM_TRIGGER_START:
        /* do something to start the PCM engine */
        break;
case SNDRV_PCM_TRIGGER_STOP:
        /* do something to stop the PCM engine */
        break;
default:
        return -EINVAL;
}
</pre></div>
</div>
<p>When the pcm supports the pause operation (given in the info field of
the hardware table), the <code class="docutils literal notranslate"><span class="pre">PAUSE_PUSH</span></code> and <code class="docutils literal notranslate"><span class="pre">PAUSE_RELEASE</span></code> commands
must be handled here, too. The former is the command to pause the pcm,
and the latter to restart the pcm again.</p>
<p>When the pcm supports the suspend/resume operation, regardless of full
or partial suspend/resume support, the <code class="docutils literal notranslate"><span class="pre">SUSPEND</span></code> and <code class="docutils literal notranslate"><span class="pre">RESUME</span></code>
commands must be handled, too. These commands are issued when the
power-management status is changed. Obviously, the <code class="docutils literal notranslate"><span class="pre">SUSPEND</span></code> and
<code class="docutils literal notranslate"><span class="pre">RESUME</span></code> commands suspend and resume the pcm substream, and usually,
they are identical to the <code class="docutils literal notranslate"><span class="pre">STOP</span></code> and <code class="docutils literal notranslate"><span class="pre">START</span></code> commands, respectively.
See the <a class="reference internal" href="#power-management">Power Management</a> section for details.</p>
<p>As mentioned, this callback is atomic as default unless <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code>
flag set, and you cannot call functions which may sleep. The
<code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback should be as minimal as possible, just really
triggering the DMA. The other stuff should be initialized
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code> and <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callbacks properly beforehand.</p>
</div>
<div class="section" id="sync-stop-callback">
<h4>sync_stop callback<a class="headerlink" href="#sync-stop-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_sync_stop(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This callback is optional, and NULL can be passed.  It’s called after
the PCM core stops the stream and changes the stream state
<code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_free</span></code>.
Since the IRQ handler might be still pending, we need to wait until
the pending task finishes before moving to the next step; otherwise it
might lead to a crash due to resource conflicts or access to the freed
resources.  A typical behavior is to call a synchronization function
like <a class="reference internal" href="../../core-api/kernel-api.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> here.</p>
<p>For majority of drivers that need only a call of
<a class="reference internal" href="../../core-api/kernel-api.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a>, there is a simpler setup, too.
While keeping NULL to <code class="docutils literal notranslate"><span class="pre">sync_stop</span></code> PCM callback, the driver can set
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> field to store the valid interrupt number after
requesting an IRQ, instead.   Then PCM core will look call
<a class="reference internal" href="../../core-api/kernel-api.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> with the given IRQ appropriately.</p>
<p>If the IRQ handler is released at the card destructor, you don’t need
to clear <code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code>, as the card itself is being released.
So, usually you’ll need to add just a single line for assigning
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> in the driver code unless the driver re-acquires
the IRQ.  When the driver frees and re-acquires the IRQ dynamically
(e.g. for suspend/resume), it needs to clear and re-set
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> again appropriately.</p>
</div>
<div class="section" id="pointer-callback">
<h4>pointer callback<a class="headerlink" href="#pointer-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static snd_pcm_uframes_t snd_xxx_pointer(struct snd_pcm_substream *substream)
</pre></div>
</div>
<p>This callback is called when the PCM middle layer inquires the current
hardware position on the buffer. The position must be returned in
frames, ranging from 0 to <code class="docutils literal notranslate"><span class="pre">buffer_size</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>This is called usually from the buffer-update routine in the pcm
middle layer, which is invoked when <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a>
is called in the interrupt routine. Then the pcm middle layer updates
the position and calculates the available space, and wakes up the
sleeping poll threads, etc.</p>
<p>This callback is also atomic as default.</p>
</div>
<div class="section" id="copy-user-copy-kernel-and-fill-silence-ops">
<h4>copy_user, copy_kernel and fill_silence ops<a class="headerlink" href="#copy-user-copy-kernel-and-fill-silence-ops" title="Permalink to this headline">¶</a></h4>
<p>These callbacks are not mandatory, and can be omitted in most cases.
These callbacks are used when the hardware buffer cannot be in the
normal memory space. Some chips have their own buffer on the hardware
which is not mappable. In such a case, you have to transfer the data
manually from the memory buffer to the hardware buffer. Or, if the
buffer is non-contiguous on both physical and virtual memory spaces,
these callbacks must be defined, too.</p>
<p>If these two callbacks are defined, copy and set-silence operations
are done by them. The detailed will be described in the later section
<a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory Management</a>.</p>
</div>
<div class="section" id="ack-callback">
<h4>ack callback<a class="headerlink" href="#ack-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is also not mandatory. This callback is called when the
<code class="docutils literal notranslate"><span class="pre">appl_ptr</span></code> is updated in read or write operations. Some drivers like
emu10k1-fx and cs46xx need to track the current <code class="docutils literal notranslate"><span class="pre">appl_ptr</span></code> for the
internal buffer, and this callback is useful only for such a purpose.</p>
<p>This callback is atomic as default.</p>
</div>
<div class="section" id="page-callback">
<h4>page callback<a class="headerlink" href="#page-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is optional too. The mmap calls this callback to get the
page fault address.</p>
<p>Since the recent changes, you need no special callback any longer for
the standard SG-buffer or vmalloc-buffer. Hence this callback should
be rarely used.</p>
</div>
<div class="section" id="mmap-calllback">
<h4>mmap calllback<a class="headerlink" href="#mmap-calllback" title="Permalink to this headline">¶</a></h4>
<p>This is another optional callback for controlling mmap behavior.
Once when defined, PCM core calls this callback when a page is
memory-mapped instead of dealing via the standard helper.
If you need special handling (due to some architecture or
device-specific issues), implement everything here as you like.</p>
</div>
</div>
<div class="section" id="pcm-interrupt-handler">
<h3>PCM Interrupt Handler<a class="headerlink" href="#pcm-interrupt-handler" title="Permalink to this headline">¶</a></h3>
<p>The rest of pcm stuff is the PCM interrupt handler. The role of PCM
interrupt handler in the sound driver is to update the buffer position
and to tell the PCM middle layer when the buffer position goes across
the prescribed period size. To inform this, call the
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> function.</p>
<p>There are several types of sound chips to generate the interrupts.</p>
<div class="section" id="interrupts-at-the-period-fragment-boundary">
<h4>Interrupts at the period (fragment) boundary<a class="headerlink" href="#interrupts-at-the-period-fragment-boundary" title="Permalink to this headline">¶</a></h4>
<p>This is the most frequently found type: the hardware generates an
interrupt at each period boundary. In this case, you can call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> at each interrupt.</p>
<p><a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> takes the substream pointer as
its argument. Thus, you need to keep the substream pointer accessible
from the chip instance. For example, define <code class="docutils literal notranslate"><span class="pre">substream</span></code> field in the
chip record to hold the current running substream pointer, and set the
pointer value at <code class="docutils literal notranslate"><span class="pre">open</span></code> callback (and reset at <code class="docutils literal notranslate"><span class="pre">close</span></code> callback).</p>
<p>If you acquire a spinlock in the interrupt handler, and the lock is used
in other pcm callbacks, too, then you have to release the lock before
calling <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a>, because
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> calls other pcm callbacks
inside.</p>
<p>Typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        spin_lock(&amp;chip-&gt;lock);
        ....
        if (pcm_irq_invoked(chip)) {
                /* call updater, unlock before it */
                spin_unlock(&amp;chip-&gt;lock);
                snd_pcm_period_elapsed(chip-&gt;substream);
                spin_lock(&amp;chip-&gt;lock);
                /* acknowledge the interrupt if necessary */
        }
        ....
        spin_unlock(&amp;chip-&gt;lock);
        return IRQ_HANDLED;
}
</pre></div>
</div>
</div>
<div class="section" id="high-frequency-timer-interrupts">
<h4>High frequency timer interrupts<a class="headerlink" href="#high-frequency-timer-interrupts" title="Permalink to this headline">¶</a></h4>
<p>This happens when the hardware doesn’t generate interrupts at the period
boundary but issues timer interrupts at a fixed timer rate (e.g. es1968
or ymfpci drivers). In this case, you need to check the current hardware
position and accumulate the processed sample length at each interrupt.
When the accumulated size exceeds the period size, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> and reset the accumulator.</p>
<p>Typical code would be like the following.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        spin_lock(&amp;chip-&gt;lock);
        ....
        if (pcm_irq_invoked(chip)) {
                unsigned int last_ptr, size;
                /* get the current hardware pointer (in frames) */
                last_ptr = get_hw_ptr(chip);
                /* calculate the processed frames since the
                 * last update
                 */
                if (last_ptr &lt; chip-&gt;last_ptr)
                        size = runtime-&gt;buffer_size + last_ptr
                                 - chip-&gt;last_ptr;
                else
                        size = last_ptr - chip-&gt;last_ptr;
                /* remember the last updated point */
                chip-&gt;last_ptr = last_ptr;
                /* accumulate the size */
                chip-&gt;size += size;
                /* over the period boundary? */
                if (chip-&gt;size &gt;= runtime-&gt;period_size) {
                        /* reset the accumulator */
                        chip-&gt;size %= runtime-&gt;period_size;
                        /* call updater */
                        spin_unlock(&amp;chip-&gt;lock);
                        snd_pcm_period_elapsed(substream);
                        spin_lock(&amp;chip-&gt;lock);
                }
                /* acknowledge the interrupt if necessary */
        }
        ....
        spin_unlock(&amp;chip-&gt;lock);
        return IRQ_HANDLED;
}
</pre></div>
</div>
</div>
<div class="section" id="on-calling-snd-pcm-period-elapsed">
<h4>On calling <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a><a class="headerlink" href="#on-calling-snd-pcm-period-elapsed" title="Permalink to this headline">¶</a></h4>
<p>In both cases, even if more than one period are elapsed, you don’t have
to call <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> many times. Call only
once. And the pcm layer will check the current hardware pointer and
update to the latest status.</p>
</div>
</div>
<div class="section" id="atomicity">
<h3>Atomicity<a class="headerlink" href="#atomicity" title="Permalink to this headline">¶</a></h3>
<p>One of the most important (and thus difficult to debug) problems in
kernel programming are race conditions. In the Linux kernel, they are
usually avoided via spin-locks, mutexes or semaphores. In general, if a
race condition can happen in an interrupt handler, it has to be managed
atomically, and you have to use a spinlock to protect the critical
session. If the critical section is not in interrupt handler code and if
taking a relatively long time to execute is acceptable, you should use
mutexes or semaphores instead.</p>
<p>As already seen, some pcm callbacks are atomic and some are not. For
example, the <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback is non-atomic, while <code class="docutils literal notranslate"><span class="pre">trigger</span></code>
callback is atomic. This means, the latter is called already in a
spinlock held by the PCM middle layer. Please take this atomicity into
account when you choose a locking scheme in the callbacks.</p>
<p>In the atomic callbacks, you cannot use functions which may call
<code class="xref c c-func docutils literal notranslate"><span class="pre">schedule()</span></code> or go to <code class="xref c c-func docutils literal notranslate"><span class="pre">sleep()</span></code>. Semaphores and
mutexes can sleep, and hence they cannot be used inside the atomic
callbacks (e.g. <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback). To implement some delay in such a
callback, please use <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code>.</p>
<p>All three atomic callbacks (trigger, pointer, and ack) are called with
local interrupts disabled.</p>
<p>The recent changes in PCM core code, however, allow all PCM operations
to be non-atomic. This assumes that the all caller sides are in
non-atomic contexts. For example, the function
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> is called typically from the
interrupt handler. But, if you set up the driver to use a threaded
interrupt handler, this call can be in non-atomic context, too. In such
a case, you can set <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code> filed of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span></code> object after creating it. When this flag is set, mutex
and rwsem are used internally in the PCM core instead of spin and
rwlocks, so that you can call all PCM functions safely in a non-atomic
context.</p>
</div>
<div class="section" id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>If your chip supports unconventional sample rates, or only the limited
samples, you need to set a constraint for the condition.</p>
<p>For example, in order to restrict the sample rates in the some supported
values, use <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_hw_constraint_list" title="snd_pcm_hw_constraint_list"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_hw_constraint_list()</span></code></a>. You need to
call this function in the open callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static unsigned int rates[] =
        {4000, 10000, 22050, 44100};
static struct snd_pcm_hw_constraint_list constraints_rates = {
        .count = ARRAY_SIZE(rates),
        .list = rates,
        .mask = 0,
};

static int snd_mychip_pcm_open(struct snd_pcm_substream *substream)
{
        int err;
        ....
        err = snd_pcm_hw_constraint_list(substream-&gt;runtime, 0,
                                         SNDRV_PCM_HW_PARAM_RATE,
                                         &amp;constraints_rates);
        if (err &lt; 0)
                return err;
        ....
}
</pre></div>
</div>
<p>There are many different constraints. Look at <code class="docutils literal notranslate"><span class="pre">sound/pcm.h</span></code> for a
complete list. You can even define your own constraint rules. For
example, let’s suppose my_chip can manage a substream of 1 channel if
and only if the format is <code class="docutils literal notranslate"><span class="pre">S16_LE</span></code>, otherwise it supports any format
specified in the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span></code> structure (or in any other
constraint_list). You can build a rule like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params,
                                      struct snd_pcm_hw_rule *rule)
{
        struct snd_interval *c = hw_param_interval(params,
                      SNDRV_PCM_HW_PARAM_CHANNELS);
        struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
        struct snd_interval ch;

        snd_interval_any(&amp;ch);
        if (f-&gt;bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {
                ch.min = ch.max = 1;
                ch.integer = 1;
                return snd_interval_refine(c, &amp;ch);
        }
        return 0;
}
</pre></div>
</div>
<p>Then you need to call this function to add your rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
                    hw_rule_channels_by_format, NULL,
                    SNDRV_PCM_HW_PARAM_FORMAT, -1);
</pre></div>
</div>
<p>The rule function is called when an application sets the PCM format, and
it refines the number of channels accordingly. But an application may
set the number of channels before setting the format. Thus you also need
to define the inverse rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params,
                                      struct snd_pcm_hw_rule *rule)
{
        struct snd_interval *c = hw_param_interval(params,
              SNDRV_PCM_HW_PARAM_CHANNELS);
        struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
        struct snd_mask fmt;

        snd_mask_any(&amp;fmt);    /* Init the struct */
        if (c-&gt;min &lt; 2) {
                fmt.bits[0] &amp;= SNDRV_PCM_FMTBIT_S16_LE;
                return snd_mask_refine(f, &amp;fmt);
        }
        return 0;
}
</pre></div>
</div>
<p>… and in the open callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
                    hw_rule_format_by_channels, NULL,
                    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
</pre></div>
</div>
<p>One typical usage of the hw constraints is to align the buffer size
with the period size.  As default, ALSA PCM core doesn’t enforce the
buffer size to be aligned with the period size.  For example, it’d be
possible to have a combination like 256 period bytes with 999 buffer
bytes.</p>
<p>Many device chips, however, require the buffer to be a multiple of
periods.  In such a case, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_hw_constraint_integer" title="snd_pcm_hw_constraint_integer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_hw_constraint_integer()</span></code></a> for
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_HW_PARAM_PERIODS</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_constraint_integer(substream-&gt;runtime,
                              SNDRV_PCM_HW_PARAM_PERIODS);
</pre></div>
</div>
<p>This assures that the number of periods is integer, hence the buffer
size is aligned with the period size.</p>
<p>The hw constraint is a very much powerful mechanism to define the
preferred PCM configuration, and there are relevant helpers.
I won’t give more details here, rather I would like to say, “Luke, use
the source.”</p>
</div>
</div>
<div class="section" id="control-interface">
<h2>Control Interface<a class="headerlink" href="#control-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>General<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The control interface is used widely for many switches, sliders, etc.
which are accessed from user-space. Its most important use is the mixer
interface. In other words, since ALSA 0.9.x, all the mixer stuff is
implemented on the control kernel API.</p>
<p>ALSA has a well-defined AC97 control module. If your chip supports only
the AC97 and nothing else, you can skip this section.</p>
<p>The control API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/control.h&gt;</span></code>. Include this file
if you want to add your own controls.</p>
</div>
<div class="section" id="definition-of-controls">
<h3>Definition of Controls<a class="headerlink" href="#definition-of-controls" title="Permalink to this headline">¶</a></h3>
<p>To create a new control, you need to define the following three
callbacks: <code class="docutils literal notranslate"><span class="pre">info</span></code>, <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">put</span></code>. Then, define a
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span></code> record, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_kcontrol_new my_control = {
        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
        .name = &quot;PCM Playback Switch&quot;,
        .index = 0,
        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
        .private_value = 0xffff,
        .info = my_control_info,
        .get = my_control_get,
        .put = my_control_put
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">iface</span></code> field specifies the control type,
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_XXX</span></code>, which is usually <code class="docutils literal notranslate"><span class="pre">MIXER</span></code>. Use <code class="docutils literal notranslate"><span class="pre">CARD</span></code>
for global controls that are not logically part of the mixer. If the
control is closely associated with some specific device on the sound
card, use <code class="docutils literal notranslate"><span class="pre">HWDEP</span></code>, <code class="docutils literal notranslate"><span class="pre">PCM</span></code>, <code class="docutils literal notranslate"><span class="pre">RAWMIDI</span></code>, <code class="docutils literal notranslate"><span class="pre">TIMER</span></code>, or <code class="docutils literal notranslate"><span class="pre">SEQUENCER</span></code>,
and specify the device number with the <code class="docutils literal notranslate"><span class="pre">device</span></code> and <code class="docutils literal notranslate"><span class="pre">subdevice</span></code>
fields.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name identifier string. Since ALSA 0.9.x, the
control name is very important, because its role is classified from
its name. There are pre-defined standard control names. The details
are described in the <a class="reference internal" href="#control-names">Control Names</a> subsection.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> field holds the index number of this control. If there
are several different controls with the same name, they can be
distinguished by the index number. This is the case when several
codecs exist on the card. If the index is zero, you can omit the
definition above.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">access</span></code> field contains the access type of this control. Give
the combination of bit masks, <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_XXX</span></code>,
there. The details will be explained in the <a class="reference internal" href="#access-flags">Access Flags</a>
subsection.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">private_value</span></code> field contains an arbitrary long integer value
for this record. When using the generic <code class="docutils literal notranslate"><span class="pre">info</span></code>, <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">put</span></code>
callbacks, you can pass a value through this field. If several small
numbers are necessary, you can combine them in bitwise. Or, it’s
possible to give a pointer (casted to unsigned long) of some record to
this field, too.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tlv</span></code> field can be used to provide metadata about the control;
see the <a class="reference internal" href="#metadata">Metadata</a> subsection.</p>
<p>The other three are <a class="reference internal" href="#control-callbacks">Control Callbacks</a>.</p>
</div>
<div class="section" id="control-names">
<h3>Control Names<a class="headerlink" href="#control-names" title="Permalink to this headline">¶</a></h3>
<p>There are some standards to define the control names. A control is
usually defined from the three parts as “SOURCE DIRECTION FUNCTION”.</p>
<p>The first, <code class="docutils literal notranslate"><span class="pre">SOURCE</span></code>, specifies the source of the control, and is a
string such as “Master”, “PCM”, “CD” and “Line”. There are many
pre-defined sources.</p>
<p>The second, <code class="docutils literal notranslate"><span class="pre">DIRECTION</span></code>, is one of the following strings according to
the direction of the control: “Playback”, “Capture”, “Bypass Playback”
and “Bypass Capture”. Or, it can be omitted, meaning both playback and
capture directions.</p>
<p>The third, <code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code>, is one of the following strings according to
the function of the control: “Switch”, “Volume” and “Route”.</p>
<p>The example of control names are, thus, “Master Capture Switch” or “PCM
Playback Volume”.</p>
<p>There are some exceptions:</p>
<div class="section" id="global-capture-and-playback">
<h4>Global capture and playback<a class="headerlink" href="#global-capture-and-playback" title="Permalink to this headline">¶</a></h4>
<p>“Capture Source”, “Capture Switch” and “Capture Volume” are used for the
global capture (input) source, switch and volume. Similarly, “Playback
Switch” and “Playback Volume” are used for the global output gain switch
and volume.</p>
</div>
<div class="section" id="tone-controls">
<h4>Tone-controls<a class="headerlink" href="#tone-controls" title="Permalink to this headline">¶</a></h4>
<p>tone-control switch and volumes are specified like “Tone Control - XXX”,
e.g. “Tone Control - Switch”, “Tone Control - Bass”, “Tone Control -
Center”.</p>
</div>
<div class="section" id="d-controls">
<h4>3D controls<a class="headerlink" href="#d-controls" title="Permalink to this headline">¶</a></h4>
<p>3D-control switches and volumes are specified like “3D Control - XXX”,
e.g. “3D Control - Switch”, “3D Control - Center”, “3D Control - Space”.</p>
</div>
<div class="section" id="mic-boost">
<h4>Mic boost<a class="headerlink" href="#mic-boost" title="Permalink to this headline">¶</a></h4>
<p>Mic-boost switch is set as “Mic Boost” or “Mic Boost (6dB)”.</p>
<p>More precise information can be found in
<code class="docutils literal notranslate"><span class="pre">Documentation/sound/designs/control-names.rst</span></code>.</p>
</div>
</div>
<div class="section" id="access-flags">
<h3>Access Flags<a class="headerlink" href="#access-flags" title="Permalink to this headline">¶</a></h3>
<p>The access flag is the bitmask which specifies the access type of the
given control. The default access type is
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_READWRITE</span></code>, which means both read and write are
allowed to this control. When the access flag is omitted (i.e. = 0), it
is considered as <code class="docutils literal notranslate"><span class="pre">READWRITE</span></code> access as default.</p>
<p>When the control is read-only, pass <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_READ</span></code>
instead. In this case, you don’t have to define the <code class="docutils literal notranslate"><span class="pre">put</span></code> callback.
Similarly, when the control is write-only (although it’s a rare case),
you can use the <code class="docutils literal notranslate"><span class="pre">WRITE</span></code> flag instead, and you don’t need the <code class="docutils literal notranslate"><span class="pre">get</span></code>
callback.</p>
<p>If the control value changes frequently (e.g. the VU meter),
<code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code> flag should be given. This means that the control may be
changed without <a class="reference internal" href="#change-notification">Change notification</a>. Applications should poll such
a control constantly.</p>
<p>When the control is inactive, set the <code class="docutils literal notranslate"><span class="pre">INACTIVE</span></code> flag, too. There are
<code class="docutils literal notranslate"><span class="pre">LOCK</span></code> and <code class="docutils literal notranslate"><span class="pre">OWNER</span></code> flags to change the write permissions.</p>
</div>
<div class="section" id="control-callbacks">
<h3>Control Callbacks<a class="headerlink" href="#control-callbacks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="info-callback">
<h4>info callback<a class="headerlink" href="#info-callback" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">info</span></code> callback is used to get detailed information on this
control. This must store the values of the given <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_ctl_elem_info</span></code> object. For example,
for a boolean control with a single element:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
        uinfo-&gt;count = 1;
        uinfo-&gt;value.integer.min = 0;
        uinfo-&gt;value.integer.max = 1;
        return 0;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span></code> field specifies the type of the control. There are
<code class="docutils literal notranslate"><span class="pre">BOOLEAN</span></code>, <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>, <code class="docutils literal notranslate"><span class="pre">ENUMERATED</span></code>, <code class="docutils literal notranslate"><span class="pre">BYTES</span></code>, <code class="docutils literal notranslate"><span class="pre">IEC958</span></code> and
<code class="docutils literal notranslate"><span class="pre">INTEGER64</span></code>. The <code class="docutils literal notranslate"><span class="pre">count</span></code> field specifies the number of elements in
this control. For example, a stereo volume would have count = 2. The
<code class="docutils literal notranslate"><span class="pre">value</span></code> field is a union, and the values stored are depending on the
type. The boolean and integer types are identical.</p>
<p>The enumerated type is a bit different from others. You’ll need to set
the string for the currently given item index.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        static char *texts[4] = {
                &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;
        };
        uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
        uinfo-&gt;count = 1;
        uinfo-&gt;value.enumerated.items = 4;
        if (uinfo-&gt;value.enumerated.item &gt; 3)
                uinfo-&gt;value.enumerated.item = 3;
        strcpy(uinfo-&gt;value.enumerated.name,
               texts[uinfo-&gt;value.enumerated.item]);
        return 0;
}
</pre></div>
</div>
<p>The above callback can be simplified with a helper function,
<a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_enum_info" title="snd_ctl_enum_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_enum_info()</span></code></a>. The final code looks like below.
(You can pass <code class="docutils literal notranslate"><span class="pre">ARRAY_SIZE(texts)</span></code> instead of 4 in the third argument;
it’s a matter of taste.)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        static char *texts[4] = {
                &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;
        };
        return snd_ctl_enum_info(uinfo, 1, 4, texts);
}
</pre></div>
</div>
<p>Some common info callbacks are available for your convenience:
<a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_boolean_mono_info" title="snd_ctl_boolean_mono_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_boolean_mono_info()</span></code></a> and
<a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_boolean_stereo_info" title="snd_ctl_boolean_stereo_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_boolean_stereo_info()</span></code></a>. Obviously, the former
is an info callback for a mono channel boolean item, just like
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_myctl_mono_info()</span></code> above, and the latter is for a
stereo channel boolean item.</p>
</div>
<div class="section" id="get-callback">
<h4>get callback<a class="headerlink" href="#get-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is used to read the current value of the control and to
return to user-space.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_get(struct snd_kcontrol *kcontrol,
                         struct snd_ctl_elem_value *ucontrol)
{
        struct mychip *chip = snd_kcontrol_chip(kcontrol);
        ucontrol-&gt;value.integer.value[0] = get_some_value(chip);
        return 0;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> field depends on the type of control as well as on the
info callback. For example, the sb driver uses this field to store the
register offset, the bit-shift and the bit-mask. The <code class="docutils literal notranslate"><span class="pre">private_value</span></code>
field is set as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.private_value = reg | (shift &lt;&lt; 16) | (mask &lt;&lt; 24)
</pre></div>
</div>
<p>and is retrieved in callbacks like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,
                                  struct snd_ctl_elem_value *ucontrol)
{
        int reg = kcontrol-&gt;private_value &amp; 0xff;
        int shift = (kcontrol-&gt;private_value &gt;&gt; 16) &amp; 0xff;
        int mask = (kcontrol-&gt;private_value &gt;&gt; 24) &amp; 0xff;
        ....
}
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">get</span></code> callback, you have to fill all the elements if the
control has more than one elements, i.e. <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>. In the example
above, we filled only one element (<code class="docutils literal notranslate"><span class="pre">value.integer.value[0]</span></code>) since
it’s assumed as <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</div>
<div class="section" id="put-callback">
<h4>put callback<a class="headerlink" href="#put-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is used to write a value from user-space.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_put(struct snd_kcontrol *kcontrol,
                         struct snd_ctl_elem_value *ucontrol)
{
        struct mychip *chip = snd_kcontrol_chip(kcontrol);
        int changed = 0;
        if (chip-&gt;current_value !=
             ucontrol-&gt;value.integer.value[0]) {
                change_current_value(chip,
                            ucontrol-&gt;value.integer.value[0]);
                changed = 1;
        }
        return changed;
}
</pre></div>
</div>
<p>As seen above, you have to return 1 if the value is changed. If the
value is not changed, return 0 instead. If any fatal error happens,
return a negative error code as usual.</p>
<p>As in the <code class="docutils literal notranslate"><span class="pre">get</span></code> callback, when the control has more than one
elements, all elements must be evaluated in this callback, too.</p>
</div>
<div class="section" id="callbacks-are-not-atomic">
<h4>Callbacks are not atomic<a class="headerlink" href="#callbacks-are-not-atomic" title="Permalink to this headline">¶</a></h4>
<p>All these three callbacks are basically not atomic.</p>
</div>
</div>
<div class="section" id="control-constructor">
<h3>Control Constructor<a class="headerlink" href="#control-constructor" title="Permalink to this headline">¶</a></h3>
<p>When everything is ready, finally we can create a new control. To create
a control, there are two functions to be called,
<a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> and <a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_add" title="snd_ctl_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add()</span></code></a>.</p>
<p>In the simplest way, you can do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_ctl_add(card, snd_ctl_new1(&amp;my_control, chip));
if (err &lt; 0)
        return err;
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">my_control</span></code> is the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span></code> object defined above, and chip is the object
pointer to be passed to kcontrol-&gt;private_data which can be referred
to in callbacks.</p>
<p><a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> allocates a new <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_kcontrol</span></code> instance, and
<a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_add" title="snd_ctl_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add()</span></code></a> assigns the given control component to the
card.</p>
</div>
<div class="section" id="change-notification">
<h3>Change Notification<a class="headerlink" href="#change-notification" title="Permalink to this headline">¶</a></h3>
<p>If you need to change and update a control in the interrupt routine, you
can call <a class="reference internal" href="../../driver-api/sound.html#c.snd_ctl_notify" title="snd_ctl_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_notify()</span></code></a>. For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);
</pre></div>
</div>
<p>This function takes the card pointer, the event-mask, and the control id
pointer for the notification. The event-mask specifies the types of
notification, for example, in the above example, the change of control
values is notified. The id pointer is the pointer of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_ctl_elem_id</span></code> to be notified. You can
find some examples in <code class="docutils literal notranslate"><span class="pre">es1938.c</span></code> or <code class="docutils literal notranslate"><span class="pre">es1968.c</span></code> for hardware volume
interrupts.</p>
</div>
<div class="section" id="metadata">
<h3>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<p>To provide information about the dB values of a mixer control, use on of
the <code class="docutils literal notranslate"><span class="pre">DECLARE_TLV_xxx</span></code> macros from <code class="docutils literal notranslate"><span class="pre">&lt;sound/tlv.h&gt;</span></code> to define a
variable containing this information, set the <code class="docutils literal notranslate"><span class="pre">tlv.p</span></code> field to point to
this variable, and include the <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_TLV_READ</span></code> flag
in the <code class="docutils literal notranslate"><span class="pre">access</span></code> field; like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);

static struct snd_kcontrol_new my_control = {
        ...
        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
                  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
        ...
        .tlv.p = db_scale_my_control,
};
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_TLV_DB_SCALE()</span></code> macro defines information
about a mixer control where each step in the control’s value changes the
dB value by a constant dB amount. The first parameter is the name of the
variable to be defined. The second parameter is the minimum value, in
units of 0.01 dB. The third parameter is the step size, in units of 0.01
dB. Set the fourth parameter to 1 if the minimum value actually mutes
the control.</p>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_TLV_DB_LINEAR()</span></code> macro defines information
about a mixer control where the control’s value affects the output
linearly. The first parameter is the name of the variable to be defined.
The second parameter is the minimum value, in units of 0.01 dB. The
third parameter is the maximum value, in units of 0.01 dB. If the
minimum value mutes the control, set the second parameter to
<code class="docutils literal notranslate"><span class="pre">TLV_DB_GAIN_MUTE</span></code>.</p>
</div>
</div>
<div class="section" id="api-for-ac97-codec">
<h2>API for AC97 Codec<a class="headerlink" href="#api-for-ac97-codec" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>General<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The ALSA AC97 codec layer is a well-defined one, and you don’t have to
write much code to control it. Only low-level control routines are
necessary. The AC97 codec API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/ac97_codec.h&gt;</span></code>.</p>
</div>
<div class="section" id="id6">
<h3>Full Code Example<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
        struct snd_ac97 *ac97;
        ....
};

static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                           unsigned short reg)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        /* read a register value here from the codec */
        return the_register_value;
}

static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                                 unsigned short reg, unsigned short val)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        /* write the given register value to the codec */
}

static int snd_mychip_ac97(struct mychip *chip)
{
        struct snd_ac97_bus *bus;
        struct snd_ac97_template ac97;
        int err;
        static struct snd_ac97_bus_ops ops = {
                .write = snd_mychip_ac97_write,
                .read = snd_mychip_ac97_read,
        };

        err = snd_ac97_bus(chip-&gt;card, 0, &amp;ops, NULL, &amp;bus);
        if (err &lt; 0)
                return err;
        memset(&amp;ac97, 0, sizeof(ac97));
        ac97.private_data = chip;
        return snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);
}
</pre></div>
</div>
</div>
<div class="section" id="ac97-constructor">
<h3>AC97 Constructor<a class="headerlink" href="#ac97-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create an ac97 instance, first call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_bus" title="snd_ac97_bus"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_bus()</span></code></a>
with an <code class="docutils literal notranslate"><span class="pre">ac97_bus_ops_t</span></code> record with callback functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_ac97_bus *bus;
static struct snd_ac97_bus_ops ops = {
      .write = snd_mychip_ac97_write,
      .read = snd_mychip_ac97_read,
};

snd_ac97_bus(card, 0, &amp;ops, NULL, &amp;pbus);
</pre></div>
</div>
<p>The bus record is shared among all belonging ac97 instances.</p>
<p>And then call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_mixer" title="snd_ac97_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_mixer()</span></code></a> with an <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_ac97_template</span></code> record together with
the bus pointer created above.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_ac97_template ac97;
int err;

memset(&amp;ac97, 0, sizeof(ac97));
ac97.private_data = chip;
snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);
</pre></div>
</div>
<p>where chip-&gt;ac97 is a pointer to a newly created <code class="docutils literal notranslate"><span class="pre">ac97_t</span></code>
instance. In this case, the chip pointer is set as the private data,
so that the read/write callback functions can refer to this chip
instance. This instance is not necessarily stored in the chip
record. If you need to change the register values from the driver, or
need the suspend/resume of ac97 codecs, keep this pointer to pass to
the corresponding functions.</p>
</div>
<div class="section" id="ac97-callbacks">
<h3>AC97 Callbacks<a class="headerlink" href="#ac97-callbacks" title="Permalink to this headline">¶</a></h3>
<p>The standard callbacks are <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code>. Obviously they
correspond to the functions for read and write accesses to the
hardware low-level codes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">read</span></code> callback returns the register value specified in the
argument.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                           unsigned short reg)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        return the_register_value;
}
</pre></div>
</div>
<p>Here, the chip can be cast from <code class="docutils literal notranslate"><span class="pre">ac97-&gt;private_data</span></code>.</p>
<p>Meanwhile, the <code class="docutils literal notranslate"><span class="pre">write</span></code> callback is used to set the register
value</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                     unsigned short reg, unsigned short val)
</pre></div>
</div>
<p>These callbacks are non-atomic like the control API callbacks.</p>
<p>There are also other callbacks: <code class="docutils literal notranslate"><span class="pre">reset</span></code>, <code class="docutils literal notranslate"><span class="pre">wait</span></code> and <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">reset</span></code> callback is used to reset the codec. If the chip
requires a special kind of reset, you can define this callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wait</span></code> callback is used to add some waiting time in the standard
initialization of the codec. If the chip requires the extra waiting
time, define this callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">init</span></code> callback is used for additional initialization of the
codec.</p>
</div>
<div class="section" id="updating-registers-in-the-driver">
<h3>Updating Registers in The Driver<a class="headerlink" href="#updating-registers-in-the-driver" title="Permalink to this headline">¶</a></h3>
<p>If you need to access to the codec from the driver, you can call the
following functions: <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a>,
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_read" title="snd_ac97_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_read()</span></code></a>, <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update_bits" title="snd_ac97_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update_bits()</span></code></a>.</p>
<p>Both <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> functions are used to set a value to
the given register (<code class="docutils literal notranslate"><span class="pre">AC97_XXX</span></code>). The difference between them is that
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> doesn’t write a value if the given
value has been already set, while <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a>
always rewrites the value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_write(ac97, AC97_MASTER, 0x8080);
snd_ac97_update(ac97, AC97_MASTER, 0x8080);
</pre></div>
</div>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_read" title="snd_ac97_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_read()</span></code></a> is used to read the value of the given
register. For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>value = snd_ac97_read(ac97, AC97_MASTER);
</pre></div>
</div>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update_bits" title="snd_ac97_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update_bits()</span></code></a> is used to update some bits in
the given register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_update_bits(ac97, reg, mask, value);
</pre></div>
</div>
<p>Also, there is a function to change the sample rate (of a given register
such as <code class="docutils literal notranslate"><span class="pre">AC97_PCM_FRONT_DAC_RATE</span></code>) when VRA or DRA is supported by the
codec: <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_set_rate" title="snd_ac97_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_set_rate()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);
</pre></div>
</div>
<p>The following registers are available to set the rate:
<code class="docutils literal notranslate"><span class="pre">AC97_PCM_MIC_ADC_RATE</span></code>, <code class="docutils literal notranslate"><span class="pre">AC97_PCM_FRONT_DAC_RATE</span></code>,
<code class="docutils literal notranslate"><span class="pre">AC97_PCM_LR_ADC_RATE</span></code>, <code class="docutils literal notranslate"><span class="pre">AC97_SPDIF</span></code>. When <code class="docutils literal notranslate"><span class="pre">AC97_SPDIF</span></code> is
specified, the register is not really changed but the corresponding
IEC958 status bits will be updated.</p>
</div>
<div class="section" id="clock-adjustment">
<h3>Clock Adjustment<a class="headerlink" href="#clock-adjustment" title="Permalink to this headline">¶</a></h3>
<p>In some chips, the clock of the codec isn’t 48000 but using a PCI clock
(to save a quartz!). In this case, change the field <code class="docutils literal notranslate"><span class="pre">bus-&gt;clock</span></code> to
the corresponding value. For example, intel8x0 and es1968 drivers have
their own function to read from the clock.</p>
</div>
<div class="section" id="proc-files">
<h3>Proc Files<a class="headerlink" href="#proc-files" title="Permalink to this headline">¶</a></h3>
<p>The ALSA AC97 interface will create a proc file such as
<code class="docutils literal notranslate"><span class="pre">/proc/asound/card0/codec97#0/ac97#0-0</span></code> and <code class="docutils literal notranslate"><span class="pre">ac97#0-0+regs</span></code>. You
can refer to these files to see the current status and registers of
the codec.</p>
</div>
<div class="section" id="multiple-codecs">
<h3>Multiple Codecs<a class="headerlink" href="#multiple-codecs" title="Permalink to this headline">¶</a></h3>
<p>When there are several codecs on the same card, you need to call
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_mixer" title="snd_ac97_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_mixer()</span></code></a> multiple times with <code class="docutils literal notranslate"><span class="pre">ac97.num=1</span></code> or
greater. The <code class="docutils literal notranslate"><span class="pre">num</span></code> field specifies the codec number.</p>
<p>If you set up multiple codecs, you either need to write different
callbacks for each codec or check <code class="docutils literal notranslate"><span class="pre">ac97-&gt;num</span></code> in the callback
routines.</p>
</div>
</div>
<div class="section" id="midi-mpu401-uart-interface">
<h2>MIDI (MPU401-UART) Interface<a class="headerlink" href="#midi-mpu401-uart-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>General<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Many soundcards have built-in MIDI (MPU401-UART) interfaces. When the
soundcard supports the standard MPU401-UART interface, most likely you
can use the ALSA MPU401-UART API. The MPU401-UART API is defined in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/mpu401.h&gt;</span></code>.</p>
<p>Some soundchips have a similar but slightly different implementation of
mpu401 stuff. For example, emu10k1 has its own mpu401 routines.</p>
</div>
<div class="section" id="midi-constructor">
<h3>MIDI Constructor<a class="headerlink" href="#midi-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create a rawmidi object, call <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi *rmidi;
snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,
                    irq, &amp;rmidi);
</pre></div>
</div>
<p>The first argument is the card pointer, and the second is the index of
this component. You can create up to 8 rawmidi devices.</p>
<p>The third argument is the type of the hardware, <code class="docutils literal notranslate"><span class="pre">MPU401_HW_XXX</span></code>. If
it’s not a special one, you can use <code class="docutils literal notranslate"><span class="pre">MPU401_HW_MPU401</span></code>.</p>
<p>The 4th argument is the I/O port address. Many backward-compatible
MPU401 have an I/O port such as 0x330. Or, it might be a part of its own
PCI I/O region. It depends on the chip design.</p>
<p>The 5th argument is a bitflag for additional information. When the I/O
port address above is part of the PCI I/O region, the MPU401 I/O port
might have been already allocated (reserved) by the driver itself. In
such a case, pass a bit flag <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_INTEGRATED</span></code>, and the
mpu401-uart layer will allocate the I/O ports by itself.</p>
<p>When the controller supports only the input or output MIDI stream, pass
the <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_INPUT</span></code> or <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_OUTPUT</span></code> bitflag,
respectively. Then the rawmidi instance is created as a single stream.</p>
<p><code class="docutils literal notranslate"><span class="pre">MPU401_INFO_MMIO</span></code> bitflag is used to change the access method to MMIO
(via readb and writeb) instead of iob and outb. In this case, you have
to pass the iomapped address to <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_TX_IRQ</span></code> is set, the output stream isn’t checked in
the default interrupt handler. The driver needs to call
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt_tx" title="snd_mpu401_uart_interrupt_tx"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt_tx()</span></code></a> by itself to start
processing the output stream in the irq handler.</p>
<p>If the MPU-401 interface shares its interrupt with the other logical
devices on the card, set <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_IRQ_HOOK</span></code> (see
<a class="reference external" href="#MIDI-Interrupt-Handler">below</a>).</p>
<p>Usually, the port address corresponds to the command port and port + 1
corresponds to the data port. If not, you may change the <code class="docutils literal notranslate"><span class="pre">cport</span></code>
field of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_mpu401</span></code> manually afterward.
However, <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_mpu401</span></code> pointer is
not returned explicitly by <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>. You
need to cast <code class="docutils literal notranslate"><span class="pre">rmidi-&gt;private_data</span></code> to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_mpu401</span></code> explicitly,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_mpu401 *mpu;
mpu = rmidi-&gt;private_data;
</pre></div>
</div>
<p>and reset the <code class="docutils literal notranslate"><span class="pre">cport</span></code> as you like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mpu-&gt;cport = my_own_control_port;
</pre></div>
</div>
<p>The 6th argument specifies the ISA irq number that will be allocated. If
no interrupt is to be allocated (because your code is already allocating
a shared interrupt, or because the device does not use interrupts), pass
-1 instead. For a MPU-401 device without an interrupt, a polling timer
will be used instead.</p>
</div>
<div class="section" id="midi-interrupt-handler">
<h3>MIDI Interrupt Handler<a class="headerlink" href="#midi-interrupt-handler" title="Permalink to this headline">¶</a></h3>
<p>When the interrupt is allocated in
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>, an exclusive ISA interrupt
handler is automatically used, hence you don’t have anything else to do
than creating the mpu401 stuff. Otherwise, you have to set
<code class="docutils literal notranslate"><span class="pre">MPU401_INFO_IRQ_HOOK</span></code>, and call
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt" title="snd_mpu401_uart_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt()</span></code></a> explicitly from your own
interrupt handler when it has determined that a UART interrupt has
occurred.</p>
<p>In this case, you need to pass the private_data of the returned rawmidi
object from <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a> as the second
argument of <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt" title="snd_mpu401_uart_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_mpu401_uart_interrupt(irq, rmidi-&gt;private_data, regs);
</pre></div>
</div>
</div>
</div>
<div class="section" id="rawmidi-interface">
<h2>RawMIDI Interface<a class="headerlink" href="#rawmidi-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The raw MIDI interface is used for hardware MIDI ports that can be
accessed as a byte stream. It is not used for synthesizer chips that do
not directly understand MIDI.</p>
<p>ALSA handles file and buffer management. All you have to do is to write
some code to move data between the buffer and the hardware.</p>
<p>The rawmidi API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/rawmidi.h&gt;</span></code>.</p>
</div>
<div class="section" id="rawmidi-constructor">
<h3>RawMIDI Constructor<a class="headerlink" href="#rawmidi-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create a rawmidi device, call the <a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_new" title="snd_rawmidi_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_new()</span></code></a>
function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi *rmidi;
err = snd_rawmidi_new(chip-&gt;card, &quot;MyMIDI&quot;, 0, outs, ins, &amp;rmidi);
if (err &lt; 0)
        return err;
rmidi-&gt;private_data = chip;
strcpy(rmidi-&gt;name, &quot;My MIDI&quot;);
rmidi-&gt;info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
                    SNDRV_RAWMIDI_INFO_INPUT |
                    SNDRV_RAWMIDI_INFO_DUPLEX;
</pre></div>
</div>
<p>The first argument is the card pointer, the second argument is the ID
string.</p>
<p>The third argument is the index of this component. You can create up to
8 rawmidi devices.</p>
<p>The fourth and fifth arguments are the number of output and input
substreams, respectively, of this device (a substream is the equivalent
of a MIDI port).</p>
<p>Set the <code class="docutils literal notranslate"><span class="pre">info_flags</span></code> field to specify the capabilities of the
device. Set <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_OUTPUT</span></code> if there is at least one
output port, <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_INPUT</span></code> if there is at least one
input port, and <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_DUPLEX</span></code> if the device can handle
output and input at the same time.</p>
<p>After the rawmidi device is created, you need to set the operators
(callbacks) for each substream. There are helper functions to set the
operators for all the substreams of a device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &amp;snd_mymidi_output_ops);
snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &amp;snd_mymidi_input_ops);
</pre></div>
</div>
<p>The operators are usually defined like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_rawmidi_ops snd_mymidi_output_ops = {
        .open =    snd_mymidi_output_open,
        .close =   snd_mymidi_output_close,
        .trigger = snd_mymidi_output_trigger,
};
</pre></div>
</div>
<p>These callbacks are explained in the <a class="reference internal" href="#rawmidi-callbacks">RawMIDI Callbacks</a> section.</p>
<p>If there are more than one substream, you should give a unique name to
each of them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi_substream *substream;
list_for_each_entry(substream,
                    &amp;rmidi-&gt;streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
                    list {
        sprintf(substream-&gt;name, &quot;My MIDI Port %d&quot;, substream-&gt;number + 1);
}
/* same for SNDRV_RAWMIDI_STREAM_INPUT */
</pre></div>
</div>
</div>
<div class="section" id="rawmidi-callbacks">
<h3>RawMIDI Callbacks<a class="headerlink" href="#rawmidi-callbacks" title="Permalink to this headline">¶</a></h3>
<p>In all the callbacks, the private data that you’ve set for the rawmidi
device can be accessed as <code class="docutils literal notranslate"><span class="pre">substream-&gt;rmidi-&gt;private_data</span></code>.</p>
<p>If there is more than one port, your callbacks can determine the port
index from the struct snd_rawmidi_substream data passed to each
callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi_substream *substream;
int index = substream-&gt;number;
</pre></div>
</div>
<div class="section" id="rawmidi-open-callback">
<h4>RawMIDI open callback<a class="headerlink" href="#rawmidi-open-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>This is called when a substream is opened. You can initialize the
hardware here, but you shouldn’t start transmitting/receiving data yet.</p>
</div>
<div class="section" id="rawmidi-close-callback">
<h4>RawMIDI close callback<a class="headerlink" href="#rawmidi-close-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>Guess what.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">open</span></code> and <code class="docutils literal notranslate"><span class="pre">close</span></code> callbacks of a rawmidi device are
serialized with a mutex, and can sleep.</p>
</div>
<div class="section" id="rawmidi-trigger-callback-for-output-substreams">
<h4>Rawmidi trigger callback for output substreams<a class="headerlink" href="#rawmidi-trigger-callback-for-output-substreams" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up);
</pre></div>
</div>
<p>This is called with a nonzero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter when there is some data
in the substream buffer that must be transmitted.</p>
<p>To read data from the buffer, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_transmit_peek" title="snd_rawmidi_transmit_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_peek()</span></code></a>. It will return the number
of bytes that have been read; this will be less than the number of bytes
requested when there are no more data in the buffer. After the data have
been transmitted successfully, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_transmit_ack" title="snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_ack()</span></code></a> to remove the data from the
substream buffer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char data;
while (snd_rawmidi_transmit_peek(substream, &amp;data, 1) == 1) {
        if (snd_mychip_try_to_transmit(data))
                snd_rawmidi_transmit_ack(substream, 1);
        else
                break; /* hardware FIFO full */
}
</pre></div>
</div>
<p>If you know beforehand that the hardware will accept data, you can use
the <a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_transmit" title="snd_rawmidi_transmit"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit()</span></code></a> function which reads some
data and removes them from the buffer at once:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while (snd_mychip_transmit_possible()) {
        unsigned char data;
        if (snd_rawmidi_transmit(substream, &amp;data, 1) != 1)
                break; /* no more data */
        snd_mychip_transmit(data);
}
</pre></div>
</div>
<p>If you know beforehand how many bytes you can accept, you can use a
buffer size greater than one with the
<a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_transmit" title="snd_rawmidi_transmit"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit*()</span></code></a> functions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback must not sleep. If the hardware FIFO is full
before the substream buffer has been emptied, you have to continue
transmitting data later, either in an interrupt handler, or with a
timer if the hardware doesn’t have a MIDI transmit interrupt.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback is called with a zero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter when
the transmission of data should be aborted.</p>
</div>
<div class="section" id="rawmidi-trigger-callback-for-input-substreams">
<h4>RawMIDI trigger callback for input substreams<a class="headerlink" href="#rawmidi-trigger-callback-for-input-substreams" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up);
</pre></div>
</div>
<p>This is called with a nonzero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter to enable receiving data,
or with a zero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter do disable receiving data.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback must not sleep; the actual reading of data
from the device is usually done in an interrupt handler.</p>
<p>When data reception is enabled, your interrupt handler should call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_rawmidi_receive" title="snd_rawmidi_receive"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_receive()</span></code></a> for all received data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void snd_mychip_midi_interrupt(...)
{
        while (mychip_midi_available()) {
                unsigned char data;
                data = mychip_midi_read();
                snd_rawmidi_receive(substream, &amp;data, 1);
        }
}
</pre></div>
</div>
</div>
<div class="section" id="drain-callback">
<h4>drain callback<a class="headerlink" href="#drain-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_drain(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>This is only used with output substreams. This function should wait
until all data read from the substream buffer have been transmitted.
This ensures that the device can be closed and the driver unloaded
without losing data.</p>
<p>This callback is optional. If you do not set <code class="docutils literal notranslate"><span class="pre">drain</span></code> in the struct
snd_rawmidi_ops structure, ALSA will simply wait for 50 milliseconds
instead.</p>
</div>
</div>
</div>
<div class="section" id="miscellaneous-devices">
<h2>Miscellaneous Devices<a class="headerlink" href="#miscellaneous-devices" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fm-opl3">
<h3>FM OPL3<a class="headerlink" href="#fm-opl3" title="Permalink to this headline">¶</a></h3>
<p>The FM OPL3 is still used in many chips (mainly for backward
compatibility). ALSA has a nice OPL3 FM control layer, too. The OPL3 API
is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/opl3.h&gt;</span></code>.</p>
<p>FM registers can be directly accessed through the direct-FM API, defined
in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound_fm.h&gt;</span></code>. In ALSA native mode, FM registers are
accessed through the Hardware-Dependent Device direct-FM extension API,
whereas in OSS compatible mode, FM registers can be accessed with the
OSS direct-FM compatible API in <code class="docutils literal notranslate"><span class="pre">/dev/dmfmX</span></code> device.</p>
<p>To create the OPL3 component, you have two functions to call. The first
one is a constructor for the <code class="docutils literal notranslate"><span class="pre">opl3_t</span></code> instance.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_opl3 *opl3;
snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,
                integrated, &amp;opl3);
</pre></div>
</div>
<p>The first argument is the card pointer, the second one is the left port
address, and the third is the right port address. In most cases, the
right port is placed at the left port + 2.</p>
<p>The fourth argument is the hardware type.</p>
<p>When the left and right ports have been already allocated by the card
driver, pass non-zero to the fifth argument (<code class="docutils literal notranslate"><span class="pre">integrated</span></code>). Otherwise,
the opl3 module will allocate the specified ports by itself.</p>
<p>When the accessing the hardware requires special method instead of the
standard I/O access, you can create opl3 instance separately with
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_new()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_opl3 *opl3;
snd_opl3_new(card, OPL3_HW_OPL3_XXX, &amp;opl3);
</pre></div>
</div>
<p>Then set <code class="docutils literal notranslate"><span class="pre">command</span></code>, <code class="docutils literal notranslate"><span class="pre">private_data</span></code> and <code class="docutils literal notranslate"><span class="pre">private_free</span></code> for the
private access function, the private data and the destructor. The
<code class="docutils literal notranslate"><span class="pre">l_port</span></code> and <code class="docutils literal notranslate"><span class="pre">r_port</span></code> are not necessarily set. Only the command
must be set properly. You can retrieve the data from the
<code class="docutils literal notranslate"><span class="pre">opl3-&gt;private_data</span></code> field.</p>
<p>After creating the opl3 instance via <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_new()</span></code>,
call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_init()</span></code> to initialize the chip to the
proper state. Note that <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_create()</span></code> always calls
it internally.</p>
<p>If the opl3 instance is created successfully, then create a hwdep device
for this opl3.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_hwdep *opl3hwdep;
snd_opl3_hwdep_new(opl3, 0, 1, &amp;opl3hwdep);
</pre></div>
</div>
<p>The first argument is the <code class="docutils literal notranslate"><span class="pre">opl3_t</span></code> instance you created, and the
second is the index number, usually 0.</p>
<p>The third argument is the index-offset for the sequencer client assigned
to the OPL3 port. When there is an MPU401-UART, give 1 for here (UART
always takes 0).</p>
</div>
<div class="section" id="hardware-dependent-devices">
<h3>Hardware-Dependent Devices<a class="headerlink" href="#hardware-dependent-devices" title="Permalink to this headline">¶</a></h3>
<p>Some chips need user-space access for special controls or for loading
the micro code. In such a case, you can create a hwdep
(hardware-dependent) device. The hwdep API is defined in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/hwdep.h&gt;</span></code>. You can find examples in opl3 driver or
<code class="docutils literal notranslate"><span class="pre">isa/sb/sb16_csp.c</span></code>.</p>
<p>The creation of the <code class="docutils literal notranslate"><span class="pre">hwdep</span></code> instance is done via
<a class="reference internal" href="../../driver-api/sound.html#c.snd_hwdep_new" title="snd_hwdep_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_hwdep_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_hwdep *hw;
snd_hwdep_new(card, &quot;My HWDEP&quot;, 0, &amp;hw);
</pre></div>
</div>
<p>where the third argument is the index number.</p>
<p>You can then pass any pointer value to the <code class="docutils literal notranslate"><span class="pre">private_data</span></code>. If you
assign a private data, you should define the destructor, too. The
destructor function is set in the <code class="docutils literal notranslate"><span class="pre">private_free</span></code> field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mydata *p = kmalloc(sizeof(*p), GFP_KERNEL);
hw-&gt;private_data = p;
hw-&gt;private_free = mydata_free;
</pre></div>
</div>
<p>and the implementation of the destructor would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void mydata_free(struct snd_hwdep *hw)
{
        struct mydata *p = hw-&gt;private_data;
        kfree(p);
}
</pre></div>
</div>
<p>The arbitrary file operations can be defined for this instance. The file
operators are defined in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> table. For example, assume that
this chip needs an ioctl.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hw-&gt;ops.open = mydata_open;
hw-&gt;ops.ioctl = mydata_ioctl;
hw-&gt;ops.release = mydata_release;
</pre></div>
</div>
<p>And implement the callback functions as you like.</p>
</div>
<div class="section" id="iec958-s-pdif">
<h3>IEC958 (S/PDIF)<a class="headerlink" href="#iec958-s-pdif" title="Permalink to this headline">¶</a></h3>
<p>Usually the controls for IEC958 devices are implemented via the control
interface. There is a macro to compose a name string for IEC958
controls, <code class="xref c c-func docutils literal notranslate"><span class="pre">SNDRV_CTL_NAME_IEC958()</span></code> defined in
<code class="docutils literal notranslate"><span class="pre">&lt;include/asound.h&gt;</span></code>.</p>
<p>There are some standard controls for IEC958 status bits. These controls
use the type <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_TYPE_IEC958</span></code>, and the size of element is
fixed as 4 bytes array (value.iec958.status[x]). For the <code class="docutils literal notranslate"><span class="pre">info</span></code>
callback, you don’t specify the value field for this type (the count
field must be set, though).</p>
<p>“IEC958 Playback Con Mask” is used to return the bit-mask for the IEC958
status bits of consumer mode. Similarly, “IEC958 Playback Pro Mask”
returns the bitmask for professional mode. They are read-only controls,
and are defined as MIXER controls (iface =
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_MIXER</span></code>).</p>
<p>Meanwhile, “IEC958 Playback Default” control is defined for getting and
setting the current default IEC958 bits. Note that this one is usually
defined as a PCM control (iface = <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_PCM</span></code>),
although in some places it’s defined as a MIXER control.</p>
<p>In addition, you can define the control switches to enable/disable or to
set the raw bit mode. The implementation will depend on the chip, but
the control should be named as “IEC958 xxx”, preferably using the
<code class="xref c c-func docutils literal notranslate"><span class="pre">SNDRV_CTL_NAME_IEC958()</span></code> macro.</p>
<p>You can find several cases, for example, <code class="docutils literal notranslate"><span class="pre">pci/emu10k1</span></code>,
<code class="docutils literal notranslate"><span class="pre">pci/ice1712</span></code>, or <code class="docutils literal notranslate"><span class="pre">pci/cmipci.c</span></code>.</p>
</div>
</div>
<div class="section" id="buffer-and-memory-management">
<h2>Buffer and Memory Management<a class="headerlink" href="#buffer-and-memory-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="buffer-types">
<h3>Buffer Types<a class="headerlink" href="#buffer-types" title="Permalink to this headline">¶</a></h3>
<p>ALSA provides several different buffer allocation functions depending on
the bus and the architecture. All these have a consistent API. The
allocation of physically-contiguous pages is done via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_malloc_xxx_pages()</span></code> function, where xxx is the bus
type.</p>
<p>The allocation of pages with fallback is
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_malloc_xxx_pages_fallback()</span></code>. This function tries
to allocate the specified pages but if the pages are not available, it
tries to reduce the page sizes until enough space is found.</p>
<p>The release the pages, call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_free_xxx_pages()</span></code>
function.</p>
<p>Usually, ALSA drivers try to allocate and reserve a large contiguous
physical space at the time the module is loaded for the later use. This
is called “pre-allocation”. As already written, you can call the
following function at pcm instance construction time (in the case of PCI
bus).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                      &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">size</span></code> is the byte size to be pre-allocated and the <code class="docutils literal notranslate"><span class="pre">max</span></code> is
the maximum size to be changed via the <code class="docutils literal notranslate"><span class="pre">prealloc</span></code> proc file. The
allocator will try to get an area as large as possible within the
given size.</p>
<p>The second argument (type) and the third argument (device pointer) are
dependent on the bus. For normal devices, pass the device pointer
(typically identical as <code class="docutils literal notranslate"><span class="pre">card-&gt;dev</span></code>) to the third argument with
<code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV</span></code> type. For the continuous buffer unrelated to the
bus can be pre-allocated with <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_CONTINUOUS</span></code> type.
You can pass NULL to the device pointer in that case, which is the
default mode implying to allocate with <code class="docutils literal notranslate"><span class="pre">GFP_KRENEL</span></code> flag.
If you need a different GFP flag, you can pass it by encoding the flag
into the device pointer via a special macro
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_dma_continuous_data()</span></code>.
For the scatter-gather buffers, use <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV_SG</span></code> with the
device pointer (see the <a class="reference internal" href="#non-contiguous-buffers">Non-Contiguous Buffers</a> section).</p>
<p>Once the buffer is pre-allocated, you can use the allocator in the
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_malloc_pages(substream, size);
</pre></div>
</div>
<p>Note that you have to pre-allocate to use this function.</p>
<p>Most of drivers use, though, rather the newly introduced “managed
buffer allocation mode” instead of the manual allocation or release.
This is done by calling <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_set_managed_buffer_all" title="snd_pcm_set_managed_buffer_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer_all()</span></code></a>
instead of <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_preallocate_pages_for_all" title="snd_pcm_lib_preallocate_pages_for_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_preallocate_pages_for_all()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                               &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>where passed arguments are identical in both functions.
The difference in the managed mode is that PCM core will call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> internally already before calling
the PCM <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback, and call <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_free_pages" title="snd_pcm_lib_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_free_pages()</span></code></a>
after the PCM <code class="docutils literal notranslate"><span class="pre">hw_free</span></code> callback automatically.  So the driver
doesn’t have to call these functions explicitly in its callback any
longer.  This made many driver code having NULL <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> and
<code class="docutils literal notranslate"><span class="pre">hw_free</span></code> entries.</p>
</div>
<div class="section" id="external-hardware-buffers">
<h3>External Hardware Buffers<a class="headerlink" href="#external-hardware-buffers" title="Permalink to this headline">¶</a></h3>
<p>Some chips have their own hardware buffers and the DMA transfer from the
host memory is not available. In such a case, you need to either 1)
copy/set the audio data directly to the external hardware buffer, or 2)
make an intermediate buffer and copy/set the data from it to the
external hardware buffer in interrupts (or in tasklets, preferably).</p>
<p>The first case works fine if the external hardware buffer is large
enough. This method doesn’t need any extra buffers and thus is more
effective. You need to define the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> and <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code>
callbacks for the data transfer, in addition to <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code>
callback for playback. However, there is a drawback: it cannot be
mmapped. The examples are GUS’s GF1 PCM or emu8000’s wavetable PCM.</p>
<p>The second case allows for mmap on the buffer, although you have to
handle an interrupt or a tasklet to transfer the data from the
intermediate buffer to the hardware buffer. You can find an example in
the vxpocket driver.</p>
<p>Another case is when the chip uses a PCI memory-map region for the
buffer instead of the host memory. In this case, mmap is available only
on certain architectures like the Intel one. In non-mmap mode, the data
cannot be transferred as in the normal way. Thus you need to define the
<code class="docutils literal notranslate"><span class="pre">copy_user</span></code>, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> callbacks as well,
as in the cases above. The examples are found in <code class="docutils literal notranslate"><span class="pre">rme32.c</span></code> and
<code class="docutils literal notranslate"><span class="pre">rme96.c</span></code>.</p>
<p>The implementation of the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code>, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> and
<code class="docutils literal notranslate"><span class="pre">silence</span></code> callbacks depends upon whether the hardware supports
interleaved or non-interleaved samples. The <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> callback is
defined like below, a bit differently depending whether the direction
is playback or capture:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int playback_copy_user(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void __user *src, unsigned long count);
static int capture_copy_user(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void __user *dst, unsigned long count);
</pre></div>
</div>
<p>In the case of interleaved samples, the second argument (<code class="docutils literal notranslate"><span class="pre">channel</span></code>) is
not used. The third argument (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) points the current position
offset in bytes.</p>
<p>The meaning of the fourth argument is different between playback and
capture. For playback, it holds the source data pointer, and for
capture, it’s the destination data pointer.</p>
<p>The last argument is the number of bytes to be copied.</p>
<p>What you have to do in this callback is again different between playback
and capture directions. In the playback case, you copy the given amount
of data (<code class="docutils literal notranslate"><span class="pre">count</span></code>) at the specified pointer (<code class="docutils literal notranslate"><span class="pre">src</span></code>) to the specified
offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the hardware buffer. When coded like memcpy-like
way, the copy would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy_from_user(my_buffer + pos, src, count);
</pre></div>
</div>
<p>For the capture direction, you copy the given amount of data (<code class="docutils literal notranslate"><span class="pre">count</span></code>)
at the specified offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the hardware buffer to the
specified pointer (<code class="docutils literal notranslate"><span class="pre">dst</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy_to_user(dst, my_buffer + pos, count);
</pre></div>
</div>
<p>Here the functions are named as <code class="docutils literal notranslate"><span class="pre">from_user</span></code> and <code class="docutils literal notranslate"><span class="pre">to_user</span></code> because
it’s the user-space buffer that is passed to these callbacks.  That
is, the callback is supposed to copy from/to the user-space data
directly to/from the hardware buffer.</p>
<p>Careful readers might notice that these callbacks receive the
arguments in bytes, not in frames like other callbacks.  It’s because
it would make coding easier like the examples above, and also it makes
easier to unify both the interleaved and non-interleaved cases, as
explained in the following.</p>
<p>In the case of non-interleaved samples, the implementation will be a bit
more complicated.  The callback is called for each channel, passed by
the second argument, so totally it’s called for N-channels times per
transfer.</p>
<p>The meaning of other arguments are almost same as the interleaved
case.  The callback is supposed to copy the data from/to the given
user-space buffer, but only for the given channel.  For the detailed
implementations, please check <code class="docutils literal notranslate"><span class="pre">isa/gus/gus_pcm.c</span></code> or
“pci/rme9652/rme9652.c” as examples.</p>
<p>The above callbacks are the copy from/to the user-space buffer.  There
are some cases where we want copy from/to the kernel-space buffer
instead.  In such a case, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> callback is called.  It’d
look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int playback_copy_kernel(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void *src, unsigned long count);
static int capture_copy_kernel(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void *dst, unsigned long count);
</pre></div>
</div>
<p>As found easily, the only difference is that the buffer pointer is
without <code class="docutils literal notranslate"><span class="pre">__user</span></code> prefix; that is, a kernel-buffer pointer is passed
in the fourth argument.  Correspondingly, the implementation would be
a version without the user-copy, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy(my_buffer + pos, src, count);
</pre></div>
</div>
<p>Usually for the playback, another callback <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> is
defined.  It’s implemented in a similar way as the copy callbacks
above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int silence(struct snd_pcm_substream *substream, int channel,
                   unsigned long pos, unsigned long count);
</pre></div>
</div>
<p>The meanings of arguments are the same as in the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> and
<code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> callbacks, although there is no buffer pointer
argument. In the case of interleaved samples, the channel argument has
no meaning, as well as on <code class="docutils literal notranslate"><span class="pre">copy_*</span></code> callbacks.</p>
<p>The role of <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> callback is to set the given amount
(<code class="docutils literal notranslate"><span class="pre">count</span></code>) of silence data at the specified offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the
hardware buffer. Suppose that the data format is signed (that is, the
silent-data is 0), and the implementation using a memset-like function
would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memset(my_buffer + pos, 0, count);
</pre></div>
</div>
<p>In the case of non-interleaved samples, again, the implementation
becomes a bit more complicated, as it’s called N-times per transfer
for each channel. See, for example, <code class="docutils literal notranslate"><span class="pre">isa/gus/gus_pcm.c</span></code>.</p>
</div>
<div class="section" id="non-contiguous-buffers">
<h3>Non-Contiguous Buffers<a class="headerlink" href="#non-contiguous-buffers" title="Permalink to this headline">¶</a></h3>
<p>If your hardware supports the page table as in emu10k1 or the buffer
descriptors as in via82xx, you can use the scatter-gather (SG) DMA. ALSA
provides an interface for handling SG-buffers. The API is provided in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>.</p>
<p>For creating the SG-buffer handler, call
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_set_managed_buffer" title="snd_pcm_set_managed_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer()</span></code></a> or
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_set_managed_buffer_all" title="snd_pcm_set_managed_buffer_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer_all()</span></code></a> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV_SG</span></code> in the PCM constructor like other PCI
pre-allocator. You need to pass <code class="docutils literal notranslate"><span class="pre">&amp;pci-&gt;dev</span></code>, where pci is
the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span></code> pointer of the chip as
well.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
                               &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_sg_buf</span></code> instance is created as
<code class="docutils literal notranslate"><span class="pre">substream-&gt;dma_private</span></code> in turn. You can cast the pointer like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_sg_buf *sgbuf = (struct snd_sg_buf *)substream-&gt;dma_private;
</pre></div>
</div>
<p>Then in <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> call, the common SG-buffer
handler will allocate the non-contiguous kernel pages of the given size
and map them onto the virtually contiguous memory. The virtual pointer
is addressed in runtime-&gt;dma_area. The physical address
(<code class="docutils literal notranslate"><span class="pre">runtime-&gt;dma_addr</span></code>) is set to zero, because the buffer is
physically non-contiguous. The physical address table is set up in
<code class="docutils literal notranslate"><span class="pre">sgbuf-&gt;table</span></code>. You can get the physical address at a certain offset
via <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_sgbuf_get_addr" title="snd_pcm_sgbuf_get_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_sgbuf_get_addr()</span></code></a>.</p>
<p>If you need to release the SG-buffer data explicitly, call the
standard API function <a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_free_pages" title="snd_pcm_lib_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_free_pages()</span></code></a> as usual.</p>
</div>
<div class="section" id="vmalloc-ed-buffers">
<h3>Vmalloc’ed Buffers<a class="headerlink" href="#vmalloc-ed-buffers" title="Permalink to this headline">¶</a></h3>
<p>It’s possible to use a buffer allocated via <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, for
example, for an intermediate buffer. In the recent version of kernel,
you can simply allocate it via standard
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> and co after setting up the
buffer preallocation with <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_VMALLOC</span></code> type.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
                               NULL, 0, 0);
</pre></div>
</div>
<p>The NULL is passed to the device pointer argument, which indicates
that the default pages (GFP_KERNEL and GFP_HIGHMEM) will be
allocated.</p>
<p>Also, note that zero is passed to both the size and the max size
arguments here.  Since each vmalloc call should succeed at any time,
we don’t need to pre-allocate the buffers like other continuous
pages.</p>
<p>If you need the 32bit DMA allocation, pass the device pointer encoded
by <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_dma_continuous_data()</span></code> with <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL|__GFP_DMA32</span></code>
argument.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
        snd_dma_continuous_data(GFP_KERNEL | __GFP_DMA32), 0, 0);
</pre></div>
</div>
</div>
</div>
<div class="section" id="proc-interface">
<h2>Proc Interface<a class="headerlink" href="#proc-interface" title="Permalink to this headline">¶</a></h2>
<p>ALSA provides an easy interface for procfs. The proc files are very
useful for debugging. I recommend you set up proc files if you write a
driver and want to get a running status or register dumps. The API is
found in <code class="docutils literal notranslate"><span class="pre">&lt;sound/info.h&gt;</span></code>.</p>
<p>To create a proc file, call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_proc_new()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_info_entry *entry;
int err = snd_card_proc_new(card, &quot;my-file&quot;, &amp;entry);
</pre></div>
</div>
<p>where the second argument specifies the name of the proc file to be
created. The above example will create a file <code class="docutils literal notranslate"><span class="pre">my-file</span></code> under the
card directory, e.g. <code class="docutils literal notranslate"><span class="pre">/proc/asound/card0/my-file</span></code>.</p>
<p>Like other components, the proc entry created via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_proc_new()</span></code> will be registered and released
automatically in the card registration and release functions.</p>
<p>When the creation is successful, the function stores a new instance in
the pointer given in the third argument. It is initialized as a text
proc file for read only. To use this proc file as a read-only text file
as it is, set the read callback with a private data via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_set_text_ops()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_info_set_text_ops(entry, chip, my_proc_read);
</pre></div>
</div>
<p>where the second argument (<code class="docutils literal notranslate"><span class="pre">chip</span></code>) is the private data to be used in
the callbacks. The third parameter specifies the read buffer size and
the fourth (<code class="docutils literal notranslate"><span class="pre">my_proc_read</span></code>) is the callback function, which is
defined like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void my_proc_read(struct snd_info_entry *entry,
                         struct snd_info_buffer *buffer);
</pre></div>
</div>
<p>In the read callback, use <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_iprintf()</span></code> for output
strings, which works just like normal <code class="xref c c-func docutils literal notranslate"><span class="pre">printf()</span></code>. For
example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void my_proc_read(struct snd_info_entry *entry,
                         struct snd_info_buffer *buffer)
{
        struct my_chip *chip = entry-&gt;private_data;

        snd_iprintf(buffer, &quot;This is my chip!\n&quot;);
        snd_iprintf(buffer, &quot;Port = %ld\n&quot;, chip-&gt;port);
}
</pre></div>
</div>
<p>The file permissions can be changed afterwards. As default, it’s set as
read only for all users. If you want to add write permission for the
user (root as default), do as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry-&gt;mode = S_IFREG | S_IRUGO | S_IWUSR;
</pre></div>
</div>
<p>and set the write buffer size and the callback</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry-&gt;c.text.write = my_proc_write;
</pre></div>
</div>
<p>For the write callback, you can use <a class="reference internal" href="../../driver-api/sound.html#c.snd_info_get_line" title="snd_info_get_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_get_line()</span></code></a>
to get a text line, and <a class="reference internal" href="../../driver-api/sound.html#c.snd_info_get_str" title="snd_info_get_str"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_get_str()</span></code></a> to retrieve
a string from the line. Some examples are found in
<code class="docutils literal notranslate"><span class="pre">core/oss/mixer_oss.c</span></code>, core/oss/and <code class="docutils literal notranslate"><span class="pre">pcm_oss.c</span></code>.</p>
<p>For a raw-data proc-file, set the attributes as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct snd_info_entry_ops my_file_io_ops = {
        .read = my_file_io_read,
};

entry-&gt;content = SNDRV_INFO_CONTENT_DATA;
entry-&gt;private_data = chip;
entry-&gt;c.ops = &amp;my_file_io_ops;
entry-&gt;size = 4096;
entry-&gt;mode = S_IFREG | S_IRUGO;
</pre></div>
</div>
<p>For the raw data, <code class="docutils literal notranslate"><span class="pre">size</span></code> field must be set properly. This specifies
the maximum size of the proc file access.</p>
<p>The read/write callbacks of raw mode are more direct than the text mode.
You need to use a low-level I/O functions such as
<code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from/to_user()</span></code> to transfer the data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static ssize_t my_file_io_read(struct snd_info_entry *entry,
                            void *file_private_data,
                            struct file *file,
                            char *buf,
                            size_t count,
                            loff_t pos)
{
        if (copy_to_user(buf, local_data + pos, count))
                return -EFAULT;
        return count;
}
</pre></div>
</div>
<p>If the size of the info entry has been set up properly, <code class="docutils literal notranslate"><span class="pre">count</span></code> and
<code class="docutils literal notranslate"><span class="pre">pos</span></code> are guaranteed to fit within 0 and the given size. You don’t
have to check the range in the callbacks unless any other condition is
required.</p>
</div>
<div class="section" id="power-management">
<h2>Power Management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h2>
<p>If the chip is supposed to work with suspend/resume functions, you need
to add power-management code to the driver. The additional code for
power-management should be ifdef-ed with <code class="docutils literal notranslate"><span class="pre">CONFIG_PM</span></code>, or annotated
with __maybe_unused attribute; otherwise the compiler will complain
you.</p>
<p>If the driver <em>fully</em> supports suspend/resume that is, the device can be
properly resumed to its state when suspend was called, you can set the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag in the pcm info field. Usually, this is
possible when the registers of the chip can be safely saved and restored
to RAM. If this is set, the trigger callback is called with
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_RESUME</span></code> after the resume callback completes.</p>
<p>Even if the driver doesn’t support PM fully but partial suspend/resume
is still possible, it’s still worthy to implement suspend/resume
callbacks. In such a case, applications would reset the status by
calling <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_prepare" title="snd_pcm_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_prepare()</span></code></a> and restart the stream
appropriately. Hence, you can define suspend/resume callbacks below but
don’t set <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> info flag to the PCM.</p>
<p>Note that the trigger with SUSPEND can always be called when
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_suspend_all" title="snd_pcm_suspend_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_suspend_all()</span></code></a> is called, regardless of the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag. The <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> flag affects only the
behavior of <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_resume()</span></code>. (Thus, in theory,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_RESUME</span></code> isn’t needed to be handled in the trigger
callback when no <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag is set. But, it’s better
to keep it for compatibility reasons.)</p>
<p>In the earlier version of ALSA drivers, a common power-management layer
was provided, but it has been removed. The driver needs to define the
suspend/resume hooks according to the bus the device is connected to. In
the case of PCI drivers, the callbacks look like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused snd_my_suspend(struct device *dev)
{
        .... /* do things for suspend */
        return 0;
}
static int __maybe_unused snd_my_resume(struct device *dev)
{
        .... /* do things for suspend */
        return 0;
}
</pre></div>
</div>
<p>The scheme of the real suspend job is as follows.</p>
<ol class="arabic simple">
<li><p>Retrieve the card and the chip data.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_change_state()</span></code> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_POWER_D3hot</span></code> to change the power status.</p></li>
<li><p>If AC97 codecs are used, call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_suspend" title="snd_ac97_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_suspend()</span></code></a> for
each codec.</p></li>
<li><p>Save the register values if necessary.</p></li>
<li><p>Stop the hardware if necessary.</p></li>
</ol>
<p>A typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused mychip_suspend(struct device *dev)
{
        /* (1) */
        struct snd_card *card = dev_get_drvdata(dev);
        struct mychip *chip = card-&gt;private_data;
        /* (2) */
        snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
        /* (3) */
        snd_ac97_suspend(chip-&gt;ac97);
        /* (4) */
        snd_mychip_save_registers(chip);
        /* (5) */
        snd_mychip_stop_hardware(chip);
        return 0;
}
</pre></div>
</div>
<p>The scheme of the real resume job is as follows.</p>
<ol class="arabic simple">
<li><p>Retrieve the card and the chip data.</p></li>
<li><p>Re-initialize the chip.</p></li>
<li><p>Restore the saved registers if necessary.</p></li>
<li><p>Resume the mixer, e.g. calling <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_resume" title="snd_ac97_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_resume()</span></code></a>.</p></li>
<li><p>Restart the hardware (if any).</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_change_state()</span></code> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_POWER_D0</span></code> to notify the processes.</p></li>
</ol>
<p>A typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused mychip_resume(struct pci_dev *pci)
{
        /* (1) */
        struct snd_card *card = dev_get_drvdata(dev);
        struct mychip *chip = card-&gt;private_data;
        /* (2) */
        snd_mychip_reinit_chip(chip);
        /* (3) */
        snd_mychip_restore_registers(chip);
        /* (4) */
        snd_ac97_resume(chip-&gt;ac97);
        /* (5) */
        snd_mychip_restart_chip(chip);
        /* (6) */
        snd_power_change_state(card, SNDRV_CTL_POWER_D0);
        return 0;
}
</pre></div>
</div>
<p>Note that, at the time this callback gets called, the PCM stream has
been already suspended via its own PM ops calling
<a class="reference internal" href="../../driver-api/sound.html#c.snd_pcm_suspend_all" title="snd_pcm_suspend_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_suspend_all()</span></code></a> internally.</p>
<p>OK, we have all callbacks now. Let’s set them up. In the initialization
of the card, make sure that you can get the chip data from the card
instance, typically via <code class="docutils literal notranslate"><span class="pre">private_data</span></code> field, in case you created the
chip data individually.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        ....
        struct snd_card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           0, &amp;card);
        ....
        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        ....
        card-&gt;private_data = chip;
        ....
}
</pre></div>
</div>
<p>When you created the chip data with <a class="reference internal" href="../../driver-api/sound.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>, it’s
anyway accessible via <code class="docutils literal notranslate"><span class="pre">private_data</span></code> field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        ....
        struct snd_card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           sizeof(struct mychip), &amp;card);
        ....
        chip = card-&gt;private_data;
        ....
}
</pre></div>
</div>
<p>If you need a space to save the registers, allocate the buffer for it
here, too, since it would be fatal if you cannot allocate a memory in
the suspend phase. The allocated buffer should be released in the
corresponding destructor.</p>
<p>And next, set suspend/resume callbacks to the pci_driver.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static SIMPLE_DEV_PM_OPS(snd_my_pm_ops, mychip_suspend, mychip_resume);

static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_my_ids,
        .probe = snd_my_probe,
        .remove = snd_my_remove,
        .driver.pm = &amp;snd_my_pm_ops,
};
</pre></div>
</div>
</div>
<div class="section" id="module-parameters">
<h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<p>There are standard module options for ALSA. At least, each module should
have the <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">enable</span></code> options.</p>
<p>If the module supports multiple cards (usually up to 8 = <code class="docutils literal notranslate"><span class="pre">SNDRV_CARDS</span></code>
cards), they should be arrays. The default initial values are defined
already as constants for easier programming:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
</pre></div>
</div>
<p>If the module supports only a single card, they could be single
variables, instead. <code class="docutils literal notranslate"><span class="pre">enable</span></code> option is not always necessary in this
case, but it would be better to have a dummy option for compatibility.</p>
<p>The module parameters must be declared with the standard
<code class="docutils literal notranslate"><span class="pre">module_param()</span></code>, <code class="docutils literal notranslate"><span class="pre">module_param_array()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">MODULE_PARM_DESC()</span></code> macros.</p>
<p>The typical coding would be like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define CARD_NAME &quot;My Chip&quot;

module_param_array(index, int, NULL, 0444);
MODULE_PARM_DESC(index, &quot;Index value for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(id, charp, NULL, 0444);
MODULE_PARM_DESC(id, &quot;ID string for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(enable, bool, NULL, 0444);
MODULE_PARM_DESC(enable, &quot;Enable &quot; CARD_NAME &quot; soundcard.&quot;);
</pre></div>
</div>
<p>Also, don’t forget to define the module description and the license.
Especially, the recent modprobe requires to define the
module license as GPL, etc., otherwise the system is shown as “tainted”.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODULE_DESCRIPTION(&quot;Sound driver for My Chip&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
</pre></div>
</div>
</div>
<div class="section" id="how-to-put-your-driver-into-alsa-tree">
<h2>How To Put Your Driver Into ALSA Tree<a class="headerlink" href="#how-to-put-your-driver-into-alsa-tree" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>General<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>So far, you’ve learned how to write the driver codes. And you might have
a question now: how to put my own driver into the ALSA driver tree? Here
(finally :) the standard procedure is described briefly.</p>
<p>Suppose that you create a new PCI driver for the card “xyz”. The card
module name would be snd-xyz. The new driver is usually put into the
alsa-driver tree, <code class="docutils literal notranslate"><span class="pre">sound/pci</span></code> directory in the case of PCI
cards.</p>
<p>In the following sections, the driver code is supposed to be put into
Linux kernel tree. The two cases are covered: a driver consisting of a
single source file and one consisting of several source files.</p>
</div>
<div class="section" id="driver-with-a-single-source-file">
<h3>Driver with A Single Source File<a class="headerlink" href="#driver-with-a-single-source-file" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Modify sound/pci/Makefile</p>
<p>Suppose you have a file xyz.c. Add the following two lines</p>
</li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd-xyz-objs := xyz.o
obj-$(CONFIG_SND_XYZ) += snd-xyz.o
</pre></div>
</div>
<ol class="arabic" start="2">
<li><p>Create the Kconfig entry</p>
<p>Add the new entry of Kconfig for your xyz driver. config SND_XYZ
tristate “Foobar XYZ” depends on SND select SND_PCM help Say Y here
to include support for Foobar XYZ soundcard. To compile this driver
as a module, choose M here: the module will be called snd-xyz. the
line, select SND_PCM, specifies that the driver xyz supports PCM. In
addition to SND_PCM, the following components are supported for
select command: SND_RAWMIDI, SND_TIMER, SND_HWDEP,
SND_MPU401_UART, SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB,
SND_AC97_CODEC. Add the select command for each supported
component.</p>
<p>Note that some selections imply the lowlevel selections. For example,
PCM includes TIMER, MPU401_UART includes RAWMIDI, AC97_CODEC
includes PCM, and OPL3_LIB includes HWDEP. You don’t need to give
the lowlevel selections again.</p>
<p>For the details of Kconfig script, refer to the kbuild documentation.</p>
</li>
</ol>
</div>
<div class="section" id="drivers-with-several-source-files">
<h3>Drivers with Several Source Files<a class="headerlink" href="#drivers-with-several-source-files" title="Permalink to this headline">¶</a></h3>
<p>Suppose that the driver snd-xyz have several source files. They are
located in the new subdirectory, sound/pci/xyz.</p>
<ol class="arabic simple">
<li><p>Add a new directory (<code class="docutils literal notranslate"><span class="pre">sound/pci/xyz</span></code>) in <code class="docutils literal notranslate"><span class="pre">sound/pci/Makefile</span></code>
as below</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>obj-$(CONFIG_SND) += sound/pci/xyz/
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Under the directory <code class="docutils literal notranslate"><span class="pre">sound/pci/xyz</span></code>, create a Makefile</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd-xyz-objs := xyz.o abc.o def.o
obj-$(CONFIG_SND_XYZ) += snd-xyz.o
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p>Create the Kconfig entry</p>
<p>This procedure is as same as in the last section.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="useful-functions">
<h2>Useful Functions<a class="headerlink" href="#useful-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="snd-printk-and-friends">
<h3><a class="reference internal" href="../../driver-api/sound.html#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> and friends<a class="headerlink" href="#snd-printk-and-friends" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This subsection describes a few helper functions for
decorating a bit more on the standard <a class="reference internal" href="../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> &amp; co.
However, in general, the use of such helpers is no longer recommended.
If possible, try to stick with the standard functions like
<code class="xref c c-func docutils literal notranslate"><span class="pre">dev_err()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">pr_err()</span></code>.</p>
</div>
<p>ALSA provides a verbose version of the <a class="reference internal" href="../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> function.
If a kernel config <code class="docutils literal notranslate"><span class="pre">CONFIG_SND_VERBOSE_PRINTK</span></code> is set, this function
prints the given message together with the file name and the line of the
caller. The <code class="docutils literal notranslate"><span class="pre">KERN_XXX</span></code> prefix is processed as well as the original
<a class="reference internal" href="../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> does, so it’s recommended to add this prefix,
e.g. snd_printk(KERN_ERR “Oh my, sorry, it’s extremely bad!\n”);</p>
<p>There are also <a class="reference internal" href="../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>’s for debugging.
<a class="reference internal" href="../../driver-api/sound.html#c.snd_printd" title="snd_printd"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printd()</span></code></a> can be used for general debugging purposes.
If <code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG</span></code> is set, this function is compiled, and works
just like <a class="reference internal" href="../../driver-api/sound.html#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a>. If the ALSA is compiled without
the debugging flag, it’s ignored.</p>
<p><a class="reference internal" href="../../driver-api/sound.html#c.snd_printdd" title="snd_printdd"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printdd()</span></code></a> is compiled in only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG_VERBOSE</span></code> is set.</p>
</div>
<div class="section" id="snd-bug">
<h3><a class="reference internal" href="../../driver-api/sound.html#c.snd_BUG" title="snd_BUG"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG()</span></code></a><a class="headerlink" href="#snd-bug" title="Permalink to this headline">¶</a></h3>
<p>It shows the <code class="docutils literal notranslate"><span class="pre">BUG?</span></code> message and stack trace as well as
<a class="reference internal" href="../../driver-api/sound.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a> at the point. It’s useful to show that a
fatal error happens there.</p>
<p>When no debug flag is set, this macro is ignored.</p>
</div>
<div class="section" id="snd-bug-on">
<h3><a class="reference internal" href="../../driver-api/sound.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a><a class="headerlink" href="#snd-bug-on" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../../driver-api/sound.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a> macro is similar with
<code class="xref c c-func docutils literal notranslate"><span class="pre">WARN_ON()</span></code> macro. For example, snd_BUG_ON(!pointer); or
it can be used as the condition, if (snd_BUG_ON(non_zero_is_bug))
return -EINVAL;</p>
<p>The macro takes an conditional expression to evaluate. When
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG</span></code>, is set, if the expression is non-zero, it shows
the warning message such as <code class="docutils literal notranslate"><span class="pre">BUG?</span> <span class="pre">(xxx)</span></code> normally followed by stack
trace. In both cases it returns the evaluated value.</p>
</div>
</div>
<div class="section" id="acknowledgments">
<h2>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h2>
<p>I would like to thank Phil Kerr for his help for improvement and
corrections of this document.</p>
<p>Kevin Conder reformatted the original plain-text to the DocBook format.</p>
<p>Giuliano Pochini corrected typos and contributed the example codes in
the hardware constraints section.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../designs/index.html" class="btn btn-neutral float-right" title="Designs and Implementations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="alsa-driver-api.html" class="btn btn-neutral float-left" title="The ALSA Driver API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>