

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mode Setting Helper Functions &mdash; The Linux Kernel 5.7.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Userland interfaces" href="drm-uapi.html" />
    <link rel="prev" title="Kernel Mode Setting (KMS)" href="drm-kms.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mode Setting Helper Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modeset-helper-reference-for-common-vtables">Modeset Helper Reference for Common Vtables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-modeset-helper-functions-reference">Atomic Modeset Helper Functions Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-asynchronous-atomic-commit">Implementing Asynchronous Atomic Commit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-functions-reference">Helper Functions Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-state-reset-and-initialization">Atomic State Reset and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-state-helper-reference">Atomic State Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simple-kms-helper-reference">Simple KMS Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fbdev-helper-functions-reference">fbdev Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#format-helper-functions-reference">format Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#framebuffer-cma-helper-functions-reference">Framebuffer CMA Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#framebuffer-gem-helper-reference">Framebuffer GEM Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bridges">Bridges</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-operations">Bridge Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-connector-helper">Bridge Connector Helper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-helper-reference">Bridge Helper Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-connector-helper-reference">Bridge Connector Helper Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#panel-bridge-helper-reference">Panel-Bridge Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#panel-helper-reference">Panel Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#panel-self-refresh-helper-reference">Panel Self Refresh Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hdcp-helper-functions-reference">HDCP Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-helper-functions-reference">Display Port Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-cec-helper-functions-reference">Display Port CEC Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-dual-mode-adaptor-helper-functions-reference">Display Port Dual Mode Adaptor Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-mst-helpers">Display Port MST Helpers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-reference">Functions Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#topology-lifetime-internals">Topology Lifetime Internals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mipi-dbi-helper-functions-reference">MIPI DBI Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mipi-dsi-helper-functions-reference">MIPI DSI Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-stream-compression-helper-functions-reference">Display Stream Compression Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-probing-helper-functions-reference">Output Probing Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edid-helper-functions-reference">EDID Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scdc-helper-functions-reference">SCDC Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hdmi-infoframes-helper-reference">HDMI Infoframes Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rectangle-utilities-reference">Rectangle Utilities Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flip-work-helper-reference">Flip-work Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-modeset-helpers">Auxiliary Modeset Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#of-dt-helpers">OF/DT Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-plane-helper-reference">Legacy Plane Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-crtc-modeset-helper-functions-reference">Legacy CRTC/Modeset Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shmem-gem-helper-reference">SHMEM GEM Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>Mode Setting Helper Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-kms-helpers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mode-setting-helper-functions">
<h1>Mode Setting Helper Functions<a class="headerlink" href="#mode-setting-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>The DRM subsystem aims for a strong separation between core code and helper
libraries. Core code takes care of general setup and teardown and decoding
userspace requests to kernel internal objects. Everything else is handled by a
large set of helper libraries, which can be combined freely to pick and choose
for each driver what fits, and avoid shared code where special behaviour is
needed.</p>
<p>This distinction between core code and helpers is especially strong in the
modesetting code, where there’s a shared userspace ABI for all drivers. This is
in contrast to the render side, where pretty much everything (with very few
exceptions) can be considered optional helper code.</p>
<p>There are a few areas these helpers can grouped into:</p>
<ul class="simple">
<li><p>Helpers to implement modesetting. The important ones here are the atomic
helpers. Old drivers still often use the legacy CRTC helpers. They both share
the same set of common helper vtables. For really simple drivers (anything
that would have been a great fit in the deprecated fbdev subsystem) there’s
also the simple display pipe helpers.</p></li>
<li><p>There’s a big pile of helpers for handling outputs. First the generic bridge
helpers for handling encoder and transcoder IP blocks. Second the panel helpers
for handling panel-related information and logic. Plus then a big set of
helpers for the various sink standards (DisplayPort, HDMI, MIPI DSI). Finally
there’s also generic helpers for handling output probing, and for dealing with
EDIDs.</p></li>
<li><p>The last group of helpers concerns itself with the frontend side of a display
pipeline: Planes, handling rectangles for visibility checking and scissoring,
flip queues and assorted bits.</p></li>
</ul>
<div class="section" id="modeset-helper-reference-for-common-vtables">
<h2>Modeset Helper Reference for Common Vtables<a class="headerlink" href="#modeset-helper-reference-for-common-vtables" title="Permalink to this headline">¶</a></h2>
<p>The DRM mode setting helper functions are common code for drivers to use if
they wish.  Drivers are not forced to use this code in their
implementations but it would be useful if the code they do use at least
provides a consistent interface and operation to userspace. Therefore it is
highly recommended to use the provided helpers as much as possible.</p>
<p>Because there is only one pointer per modeset object to hold a vfunc table
for helper libraries they are by necessity shared among the different
helpers.</p>
<p>To make this clear all the helper vtables are pulled together in this location here.</p>
<dl class="type">
<dt id="c.drm_crtc_helper_funcs">
struct <code class="sig-name descname">drm_crtc_helper_funcs</code><a class="headerlink" href="#c.drm_crtc_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for CRTCs</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc_helper_funcs {
  void (*dpms)(struct drm_crtc *crtc, int mode);
  void (*prepare)(struct drm_crtc *crtc);
  void (*commit)(struct drm_crtc *crtc);
  enum drm_mode_status (*mode_valid)(struct drm_crtc *crtc, const struct drm_display_mode *mode);
  bool (*mode_fixup)(struct drm_crtc *crtc,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode, int x, int y, struct drm_framebuffer *old_fb);
  void (*mode_set_nofb)(struct drm_crtc *crtc);
  int (*mode_set_base)(struct drm_crtc *crtc, int x, int y, struct drm_framebuffer *old_fb);
  int (*mode_set_base_atomic)(struct drm_crtc *crtc,struct drm_framebuffer *fb, int x, int y, enum mode_set_atomic);
  void (*disable)(struct drm_crtc *crtc);
  int (*atomic_check)(struct drm_crtc *crtc, struct drm_crtc_state *state);
  void (*atomic_begin)(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (*atomic_flush)(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (*atomic_enable)(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (*atomic_disable)(struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  bool (*get_scanout_position)(struct drm_crtc *crtc,bool in_vblank_irq, int *vpos, int *hpos,ktime_t *stime, ktime_t *etime, const struct drm_display_mode *mode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Callback to control power levels on the CRTC.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy CRTC helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable a CRTC by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn’t used.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling a CRTC to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>atomic_enable</strong> and <strong>atomic_disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>This callback should prepare the CRTC for a subsequent modeset, which
in practice means the driver should disable the CRTC if it is
running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_disable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>This callback should commit the new mode on the CRTC after a modeset,
which in practice means the driver should enable the CRTC.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_enable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
crtc. This should be implemented if the crtc has some sort of
restriction in the modes it can display. For example, a given crtc
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate a mode. The parameter mode is the
display mode that userspace requested, adjusted_mode is the mode the
encoders need to be fed with. Note that this is the inverse semantics
of the meaning for the <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a>
vfunc. If the CRTC cannot support the requested conversion from mode
to adjusted_mode it should reject the modeset. See also
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
With atomic helpers it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback, but note that they’re not
perfectly equivalent: <strong>mode_valid</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>, but <strong>atomic_check</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>, because originally it was meant for
plane update checks only.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback is used by the legacy CRTC helpers to set a new mode,
position and framebuffer. Since it ties the primary plane to every
mode change it is incompatible with universal plane support. And
since it can’t update other planes it’s incompatible with atomic
modeset support.</p>
<p>This callback is only used by CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_nofb</span></code></dt><dd><p>This callback is used to update the display mode of a CRTC without
changing anything of the primary plane configuration. This fits the
requirement of atomic and hence is used by the atomic helpers. It is
also used by the transitional plane helpers to implement a
<strong>mode_set</strong> hook in drm_helper_crtc_mode_set().</p>
<p>Note that the display pipe is completely off when this function is
called. Atomic drivers which need hardware to be running before they
program the new display mode (e.g. because they implement runtime PM)
should not use this hook. This is because the helper library calls
this hook only once per mode change and not every time the display
pipeline is suspended using either DPMS or the new “ACTIVE” property.
Which means register values set in this callback might get reset when
the CRTC is suspended, but not restored.  Such drivers should instead
move all their CRTC setup into the <strong>atomic_enable</strong> callback.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_base</span></code></dt><dd><p>This callback is used by the legacy CRTC helpers to set a new
framebuffer and scanout position. It is optional and used as an
optimized fast-path instead of a full mode set operation with all the
resulting flickering. If it is not present
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> will fall back to a full modeset, using
the <strong>mode_set</strong> callback. Since it can’t update other planes it’s
incompatible with atomic modeset support.</p>
<p>This callback is only used by the CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_base_atomic</span></code></dt><dd><p>This callback is used by the fbdev helpers to set a new framebuffer
and scanout without sleeping, i.e. from an atomic calling context. It
is only used to implement kgdb support.</p>
<p>This callback is optional and only needed for kgdb support in the fbdev
helpers.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
for_each_encoder_on_crtc().</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don’t need to implement it if there’s no need to
disable anything at the CRTC level. To ensure that runtime PM
handling (using either DPMS or the new “ACTIVE” property) works
<strong>disable</strong> must be the inverse of <strong>atomic_enable</strong> for atomic drivers.
Atomic drivers should consider to use <strong>atomic_disable</strong> instead of
this one.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there’s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
CRTC: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p>Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>Drivers should check plane-update related CRTC constraints in this
hook. They can also check mode related limitations but need to be
aware of the calling order, since this hook is used by
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> whereas the preparations needed to
check output routing and the display mode is done in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. Therefore drivers that want to
check output routing and display mode constraints in this callback
must ensure that <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> has been called
beforehand. This is calling order used by the default helper
implementation in <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a>.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> this hook is called
after the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hook for planes, which
allows drivers to assign shared resources requested by planes in this
callback here. For more complicated dependencies the driver can call
the provided check helpers multiple times until the computed state
has a final configuration and everything has been checked.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_begin</span></code></dt><dd><p>Drivers should prepare for an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might be vblank
evasion, blocking updates by setting bits or doing preparatory work
for e.g. manual update display.</p>
<p>This hook is called before any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_flush</span></code></dt><dd><p>Drivers should finalize an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might include
checking that vblank evasion was successful, unblocking updates by
setting bits or setting the GO bit to flush out all updates.</p>
<p>Simple hardware or hardware with special requirements can commit and
flush out all updates for all planes from this hook and forgo all the
other commit hooks for plane updates.</p>
<p>This hook is called after any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should be used to enable the CRTC. With the atomic
drivers it is called before all encoders connected to this CRTC are
enabled through the encoder’s own <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>
hook.  If that sequence is too simple drivers can just add their own
hooks and call it from this CRTC callback here by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is used only by atomic helpers, for symmetry with
<strong>atomic_disable</strong>. Atomic drivers don’t need to implement it if there’s
no need to enable anything at the CRTC level. To ensure that runtime
PM handling (using either DPMS or the new “ACTIVE” property) works
<strong>atomic_enable</strong> must be the inverse of <strong>atomic_disable</strong> for atomic
drivers.</p>
<p>Drivers can use the <strong>old_crtc_state</strong> input parameter if the operations
needed to enable the CRTC don’t depend solely on the new state but
also on the transition between the old state and the new state.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
for_each_encoder_on_crtc().</p>
<p>This hook is used only by atomic helpers. Atomic drivers don’t
need to implement it if there’s no need to disable anything at the
CRTC level.</p>
<p>Comparing to <strong>disable</strong>, this one provides the additional input
parameter <strong>old_crtc_state</strong> which could be used to access the old
state. Atomic drivers should consider to use this one instead
of <strong>disable</strong>.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_scanout_position</span></code></dt><dd><p>Called by vblank timestamping code.</p>
<p>Returns the current display scanout position from a CRTC and an
optional accurate <a class="reference internal" href="../core-api/timekeeping.html#c.ktime_get" title="ktime_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ktime_get()</span></code></a> timestamp of when the position was
measured. Note that this is a helper callback which is only used
if a driver uses <a class="reference internal" href="drm-kms.html#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a>
for the <strong>drm_crtc_funcs.get_vblank_timestamp</strong> callback.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>crtc:</dt><dd><p>The CRTC.</p>
</dd>
<dt>in_vblank_irq:</dt><dd><p>True when called from <a class="reference internal" href="drm-kms.html#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>. Some drivers
need to apply some workarounds for gpu-specific vblank irq
quirks if the flag is set.</p>
</dd>
<dt>vpos:</dt><dd><p>Target location for current vertical scanout position.</p>
</dd>
<dt>hpos:</dt><dd><p>Target location for current horizontal scanout position.</p>
</dd>
<dt>stime:</dt><dd><p>Target location for timestamp taken immediately before
scanout position query. Can be NULL to skip timestamp.</p>
</dd>
<dt>etime:</dt><dd><p>Target location for timestamp taken immediately after
scanout position query. Can be NULL to skip timestamp.</p>
</dd>
<dt>mode:</dt><dd><p>Current display timings.</p>
</dd>
</dl>
<p>Returns vpos as a positive number while in active scanout area.
Returns vpos as a negative number inside vblank, counting the number
of scanlines to go until end of vblank, e.g., -1 means “one scanline
until start of active scanout / end of vblank.”</p>
<p>Returns:</p>
<p>True on success, false if a reliable scanout position counter could
not be read out.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_add">
void <code class="sig-name descname">drm_crtc_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, const struct <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs">drm_crtc_helper_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>helper vtable to set for <strong>crtc</strong></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_encoder_helper_funcs">
struct <code class="sig-name descname">drm_encoder_helper_funcs</code><a class="headerlink" href="#c.drm_encoder_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for encoders</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_encoder_helper_funcs {
  void (*dpms)(struct drm_encoder *encoder, int mode);
  enum drm_mode_status (*mode_valid)(struct drm_encoder *crtc, const struct drm_display_mode *mode);
  bool (*mode_fixup)(struct drm_encoder *encoder,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (*prepare)(struct drm_encoder *encoder);
  void (*commit)(struct drm_encoder *encoder);
  void (*mode_set)(struct drm_encoder *encoder,struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (*atomic_mode_set)(struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
  enum drm_connector_status (*detect)(struct drm_encoder *encoder, struct drm_connector *connector);
  void (*atomic_disable)(struct drm_encoder *encoder, struct drm_atomic_state *state);
  void (*atomic_enable)(struct drm_encoder *encoder, struct drm_atomic_state *state);
  void (*disable)(struct drm_encoder *encoder);
  void (*enable)(struct drm_encoder *encoder);
  int (*atomic_check)(struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Callback to control power levels on the encoder.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy encoder helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable an encoder by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn’t used.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling an encoder to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>enable</strong> and <strong>disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
encoder. This should be implemented if the encoder has some sort
of restriction in the modes it can display. For example, a given
encoder may be responsible to set a clock value. If the clock can
not produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> or a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>.
The parameter adjusted_mode is the input mode the encoder requires. It
can be modified by this callback and does not need to match mode. See
also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
This hook is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback. If <strong>atomic_check</strong> is used,
this hook isn’t called since <strong>atomic_check</strong> allows a strict superset
of the functionality of <strong>mode_fixup</strong>.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>This callback should prepare the encoder for a subsequent modeset,
which in practice means the driver should disable the encoder if it
is running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>disable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>This callback should commit the new mode on the encoder after a modeset,
which in practice means the driver should enable the encoder.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>enable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspend using either DPMS or the
new “ACTIVE” property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used both by the legacy CRTC helpers and the atomic
modeset helpers. It is optional in the atomic helpers.</p>
<p>NOTE:</p>
<p>If the driver uses the atomic modeset helpers and needs to inspect
the connector state or connector display info during mode setting,
<strong>atomic_mode_set</strong> can be used instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_mode_set</span></code></dt><dd><p>This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspended using either DPMS or the
new “ACTIVE” property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used by the atomic modeset helpers in place of the
<strong>mode_set</strong> callback, if set by the driver. It is optional and should
be used instead of <strong>mode_set</strong> if the driver needs to inspect the
connector state or display info, since there is no direct way to
go from the encoder to the current connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>This callback can be used by drivers who want to do detection on the
encoder object instead of in connector functions.</p>
<p>It is not used by any helper and therefore has purely driver-specific
semantics. New drivers shouldn’t use this and instead just implement
their own private callbacks.</p>
<p>FIXME:</p>
<p>This should just be converted into a pile of driver vfuncs.
Currently radeon, amdgpu and nouveau are using it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder’s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_disable</span></code></a> hook. If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC’s callback by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This callback is a variant of <strong>disable</strong> that provides the atomic state
to the driver. If <strong>atomic_disable</strong> is implemented, <strong>disable</strong> is not
called by the helpers.</p>
<p>This hook is only used by atomic helpers. Atomic drivers don’t need
to implement it if there’s no need to disable anything at the encoder
level. To ensure that runtime PM handling (using either DPMS or the
new “ACTIVE” property) works <strong>atomic_disable</strong> must be the inverse of
<strong>atomic_enable</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should be used to enable the encoder. It is called
after this encoder’s CRTC has been enabled using their own
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_enable</span></code></a> hook. If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC’s callback by looping over all encoders
connected to it using for_each_encoder_on_crtc().</p>
<p>This callback is a variant of <strong>enable</strong> that provides the atomic state
to the driver. If <strong>atomic_enable</strong> is implemented, <strong>enable</strong> is not
called by the helpers.</p>
<p>This hook is only used by atomic helpers, it is the opposite of
<strong>atomic_disable</strong>. Atomic drivers don’t need to implement it if there’s
no need to enable anything at the encoder level. To ensure that
runtime PM handling works <strong>atomic_enable</strong> must be the inverse of
<strong>atomic_disable</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder’s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.  If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC’s callback by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don’t need to implement it if there’s no need to
disable anything at the encoder level. To ensure that runtime PM
handling (using either DPMS or the new “ACTIVE” property) works
<strong>disable</strong> must be the inverse of <strong>enable</strong> for atomic drivers.</p>
<p>For atomic drivers also consider <strong>atomic_disable</strong> and save yourself
from having to read the NOTE below!</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there’s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
encoder: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p>Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This callback should be used to enable the encoder. With the atomic
drivers it is called after this encoder’s CRTC has been enabled using
their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.enable</span></code></a> hook.  If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC’s callback by looping over all encoders
connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is only used by atomic helpers, it is the opposite of
<strong>disable</strong>. Atomic drivers don’t need to implement it if there’s no
need to enable anything at the encoder level. To ensure that
runtime PM handling (using either DPMS or the new “ACTIVE” property)
works <strong>enable</strong> must be the inverse of <strong>disable</strong> for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This callback is used to validate encoder state for atomic drivers.
Since the encoder is the object connecting the CRTC and connector it
gets passed both states, to be able to validate interactions and
update the CRTC to match what the encoder needs for the requested
connector.</p>
<p>Since this provides a strict superset of the functionality of
<strong>mode_fixup</strong> (the requested and adjusted modes are both available
through the passed in <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>) <strong>mode_fixup</strong> is not
called when <strong>atomic_check</strong> is implemented.</p>
<p>This function is used by the atomic helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_encoder_helper_add">
void <code class="sig-name descname">drm_encoder_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>DRM encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>helper vtable to set for <strong>encoder</strong></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_helper_funcs">
struct <code class="sig-name descname">drm_connector_helper_funcs</code><a class="headerlink" href="#c.drm_connector_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for connectors</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_helper_funcs {
  int (*get_modes)(struct drm_connector *connector);
  int (*detect_ctx)(struct drm_connector *connector,struct drm_modeset_acquire_ctx *ctx, bool force);
  enum drm_mode_status (*mode_valid)(struct drm_connector *connector, struct drm_display_mode *mode);
  struct drm_encoder *(*best_encoder)(struct drm_connector *connector);
  struct drm_encoder *(*atomic_best_encoder)(struct drm_connector *connector, struct drm_connector_state *connector_state);
  int (*atomic_check)(struct drm_connector *connector, struct drm_atomic_state *state);
  void (*atomic_commit)(struct drm_connector *connector, struct drm_connector_state *state);
  int (*prepare_writeback_job)(struct drm_writeback_connector *connector, struct drm_writeback_job *job);
  void (*cleanup_writeback_job)(struct drm_writeback_connector *connector, struct drm_writeback_job *job);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>This function should fill in all modes currently valid for the sink
into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.probed_modes</span></code></a> list. It should also update the
EDID property by calling <a class="reference internal" href="drm-kms.html#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_update_edid_property()</span></code></a>.</p>
<p>The usual way to implement this is to cache the EDID retrieved in the
probe callback somewhere in the driver-private connector structure.
In this function drivers then parse the modes in the EDID and add
them by calling <a class="reference internal" href="#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_edid_modes()</span></code></a>. But connectors that driver a
fixed panel can also manually add specific modes using
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>. Drivers which manually add modes should also
make sure that the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>,
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.width_mm</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.height_mm</span></code></a> fields are
filled in.</p>
<p>Virtual drivers that just want some standard VESA mode with a given
resolution can call <a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_modes_noedid()</span></code></a>, and mark the preferred
one using <a class="reference internal" href="#c.drm_set_preferred_mode" title="drm_set_preferred_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_set_preferred_mode()</span></code></a>.</p>
<p>This function is only called after the <strong>detect</strong> hook has indicated
that a sink is connected and when the EDID isn’t overridden through
sysfs or the kernel commandline.</p>
<p>This callback is used by the probe helpers in e.g.
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it’s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p>The number of modes added by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect_ctx</span></code></dt><dd><p>Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>This is the atomic version of <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.detect</span></code></a>.</p>
<p>To avoid races against concurrent connector state updates, the
helper libraries always call this with ctx set to a valid context,
and <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a> will always be locked with
the ctx parameter set to this ctx. This allows taking additional
locks as required.</p>
<p>RETURNS:</p>
<p><a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_status</span></code></a> indicating the connector’s status,
or the error code returned by <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a>, -EDEADLK.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>Callback to validate a mode for a connector, irrespective of the
specific display configuration.</p>
<p>This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. <a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>This only filters the mode list supplied to userspace in the
GETCONNECTOR IOCTL. Compared to <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a>,
which are also called by the atomic helpers from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. This allows userspace to force and
ignore sink constraint (like the pixel clock limits in the screen’s
EDID), which is useful for e.g. testing, or working around a broken
EDID. Any source hardware constraint (which always need to be
enforced) therefore should be checked in one of the above callbacks,
and not this one here.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it’s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p>Either <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_status.MODE_OK</span></code></a> or one of the failure reasons in <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">drm_mode_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best_encoder</span></code></dt><dd><p>This function should select the best encoder for the given connector.</p>
<p>This function is used by both the atomic helpers (in the
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> function) and in the legacy CRTC
helpers.</p>
<p>NOTE:</p>
<p>In atomic drivers this function is called in the check phase of an
atomic update. The driver is not allowed to change or inspect
anything outside of arguments passed-in. Atomic drivers which need to
inspect dynamic configuration state should instead use
<strong>atomic_best_encoder</strong>.</p>
<p>You can leave this function to NULL if the connector is only
attached to a single encoder. In this case, the core will call
drm_connector_get_single_encoder() for you.</p>
<p>RETURNS:</p>
<p>Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren’t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_best_encoder</span></code></dt><dd><p>This is the atomic version of <strong>best_encoder</strong> for atomic drivers which
need to select the best encoder depending upon the desired
configuration and can’t select it statically.</p>
<p>This function is used by <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.
If it is not implemented, the core will fallback to <strong>best_encoder</strong>
(or drm_connector_get_single_encoder() if <strong>best_encoder</strong> is NULL).</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p>Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren’t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This hook is used to validate connector state. This function is
called from <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset</span></code></a>, and is called when
a connector property is set, or a modeset on the crtc is forced.</p>
<p>Because <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset</span></code></a> may be called multiple times,
this function should handle being called multiple times as well.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit</span></code></dt><dd><p>This hook is to be used by drivers implementing writeback connectors
that need a point when to commit the writeback job to the hardware.
The writeback_job to commit is available in
<a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.writeback_job</span></code></a>.</p>
<p>This hook is optional.</p>
<p>This callback is used by the atomic modeset helpers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic and legacy modeset helpers and by the
probe helpers.</p>
<dl class="function">
<dt id="c.drm_connector_helper_add">
void <code class="sig-name descname">drm_connector_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, const struct <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs">drm_connector_helper_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>DRM connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>helper vtable to set for <strong>connector</strong></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_helper_funcs">
struct <code class="sig-name descname">drm_plane_helper_funcs</code><a class="headerlink" href="#c.drm_plane_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for planes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_plane_helper_funcs {
  int (*prepare_fb)(struct drm_plane *plane, struct drm_plane_state *new_state);
  void (*cleanup_fb)(struct drm_plane *plane, struct drm_plane_state *old_state);
  int (*atomic_check)(struct drm_plane *plane, struct drm_plane_state *state);
  void (*atomic_update)(struct drm_plane *plane, struct drm_plane_state *old_state);
  void (*atomic_disable)(struct drm_plane *plane, struct drm_plane_state *old_state);
  int (*atomic_async_check)(struct drm_plane *plane, struct drm_plane_state *state);
  void (*atomic_async_update)(struct drm_plane *plane, struct drm_plane_state *new_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_fb</span></code></dt><dd><p>This hook is to prepare a framebuffer for scanout by e.g. pinning
its backing storage or relocating it into a contiguous block of
VRAM. Other possible preparatory work includes flushing caches.</p>
<p>This function must not block for outstanding rendering, since it is
called in the context of the atomic IOCTL even for async commits to
be able to return any errors to userspace. Instead the recommended
way is to fill out the <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fence</span></code></a> of the passed-in
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a>. If the driver doesn’t support native fences then
equivalent functionality should be implemented through private
members in the plane structure.</p>
<p>Drivers which always have their buffers pinned should use
<a class="reference internal" href="#c.drm_gem_fb_prepare_fb" title="drm_gem_fb_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_prepare_fb()</span></code></a> for this hook.</p>
<p>The helpers will call <strong>cleanup_fb</strong> with matching arguments for every
successful call to this hook.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>RETURNS:</p>
<p>0 on success or one of the following negative error codes allowed by
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> vfunc. When using helpers
this callback is the only one which can fail an atomic commit,
everything else must complete successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_fb</span></code></dt><dd><p>This hook is called to clean up any resources allocated for the given
framebuffer and plane configuration in <strong>prepare_fb</strong>.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>Drivers should check plane specific constraints in this hook.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> plane’s <strong>atomic_check</strong>
hooks are called before the ones for CRTCs, which allows drivers to
request shared resources that the CRTC controls here. For more
complicated dependencies the driver can call the provided check helpers
multiple times until the computed state has a final configuration and
everything has been checked.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_update</span></code></dt><dd><p>Drivers should use this function to update the plane state.  This
hook is called in-between the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>Drivers should use this function to unconditionally disable a plane.
This hook is called in-between the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks. It is an alternative to
<strong>atomic_update</strong>, which will be called for disabling planes, too, if
the <strong>atomic_disable</strong> hook isn’t implemented.</p>
<p>This hook is also useful to disable planes in preparation of a modeset,
by calling <a class="reference internal" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> from the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_async_check</span></code></dt><dd><p>Drivers should set this function pointer to check if the plane state
can be updated in a async fashion. Here async means “not vblank
synchronized”.</p>
<p>This hook is called by drm_atomic_async_check() to establish if a
given update can be committed asynchronously, that is, if it can
jump ahead of the state currently queued for update.</p>
<p>RETURNS:</p>
<p>Return 0 on success and any error returned indicates that the update
can not be applied in asynchronous manner.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_async_update</span></code></dt><dd><p>Drivers should set this function pointer to perform asynchronous
updates of planes, that is, jump ahead of the currently queued
state and update the plane. Here async means “not vblank
synchronized”.</p>
<p>This hook is called by <a class="reference internal" href="#c.drm_atomic_helper_async_commit" title="drm_atomic_helper_async_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_async_commit()</span></code></a>.</p>
<p>An async update will happen on legacy cursor updates. An async
update won’t happen if there is an outstanding commit modifying
the same plane.</p>
<p>Note that unlike <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_update</span></code></a> this hook
takes the new <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a> as parameter. When doing async_update
drivers shouldn’t replace the <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a> but update the
current one with the new plane configurations in the new
plane_state.</p>
<p>Drivers should also swap the framebuffers between current plane
state (<a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a>) and new_state.
This is required since cleanup for async commits is performed on
the new state, rather than old state like for traditional commits.
Since we want to give up the reference on the current (old) fb
instead of our brand new one, swap them in the driver during the
async commit.</p>
<dl class="simple">
<dt>FIXME:</dt><dd><ul class="simple">
<li><p>It only works for single plane updates</p></li>
<li><p>Async Pageflips are not supported yet</p></li>
<li><p>Some hw might still scan out the old buffer until the next
vblank, however we let go of the fb references as soon as
we run this hook. For now drivers must implement their own workers
for deferring if needed, until a common solution is created.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic helpers and by the transitional plane
helpers.</p>
<dl class="function">
<dt id="c.drm_plane_helper_add">
void <code class="sig-name descname">drm_plane_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, const struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs">drm_plane_helper_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>DRM plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>helper vtable to set for <strong>plane</strong></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_mode_config_helper_funcs">
struct <code class="sig-name descname">drm_mode_config_helper_funcs</code><a class="headerlink" href="#c.drm_mode_config_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>global modeset helper operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_config_helper_funcs {
  void (*atomic_commit_tail)(struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit_tail</span></code></dt><dd><p>This hook is used by the default atomic_commit() hook implemented in
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> together with the nonblocking commit
helpers (see <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for a starting point)
to implement blocking and nonblocking commits easily. It is not used
by the atomic helpers</p>
<p>This function is called when the new atomic state has already been
swapped into the various state pointers. The passed in state
therefore contains copies of the old/previous state. This hook should
commit the new state into hardware. Note that the helpers have
already waited for preceeding atomic commits and fences, but drivers
can add more waiting calls at the start of their implementation, e.g.
to wait for driver-internal request for implicit syncing, before
starting to commit the update to the hardware.</p>
<p>After the atomic update is committed to the hardware this hook needs
to call <a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. Then wait for the upate
to be executed by the hardware, for example using
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a>, and then clean up the old
framebuffers using <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>When disabling a CRTC this hook _must_ stall for the commit to
complete. Vblank waits don’t work on disabled CRTC, hence the core
can’t take care of this. And it also can’t rely on the vblank event,
since that can be signalled already when the screen shows black,
which can happen much earlier than the last hardware access needed to
shut off the display pipeline completely.</p>
<p>This hook is optional, the default implementation is
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These helper functions are used by the atomic helpers.</p>
</div>
<div class="section" id="atomic-modeset-helper-functions-reference">
<span id="drm-atomic-helper"></span><h2>Atomic Modeset Helper Functions Reference<a class="headerlink" href="#atomic-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>This helper library provides implementations of check and commit functions on
top of the CRTC modeset helper callbacks and the plane helper callbacks. It
also provides convenience implementations for the atomic state handling
callbacks for drivers which don’t need to subclass the drm core structures to
add their own additional internal state.</p>
<p>This library also provides default implementations for the check callback in
<a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> and for the commit callback with
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a>. But the individual stages and callbacks are
exposed to allow drivers to mix and match and e.g. use the plane helpers only
together with a driver private modeset implementation.</p>
<p>This library also provides implementations for all the legacy driver
interfaces on top of the atomic interface. See <a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_set_config()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> and the
various functions to implement set_property callbacks. New drivers must not
implement these functions themselves but must use the provided helpers.</p>
<p>The atomic helper uses the same function table structures as all other
modesetting helpers. See the documentation for <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a>,
struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a> and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a>. It
also shares the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> function table with the plane
helpers.</p>
</div>
<div class="section" id="implementing-asynchronous-atomic-commit">
<h3>Implementing Asynchronous Atomic Commit<a class="headerlink" href="#implementing-asynchronous-atomic-commit" title="Permalink to this headline">¶</a></h3>
<p>Nonblocking atomic commits should use struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> to sequence
different operations against each another. Locks, especially struct
<a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>, should not be held in worker threads or any other
asynchronous context used to commit the hardware state.</p>
<p><a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> implements the recommended sequence for
nonblocking commits, using <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> internally:</p>
<p>1. Run <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>. Since this can fail and we
need to propagate out of memory/VRAM errors to userspace, it must be called
synchronously.</p>
<p>2. Synchronize with any outstanding nonblocking commit worker threads which
might be affected by the new state update. This is handled by
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>.</p>
<p>Asynchronous workers need to have sufficient parallelism to be able to run
different atomic commits on different CRTCs in parallel. The simplest way to
achieve this is by running them on the <code class="xref c c-type docutils literal notranslate"><span class="pre">system_unbound_wq</span></code> work queue. Note
that drivers are not required to split up atomic commits and run an
individual commit in parallel - userspace is supposed to do that if it cares.
But it might be beneficial to do that for modesets, since those necessarily
must be done as one global operation, and enabling or disabling a CRTC can
take a long time. But even that is not required.</p>
<p>IMPORTANT: A <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> update for multiple CRTCs is sequenced
against all CRTCs therein. Therefore for atomic state updates which only flip
planes the driver must not get the struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a> of unrelated CRTCs
in its atomic check code: This would prevent committing of atomic updates to
multiple CRTCs in parallel. In general, adding additional state structures
should be avoided as much as possible, because this reduces parallelism in
(nonblocking) commits, both due to locking and due to commit sequencing
requirements.</p>
<p>3. The software state is updated synchronously with
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>. Doing this under the protection of all modeset
locks means concurrent callers never see inconsistent state. Note that commit
workers do not hold any locks; their access is only coordinated through
ordering. If workers would access state only through the pointers in the
free-standing state objects (currently not the case for any driver) then even
multiple pending commits could be in-flight at the same time.</p>
<p>4. Schedule a work item to do all subsequent steps, using the split-out
commit helpers: a) pre-plane commit b) plane commit c) post-plane commit and
then cleaning up the framebuffers after the old framebuffer is no longer
being displayed. The scheduled work should synchronize against other workers
using the <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> infrastructure as needed. See
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for more details.</p>
</div>
<div class="section" id="helper-functions-reference">
<h3>Helper Functions Reference<a class="headerlink" href="#helper-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_atomic_crtc_for_each_plane">
<code class="sig-name descname">drm_atomic_crtc_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes currently attached to CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>the CRTC whose planes are iterated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over the current state, useful (for example) when applying
atomic state after it has been checked and swapped.  To iterate over the
planes which <em>will</em> be attached (more useful in code called from
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>) see
<a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane">
<code class="sig-name descname">drm_atomic_crtc_state_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_state</span></code></dt><dd><p>the incoming CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to drm_crtc_for_each_plane(), but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane_state">
<code class="sig-name descname">drm_atomic_crtc_state_for_each_plane_state</code><span class="sig-paren">(</span><em>plane</em>, <em>plane_state</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_state</span></code></dt><dd><p>loop cursor for the plane’s state, must be const</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_state</span></code></dt><dd><p>the incoming CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to drm_crtc_for_each_plane(), but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<p>Compared to just <a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a> this also fills in a
const plane_state. This is useful when a driver just wants to peek at other
active planes on this CRTC, but does not need to change it.</p>
<dl class="function">
<dt id="c.drm_atomic_plane_disabling">
bool <code class="sig-name descname">drm_atomic_plane_disabling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> old_plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> new_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_disabling" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a plane is being disabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">old_plane_state</span></code></dt><dd><p>old atomic plane state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">new_plane_state</span></code></dt><dd><p>new atomic plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the atomic state of a plane to determine whether it’s being disabled
or not. This also WARNs if it detects an invalid state (both CRTC and FB
need to either both be NULL or both be non-NULL).</p>
<p><strong>Return</strong></p>
<p>True if the plane is being disabled, false otherwise.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check_modeset">
int <code class="sig-name descname">drm_atomic_helper_check_modeset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for modeset changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the CRTC and connector related computations for an atomic
update and adds any additional connectors needed for full modesets. It calls
the various per-object callbacks in the follow order:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_best_encoder</span></code></a> for determining the new encoder.</p></li>
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> to validate the connector state.</p></li>
<li><p>If it’s determined a modeset is needed then all connectors on the affected
CRTC are added and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> is run on them.</p></li>
<li><p><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> are called on the affected components.</p></li>
<li><p><a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> is called on all encoder bridges.</p></li>
<li><p><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check</span></code></a> is called to validate any encoder state.
This function is only called when the encoder will be part of a configured CRTC,
it must not be used for implementing connector property validation.
If this function is NULL, <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_encoder_helper_funcs.mode_fixup</span></code> is called
instead.</p></li>
<li><p><a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_fixup</span></code></a> is called last, to fix up the mode with CRTC constraints.</p></li>
</ol>
<p><a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode_changed</span></code></a> is set when the input mode is changed.
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.connectors_changed</span></code></a> is set when a connector is added or
removed from the CRTC.  <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active_changed</span></code></a> is set when
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active</span></code></a> changes, which is used for DPMS.
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_vblank</span></code></a> is set from the result of <a class="reference internal" href="drm-kms.html#c.drm_dev_has_vblank" title="drm_dev_has_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_has_vblank()</span></code></a>.
See also: <a class="reference internal" href="drm-kms.html#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<p>IMPORTANT:</p>
<p>Drivers which set <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode_changed</span></code></a> (e.g. in their
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hooks if a plane update can’t be done
without a full modeset) _must_ call this function afterwards after that
change. It is permitted to call this function multiple times for the same
update, e.g. when the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> functions depend
upon the adjusted dotclock for fifo space allocation and watermark
computation.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check_plane_state">
int <code class="sig-name descname">drm_atomic_helper_check_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> plane_state</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em>, int<em> min_scale</em>, int<em> max_scale</em>, bool<em> can_position</em>, bool<em> can_update_disabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check plane state for validity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt><dd><p>plane state to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>CRTC state to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_scale</span></code></dt><dd><p>minimum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_scale</span></code></dt><dd><p>maximum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">can_position</span></code></dt><dd><p>is it legal to position the plane such that it
doesn’t cover the entire CRTC?  This will generally
only be false for primary planes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">can_update_disabled</span></code></dt><dd><p>can the plane be updated while the CRTC
is disabled?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a desired plane update is valid, and updates various
bits of derived state (clipped coordinates etc.). Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.</p>
<p><strong>Return</strong></p>
<p>Zero if update appears valid, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check_planes">
int <code class="sig-name descname">drm_atomic_helper_check_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for planes changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the plane update related checks using by calling into the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a>
hooks provided by the driver.</p>
<p>It also sets <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.planes_changed</span></code></a> to indicate that a CRTC has
updated planes.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check">
int <code class="sig-name descname">drm_atomic_helper_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
Only CRTCs and planes have check callbacks, so for any additional (global)
checking that a driver needs it can simply wrap that around this function.
Drivers without such needs can directly use this as their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> callback.</p>
<p>This just wraps the two parts of the state checking for planes and modeset
state in the default order: First it calls <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>
and then <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>. The assumption is that the
<strong>drm_plane_helper_funcs.atomic_check</strong> and <strong>drm_crtc_helper_funcs.atomic_check</strong>
functions depend upon an updated adjusted_mode.clock to e.g. properly compute
watermarks.</p>
<p>Note that zpos normalization will add all enable planes to the state which
might not desired for some drivers.
For example enable/disable of a cursor plane which have fixed zpos value
would trigger all other enabled planes to be forced to the state change.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_update_legacy_modeset_state">
void <code class="sig-name descname">drm_atomic_helper_update_legacy_modeset_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_legacy_modeset_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update legacy modeset state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates all the various legacy modeset state pointers in
connectors, encoders and CRTCs. It also updates the timestamping constants
used for precise vblank timestamps by calling
<a class="reference internal" href="drm-kms.html#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
<p>Drivers can use this for building their own atomic commit if they don’t have
a pure helper-based modeset implementation.</p>
<p>Since these updates are not synchronized with lockings, only code paths
called from <a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> can look at the
legacy state filled out by this helper. Defacto this means this helper and
the legacy state pointers are only really useful for transitioning an
existing driver to the atomic world.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_disables">
void <code class="sig-name descname">drm_atomic_helper_commit_modeset_disables</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_disables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to disable outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shuts down all the outputs that need to be shut down and
prepares them (if required) with the new mode.</p>
<p>For compatibility with legacy CRTC helpers this should be called before
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_enables">
void <code class="sig-name descname">drm_atomic_helper_commit_modeset_enables</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_enables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to enable outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables all the outputs with the new configuration which had to
be turned off for the update.</p>
<p>For compatibility with legacy CRTC helpers this should be called after
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_fences">
int <code class="sig-name descname">drm_atomic_helper_wait_for_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, bool<em> pre_swap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for fences stashed in plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">pre_swap</span></code></dt><dd><p>If true, do an interruptible wait, and <strong>state</strong> is the new state.
Otherwise <strong>state</strong> is the old state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For implicit sync, driver should fish the exclusive fence out from the
incoming fb’s and stash it in the drm_plane_state.  This is called after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> so it uses the current plane state (and
just uses the atomic state to find the changed planes)</p>
<p>Note that <strong>pre_swap</strong> is needed since the point where we block for fences moves
around depending upon whether an atomic commit is blocking or
non-blocking. For non-blocking commit all waiting needs to happen after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> is called, but for blocking commits we want
to wait <strong>before</strong> we do anything that can’t be easily rolled back. That is
before we call <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>.</p>
<p>Returns zero if success or &lt; 0 if <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> fails.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_vblanks">
void <code class="sig-name descname">drm_atomic_helper_wait_for_vblanks</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_vblanks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for vblank on CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to, after atomic commit, wait for vblanks on all affected
CRTCs (ie. before cleaning up old framebuffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>). It will only wait on CRTCs where the
framebuffers have actually changed to optimize for the legacy cursor and
plane update use-case.</p>
<p>Drivers using the nonblocking commit tracking support initialized by calling
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> should look at
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a> as an alternative.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_flip_done">
void <code class="sig-name descname">drm_atomic_helper_wait_for_flip_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_flip_done" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for all page flips to be done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to, after atomic commit, wait for page flips on all affected
crtcs (ie. before cleaning up old framebuffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>). Compared to
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> this waits for the completion on all
CRTCs, assuming that cursors-only updates are signalling their completion
immediately (or using a different path).</p>
<p>This requires that drivers use the nonblocking commit tracking support
initialized using <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_tail">
void <code class="sig-name descname">drm_atomic_helper_commit_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>commit atomic update to hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation for the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> hook, for drivers
that do not support runtime_pm or do not need the CRTC to be
enabled to perform a commit. Otherwise, see
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail_rpm" title="drm_atomic_helper_commit_tail_rpm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail_rpm()</span></code></a>.</p>
<p>Note that the default ordering of how the various stages are called is to
match the legacy modeset helper library closest.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_tail_rpm">
void <code class="sig-name descname">drm_atomic_helper_commit_tail_rpm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_tail_rpm" title="Permalink to this definition">¶</a></dt>
<dd><p>commit atomic update to hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>new modeset state to be committed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an alternative implementation for the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> hook, for drivers
that support runtime_pm or need the CRTC to be enabled to perform a
commit. Otherwise, one should use the default implementation
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_async_check">
int <code class="sig-name descname">drm_atomic_helper_async_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_async_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check if state can be commited asynchronously</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper will check if it is possible to commit the state asynchronously.
Async commits are not supposed to swap the states like normal sync commits
but just do in-place changes on the current state.</p>
<p>It will return 0 if the commit can happen in an asynchronous fashion or error
if not. Note that error just mean it can’t be commited asynchronously, if it
fails the commit should be treated like a normal synchronous commit.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_async_commit">
void <code class="sig-name descname">drm_atomic_helper_async_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_async_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit state asynchronously</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits a state asynchronously, i.e., not vblank
synchronized. It should be used on a state only when
drm_atomic_async_check() succeeds. Async commits are not supposed to swap
the states like normal sync commits, but just do in-place changes on the
current state.</p>
<p>TODO: Implement full swap instead of doing in-place changes.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit">
int <code class="sig-name descname">drm_atomic_helper_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, bool<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit validated state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the driver state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt><dd><p>whether nonblocking behavior is requested.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits a with <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> pre-validated state
object. This can still fail when e.g. the framebuffer reservation fails. This
function implements nonblocking commits, using
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> and related functions.</p>
<p>Committing the actual hardware state is done through the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> callback, or its default
implementation <a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_setup_commit">
int <code class="sig-name descname">drm_atomic_helper_setup_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, bool<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_setup_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possibly nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>new modeset state to be committed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt><dd><p>whether nonblocking behavior is requested.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares <strong>state</strong> to be used by the atomic helper’s support for
nonblocking commits. Drivers using the nonblocking commit infrastructure
should always call this function from their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> hook.</p>
<p>To be able to use this support drivers need to use a few more helper
functions. <a class="reference internal" href="#c.drm_atomic_helper_wait_for_dependencies" title="drm_atomic_helper_wait_for_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_dependencies()</span></code></a> must be called before
actually committing the hardware state, and for nonblocking commits this call
must be placed in the async worker. See also <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>
and its stall parameter, for when a driver’s commit hooks look at the
<a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a> pointer directly.</p>
<p>Completion of the hardware commit step must be signalled using
<a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. After this step the driver is not allowed
to read or change any permanent software or hardware modeset state. The only
exception is state protected by other means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> locks.
Only the free standing <strong>state</strong> with pointers to the old state structures can
be inspected, e.g. to clean up old buffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>At the very end, before cleaning up <strong>state</strong> drivers must call
<a class="reference internal" href="#c.drm_atomic_helper_commit_cleanup_done" title="drm_atomic_helper_commit_cleanup_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_cleanup_done()</span></code></a>.</p>
<p>This is all implemented by in <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a>, giving drivers a
complete and easy-to-use default implementation of the atomic_commit() hook.</p>
<p>The tracking of asynchronously executed and still pending commits is done
using the core structure <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a>.</p>
<p>By default there’s no need to clean up resources allocated by this function
explicitly: <a class="reference internal" href="drm-kms.html#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_default_clear()</span></code></a> will take care of that
automatically.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
-ENOMEM on allocation failures and -EINTR when a signal is pending.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_dependencies">
void <code class="sig-name descname">drm_atomic_helper_wait_for_dependencies</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for required preceeding commits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function waits for all preceeding commits that touch the same CRTC as
<strong>old_state</strong> to both be committed to the hardware (as signalled by
<a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>) and executed by the hardware (as signalled
by calling <a class="reference internal" href="drm-kms.html#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> on the <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a>).</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_fake_vblank">
void <code class="sig-name descname">drm_atomic_helper_fake_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_fake_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>fake VBLANK events if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks all CRTCs and fakes VBLANK events on those with
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_vblank</span></code></a> set to true and <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a> != NULL.
The primary use of this function is writeback connectors working in oneshot
mode and faking VBLANK events. In this case they only fake the VBLANK event
when a job is queued, and any change to the pipeline that does not touch the
connector is leading to timeouts when calling
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a>. In addition to writeback
connectors, this function can also fake VBLANK events for CRTCs without
VBLANK interrupt.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_hw_done">
void <code class="sig-name descname">drm_atomic_helper_commit_hw_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_hw_done" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possible nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to signal completion of the hardware commit step. After
this step the driver is not allowed to read or change any permanent software
or hardware modeset state. The only exception is state protected by other
means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> locks.</p>
<p>Drivers should try to postpone any expensive or delayed cleanup work after
this function is called.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_cleanup_done">
void <code class="sig-name descname">drm_atomic_helper_commit_cleanup_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_cleanup_done" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This signals completion of the atomic update <strong>old_state</strong>, including any
cleanup work. If used, it must be called right before calling
<a class="reference internal" href="drm-kms.html#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_prepare_planes">
int <code class="sig-name descname">drm_atomic_helper_prepare_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_prepare_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare plane resources before commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic state object with new state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares plane state, specifically framebuffers, for the new
configuration, by calling <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>. If any failure
is encountered this function will call <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> on
any already successfully prepared framebuffer.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes">
void <code class="sig-name descname">drm_atomic_helper_commit_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em>, uint32_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flags for committing plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes and CRTCs. It assumes that the atomic state has already
been pushed into the relevant object state pointers, since this step can no
longer fail.</p>
<p>It still requires the global state object <strong>old_state</strong> to know which planes and
crtcs need to be updated though.</p>
<p>Note that this function does all plane updates across all CRTCs in one step.
If the hardware can’t support this approach look at
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="drm_atomic_helper_commit_planes_on_crtc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes_on_crtc()</span></code></a> instead.</p>
<p>Plane parameters can be updated by applications while the associated CRTC is
disabled. The DRM/KMS core will store the parameters in the plane state,
which will be available to the driver when the CRTC is turned on. As a result
most drivers don’t need to be immediately notified of plane updates for a
disabled CRTC.</p>
<p>Unless otherwise needed, drivers are advised to set the ACTIVE_ONLY flag in
<strong>flags</strong> in order not to receive plane update notifications related to a
disabled CRTC. This avoids the need to manually ignore plane updates in
driver code when the driver and/or hardware can’t or just don’t need to deal
with updates on disabled CRTCs, for example when supporting runtime PM.</p>
<p>Drivers may set the NO_DISABLE_AFTER_MODESET flag in <strong>flags</strong> if the relevant
display controllers require to disable a CRTC’s planes when the CRTC is
disabled. This function would skip the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a>
call for a plane if the CRTC of the old plane state needs a modesetting
operation. Of course, the drivers need to disable the planes in their CRTC
disable callbacks since no one else would do that.</p>
<p>The <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> default implementation doesn’t set the
ACTIVE_ONLY flag to most closely match the behaviour of the legacy helpers.
This should not be copied blindly by drivers.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes_on_crtc">
void <code class="sig-name descname">drm_atomic_helper_commit_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state for a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">old_crtc_state</span></code></dt><dd><p>atomic state object with the old CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes on the specific CRTC. It assumes that the atomic state
has already been pushed into the relevant object state pointers, since this
step can no longer fail.</p>
<p>This function is useful when plane updates should be done CRTC-by-CRTC
instead of one global step like <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> does.</p>
<p>This function can only be savely used when planes are not allowed to move
between different CRTCs because this function doesn’t handle inter-CRTC
depencies. Callers need to ensure that either no such depencies exist,
resolve them through ordering of commit calls or through some other means.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_planes_on_crtc">
void <code class="sig-name descname">drm_atomic_helper_disable_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> old_crtc_state</em>, bool<em> atomic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to disable CRTC’s planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">old_crtc_state</span></code></dt><dd><p>atomic state object with the old CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">atomic</span></code></dt><dd><p>if set, synchronize with CRTC’s atomic_begin/flush hooks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables all planes associated with the given CRTC. This can be
used for instance in the CRTC helper atomic_disable callback to disable
all planes.</p>
<p>If the atomic-parameter is set the function calls the CRTC’s
atomic_begin hook before and atomic_flush hook after disabling the
planes.</p>
<p>It is a bug to call this function without having implemented the
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a> plane hook.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_cleanup_planes">
void <code class="sig-name descname">drm_atomic_helper_cleanup_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_cleanup_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup plane resources after commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up plane state, specifically framebuffers, from the old
configuration. Hence the old configuration must be perserved in <strong>old_state</strong> to
be able to call this function.</p>
<p>This function must also be called on the new state when the atomic update
fails at any point after calling <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_swap_state">
int <code class="sig-name descname">drm_atomic_helper_swap_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, bool<em> stall</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_swap_state" title="Permalink to this definition">¶</a></dt>
<dd><p>store atomic state into current sw state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">stall</span></code></dt><dd><p>stall for preceeding commits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stores the atomic state into the current state pointers in all
driver objects. It should be called after all failing steps have been done
and succeeded, but before the actual hardware state is committed.</p>
<p>For cleanup and error recovery the current state for all changed objects will
be swapped into <strong>state</strong>.</p>
<p>With that sequence it fits perfectly into the plane prepare/cleanup sequence:</p>
<ol class="arabic simple">
<li><p>Call <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a> with the staged atomic state.</p></li>
<li><p>Do any other steps that might fail.</p></li>
<li><p>Put the staged state into the current state pointers with this function.</p></li>
<li><p>Actually commit the hardware state.</p></li>
</ol>
<p>5. Call <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a> with <strong>state</strong>, which since step 3
contains the old state. Also do any other cleanup required with that state.</p>
<p><strong>stall</strong> must be set when nonblocking commits for this driver directly access
the <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a> pointer. With
the current atomic helpers this is almost always the case, since the helpers
don’t pass the right state structures to the callbacks.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success. Can return -ERESTARTSYS when <strong>stall</strong> is true and the
waiting for the previous commits has been interrupted.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_update_plane">
int <code class="sig-name descname">drm_atomic_helper_update_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, int<em> crtc_x</em>, int<em> crtc_y</em>, unsigned int<em> crtc_w</em>, unsigned int<em> crtc_h</em>, uint32_t<em> src_x</em>, uint32_t<em> src_y</em>, uint32_t<em> src_w</em>, uint32_t<em> src_h</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane update using atomic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>plane object to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>owning CRTC of owning plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>framebuffer to flip onto plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt><dd><p>x offset of primary plane on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt><dd><p>y offset of primary plane on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt><dd><p>width of primary plane rectangle on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt><dd><p>height of primary plane rectangle on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt><dd><p>x offset of <strong>fb</strong> for panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt><dd><p>y offset of <strong>fb</strong> for panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt><dd><p>width of source rectangle in <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt><dd><p>height of source rectangle in <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane update handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_plane">
int <code class="sig-name descname">drm_atomic_helper_disable_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane disable using * atomic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>plane to disable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane disable handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_set_config">
int <code class="sig-name descname">drm_atomic_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em> set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt><dd><p>mode set configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default CRTC set_config handler using the atomic driver interface.</p>
<p><strong>NOTE</strong></p>
<p>For backwards compatibility with old userspace this automatically
resets the “link-status” property to GOOD, to force any link
re-training. The SETCRTC ioctl does not define whether an update does
need a full modeset or just a plane update, hence we’re allowed to do
that. See also <a class="reference internal" href="drm-kms.html#c.drm_connector_set_link_status_property" title="drm_connector_set_link_status_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_link_status_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_all">
int <code class="sig-name descname">drm_atomic_helper_disable_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all currently active outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Loops through all connectors, finding those that aren’t turned off and then
turns them off by setting their DPMS mode to OFF and deactivating the CRTC
that they are connected to.</p>
<p>This is used for example in suspend/resume to disable all currently active
functions when suspending. If you just want to shut down everything at e.g.
driver unload, look at <a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p>Note that if callers haven’t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_shutdown">
void <code class="sig-name descname">drm_atomic_helper_shutdown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown all CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This shuts down all CRTC, which is useful for driver unloading. Shutdown on
suspend should instead be handled with <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, since
that also takes a snapshot of the modeset state to be restored on resume.</p>
<p>This is just a convenience wrapper around <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
and it is the atomic version of drm_crtc_force_disable_all().</p>
<dl class="function">
<dt id="c.drm_atomic_helper_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="sig-name descname">drm_atomic_helper_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an atomic state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes a copy of the current atomic state by looping over all objects and
duplicating their respective states. This is used for example by suspend/
resume support code to save the state prior to suspend such that it can
be restored upon resume.</p>
<p>Note that this treats atomic state as persistent between save and restore.
Drivers must make sure that this is possible and won’t result in confusion
or erroneous behaviour.</p>
<p>Note that if callers haven’t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the copy of the atomic state object on success or an
ERR_PTR()-encoded error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_suspend">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="sig-name descname">drm_atomic_helper_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level suspend helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicates the current atomic state, disables all active outputs and then
returns a pointer to the original atomic state to the caller. Drivers can
pass this pointer to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon resume to
restore the output configuration that was active at the time the system
entered suspend.</p>
<p>Note that it is potentially unsafe to use this. The atomic state object
returned by this function is assumed to be persistent. Drivers must ensure
that this holds true. Before calling this function, drivers must make sure
to suspend fbdev emulation so that nothing can be using the device.</p>
<p><strong>Return</strong></p>
<p>A pointer to a copy of the state before suspend on success or an ERR_PTR()-
encoded error code on failure. Drivers should store the returned atomic
state object and pass it to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon
resume.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_commit_duplicated_state" title="drm_atomic_helper_commit_duplicated_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_duplicated_state()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_duplicated_state">
int <code class="sig-name descname">drm_atomic_helper_commit_duplicated_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_duplicated_state" title="Permalink to this definition">¶</a></dt>
<dd><p>commit duplicated state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>duplicated atomic state to commit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>pointer to acquire_ctx to use for commit.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state returned by <a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> is partially invalid, and needs to
be fixed up before commit.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_resume">
int <code class="sig-name descname">drm_atomic_helper_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level resume helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic state to resume to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> to synchronize hardware and software states,
grabs all modeset locks and commits the atomic state object. This can be
used in conjunction with the <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> helper to
implement suspend/resume for drivers that support atomic mode-setting.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip">
int <code class="sig-name descname">drm_atomic_helper_page_flip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em> event</em>, uint32_t<em> flags</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a legacy page flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt><dd><p>optional DRM event to signal upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flip flags for non-vblank sync’ed updates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> implementation
using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_page_flip_target" title="drm_atomic_helper_page_flip_target"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_page_flip_target()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip_target">
int <code class="sig-name descname">drm_atomic_helper_page_flip_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em> event</em>, uint32_t<em> flags</em>, uint32_t<em> target</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip_target" title="Permalink to this definition">¶</a></dt>
<dd><p>do page flip on target vblank period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt><dd><p>optional DRM event to signal upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flip flags for non-vblank sync’ed updates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">target</span></code></dt><dd><p>specifying the target vblank period when the flip to take effect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip_target</span></code></a> implementation.
Similar to <a class="reference internal" href="#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> with extra parameter to specify
target vblank period to flip.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_legacy_gamma_set">
int <code class="sig-name descname">drm_atomic_helper_legacy_gamma_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, u16 *<em> red</em>, u16 *<em> green</em>, u16 *<em> blue</em>, uint32_t<em> size</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_legacy_gamma_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set the legacy gamma correction table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">red</span></code></dt><dd><p>red correction table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">green</span></code></dt><dd><p>green correction table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">blue</span></code></dt><dd><p>green correction table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">size</span></code></dt><dd><p>size of the tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements support for legacy gamma correction table for drivers
that support color management through the DEGAMMA_LUT/GAMMA_LUT
properties. See <a class="reference internal" href="drm-kms.html#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a> and the containing chapter for
how the atomic color management and gamma tables work.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_propagate_bus_fmt">
u32 * <code class="sig-name descname">drm_atomic_helper_bridge_propagate_bus_fmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<em> bridge_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em>, u32<em> output_fmt</em>, unsigned int *<em> num_input_fmts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_propagate_bus_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate output format to the input end of a bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*</span> <span class="pre">bridge_state</span></code></dt><dd><p>new bridge state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>new connector state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">output_fmt</span></code></dt><dd><p>tested output bus format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">num_input_fmts</span></code></dt><dd><p>will contain the size of the returned array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is a pluggable implementation of the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_input_bus_fmts</span></code></a> operation for bridges that don’t
modify the bus configuration between their input and their output. It
returns an array of input formats with a single element set to <strong>output_fmt</strong>.</p>
<p><strong>Return</strong></p>
<p>a valid format array of size <strong>num_input_fmts</strong>, or NULL if the allocation
failed</p>
</div>
<div class="section" id="atomic-state-reset-and-initialization">
<h3>Atomic State Reset and Initialization<a class="headerlink" href="#atomic-state-reset-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>Both the drm core and the atomic helpers assume that there is always the full
and correct atomic software state for all connectors, CRTCs and planes
available. Which is a bit a problem on driver load and also after system
suspend. One way to solve this is to have a hardware state read-out
infrastructure which reconstructs the full software state (e.g. the i915
driver).</p>
<p>The simpler solution is to just reset the software state to everything off,
which is easiest to do by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>. To facilitate this
the atomic helpers provide default reset implementations for all hooks.</p>
<p>On the upside the precise state tracking of atomic simplifies system suspend
and resume a lot. For drivers using <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> a complete recipe
is implemented in <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>.
For other drivers the building blocks are split out, see the documentation
for these functions.</p>
</div>
<div class="section" id="atomic-state-helper-reference">
<h3>Atomic State Helper Reference<a class="headerlink" href="#atomic-state-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_crtc_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>atomic CRTC state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>crtc_state</strong> with default
values. This is useful for drivers that subclass the CRTC state.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_reset">
void <code class="sig-name descname">__drm_atomic_helper_crtc_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>CRTC state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>crtc_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc-&gt;state</span></code></a> pointer of <strong>crtc</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the CRTC state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_reset">
void <code class="sig-name descname">drm_atomic_helper_crtc_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a> hook for CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>crtc</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a CRTC’s current state and resets inferred values.
This is useful for drivers that subclass the CRTC state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="sig-name descname">drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state duplicate hook for drivers which don’t have their own
subclassed CRTC state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>CRTC state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the CRTC state without actually freeing
the memory of the CRTC state. This is useful for drivers that subclass the
CRTC state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>CRTC state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state destroy hook for drivers which don’t have their own
subclassed CRTC state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_plane_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets plane state to default values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt><dd><p>atomic plane state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>plane object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>plane_state</strong> with default
values. This is useful for drivers that subclass the CRTC state.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_reset">
void <code class="sig-name descname">__drm_atomic_helper_plane_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt><dd><p>plane state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>plane_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc-&gt;state</span></code></a> pointer of <strong>plane</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the plane state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_reset">
void <code class="sig-name descname">drm_atomic_helper_plane_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a> hook for planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>plane</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>plane object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a plane’s current state. This is useful for
drivers that subclass the plane state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="sig-name descname">drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state duplicate hook for drivers which don’t have their own
subclassed plane state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>plane state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the plane state without actually freeing
the memory of the plane state. This is useful for drivers that subclass the
plane state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>plane state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state destroy hook for drivers which don’t have their own
subclassed plane state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_connector_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>atomic connector state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connectotr object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>conn_state</strong> with default
values. This is useful for drivers that subclass the connector state.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_reset">
void <code class="sig-name descname">__drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>connector state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>conn_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a> pointer of <strong>connector</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_reset">
void <code class="sig-name descname">drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.reset</span></code></a> hook for connectors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>connector</strong> by freeing the state pointer (which
might be NULL, e.g. at driver load time) and allocating a new empty state
object.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_tv_reset">
void <code class="sig-name descname">drm_atomic_helper_connector_tv_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_tv_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets TV connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the TV-related properties attached to a connector.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic connector state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a connector’s current state. This is useful for
drivers that subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="sig-name descname">drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state duplicate hook for drivers which don’t have their own
subclassed connector state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>connector state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the connector state without actually
freeing the memory of the connector state. This is useful for drivers that
subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>connector state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state destroy hook for drivers which don’t have their own
subclassed connector state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_private_obj_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_private_obj_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em> obj</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_private_obj_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic private state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>CRTC object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>new private object state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a private objects’s current state and resets inferred values.
This is useful for drivers that subclass the private state.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_bridge_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_bridge_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_bridge_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy atomic bridge state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>atomic bridge state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a bridge’s current state and resets inferred values.
This is useful for drivers that subclass the bridge state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> * <code class="sig-name descname">drm_atomic_helper_bridge_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate a bridge state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a new bridge state and initializes it with the current bridge
state values. This helper is meant to be used as a bridge
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state</span></code></a> hook for bridges that don’t
subclass the bridge state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_bridge_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy a bridge state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>bridge state to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys a bridge state previously created by
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_reset`()</span> <span class="pre">or</span>
<span class="pre">:c:type:`drm_atomic_helper_bridge_duplicate_state`().</span> <span class="pre">This</span> <span class="pre">helper</span> <span class="pre">is</span> <span class="pre">meant</span> <span class="pre">to</span> <span class="pre">be</span>
<span class="pre">used</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">bridge</span> <span class="pre">:c:type:`drm_bridge_funcs.atomic_destroy_state</span></code></a> hook for bridges
that don’t subclass the bridge state.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_bridge_reset">
void <code class="sig-name descname">__drm_atomic_helper_bridge_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_bridge_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bridge state to its default</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>bridge state to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the bridge state to default values. This is meant to be called
by the bridge <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_reset</span></code></a> hook for bridges that subclass
the bridge state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_reset">
struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> * <code class="sig-name descname">drm_atomic_helper_bridge_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize a bridge state to its default</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the bridge state and initializes it to default values. This helper
is meant to be used as a bridge <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_reset</span></code></a> hook for
bridges that don’t subclass the bridge state.</p>
</div>
</div>
<div class="section" id="simple-kms-helper-reference">
<h2>Simple KMS Helper Reference<a class="headerlink" href="#simple-kms-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library provides helpers for drivers for simple display
hardware.</p>
<p><a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a> initializes a simple display pipeline
which has only one full-screen scanout buffer feeding one output. The
pipeline is represented by <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span></code></a> and binds
together <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> structures into one fixed
entity. Some flexibility for code reuse is provided through a separately
allocated <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> object and supporting optional <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>
encoder drivers.</p>
<p>Many drivers require only a very simple encoder that fulfills the minimum
requirements of the display pipeline and does not add additional
functionality. The function <a class="reference internal" href="#c.drm_simple_encoder_init" title="drm_simple_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_encoder_init()</span></code></a> provides an
implementation of such an encoder.</p>
<dl class="type">
<dt id="c.drm_simple_display_pipe_funcs">
struct <code class="sig-name descname">drm_simple_display_pipe_funcs</code><a class="headerlink" href="#c.drm_simple_display_pipe_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for a simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe_funcs {
  enum drm_mode_status (*mode_valid)(struct drm_simple_display_pipe *pipe, const struct drm_display_mode *mode);
  void (*enable)(struct drm_simple_display_pipe *pipe,struct drm_crtc_state *crtc_state, struct drm_plane_state *plane_state);
  void (*disable)(struct drm_simple_display_pipe *pipe);
  int (*check)(struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state, struct drm_crtc_state *crtc_state);
  void (*update)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *old_plane_state);
  int (*prepare_fb)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
  void (*cleanup_fb)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
  int (*enable_vblank)(struct drm_simple_display_pipe *pipe);
  void (*disable_vblank)(struct drm_simple_display_pipe *pipe);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in the
crtc used in this simple display pipe. This should be implemented
if the display pipe has some sort of restriction in the modes
it can display. For example, a given display pipe may be responsible
to set a clock value. If the clock can not produce all the values
for the available modes then this callback can be used to restrict
the number of modes to only the ones that can be displayed. Another
reason can be bandwidth mitigation: the memory port on the display
controller can have bandwidth limitations not allowing pixel data
to be fetched at any rate.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardware constraints.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This function should be used to enable the pipeline.
It is called when the underlying crtc is enabled.
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This function should be used to disable the pipeline.
It is called when the underlying crtc is disabled.
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check</span></code></dt><dd><p>This function is called in the check phase of an atomic update,
specifically when the underlying plane is checked.
The simple display pipeline helpers already check that the plane is
not scaled, fills the entire visible area and is always enabled
when the crtc is also enabled.
This hook is optional.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update</span></code></dt><dd><p>This function is called when the underlying plane state is updated.
This hook is optional.</p>
<p>This is the function drivers should submit the
<a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pending_vblank_event</span></code></a> from. Using either
<a class="reference internal" href="drm-kms.html#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>, when the driver supports vblank
interrupt handling, or <a class="reference internal" href="drm-kms.html#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> for more
complex case. In case the hardware lacks vblank support entirely,
drivers can set <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>.no_vblank in
<a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a>.check and let DRM’s
atomic helper fake a vblank event.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_fb</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> hook for
more details.</p>
<p>Drivers which always have their buffers pinned should use
<a class="reference internal" href="#c.drm_gem_fb_simple_display_pipe_prepare_fb" title="drm_gem_fb_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_simple_display_pipe_prepare_fb()</span></code></a> for this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_fb</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_vblank</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a>. Please read
the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_vblank</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a>. Please read
the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> hook for
more details.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_simple_display_pipe">
struct <code class="sig-name descname">drm_simple_display_pipe</code><a class="headerlink" href="#c.drm_simple_display_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe {
  struct drm_crtc crtc;
  struct drm_plane plane;
  struct drm_encoder encoder;
  struct drm_connector *connector;
  const struct drm_simple_display_pipe_funcs *funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>CRTC control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>Plane control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>Encoder control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>Connector control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Pipeline control functions (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple display pipeline with plane, crtc and encoder collapsed into one
entity. It should be initialized by calling <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_simple_encoder_init">
int <code class="sig-name descname">drm_simple_encoder_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em>, int<em> encoder_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_encoder_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a preallocated encoder with basic functionality.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>the encoder to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">encoder_type</span></code></dt><dd><p>user visible type of the encoder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated encoder that has no further functionality.
Settings for possible CRTC and clones are left to their initial values.
The encoder will be cleaned up automatically as part of the mode-setting
cleanup.</p>
<p>The caller of <a class="reference internal" href="#c.drm_simple_encoder_init" title="drm_simple_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_encoder_init()</span></code></a> is responsible for freeing
the encoder’s memory after the encoder has been cleaned up. At the
moment this only works reliably if the encoder data structure is
stored in the device structure. Free the encoder’s memory as part of
the device release function.</p>
<dl class="simple">
<dt>FIXME: Later improvements to DRM’s resource management may allow for</dt><dd><p>an automated <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> of the encoder’s memory.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_simple_display_pipe_attach_bridge">
int <code class="sig-name descname">drm_simple_display_pipe_attach_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em> pipe</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_attach_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a bridge to the display pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>simple display pipe object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge to attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes it possible to still use the drm_simple_display_pipe helpers when
a DRM bridge has to be used.</p>
<p>Note that you probably want to initialize the pipe by passing a NULL
connector to <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_simple_display_pipe_init">
int <code class="sig-name descname">drm_simple_display_pipe_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em> pipe</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a> *<em> funcs</em>, const uint32_t *<em> formats</em>, unsigned int<em> format_count</em>, const uint64_t *<em> format_modifiers</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a simple display pipeline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>simple display pipe object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>callbacks for the display pipe (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt><dd><p>array of supported formats (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">format_modifiers</span></code></dt><dd><p>array of formats modifiers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector to attach and register (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a display pipeline which consist of a really simple
plane-crtc-encoder pipe.</p>
<p>If a connector is supplied, the pipe will be coupled with the provided
connector. You may supply a NULL connector when using drm bridges, that
handle connectors themselves (see <a class="reference internal" href="#c.drm_simple_display_pipe_attach_bridge" title="drm_simple_display_pipe_attach_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_attach_bridge()</span></code></a>).</p>
<p>Teardown of a simple display pipe is all handled automatically by the drm
core through calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>. Drivers afterwards need to
release the memory for the structure themselves.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<div class="section" id="fbdev-helper-functions-reference">
<h2>fbdev Helper Functions Reference<a class="headerlink" href="#fbdev-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The fb helper functions are useful to provide an fbdev on top of a drm kernel
mode setting driver. They can be used mostly independently from the crtc
helper functions used by many drivers to implement the kernel mode setting
interfaces.</p>
<p>Drivers that support a dumb buffer with a virtual address and mmap support,
should try out the generic fbdev emulation using <a class="reference internal" href="#c.drm_fbdev_generic_setup" title="drm_fbdev_generic_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fbdev_generic_setup()</span></code></a>.
It will automatically set up deferred I/O if the driver requires a shadow
buffer.</p>
<p>At runtime drivers should restore the fbdev console by using
<a class="reference internal" href="#c.drm_fb_helper_lastclose" title="drm_fb_helper_lastclose"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_lastclose()</span></code></a> as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.lastclose</span></code></a> callback.
They should also notify the fb helper code from updates to the output
configuration by using <a class="reference internal" href="#c.drm_fb_helper_output_poll_changed" title="drm_fb_helper_output_poll_changed"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_output_poll_changed()</span></code></a> as their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.output_poll_changed</span></code></a> callback.</p>
<p>For suspend/resume consider using <a class="reference internal" href="#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_suspend()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_config_helper_resume" title="drm_mode_config_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_resume()</span></code></a> which takes care of fbdev as well.</p>
<p>All other functions exported by the fb helper library can be used to
implement the fbdev driver interface by the driver.</p>
<p>It is possible, though perhaps somewhat tricky, to implement race-free
hotplug detection using the fbdev helpers. The <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_prepare()</span></code></a>
helper must be called first to initialize the minimum required to make
hotplug detection work. Drivers also need to make sure to properly set up
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.funcs</span></code></a> member. After calling <a class="reference internal" href="#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_init()</span></code></a>
it is safe to enable interrupts and start processing hotplug events. At the
same time, drivers should initialize all modeset objects such as CRTCs,
encoders and connectors. To finish up the fbdev helper initialization, the
<a class="reference internal" href="#c.drm_fb_helper_init" title="drm_fb_helper_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_init()</span></code></a> function is called. To probe for all attached displays
and set up an initial configuration using the detected hardware, drivers
should call <a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_initial_config()</span></code></a>.</p>
<p>If <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> is set, the
drm_fb_helper_{cfb,sys}_{write,fillrect,copyarea,imageblit} functions will
accumulate changes and schedule <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper.dirty_work</span></code></a> to run right
away. This worker then calls the dirty() function ensuring that it will
always run in process context since the fb_*() function could be running in
atomic context. If <a class="reference internal" href="#c.drm_fb_helper_deferred_io" title="drm_fb_helper_deferred_io"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_deferred_io()</span></code></a> is used as the deferred_io
callback it will also schedule dirty_work with the damage collected from the
mmap page writes.</p>
<p>Deferred I/O is not compatible with SHMEM. Such drivers should request an
fbdev shadow buffer and call <a class="reference internal" href="#c.drm_fbdev_generic_setup" title="drm_fbdev_generic_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fbdev_generic_setup()</span></code></a> instead.</p>
<dl class="type">
<dt id="c.drm_fb_helper_surface_size">
struct <code class="sig-name descname">drm_fb_helper_surface_size</code><a class="headerlink" href="#c.drm_fb_helper_surface_size" title="Permalink to this definition">¶</a></dt>
<dd><p>describes fbdev size and scanout surface size</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper_surface_size {
  u32 fb_width;
  u32 fb_height;
  u32 surface_width;
  u32 surface_height;
  u32 surface_bpp;
  u32 surface_depth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fb_width</span></code></dt><dd><p>fbdev width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_height</span></code></dt><dd><p>fbdev height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_width</span></code></dt><dd><p>scanout buffer width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_height</span></code></dt><dd><p>scanout buffer height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_bpp</span></code></dt><dd><p>scanout buffer bpp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_depth</span></code></dt><dd><p>scanout buffer depth</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the scanout surface width/height may be larger than the fbdev
width/height.  In case of multiple displays, the scanout surface is sized
according to the largest width/height (so it is large enough for all CRTCs
to scanout).  But the fbdev width/height is sized to the minimum width/
height of all the displays.  This ensures that fbcon fits on the smallest
of the attached displays. fb_width/fb_height is used by
<a class="reference internal" href="#c.drm_fb_helper_fill_info" title="drm_fb_helper_fill_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fill_info()</span></code></a> to fill out the <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_info.var</span></code> structure.</p>
<dl class="type">
<dt id="c.drm_fb_helper_funcs">
struct <code class="sig-name descname">drm_fb_helper_funcs</code><a class="headerlink" href="#c.drm_fb_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver callbacks for the fbdev emulation library</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper_funcs {
  int (*fb_probe)(struct drm_fb_helper *helper, struct drm_fb_helper_surface_size *sizes);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">fb_probe</span></code></dt><dd><p>Driver callback to allocate and initialize the fbdev info structure.
Furthermore it also needs to allocate the DRM framebuffer used to
back the fbdev.</p>
<p>This callback is mandatory.</p>
<p>RETURNS:</p>
<p>The driver should return 0 on success and a negative error code on
failure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver callbacks used by the fbdev emulation helper library.</p>
<dl class="type">
<dt id="c.drm_fb_helper">
struct <code class="sig-name descname">drm_fb_helper</code><a class="headerlink" href="#c.drm_fb_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>main structure to emulate fbdev on top of KMS</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper {
  struct drm_client_dev client;
  struct drm_client_buffer *buffer;
  struct drm_framebuffer *fb;
  struct drm_device *dev;
  const struct drm_fb_helper_funcs *funcs;
  struct fb_info *fbdev;
  u32 pseudo_palette[17];
  struct drm_clip_rect dirty_clip;
  spinlock_t dirty_lock;
  struct work_struct dirty_work;
  struct work_struct resume_work;
  struct mutex lock;
  struct list_head kernel_fb_list;
  bool delayed_hotplug;
  bool deferred_setup;
  int preferred_bpp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">client</span></code></dt><dd><p>DRM client used by the generic fbdev emulation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Framebuffer used by the generic fbdev emulation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>Scanout framebuffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>driver callbacks for fb helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fbdev</span></code></dt><dd><p>emulated fbdev device info struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pseudo_palette</span></code></dt><dd><p>fake palette of 16 colors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty_clip</span></code></dt><dd><p>clip rectangle used with deferred_io to accumulate damage to
the screen buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty_lock</span></code></dt><dd><p>spinlock protecting <strong>dirty_clip</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty_work</span></code></dt><dd><p>worker used to flush the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume_work</span></code></dt><dd><p>worker used during resume if the console lock is already taken</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Top-level FBDEV helper lock. This protects all internal data
structures and lists, such as <strong>connector_info</strong> and <strong>crtc_info</strong>.</p>
<p>FIXME: fbdev emulation locking is a mess and long term we want to
protect all helper internal state with this lock as well as reduce
core KMS locking as much as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_fb_list</span></code></dt><dd><p>Entry on the global kernel_fb_helper_list, used for kgdb entry/exit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_hotplug</span></code></dt><dd><p>A hotplug was received while fbdev wasn’t in control of the DRM
device, i.e. another KMS master was active. The output configuration
needs to be reprobe when fbdev is in control again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deferred_setup</span></code></dt><dd><p>If no outputs are connected (disconnected or unknown) the FB helper
code will defer setup until at least one of the outputs shows up.
This field keeps track of the status so that setup can be retried
at every hotplug event until it succeeds eventually.</p>
<p>Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preferred_bpp</span></code></dt><dd><p>Temporary storage for the driver’s preferred BPP setting passed to
FB helper initialization. This needs to be tracked so that deferred
FB helper setup can pass this on.</p>
<p>See also: <strong>deferred_setup</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main structure used by the fbdev helpers. Drivers supporting
fbdev emulation should embedded this into their overall driver structure.
Drivers must also fill out a <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span></code></a> with a few
operations.</p>
<dl class="function">
<dt id="c.DRM_FB_HELPER_DEFAULT_OPS">
<code class="sig-name descname">DRM_FB_HELPER_DEFAULT_OPS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_FB_HELPER_DEFAULT_OPS" title="Permalink to this definition">¶</a></dt>
<dd><p>helper define for drm drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Helper define to register default implementations of drm_fb_helper
functions. To be used in struct fb_ops of drm drivers.</p>
<dl class="function">
<dt id="c.drm_fb_helper_remove_conflicting_framebuffers">
int <code class="sig-name descname">drm_fb_helper_remove_conflicting_framebuffers</code><span class="sig-paren">(</span>struct apertures_struct *<em> a</em>, const char *<em> name</em>, bool<em> primary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_remove_conflicting_framebuffers" title="Permalink to this definition">¶</a></dt>
<dd><p>remove firmware-configured framebuffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">apertures_struct</span> <span class="pre">*</span> <span class="pre">a</span></code></dt><dd><p>memory range, users of which are to be removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>requesting driver name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">primary</span></code></dt><dd><p>also kick vga16fb if present</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes framebuffer devices (initialized by firmware/bootloader)
which use memory range described by <strong>a</strong>. If <strong>a</strong> is NULL all such devices are
removed.</p>
<dl class="function">
<dt id="c.drm_fb_helper_remove_conflicting_pci_framebuffers">
int <code class="sig-name descname">drm_fb_helper_remove_conflicting_pci_framebuffers</code><span class="sig-paren">(</span>struct pci_dev *<em> pdev</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_remove_conflicting_pci_framebuffers" title="Permalink to this definition">¶</a></dt>
<dd><p>remove firmware-configured framebuffers for PCI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt><dd><p>PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>requesting driver name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes framebuffer devices (eg. initialized by firmware)
using memory range configured for any of <strong>pdev</strong>’s memory bars.</p>
<p>The function assumes that PCI device with shadowed ROM drives a primary
display and so kicks out vga16fb.</p>
<dl class="function">
<dt id="c.drm_fb_helper_debug_enter">
int <code class="sig-name descname">drm_fb_helper_debug_enter</code><span class="sig-paren">(</span>struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_debug_enter</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_debug_leave">
int <code class="sig-name descname">drm_fb_helper_debug_leave</code><span class="sig-paren">(</span>struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_leave" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_debug_leave</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_restore_fbdev_mode_unlocked">
int <code class="sig-name descname">drm_fb_helper_restore_fbdev_mode_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>restore fbdev configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from driver’s drm <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.lastclose</span></code></a> callback
when implementing an fbcon on top of kms using this helper. This ensures that
the user isn’t greeted with a black screen when e.g. X dies.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, negative error code otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_blank">
int <code class="sig-name descname">drm_fb_helper_blank</code><span class="sig-paren">(</span>int<em> blank</em>, struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_blank" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_blank</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">blank</span></code></dt><dd><p>desired blanking state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_prepare">
void <code class="sig-name descname">drm_fb_helper_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> helper</em>, const struct <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs">drm_fb_helper_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a drm_fb_helper structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">helper</span></code></dt><dd><p>driver-allocated fbdev helper structure to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>pointer to structure of functions associate with this helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the bare minimum to make the framebuffer helper usable. This is
useful to implement race-free initialization of the polling helpers.</p>
<dl class="function">
<dt id="c.drm_fb_helper_init">
int <code class="sig-name descname">drm_fb_helper_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper structure to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates the structures for the fbdev helper with the given limits.
Note that this won’t yet touch the hardware (through the driver interfaces)
nor register the fbdev. This is only done in <a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_initial_config()</span></code></a>
to allow driver writes more control over the exact init sequence.</p>
<p>Drivers must call <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_prepare()</span></code></a> before calling this function.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_alloc_fbi">
struct fb_info * <code class="sig-name descname">drm_fb_helper_alloc_fbi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_alloc_fbi" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate fb_info and some of its members</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to alloc fb_info and the members cmap and apertures. Called
by the driver within the fb_probe fb_helper callback function. Drivers do not
need to release the allocated fb_info structure themselves, this is
automatically done when calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>fb_info pointer if things went okay, pointer containing error code
otherwise</p>
<dl class="function">
<dt id="c.drm_fb_helper_unregister_fbi">
void <code class="sig-name descname">drm_fb_helper_unregister_fbi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_unregister_fbi" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister fb_info framebuffer device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around unregister_framebuffer, to release the fb_info
framebuffer device. This must be called before releasing all resources for
<strong>fb_helper</strong> by calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fb_helper_fini">
void <code class="sig-name descname">drm_fb_helper_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This cleans up all remaining resources associated with <strong>fb_helper</strong>.</p>
<dl class="function">
<dt id="c.drm_fb_helper_deferred_io">
void <code class="sig-name descname">drm_fb_helper_deferred_io</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, struct list_head *<em> pagelist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_deferred_io" title="Permalink to this definition">¶</a></dt>
<dd><p>fbdev deferred_io callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pagelist</span></code></dt><dd><p>list of dirty mmap framebuffer pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used as the <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_deferred_io.deferred_io</span></code>
callback function for flushing the fbdev mmap writes.</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_read">
ssize_t <code class="sig-name descname">drm_fb_helper_sys_read</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, char __user *<em> buf</em>, size_t<em> count</em>, loff_t *<em> ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_read" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_sys_read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>userspace buffer to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt><dd><p>read offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_sys_read implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_write">
ssize_t <code class="sig-name descname">drm_fb_helper_sys_write</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const char __user *<em> buf</em>, size_t<em> count</em>, loff_t *<em> ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_write" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_sys_write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>userspace buffer to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt><dd><p>write offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_sys_write implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_fillrect">
void <code class="sig-name descname">drm_fb_helper_sys_fillrect</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_fillrect *<em> rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_fillrect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*</span> <span class="pre">rect</span></code></dt><dd><p>info about rectangle to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_fillrect implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_copyarea">
void <code class="sig-name descname">drm_fb_helper_sys_copyarea</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_copyarea *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_copyarea</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>info about area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_copyarea implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_imageblit">
void <code class="sig-name descname">drm_fb_helper_sys_imageblit</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_image *<em> image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_imageblit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*</span> <span class="pre">image</span></code></dt><dd><p>info about image to blit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_imageblit implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_fillrect">
void <code class="sig-name descname">drm_fb_helper_cfb_fillrect</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_fillrect *<em> rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_fillrect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*</span> <span class="pre">rect</span></code></dt><dd><p>info about rectangle to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_fillrect implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_copyarea">
void <code class="sig-name descname">drm_fb_helper_cfb_copyarea</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_copyarea *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_copyarea</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>info about area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_copyarea implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_imageblit">
void <code class="sig-name descname">drm_fb_helper_cfb_imageblit</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, const struct fb_image *<em> image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_imageblit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*</span> <span class="pre">image</span></code></dt><dd><p>info about image to blit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_imageblit implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend">
void <code class="sig-name descname">drm_fb_helper_set_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em>, bool<em> suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt><dd><p>whether to suspend or resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_set_suspend implemented by fbdev core.
Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> if you don’t need to take
the lock yourself</p>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend_unlocked">
void <code class="sig-name descname">drm_fb_helper_set_suspend_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em>, bool<em> suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend that also takes the console lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt><dd><p>whether to suspend or resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around <a class="reference internal" href="../driver-api/frame-buffer.html#c.fb_set_suspend" title="fb_set_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">fb_set_suspend()</span></code></a> that takes the console lock. If the lock
isn’t available on resume, a worker is tasked with waiting for the lock
to become available. The console lock can be pretty contented on resume
due to all the printk activity.</p>
<p>This function can be called multiple times with the same state since
<code class="xref c c-type docutils literal notranslate"><span class="pre">fb_info.state</span></code> is checked to see if fbdev is running or not before locking.</p>
<p>Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend" title="drm_fb_helper_set_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend()</span></code></a> if you need to take the lock yourself.</p>
<dl class="function">
<dt id="c.drm_fb_helper_setcmap">
int <code class="sig-name descname">drm_fb_helper_setcmap</code><span class="sig-paren">(</span>struct fb_cmap *<em> cmap</em>, struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_setcmap" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_setcmap</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_cmap</span> <span class="pre">*</span> <span class="pre">cmap</span></code></dt><dd><p>cmap to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_ioctl">
int <code class="sig-name descname">drm_fb_helper_ioctl</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, unsigned int<em> cmd</em>, unsigned long<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>legacy ioctl implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>ioctl argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to implement the standard fbdev ioctl. Only
FBIO_WAITFORVSYNC is implemented for now.</p>
<dl class="function">
<dt id="c.drm_fb_helper_check_var">
int <code class="sig-name descname">drm_fb_helper_check_var</code><span class="sig-paren">(</span>struct fb_var_screeninfo *<em> var</em>, struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_check_var" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_check_var</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*</span> <span class="pre">var</span></code></dt><dd><p>screeninfo to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_set_par">
int <code class="sig-name descname">drm_fb_helper_set_par</code><span class="sig-paren">(</span>struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_par" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_set_par</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will let fbcon do the mode init and is called at initialization time by
the fbdev core when registering the driver, and later on through the hotplug
callback.</p>
<dl class="function">
<dt id="c.drm_fb_helper_pan_display">
int <code class="sig-name descname">drm_fb_helper_pan_display</code><span class="sig-paren">(</span>struct fb_var_screeninfo *<em> var</em>, struct fb_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_pan_display" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_pan_display</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*</span> <span class="pre">var</span></code></dt><dd><p>updated screen information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_fill_info">
void <code class="sig-name descname">drm_fb_helper_fill_info</code><span class="sig-paren">(</span>struct fb_info *<em> info</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em>, struct <a class="reference internal" href="#c.drm_fb_helper_surface_size" title="drm_fb_helper_surface_size">drm_fb_helper_surface_size</a> *<em> sizes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fill_info" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes fbdev information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>fbdev instance to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>fb helper instance to use as template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper_surface_size</span> <span class="pre">*</span> <span class="pre">sizes</span></code></dt><dd><p>describes fbdev size and scanout surface size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the variable and fixed fbdev metainformation from the given fb helper
instance and the drm framebuffer allocated in <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper.fb</span></code></a>.</p>
<p>Drivers should call this (or their equivalent setup code) from their
<a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback after having allocated the fbdev
backing storage framebuffer.</p>
<dl class="function">
<dt id="c.drm_fb_helper_initial_config">
int <code class="sig-name descname">drm_fb_helper_initial_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em>, int<em> bpp_sel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_initial_config" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a sane initial connector configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>fb_helper device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bpp_sel</span></code></dt><dd><p>bpp value to use for the framebuffer configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans the CRTCs and connectors and tries to put together an initial setup.
At the moment, this is a cloned configuration across all heads with
a new framebuffer object as the backing store.</p>
<p>Note that this also registers the fbdev and so allows userspace to call into
the driver through the fbdev interfaces.</p>
<p>This function will call down into the <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback
to let the driver allocate and initialize the fbdev info structure and the
drm framebuffer used to back the fbdev. <a class="reference internal" href="#c.drm_fb_helper_fill_info" title="drm_fb_helper_fill_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fill_info()</span></code></a> is provided
as a helper to setup simple default values for the fbdev info structure.</p>
<p>HANG DEBUGGING:</p>
<p>When you have fbcon support built-in or already loaded, this function will do
a full modeset to setup the fbdev console. Due to locking misdesign in the
VT/fbdev subsystem that entire modeset sequence has to be done while holding
console_lock. Until console_unlock is called no dmesg lines will be sent out
to consoles, not even serial console. This means when your driver crashes,
you will see absolutely nothing else but a system stuck in this function,
with no further output. Any kind of <a class="reference internal" href="../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> you place within your own driver
or in the drm core modeset code will also never show up.</p>
<p>Standard debug practice is to run the fbcon setup without taking the
console_lock as a hack, to be able to see backtraces and crashes on the
serial line. This can be done by setting the fb.lockless_register_fb=1 kernel
cmdline option.</p>
<p>The other option is to just disable fbdev emulation since very likely the
first modeset from userspace will crash in the same way, and is even easier
to debug. This can be done by setting the drm_kms_helper.fbdev_emulation=0
kernel cmdline option.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_hotplug_event">
int <code class="sig-name descname">drm_fb_helper_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em> fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>respond to a hotplug notification by probing all the outputs attached to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan the connectors attached to the fb_helper and try to put together a
setup after notification of a change in output configuration.</p>
<p>Called at runtime, takes the mode config locks to be able to check/change the
modeset configuration. Must be run from process context (which usually means
either the output polling work or a work item launched from the driver’s
hotplug interrupt).</p>
<p>Note that drivers may call this even before calling
drm_fb_helper_initial_config but only after drm_fb_helper_init. This allows
for a race-free fbcon setup and will make sure that the fbdev emulation will
not miss any hotplug events.</p>
<p><strong>Return</strong></p>
<p>0 on success and a non-zero error code otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_lastclose">
void <code class="sig-name descname">drm_fb_helper_lastclose</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_lastclose" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver lastclose helper for fbdev emulation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;lastclose</span></code></a> callback for drivers
that only need to call <a class="reference internal" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="drm_fb_helper_restore_fbdev_mode_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_restore_fbdev_mode_unlocked()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fb_helper_output_poll_changed">
void <code class="sig-name descname">drm_fb_helper_output_poll_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_output_poll_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM mode config .output_poll_changed helper for fbdev emulation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.output_poll_changed</span></code></a> callback for drivers that only
need to call <a class="reference internal" href="#c.drm_fb_helper_hotplug_event" title="drm_fb_helper_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_hotplug_event()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fbdev_generic_setup">
int <code class="sig-name descname">drm_fbdev_generic_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, unsigned int<em> preferred_bpp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_generic_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup generic fbdev emulation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">preferred_bpp</span></code></dt><dd><p>Preferred bits per pixel for the device.
<strong>dev-&gt;mode_config.preferred_depth</strong> is used if this is zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up generic fbdev emulation for drivers that supports
dumb buffers with a virtual address and that can be mmap’ed.</p>
<p>Restore, hotplug events and teardown are all taken care of. Drivers that do
suspend/resume need to call <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> themselves.
Simple drivers might use <a class="reference internal" href="#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_suspend()</span></code></a>.</p>
<p>Drivers that set the dirty callback on their framebuffer will get a shadow
fbdev buffer that is blitted onto the real buffer. This is done in order to
make deferred I/O work with all kinds of buffers. A shadow buffer can be
requested explicitly by setting struct drm_mode_config.prefer_shadow or
struct drm_mode_config.prefer_shadow_fbdev to true beforehand. This is
required to use generic fbdev emulation with SHMEM helpers.</p>
<p>This function is safe to call even when there are no connectors present.
Setup will be retried on the next hotplug event.</p>
<p>The fbdev is destroyed by <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success or negative error code on failure.</p>
</div>
<div class="section" id="format-helper-functions-reference">
<h2>format Helper Functions Reference<a class="headerlink" href="#format-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_fb_memcpy">
void <code class="sig-name descname">drm_fb_memcpy</code><span class="sig-paren">(</span>void *<em> dst</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>Destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>Source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does not apply clipping on dst, i.e. the destination
is a small buffer containing the clip rect only.</p>
<dl class="function">
<dt id="c.drm_fb_memcpy_dstclip">
void <code class="sig-name descname">drm_fb_memcpy_dstclip</code><span class="sig-paren">(</span>void __iomem *<em> dst</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_memcpy_dstclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>Destination buffer (iomem)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>Source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function applies clipping on dst, i.e. the destination is a
full (iomem) framebuffer but only the clip rect content is copied over.</p>
<dl class="function">
<dt id="c.drm_fb_swab16">
void <code class="sig-name descname">drm_fb_swab16</code><span class="sig-paren">(</span>u16 *<em> dst</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_swab16" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap bytes into clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>RGB565 destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>RGB565 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb565">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb565</code><span class="sig-paren">(</span>void *<em> dst</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em>, bool<em> swab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb565" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB565 clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>RGB565 destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>XRGB8888 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">swab</span></code></dt><dd><p>Swap bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function for RGB565 devices that don’t natively
support XRGB8888.</p>
<p>This function does not apply clipping on dst, i.e. the destination
is a small buffer containing the clip rect only.</p>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb565_dstclip">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb565_dstclip</code><span class="sig-paren">(</span>void __iomem *<em> dst</em>, unsigned int<em> dst_pitch</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em>, bool<em> swab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb565_dstclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB565 clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>RGB565 destination buffer (iomem)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dst_pitch</span></code></dt><dd><p>destination buffer pitch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>XRGB8888 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">swab</span></code></dt><dd><p>Swap bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function for RGB565 devices that don’t natively
support XRGB8888.</p>
<p>This function applies clipping on dst, i.e. the destination is a
full (iomem) framebuffer but only the clip rect content is copied over.</p>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb888_dstclip">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb888_dstclip</code><span class="sig-paren">(</span>void __iomem *<em> dst</em>, unsigned int<em> dst_pitch</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb888_dstclip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB888 clip buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>RGB565 destination buffer (iomem)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dst_pitch</span></code></dt><dd><p>destination buffer pitch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>XRGB8888 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function for RGB888 devices that don’t natively
support XRGB8888.</p>
<p>This function applies clipping on dst, i.e. the destination is a
full (iomem) framebuffer but only the clip rect content is copied over.</p>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_gray8">
void <code class="sig-name descname">drm_fb_xrgb8888_to_gray8</code><span class="sig-paren">(</span>u8 *<em> dst</em>, void *<em> vaddr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_gray8" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to grayscale</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>8-bit grayscale destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt><dd><p>XRGB8888 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drm doesn’t have native monochrome or grayscale support.
Such drivers can announce the commonly supported XR24 format to userspace
and use this function to convert to the native format.</p>
<p>Monochrome drivers will use the most significant bit,
where 1 means foreground color and 0 background color.</p>
<p>ITU BT.601 is used for the RGB -&gt; luma (brightness) conversion.</p>
</div>
<div class="section" id="framebuffer-cma-helper-functions-reference">
<h2>Framebuffer CMA Helper Functions Reference<a class="headerlink" href="#framebuffer-cma-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Provides helper functions for creating a cma (contiguous memory allocator)
backed framebuffer.</p>
<p><a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> is used in the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>
callback function to create a cma backed framebuffer.</p>
<dl class="function">
<dt id="c.drm_fb_cma_get_gem_obj">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_cma_object" title="drm_gem_cma_object">drm_gem_cma_object</a> * <code class="sig-name descname">drm_fb_cma_get_gem_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_get_gem_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get CMA GEM object for framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>The framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Which plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the CMA GEM object for given framebuffer.</p>
<p>This function will usually be called from the CRTC callback functions.</p>
<dl class="function">
<dt id="c.drm_fb_cma_get_gem_addr">
dma_addr_t <code class="sig-name descname">drm_fb_cma_get_gem_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> state</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_get_gem_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get physical address for framebuffer, for pixel formats where values are grouped in blocks this will get you the beginning of the block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>The framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>Which state of drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Which plane
Return the CMA GEM address for given framebuffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will usually be called from the PLANE callback functions.</p>
</div>
<div class="section" id="framebuffer-gem-helper-reference">
<h2>Framebuffer GEM Helper Reference<a class="headerlink" href="#framebuffer-gem-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides helpers for drivers that don’t subclass
<a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> and use <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> for their backing storage.</p>
<p>Drivers without additional needs to validate framebuffers can simply use
<a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> and everything is wired up automatically. Other drivers
can use all parts independently.</p>
<dl class="function">
<dt id="c.drm_gem_fb_get_obj">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="sig-name descname">drm_gem_fb_get_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_get_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get GEM object backing the framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Plane index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No additional reference is taken beyond the one that the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_frambuffer</span></code>
already holds.</p>
<p><strong>Return</strong></p>
<p>Pointer to <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> for the given framebuffer and plane index or NULL
if it does not exist.</p>
<dl class="function">
<dt id="c.drm_gem_fb_destroy">
void <code class="sig-name descname">drm_gem_fb_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GEM backed framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees a GEM backed framebuffer with its backing buffer(s) and the structure
itself. Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs-&gt;destroy</span></code></a>
callback.</p>
<dl class="function">
<dt id="c.drm_gem_fb_create_handle">
int <code class="sig-name descname">drm_gem_fb_create_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em> file</em>, unsigned int *<em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create handle for GEM backed framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>DRM file to register the handle for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt><dd><p>Pointer to return the created handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a handle for the GEM object backing the framebuffer.
Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs-&gt;create_handle</span></code></a>
callback. The GETFB IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_fb_create_with_funcs">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create_with_funcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em> file</em>, const struct drm_mode_fb_cmd2 *<em> mode_cmd</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_with_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>vtable to be used for the new framebuffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to set <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a> for drivers that need
custom framebuffer callbacks. Use <a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> if you don’t need to
change <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a>. The function does buffer size validation.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
<dl class="function">
<dt id="c.drm_gem_fb_create">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em> file</em>, const struct drm_mode_fb_cmd2 *<em> mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new framebuffer object described by
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2</span></code>. This description includes handles for the buffer(s)
backing the framebuffer.</p>
<p>If your hardware has special alignment or pitch requirements these should be
checked before calling this function. The function does buffer size
validation. Use <a class="reference internal" href="#c.drm_gem_fb_create_with_dirty" title="drm_gem_fb_create_with_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create_with_dirty()</span></code></a> if you need framebuffer
flushing.</p>
<p>Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback.
The ADDFB2 IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
<dl class="function">
<dt id="c.drm_gem_fb_create_with_dirty">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create_with_dirty</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em> file</em>, const struct drm_mode_fb_cmd2 *<em> mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_with_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new framebuffer object described by
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2</span></code>. This description includes handles for the buffer(s)
backing the framebuffer. <a class="reference internal" href="drm-kms.html#c.drm_atomic_helper_dirtyfb" title="drm_atomic_helper_dirtyfb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_dirtyfb()</span></code></a> is used for the dirty
callback giving framebuffer flushing through the atomic machinery. Use
<a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> if you don’t need the dirty callback.
The function does buffer size validation.</p>
<p>Drivers should also call <a class="reference internal" href="drm-kms.html#c.drm_plane_enable_fb_damage_clips" title="drm_plane_enable_fb_damage_clips"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_enable_fb_damage_clips()</span></code></a> on all planes
to enable userspace to use damage clips also with the ATOMIC IOCTL.</p>
<p>Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback.
The ADDFB2 IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
<dl class="function">
<dt id="c.drm_gem_fb_prepare_fb">
int <code class="sig-name descname">drm_gem_fb_prepare_fb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_prepare_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a GEM backed framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>Plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>Plane state the fence will be attached to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function extracts the exclusive fence from <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.resv</span></code></a> and
attaches it to plane state for the atomic helper to wait on. This is
necessary to correctly implement implicit synchronization for any buffers
shared as a struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. This function can be used as the
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> callback.</p>
<p>There is no need for <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for simple
gem based framebuffer drivers which have their buffers always pinned in
memory.</p>
<p>See <a class="reference internal" href="drm-kms.html#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a> for a discussion of implicit and
explicit fencing in atomic modeset updates.</p>
<dl class="function">
<dt id="c.drm_gem_fb_simple_display_pipe_prepare_fb">
int <code class="sig-name descname">drm_gem_fb_simple_display_pipe_prepare_fb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em> pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_simple_display_pipe_prepare_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare_fb helper for <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>Simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt><dd><p>Plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function uses <a class="reference internal" href="#c.drm_gem_fb_prepare_fb" title="drm_gem_fb_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_prepare_fb()</span></code></a> to extract the exclusive fence
from <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.resv</span></code></a> and attaches it to plane state for the atomic
helper to wait on. This is necessary to correctly implement implicit
synchronization for any buffers shared as a struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. Drivers can use
this as their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs.prepare_fb</span></code></a> callback.</p>
<p>See <a class="reference internal" href="drm-kms.html#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a> for a discussion of implicit and
explicit fencing in atomic modeset updates.</p>
</div>
<div class="section" id="bridges">
<span id="drm-bridges"></span><h2>Bridges<a class="headerlink" href="#bridges" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a> represents a device that hangs on to an encoder. These are
handy when a regular <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> entity isn’t enough to represent the entire
encoder chain.</p>
<p>A bridge is always attached to a single <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> at a time, but can be
either connected to it directly, or through a chain of bridges:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[ CRTC ---&gt; ] Encoder ---&gt; Bridge A ---&gt; Bridge B
</pre></div>
</div>
<p>Here, the output of the encoder feeds to bridge A, and that furthers feeds to
bridge B. Bridge chains can be arbitrarily long, and shall be fully linear:
Chaining multiple bridges to the output of a bridge, or the same bridge to
the output of different bridges, is not supported.</p>
<p>Display drivers are responsible for linking encoders with the first bridge
in the chains. This is done by acquiring the appropriate bridge with
<a class="reference internal" href="#c.of_drm_find_bridge" title="of_drm_find_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_drm_find_bridge()</span></code></a> or <a class="reference internal" href="#c.drm_of_find_panel_or_bridge" title="drm_of_find_panel_or_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_of_find_panel_or_bridge()</span></code></a>, or creating it for a
panel with <a class="reference internal" href="#c.drm_panel_bridge_add_typed" title="drm_panel_bridge_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add_typed()</span></code></a> (or the managed version
<a class="reference internal" href="#c.devm_drm_panel_bridge_add_typed" title="devm_drm_panel_bridge_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add_typed()</span></code></a>). Once acquired, the bridge shall be
attached to the encoder with a call to <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a>.</p>
<p>Bridges are responsible for linking themselves with the next bridge in the
chain, if any. This is done the same way as for encoders, with the call to
<a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> occurring in the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a> operation.</p>
<p>Once these links are created, the bridges can participate along with encoder
functions to perform mode validation and fixup (through
<a class="reference internal" href="#c.drm_bridge_chain_mode_valid" title="drm_bridge_chain_mode_valid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_chain_mode_valid()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_bridge_chain_check" title="drm_atomic_bridge_chain_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_check()</span></code></a>), mode
setting (through <a class="reference internal" href="#c.drm_bridge_chain_mode_set" title="drm_bridge_chain_mode_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_chain_mode_set()</span></code></a>), enable (through
<a class="reference internal" href="#c.drm_atomic_bridge_chain_pre_enable" title="drm_atomic_bridge_chain_pre_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_pre_enable()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_bridge_chain_enable" title="drm_atomic_bridge_chain_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_enable()</span></code></a>)
and disable (through <a class="reference internal" href="#c.drm_atomic_bridge_chain_disable" title="drm_atomic_bridge_chain_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_disable()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_bridge_chain_post_disable" title="drm_atomic_bridge_chain_post_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_post_disable()</span></code></a>). Those functions call the
corresponding operations provided in <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> in sequence for all
bridges in the chain.</p>
<p>For display drivers that use the atomic helpers
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_commit_modeset_enables" title="drm_atomic_helper_commit_modeset_enables"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_modeset_enables()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_commit_modeset_disables" title="drm_atomic_helper_commit_modeset_disables"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_modeset_disables()</span></code></a> (either directly in hand-rolled
commit check and commit tail handlers, or through the higher-level
<a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail_rpm" title="drm_atomic_helper_commit_tail_rpm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail_rpm()</span></code></a> helpers), this is done transparently and
requires no intervention from the driver. For other drivers, the relevant
DRM bridge chain functions shall be called manually.</p>
<p>Bridges also participate in implementing the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> at the end of
the bridge chain. Display drivers may use the <a class="reference internal" href="#c.drm_bridge_connector_init" title="drm_bridge_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_connector_init()</span></code></a>
helper to create the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>, or implement it manually on top of the
connector-related operations exposed by the bridge (see the overview
documentation of bridge operations for more details).</p>
<p><a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>, like <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>, aren’t <a class="reference internal" href="drm-kms.html#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a> entities like planes,
CRTCs, encoders or connectors and hence are not visible to userspace. They
just provide additional hooks to get the desired output at the end of the
encoder chain.</p>
</div>
<div class="section" id="bridge-operations">
<h3>Bridge Operations<a class="headerlink" href="#bridge-operations" title="Permalink to this headline">¶</a></h3>
<p>Bridge drivers expose operations through the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> structure.
The DRM internals (atomic and CRTC helpers) use the helpers defined in
drm_bridge.c to call bridge operations. Those operations are divided in
three big categories to support different parts of the bridge usage.</p>
<ul>
<li><p>The encoder-related operations support control of the bridges in the
chain, and are roughly counterparts to the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a>
operations. They are used by the legacy CRTC and the atomic modeset
helpers to perform mode validation, fixup and setting, and enable and
disable the bridge automatically.</p>
<p>The enable and disable operations are split in
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a> to provide
finer-grained control.</p>
<p>Bridge drivers may implement the legacy version of those operations, or
the atomic version (prefixed with atomic_), in which case they shall also
implement the atomic state bookkeeping operations
(<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_destroy_state</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.reset</span></code></a>).
Mixing atomic and non-atomic versions of the operations is not supported.</p>
</li>
<li><p>The bus format negotiation operations
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_output_bus_fmts</span></code></a> and
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_input_bus_fmts</span></code></a> allow bridge drivers to
negotiate the formats transmitted between bridges in the chain when
multiple formats are supported. Negotiation for formats is performed
transparently for display drivers by the atomic modeset helpers. Only
atomic versions of those operations exist, bridge drivers that need to
implement them shall thus also implement the atomic version of the
encoder-related operations. This feature is not supported by the legacy
CRTC helpers.</p></li>
<li><p>The connector-related operations support implementing a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>
based on a chain of bridges. DRM bridges traditionally create a
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> for bridges meant to be used at the end of the chain. This
puts additional burden on bridge drivers, especially for bridges that may
be used in the middle of a chain or at the end of it. Furthermore, it
requires all operations of the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> to be handled by a single
bridge, which doesn’t always match the hardware architecture.</p>
<p>To simplify bridge drivers and make the connector implementation more
flexible, a new model allows bridges to unconditionally skip creation of
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> and instead expose <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> operations to support
an externally-implemented <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>. Those operations are
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.detect</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_modes</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_notify</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_enable</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_disable</span></code></a>. When
implemented, display drivers shall create a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> instance for
each chain of bridges, and implement those connector instances based on
the bridge connector operations.</p>
<p>Bridge drivers shall implement the connector-related operations for all
the features that the bridge hardware support. For instance, if a bridge
supports reading EDID, the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a> shall be
implemented. This however doesn’t mean that the DDC lines are wired to the
bridge on a particular platform, as they could also be connected to an I2C
controller of the SoC. Support for the connector-related operations on the
running platform is reported through the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags. Bridge
drivers shall detect which operations they can support on the platform
(usually this information is provided by ACPI or DT), and set the
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags for all supported operations. A flag shall only be
set if the corresponding <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> operation is implemented, but
an implemented operation doesn’t necessarily imply that the corresponding
flag will be set. Display drivers shall use the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags to
decide which bridge to delegate a connector operation to. This mechanism
allows providing a single static const <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> instance in
bridge drivers, improving security by storing function pointers in
read-only memory.</p>
<p>In order to ease transition, bridge drivers may support both the old and
new models by making connector creation optional and implementing the
connected-related bridge operations. Connector creation is then controlled
by the flags argument to the <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> function. Display drivers
that support the new model and create connectors themselves shall set the
<code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code> flag, and bridge drivers shall then skip
connector creation. For intermediate bridges in the chain, the flag shall
be passed to the <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> call for the downstream bridge.
Bridge drivers that implement the new model only shall return an error
from their <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a> handler when the
<code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code> flag is not set. New display drivers
should use the new model, and convert the bridge drivers they use if
needed, in order to gradually transition to the new model.</p>
</li>
</ul>
</div>
<div class="section" id="bridge-connector-helper">
<h3>Bridge Connector Helper<a class="headerlink" href="#bridge-connector-helper" title="Permalink to this headline">¶</a></h3>
<p>The DRM bridge connector helper object provides a DRM connector
implementation that wraps a chain of <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>. The connector
operations are fully implemented based on the operations of the bridges in
the chain, and don’t require any intervention from the display controller
driver at runtime.</p>
<p>To use the helper, display controller drivers create a bridge connector with
a call to <a class="reference internal" href="#c.drm_bridge_connector_init" title="drm_bridge_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_connector_init()</span></code></a>. This associates the newly created
connector with the chain of bridges passed to the function and registers it
with the DRM device. At that point the connector becomes fully usable, no
further operation is needed.</p>
<p>The DRM bridge connector operations are implemented based on the operations
provided by the bridges in the chain. Each connector operation is delegated
to the bridge closest to the connector (at the end of the chain) that
provides the relevant functionality.</p>
<p>To make use of this helper, all bridges in the chain shall report bridge
operation flags (<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>) and bridge output type
(<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;type</span></code></a>), as well as the DRM_BRIDGE_ATTACH_NO_CONNECTOR attach
flag (none of the bridges shall create a DRM connector directly).</p>
</div>
<div class="section" id="bridge-helper-reference">
<h3>Bridge Helper Reference<a class="headerlink" href="#bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_bridge_attach_flags">
enum <code class="sig-name descname">drm_bridge_attach_flags</code><a class="headerlink" href="#c.drm_bridge_attach_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code></dt><dd><p>When this flag is set the bridge
shall not create a drm_connector.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge_funcs">
struct <code class="sig-name descname">drm_bridge_funcs</code><a class="headerlink" href="#c.drm_bridge_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>drm_bridge control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge_funcs {
  int (*attach)(struct drm_bridge *bridge, enum drm_bridge_attach_flags flags);
  void (*detach)(struct drm_bridge *bridge);
  enum drm_mode_status (*mode_valid)(struct drm_bridge *bridge, const struct drm_display_mode *mode);
  bool (*mode_fixup)(struct drm_bridge *bridge,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (*disable)(struct drm_bridge *bridge);
  void (*post_disable)(struct drm_bridge *bridge);
  void (*mode_set)(struct drm_bridge *bridge,const struct drm_display_mode *mode, const struct drm_display_mode *adjusted_mode);
  void (*pre_enable)(struct drm_bridge *bridge);
  void (*enable)(struct drm_bridge *bridge);
  void (*atomic_pre_enable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
  void (*atomic_enable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
  void (*atomic_disable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
  void (*atomic_post_disable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
  struct drm_bridge_state *(*atomic_duplicate_state)(struct drm_bridge *bridge);
  void (*atomic_destroy_state)(struct drm_bridge *bridge, struct drm_bridge_state *state);
  u32 *(*atomic_get_output_bus_fmts)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state, unsigned int *num_output_fmts);
  u32 *(*atomic_get_input_bus_fmts)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state,u32 output_fmt, unsigned int *num_input_fmts);
  int (*atomic_check)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
  struct drm_bridge_state *(*atomic_reset)(struct drm_bridge *bridge);
  enum drm_connector_status (*detect)(struct drm_bridge *bridge);
  int (*get_modes)(struct drm_bridge *bridge, struct drm_connector *connector);
  struct edid *(*get_edid)(struct drm_bridge *bridge, struct drm_connector *connector);
  void (*hpd_notify)(struct drm_bridge *bridge, enum drm_connector_status status);
  void (*hpd_enable)(struct drm_bridge *bridge);
  void (*hpd_disable)(struct drm_bridge *bridge);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>This callback is invoked whenever our bridge is being attached to a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>. The flags argument tunes the behaviour of the attach
operation (see DRM_BRIDGE_ATTACH_*).</p>
<p>The <strong>attach</strong> callback is optional.</p>
<p>RETURNS:</p>
<p>Zero on success, error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>This callback is invoked whenever our bridge is being detached from a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>.</p>
<p>The <strong>detach</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
bridge. This should be implemented if the bridge has some sort of
restriction in the modes it can display. For example, a given bridge
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>The <strong>mode_valid</strong> callback is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> or the next
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>. The parameter adjusted_mode is the input mode the bridge
requires. It can be modified by this callback and does not need to
match mode. See also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This is the only hook that allows a bridge to reject a modeset. If
this function passes all other callbacks must succeed for this
configuration.</p>
<p>The mode_fixup callback is optional. <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a>
is not called when <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> is implemented,
so only one of them should be provided.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Drivers MUST
NOT touch any persistent state (hardware or software) or data
structures except the passed in <strong>state</strong> parameter.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any bridge constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>disable</strong> vfunc. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>
it’s called right before the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>,
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a> or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a>
hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p>The <strong>disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it’s called after that bridge’s
<strong>post_disable</strong> function. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>
it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a>
or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
singals) feeding it is no longer running when this callback is
called.</p>
<p>The <strong>post_disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback should set the given mode on the bridge. It is called
after the <strong>mode_set</strong> callback for the preceding element in the display
pipeline has been called already. If the bridge is the first element
then this would be <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_set</span></code></a>. The display
pipe (i.e.  clocks and timing signals) is off when this function is
called.</p>
<p>The adjusted_mode parameter is the mode output by the CRTC for the
first bridge in the chain. It can be different from the mode
parameter that contains the desired mode for the connector at the end
of the bridges chain, for instance when the first bridge in the chain
performs scaling. The adjusted mode is mostly useful for the first
bridge in the chain and is likely irrelevant for the other bridges.</p>
<p>For atomic drivers the adjusted_mode is the mode stored in
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>.</p>
<p>NOTE:</p>
<p>If a need arises to store and access modes adjusted for other
locations than the connection between the CRTC and the first bridge,
the DRM framework will have to be extended with DRM bridge states.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>pre_enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p>The <strong>pre_enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called after that
bridge’s <strong>enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p>The <strong>enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_pre_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>atomic_pre_enable</strong> or <strong>pre_enable</strong> function. If the preceding
element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_pre_enable" title="drm_bridge_chain_pre_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_pre_enable</span></code></a>. It would be prudent to also provide an
implementation of <strong>pre_enable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_pre_enable" title="drm_bridge_chain_pre_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_pre_enable</span></code></a>.</p>
<p>The <strong>atomic_pre_enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called after that
bridge’s <strong>atomic_enable</strong> or <strong>enable</strong> function. If the preceding element
is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from <a class="reference internal" href="#c.drm_bridge_chain_enable" title="drm_bridge_chain_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_enable</span></code></a>.
It would be prudent to also provide an implementation of <strong>enable</strong> if
you are expecting driver calls into <a class="reference internal" href="#c.drm_bridge_chain_enable" title="drm_bridge_chain_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_enable</span></code></a>.</p>
<p>The <strong>atomic_enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>atomic_disable</strong> or <strong>disable</strong> vfunc. If the preceding element
is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_disable" title="drm_bridge_chain_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_disable</span></code></a>. It would be prudent to also provide an
implementation of <strong>disable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_disable" title="drm_bridge_chain_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_disable</span></code></a>.</p>
<p>The <strong>atomic_disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_post_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it’s called after that bridge’s
<strong>atomic_post_disable</strong> or <strong>post_disable</strong> function. If the preceding
element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
signals) feeding it is no longer running when this callback is
called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_post_disable" title="drm_bridge_chain_post_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_post_disable</span></code></a>.
It would be prudent to also provide an implementation of
<strong>post_disable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_post_disable" title="drm_bridge_chain_post_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_post_disable</span></code></a>.</p>
<p>The <strong>atomic_post_disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current bridge state object (which is guaranteed to be
non-NULL).</p>
<p>The atomic_duplicate_state hook is mandatory if the bridge
implements any of the atomic hooks, and should be left unassigned
otherwise. For bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_duplicate_state" title="drm_atomic_helper_bridge_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_duplicate_state()</span></code></a> helper function shall be
used to implement this hook.</p>
<p>RETURNS:
A valid drm_bridge_state object or NULL if the allocation fails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Destroy a bridge state object previously allocated by
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state()</span></code></a>.</p>
<p>The atomic_destroy_state hook is mandatory if the bridge implements
any of the atomic hooks, and should be left unassigned otherwise.
For bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_destroy_state" title="drm_atomic_helper_bridge_destroy_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_destroy_state()</span></code></a> helper function shall be
used to implement this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_output_bus_fmts</span></code></dt><dd><p>Return the supported bus formats on the output end of a bridge.
The returned array must be allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and will be
freed by the caller. If the allocation fails, NULL should be
returned. num_output_fmts must be set to the returned array size.
Formats listed in the returned array should be listed in decreasing
preference order (the core will try all formats until it finds one
that works).</p>
<p>This method is only called on the last element of the bridge chain
as part of the bus format negotiation process that happens in
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_select_bus_fmts`().</span>
<span class="pre">This</span> <span class="pre">method</span> <span class="pre">is</span> <span class="pre">optional.</span> <span class="pre">When</span> <span class="pre">not</span> <span class="pre">implemented,</span> <span class="pre">the</span> <span class="pre">core</span> <span class="pre">will</span>
<span class="pre">fall</span> <span class="pre">back</span> <span class="pre">to</span> <span class="pre">:c:type:`drm_connector.display_info</span></code></a>.bus_formats[0] if
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>.num_bus_formats &gt; 0,
or to MEDIA_BUS_FMT_FIXED otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_input_bus_fmts</span></code></dt><dd><p>Return the supported bus formats on the input end of a bridge for
a specific output bus format.</p>
<p>The returned array must be allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and will be
freed by the caller. If the allocation fails, NULL should be
returned. num_output_fmts must be set to the returned array size.
Formats listed in the returned array should be listed in decreasing
preference order (the core will try all formats until it finds one
that works). When the format is not supported NULL should be
returned and num_output_fmts should be set to 0.</p>
<p>This method is called on all elements of the bridge chain as part of
the bus format negotiation process that happens in
drm_atomic_bridge_chain_select_bus_fmts().
This method is optional. When not implemented, the core will bypass
bus format negotiation on this element of the bridge without
failing, and the previous element in the chain will be passed
MEDIA_BUS_FMT_FIXED as its output bus format.</p>
<p>Bridge drivers that need to support being linked to bridges that are
not supporting bus format negotiation should handle the
output_fmt == MEDIA_BUS_FMT_FIXED case appropriately, by selecting a
sensible default value or extracting this information from somewhere
else (FW property, <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a>, …)</p>
<p>Note: Even if input format selection on the first bridge has no
impact on the negotiation process (bus format negotiation stops once
we reach the first element of the chain), drivers are expected to
return accurate input formats as the input format may be used to
configure the CRTC output appropriately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This method is responsible for checking bridge state correctness.
It can also check the state of the surrounding components in chain
to make sure the whole pipeline can work properly.</p>
<p><a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> hooks are called in reverse
order (from the last to the first bridge).</p>
<p>This method is optional. <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a> is not
called when <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> is implemented, so only
one of them should be provided.</p>
<p>If drivers need to tweak <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.input_bus_cfg</span></code></a>.flags or
<a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.output_bus_cfg</span></code></a>.flags it should should happen in
this function. By default the <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.output_bus_cfg</span></code></a>.flags
field is set to the next bridge
<a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.input_bus_cfg</span></code></a>.flags value or
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>.bus_flags if the bridge is the last
element in the chain.</p>
<p>RETURNS:
zero if the check passed, a negative error code otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_reset</span></code></dt><dd><p>Reset the bridge to a predefined state (or retrieve its current
state) and return a <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a> object matching this state.
This function is called at attach time.</p>
<p>The atomic_reset hook is mandatory if the bridge implements any of
the atomic hooks, and should be left unassigned otherwise. For
bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_reset" title="drm_atomic_helper_bridge_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_reset()</span></code></a> helper function shall be used to
implement this hook.</p>
<p>Note that the atomic_reset() semantics is not exactly matching the
reset() semantics found on other components (connector, plane, …).</p>
<ol class="arabic simple">
<li><p>The reset operation happens when the bridge is attached, not when
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> is called</p></li>
<li><p>It’s meant to be used exclusively on bridges that have been
converted to the ATOMIC API</p></li>
</ol>
<p>RETURNS:
A valid drm_bridge_state object in case of success, an ERR_PTR()
giving the reason of the failure otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>Check if anything is attached to the bridge output.</p>
<p>This callback is optional, if not implemented the bridge will be
considered as always having a component attached to its output.
Bridges that implement this callback shall set the
DRM_BRIDGE_OP_DETECT flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>RETURNS:</p>
<p>drm_connector_status indicating the bridge output status.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>Fill all modes currently valid for the sink into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>
with <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
<p>The <strong>get_modes</strong> callback is mostly intended to support non-probeable
displays such as many fixed panels. Bridges that support reading
EDID shall leave <strong>get_modes</strong> unimplemented and implement the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_edid</span></code></a> callback instead.</p>
<p>This callback is optional. Bridges that implement it shall set the
DRM_BRIDGE_OP_MODES flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>The connector parameter shall be used for the sole purpose of
filling modes, and shall not be stored internally by bridge drivers
for future usage.</p>
<p>RETURNS:</p>
<p>The number of modes added by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_edid</span></code></dt><dd><p>Read and parse the EDID data of the connected display.</p>
<p>The <strong>get_edid</strong> callback is the preferred way of reporting mode
information for a display connected to the bridge output. Bridges
that support reading EDID shall implement this callback and leave
the <strong>get_modes</strong> callback unimplemented.</p>
<p>The caller of this operation shall first verify the output
connection status and refrain from reading EDID from a disconnected
output.</p>
<p>This callback is optional. Bridges that implement it shall set the
DRM_BRIDGE_OP_EDID flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>The connector parameter shall be used for the sole purpose of EDID
retrieval and parsing, and shall not be stored internally by bridge
drivers for future usage.</p>
<p>RETURNS:</p>
<p>An edid structure newly allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> (or similar) on
success, or NULL otherwise. The caller is responsible for freeing
the returned edid structure with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_notify</span></code></dt><dd><p>Notify the bridge of hot plug detection.</p>
<p>This callback is optional, it may be implemented by bridges that
need to be notified of display connection or disconnection for
internal reasons. One use case is to reset the internal state of CEC
controllers for HDMI bridges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_enable</span></code></dt><dd><p>Enable hot plug detection. From now on the bridge shall call
<a class="reference internal" href="#c.drm_bridge_hpd_notify" title="drm_bridge_hpd_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_notify()</span></code></a> each time a change is detected in the output
connection status, until hot plug detection gets disabled with
<strong>hpd_disable</strong>.</p>
<p>This callback is optional and shall only be implemented by bridges
that support hot-plug notification without polling. Bridges that
implement it shall also implement the <strong>hpd_disable</strong> callback and set
the DRM_BRIDGE_OP_HPD flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_disable</span></code></dt><dd><p>Disable hot plug detection. Once this function returns the bridge
shall not call <a class="reference internal" href="#c.drm_bridge_hpd_notify" title="drm_bridge_hpd_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_notify()</span></code></a> when a change in the output
connection status occurs.</p>
<p>This callback is optional and shall only be implemented by bridges
that support hot-plug notification without polling. Bridges that
implement it shall also implement the <strong>hpd_enable</strong> callback and set
the DRM_BRIDGE_OP_HPD flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge_timings">
struct <code class="sig-name descname">drm_bridge_timings</code><a class="headerlink" href="#c.drm_bridge_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>timing information for the bridge</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge_timings {
  u32 input_bus_flags;
  u32 setup_time_ps;
  u32 hold_time_ps;
  bool dual_link;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">input_bus_flags</span></code></dt><dd><p>Tells what additional settings for the pixel data on the bus
this bridge requires (like pixel signal polarity). See also
<a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info-&gt;bus_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_time_ps</span></code></dt><dd><p>Defines the time in picoseconds the input data lines must be
stable before the clock edge.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hold_time_ps</span></code></dt><dd><p>Defines the time in picoseconds taken for the bridge to sample the
input signal after the clock edge.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dual_link</span></code></dt><dd><p>True if the bus operates in dual-link mode. The exact meaning is
dependent on the bus type. For LVDS buses, this indicates that even-
and odd-numbered pixels are received on separate links.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge_ops">
enum <code class="sig-name descname">drm_bridge_ops</code><a class="headerlink" href="#c.drm_bridge_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitmask of operations supported by the bridge</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_DETECT</span></code></dt><dd><p>The bridge can detect displays connected to
its output. Bridges that set this flag shall implement the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;detect</span></code></a> callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_EDID</span></code></dt><dd><p>The bridge can retrieve the EDID of the display
connected to its output. Bridges that set this flag shall implement
the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_edid</span></code></a> callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_HPD</span></code></dt><dd><p>The bridge can detect hot-plug and hot-unplug
without requiring polling. Bridges that set this flag shall
implement the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;hpd_enable</span></code></a> and
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;hpd_disable</span></code></a> callbacks if they support enabling
and disabling hot-plug detection dynamically.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_MODES</span></code></dt><dd><p>The bridge can retrieve the modes supported
by the display at its output. This does not include reading EDID
which is separately covered by <strong>DRM_BRIDGE_OP_EDID</strong>. Bridges that set
this flag shall implement the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_modes</span></code></a> callback.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge">
struct <code class="sig-name descname">drm_bridge</code><a class="headerlink" href="#c.drm_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM bridge control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge {
  struct drm_private_obj base;
  struct drm_device *dev;
  struct drm_encoder *encoder;
  struct list_head chain_node;
#ifdef CONFIG_OF;
  struct device_node *of_node;
#endif;
  struct list_head list;
  const struct drm_bridge_timings *timings;
  const struct drm_bridge_funcs *funcs;
  void *driver_private;
  enum drm_bridge_ops ops;
  int type;
  bool interlace_allowed;
  struct i2c_adapter *ddc;
  struct mutex hpd_mutex;
  void (*hpd_cb)(void *data, enum drm_connector_status status);
  void *hpd_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>inherit from <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_object</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device this bridge belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>encoder to which this bridge is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_node</span></code></dt><dd><p>used to form a bridge chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>device node pointer to the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>to keep track of all added bridges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings</span></code></dt><dd><p>the timing specification for the bridge, if any (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_private</span></code></dt><dd><p>pointer to the bridge driver’s internal context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>bitmask of operations supported by the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the connection at the bridge output
(DRM_MODE_CONNECTOR_*). For bridges at the end of this chain this
identifies the type of connected display.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interlace_allowed</span></code></dt><dd><p>Indicate that the bridge can handle interlaced
modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddc</span></code></dt><dd><p>Associated I2C adapter for DDC access, if any.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_mutex</span></code></dt><dd><p>Protects the <strong>hpd_cb</strong> and <strong>hpd_data</strong> fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_cb</span></code></dt><dd><p>Hot plug detection callback, registered with
<a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_data</span></code></dt><dd><p>Private data passed to the Hot plug detection callback
<strong>hpd_cb</strong>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_bridge_get_next_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_get_next_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_next_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next bridge in the chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the next bridge in the chain after <strong>bridge</strong>, or NULL if <strong>bridge</strong> is the last.</p>
<dl class="function">
<dt id="c.drm_bridge_get_prev_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_get_prev_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_prev_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the previous bridge in the chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the previous bridge in the chain, or NULL if <strong>bridge</strong> is the first.</p>
<dl class="function">
<dt id="c.drm_bridge_chain_get_first_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_chain_get_first_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_get_first_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first bridge in the chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>encoder object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the first bridge in the chain, or NULL if <strong>encoder</strong> has no bridge attached
to it.</p>
<dl class="function">
<dt id="c.drm_for_each_bridge_in_chain">
<code class="sig-name descname">drm_for_each_bridge_in_chain</code><span class="sig-paren">(</span><em>encoder</em>, <em>bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_bridge_in_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all bridges present in a chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>the encoder to iterate bridges on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge</span></code></dt><dd><p>a bridge pointer updated to point to the current bridge at each
iteration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all bridges present in the bridge chain attached to <strong>encoder</strong>.</p>
<dl class="function">
<dt id="c.drm_bridge_add">
void <code class="sig-name descname">drm_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the given bridge to the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_bridge_remove">
void <code class="sig-name descname">drm_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given bridge from the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_bridge_attach">
int <code class="sig-name descname">drm_bridge_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> previous</em>, enum <a class="reference internal" href="#c.drm_bridge_attach_flags" title="drm_bridge_attach_flags">drm_bridge_attach_flags</a><em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach the bridge to an encoder’s chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>DRM encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">previous</span></code></dt><dd><p>previous bridge in the chain (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_bridge_attach_flags</span> <span class="pre">flags</span></code></dt><dd><p>DRM_BRIDGE_ATTACH_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a kms driver to link the bridge to an encoder’s chain. The previous
argument specifies the previous bridge in the chain. If NULL, the bridge is
linked directly at the encoder’s output. Otherwise it is linked at the
previous bridge’s output.</p>
<p>If non-NULL the previous bridge must be already attached by a call to this
function.</p>
<p>Note that bridges attached to encoders are auto-detached during encoder
cleanup in <a class="reference internal" href="drm-kms.html#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_cleanup()</span></code></a>, so <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> should generally
<em>not</em> be balanced with a drm_bridge_detach() in driver code.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_fixup">
bool <code class="sig-name descname">drm_bridge_chain_mode_fixup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>fixup proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>desired mode to be set for the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">adjusted_mode</span></code></dt><dd><p>updated mode that works for this bridge</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<p><strong>Return</strong></p>
<p>true on success, false on failure</p>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_valid">
enum <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_bridge_chain_mode_valid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the mode against all bridges in the encoder chain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>desired mode to be validated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> for all the bridges in the encoder
chain, starting from the first bridge to the last. If at least one bridge
does not accept the mode the function returns the error code.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder.</p>
<p><strong>Return</strong></p>
<p>MODE_OK on success, drm_mode_status Enum error code on failure</p>
<dl class="function">
<dt id="c.drm_bridge_chain_disable">
void <code class="sig-name descname">drm_bridge_chain_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called before
calling the encoder’s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_chain_post_disable">
void <code class="sig-name descname">drm_bridge_chain_post_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_post_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up after disabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last. These are called
after completing the encoder’s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_set">
void <code class="sig-name descname">drm_bridge_chain_mode_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>desired mode to be set for the encoder chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">adjusted_mode</span></code></dt><dd><p>updated mode that works for this encoder chain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_set</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_chain_pre_enable">
void <code class="sig-name descname">drm_bridge_chain_pre_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_pre_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares for enabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called
before calling the encoder’s commit op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_chain_enable">
void <code class="sig-name descname">drm_bridge_chain_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a> op for all the bridges in the encoder
chain, starting from the first bridge to the last. These are called
after completing the encoder’s commit op.</p>
<p>Note that the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_disable">
void <code class="sig-name descname">drm_atomic_bridge_chain_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_disable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_post_disable">
void <code class="sig-name descname">drm_atomic_bridge_chain_post_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_post_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up after disabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_post_disable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a>) op for all the bridges in the encoder chain,
starting from the first bridge to the last. These are called after completing
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_pre_enable">
void <code class="sig-name descname">drm_atomic_bridge_chain_pre_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_pre_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares for enabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_pre_enable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_enable">
void <code class="sig-name descname">drm_atomic_bridge_chain_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_enable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a>) op for all the bridges in the encoder chain,
starting from the first bridge to the last. These are called after completing
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_check">
int <code class="sig-name descname">drm_atomic_bridge_chain_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an atomic check on the bridge chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>new connector state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>First trigger a bus format negotiation before calling
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code on failure</p>
<dl class="function">
<dt id="c.drm_bridge_detect">
enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> <code class="sig-name descname">drm_bridge_detect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>check if anything is attached to the bridge output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output detection, as reported by the
DRM_BRIDGE_OP_DETECT bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.detect</span></code></a> for the
bridge and return the connection status. Otherwise return
connector_status_unknown.</p>
<p><strong>Return</strong></p>
<p>The detection status on success, or connector_status_unknown if the bridge
doesn’t support output detection.</p>
<dl class="function">
<dt id="c.drm_bridge_get_modes">
int <code class="sig-name descname">drm_bridge_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>fill all modes currently valid for the sink into the <strong>connector</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>the connector to fill with modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output modes retrieval, as reported by the
DRM_BRIDGE_OP_MODES bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_modes</span></code></a> to
fill the connector with all valid modes and return the number of modes
added. Otherwise return 0.</p>
<p><strong>Return</strong></p>
<p>The number of modes added to the connector.</p>
<dl class="function">
<dt id="c.drm_bridge_get_edid">
struct edid * <code class="sig-name descname">drm_bridge_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get the EDID data of the connected display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>the connector to read EDID for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output EDID retrieval, as reported by the
DRM_BRIDGE_OP_EDID bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a> to
get the EDID and return it. Otherwise return ERR_PTR(-ENOTSUPP).</p>
<p><strong>Return</strong></p>
<p>The retrieved EDID on success, or an error pointer otherwise.</p>
<dl class="function">
<dt id="c.drm_bridge_hpd_enable">
void <code class="sig-name descname">drm_bridge_hpd_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, void (<em>*cb</em>)(void *data, enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> status), void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable hot plug detection for the bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*data,</span> <span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status)</span> <span class="pre">cb</span></code></dt><dd><p>hot-plug detection callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data to be passed to the hot-plug detection callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_enable</span></code></a> if implemented and register the given <strong>cb</strong>
and <strong>data</strong> as hot plug notification callback. From now on the <strong>cb</strong> will be
called with <strong>data</strong> when an output status change is detected by the bridge,
until hot plug notification gets disabled with <a class="reference internal" href="#c.drm_bridge_hpd_disable" title="drm_bridge_hpd_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_disable()</span></code></a>.</p>
<p>Hot plug detection is supported only if the DRM_BRIDGE_OP_HPD flag is set in
bridge-&gt;ops. This function shall not be called when the flag is not set.</p>
<p>Only one hot plug detection callback can be registered at a time, it is an
error to call this function when hot plug detection is already enabled for
the bridge.</p>
<dl class="function">
<dt id="c.drm_bridge_hpd_disable">
void <code class="sig-name descname">drm_bridge_hpd_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable hot plug detection for the bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_disable</span></code></a> if implemented and unregister the hot
plug detection callback previously registered with <a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.
Once this function returns the callback will not be called by the bridge
when an output status change occurs.</p>
<p>Hot plug detection is supported only if the DRM_BRIDGE_OP_HPD flag is set in
bridge-&gt;ops. This function shall not be called when the flag is not set.</p>
<dl class="function">
<dt id="c.drm_bridge_hpd_notify">
void <code class="sig-name descname">drm_bridge_hpd_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a><em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notify hot plug detection events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt><dd><p>output connection status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Bridge drivers shall call this function to report hot plug events when they
detect a change in the output status, when hot plug detection has been
enabled by <a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.</p>
<p>This function shall be called in a context that can sleep.</p>
<dl class="function">
<dt id="c.of_drm_find_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">of_drm_find_bridge</code><span class="sig-paren">(</span>struct device_node *<em> np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bridge corresponding to the device node in the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>device node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>drm_bridge control struct on success, NULL on failure</p>
</div>
<div class="section" id="bridge-connector-helper-reference">
<h3>Bridge Connector Helper Reference<a class="headerlink" href="#bridge-connector-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_bridge_connector_enable_hpd">
void <code class="sig-name descname">drm_bridge_connector_enable_hpd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_enable_hpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable hot-plug detection for the connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>The DRM bridge connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables hot-plug detection for the given bridge connector.
This is typically used by display drivers in their resume handler.</p>
<dl class="function">
<dt id="c.drm_bridge_connector_disable_hpd">
void <code class="sig-name descname">drm_bridge_connector_disable_hpd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_disable_hpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable hot-plug detection for the connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>The DRM bridge connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables hot-plug detection for the given bridge connector.
This is typically used by display drivers in their suspend handler.</p>
<dl class="function">
<dt id="c.drm_bridge_connector_init">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="sig-name descname">drm_bridge_connector_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> drm</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a connector for a chain of bridges</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>the encoder where the bridge chain starts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate, initialise and register a <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_connector</span></code> with the <strong>drm</strong>
device. The connector is associated with a chain of bridges that starts at
the <strong>encoder</strong>. All bridges in the chain shall report bridge operation flags
(<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>) and bridge output type (<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;type</span></code></a>), and none of
them may create a DRM connector directly.</p>
<p>Returns a pointer to the new connector on success, or a negative error
pointer otherwise.</p>
</div>
<div class="section" id="panel-bridge-helper-reference">
<h3>Panel-Bridge Helper Reference<a class="headerlink" href="#panel-bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that just calls the appropriate functions from <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For drivers converting from directly using drm_panel: The expected
usage pattern is that during either encoder module probe or DSI
host attach, a drm_panel will be looked up through
<a class="reference internal" href="#c.drm_of_find_panel_or_bridge" title="drm_of_find_panel_or_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_of_find_panel_or_bridge()</span></code></a>.  <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> is used to
wrap that panel in the new bridge, and the result can then be
passed to <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a>.  The <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_prepare()</span></code></a> and related
functions can be dropped from the encoder driver (they’re now
called by the KMS helpers before calling into the encoder), along
with connector creation.  When done with the bridge (after
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> if the bridge has already been attached), then
<a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_remove()</span></code></a> to free it.</p>
<p>The connector type is set to <strong>panel-&gt;connector_type</strong>, which must be set to a
known type. Calling this function with a panel whose connector type is
DRM_MODE_CONNECTOR_Unknown will return NULL.</p>
<p>See <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a> for an automatically managed version of this
function.</p>
<dl class="function">
<dt id="c.drm_panel_bridge_add_typed">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_panel_bridge_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em>, u32<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> with an explicit connector type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">connector_type</span></code></dt><dd><p>The connector type (DRM_MODE_CONNECTOR_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just like <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a>, but forces the connector type to
<strong>connector_type</strong> instead of infering it from the panel.</p>
<p>This function is deprecated and should not be used in new drivers. Use
<a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> instead, and fix panel drivers as necessary if they
don’t report a connector type.</p>
<dl class="function">
<dt id="c.drm_panel_bridge_remove">
void <code class="sig-name descname">drm_panel_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters and frees a drm_bridge created by <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p>The drm_bridge being freed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_drm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">devm_drm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a managed <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that just calls the appropriate functions from <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the managed version of <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> which automatically
calls <a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_remove()</span></code></a> when <strong>dev</strong> is unbound.</p>
<dl class="function">
<dt id="c.devm_drm_panel_bridge_add_typed">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">devm_drm_panel_bridge_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em>, u32<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_panel_bridge_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a managed <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> with an explicit connector type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">connector_type</span></code></dt><dd><p>The connector type (DRM_MODE_CONNECTOR_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just like <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a>, but forces the connector type
to <strong>connector_type</strong> instead of infering it from the panel.</p>
<p>This function is deprecated and should not be used in new drivers. Use
<a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a> instead, and fix panel drivers as necessary if
they don’t report a connector type.</p>
<dl class="function">
<dt id="c.drm_panel_bridge_connector">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="sig-name descname">drm_panel_bridge_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>return the connector for the panel bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>drm_panel_bridge creates the connector.
This function gives external access to the connector.</p>
<p><strong>Return</strong></p>
<p>Pointer to drm_connector</p>
</div>
</div>
<div class="section" id="panel-helper-reference">
<span id="drm-panel-helper"></span><h2>Panel Helper Reference<a class="headerlink" href="#panel-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>The DRM panel helpers allow drivers to register panel objects with a
central registry and provide functions to retrieve those panels in display
drivers.</p>
<p>For easy integration into drivers using the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> infrastructure please
take look at <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> and <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_panel_funcs">
struct <code class="sig-name descname">drm_panel_funcs</code><a class="headerlink" href="#c.drm_panel_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>perform operations on a given panel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panel_funcs {
  int (*prepare)(struct drm_panel *panel);
  int (*enable)(struct drm_panel *panel);
  int (*disable)(struct drm_panel *panel);
  int (*unprepare)(struct drm_panel *panel);
  int (*get_modes)(struct drm_panel *panel, struct drm_connector *connector);
  int (*get_timings)(struct drm_panel *panel, unsigned int num_timings, struct display_timing *timings);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>Turn on panel and perform set up.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Enable panel (turn on back light, etc.).</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Disable panel (turn off back light, etc.).</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare</span></code></dt><dd><p>Turn off panel.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>Add modes to the connector that the panel is attached to
and returns the number of modes added.</p>
<p>This function is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_timings</span></code></dt><dd><p>Copy display timings into the provided array and return
the number of display timings available.</p>
<p>This function is optional.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .prepare() function is typically called before the display controller
starts to transmit video data. Panel drivers can use this to turn the panel
on and wait for it to become ready. If additional configuration is required
(via a control bus such as I2C, SPI or DSI for example) this is a good time
to do that.</p>
<p>After the display controller has started transmitting video data, it’s safe
to call the .enable() function. This will typically enable the backlight to
make the image on screen visible. Some panels require a certain amount of
time or frames before the image is displayed. This function is responsible
for taking this into account before enabling the backlight to avoid visual
glitches.</p>
<p>Before stopping video transmission from the display controller it can be
necessary to turn off the panel to avoid visual glitches. This is done in
the .disable() function. Analogously to .enable() this typically involves
turning off the backlight and waiting for some time to make sure no image
is visible on the panel. It is then safe for the display controller to
cease transmission of video data.</p>
<p>To save power when no video data is transmitted, a driver can power down
the panel. This is the job of the .unprepare() function.</p>
<p>Backlight can be handled automatically if configured using
<a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a>. Then the driver does not need to implement the
functionality to enable/disable backlight.</p>
<dl class="type">
<dt id="c.drm_panel">
struct <code class="sig-name descname">drm_panel</code><a class="headerlink" href="#c.drm_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM panel object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panel {
  struct device *dev;
  struct backlight_device *backlight;
  const struct drm_panel_funcs *funcs;
  int connector_type;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Parent device of the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight</span></code></dt><dd><p>Backlight device, used to turn on backlight after the call
to enable(), and to turn off backlight before the call to
disable().
backlight is set by <a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a> and drivers
shall not assign it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Operations that can be performed on the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type</span></code></dt><dd><p>Type of the panel as a DRM_MODE_CONNECTOR_* value. This is used to
initialise the drm_connector corresponding to the panel with the
correct connector type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Panel entry in registry.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_panel_init">
void <code class="sig-name descname">drm_panel_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const struct <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs">drm_panel_funcs</a> *<em> funcs</em>, int<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>parent device of the panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_panel_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>panel operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt><dd><p>the connector type (DRM_MODE_CONNECTOR_*) corresponding to
the panel interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the panel structure for subsequent registration with
<a class="reference internal" href="#c.drm_panel_add" title="drm_panel_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_add()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_panel_add">
int <code class="sig-name descname">drm_panel_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a panel to the global registry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>panel to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a panel to the global registry so that it can be looked up by display
drivers.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_remove">
void <code class="sig-name descname">drm_panel_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a panel from the global registry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a panel from the global registry.</p>
<dl class="function">
<dt id="c.drm_panel_attach">
int <code class="sig-name descname">drm_panel_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a panel to a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After obtaining a pointer to a DRM panel a display driver calls this
function to attach a panel to a connector.</p>
<p>An error is returned if the panel is already attached to another connector.</p>
<p>When unloading, the driver should detach from the panel by calling
<a class="reference internal" href="#c.drm_panel_detach" title="drm_panel_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_detach()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_detach">
void <code class="sig-name descname">drm_panel_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a panel from a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detaches a panel from the connector it is attached to. If a panel is not
attached to any connector this is effectively a no-op.</p>
<p>This function should not be called by the panel device itself. It
is only for the drm device that called <a class="reference internal" href="#c.drm_panel_attach" title="drm_panel_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_attach()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_panel_prepare">
int <code class="sig-name descname">drm_panel_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power on a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will enable power and deassert any reset signals to
the panel. After this has completed it is possible to communicate with any
integrated circuitry via a command bus.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_unprepare">
int <code class="sig-name descname">drm_panel_unprepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power off a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will completely power off a panel (assert the panel’s
reset, turn off power supplies, …). After this function has completed, it
is usually no longer possible to communicate with the panel until another
call to <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_prepare()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_enable">
int <code class="sig-name descname">drm_panel_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the panel display drivers to be turned on
and the backlight to be enabled. Content will be visible on screen after
this call completes.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_disable">
int <code class="sig-name descname">drm_panel_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will typically turn off the panel’s backlight or disable the display
drivers. For smart panels it should still be possible to communicate with
the integrated circuitry via any command bus after this call.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_get_modes">
int <code class="sig-name descname">drm_panel_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>probe the available display modes of a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The modes probed from the panel are automatically added to the connector
that the panel is attached to.</p>
<p><strong>Return</strong></p>
<p>The number of modes available from the panel on success or a
negative error code on failure.</p>
<dl class="function">
<dt id="c.of_drm_find_panel">
struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> * <code class="sig-name descname">of_drm_find_panel</code><span class="sig-paren">(</span>const struct device_node *<em> np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a panel using a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>device tree node of the panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the set of registered panels for one that matches the given device
tree node. If a matching panel is found, return a pointer to it.</p>
<p><strong>Return</strong></p>
<p>A pointer to the panel registered for the specified device tree
node or an ERR_PTR() if no panel matching the device tree node can be found.</p>
<p>Possible error codes returned by this function:</p>
<ul class="simple">
<li><p>EPROBE_DEFER: the panel device has not been probed yet, and the caller
should retry later</p></li>
<li><p>ENODEV: the device is not available (status != “okay” or “ok”)</p></li>
</ul>
<dl class="function">
<dt id="c.drm_panel_of_backlight">
int <code class="sig-name descname">drm_panel_of_backlight</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em> panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_of_backlight" title="Permalink to this definition">¶</a></dt>
<dd><p>use backlight device node for backlight</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to enable backlight handling if your panel
uses device tree and has a backlight phandle.</p>
<p>When the panel is enabled backlight will be enabled after a
successful call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.enable()</span></code></a></p>
<p>When the panel is disabled backlight will be disabled before the
call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.disable()</span></code></a>.</p>
<p>A typical implementation for a panel driver supporting device tree
will call this function at probe time. Backlight will then be handled
transparently without requiring any intervention from the driver.
<a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a> must be called after the call to <a class="reference internal" href="#c.drm_panel_init" title="drm_panel_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_get_panel_orientation_quirk">
int <code class="sig-name descname">drm_get_panel_orientation_quirk</code><span class="sig-paren">(</span>int<em> width</em>, int<em> height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_panel_orientation_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for panel orientation quirks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width in pixels of the panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height in pixels of the panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks for platform specific (e.g. DMI based) quirks
providing info on panel_orientation for systems where this cannot be
probed from the hard-/firm-ware. To avoid false-positive this function
takes the panel resolution as argument and checks that against the
resolution expected by the quirk-table entry.</p>
<p>Note this function is also used outside of the drm-subsys, by for example
the efifb code. Because of this this function gets compiled into its own
kernel-module when built as a module.</p>
<p><strong>Return</strong></p>
<p>A DRM_MODE_PANEL_ORIENTATION_* value if there is a quirk for this system,
or DRM_MODE_PANEL_ORIENTATION_UNKNOWN if there is no quirk.</p>
</div>
<div class="section" id="panel-self-refresh-helper-reference">
<h2>Panel Self Refresh Helper Reference<a class="headerlink" href="#panel-self-refresh-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library provides an easy way for drivers to leverage the atomic
framework to implement panel self refresh (SR) support. Drivers are
responsible for initializing and cleaning up the SR helpers on load/unload
(see <a class="reference internal" href="#c.drm_self_refresh_helper_init" title="drm_self_refresh_helper_init"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_init</span></code></a>/<a class="reference internal" href="#c.drm_self_refresh_helper_cleanup" title="drm_self_refresh_helper_cleanup"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_cleanup</span></code></a>).
The connector is responsible for setting
<a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.self_refresh_aware</span></code></a> to true at runtime if it is SR-aware
(meaning it knows how to initiate self refresh on the panel).</p>
<p>Once a crtc has enabled SR using <a class="reference internal" href="#c.drm_self_refresh_helper_init" title="drm_self_refresh_helper_init"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_init</span></code></a>, the
helpers will monitor activity and call back into the driver to enable/disable
SR as appropriate. The best way to think about this is that it’s a DPMS
on/off request with <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> set in crtc state
that tells you to disable/enable SR on the panel instead of power-cycling it.</p>
<p>During SR, drivers may choose to fully disable their crtc/encoder/bridge
hardware (in which case no driver changes are necessary), or they can inspect
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> if they want to enter low power mode
without full disable (in case full disable/enable is too slow).</p>
<p>SR will be deactivated if there are any atomic updates affecting the
pipe that is in SR mode. If a crtc is driving multiple connectors, all
connectors must be SR aware and all will enter/exit SR mode at the same time.</p>
<p>If the crtc and connector are SR aware, but the panel connected does not
support it (or is otherwise unable to enter SR), the driver should fail
atomic_check when <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> is true.</p>
<dl class="function">
<dt id="c.drm_self_refresh_helper_update_avg_times">
void <code class="sig-name descname">drm_self_refresh_helper_update_avg_times</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, unsigned int<em> commit_time_ms</em>, unsigned int<em> new_self_refresh_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_update_avg_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates a crtc’s SR time averages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the state which has just been applied to hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">commit_time_ms</span></code></dt><dd><p>the amount of time in ms that this commit took to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_self_refresh_mask</span></code></dt><dd><p>bitmask of crtc’s that have self_refresh_active in
new state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit_tail</span></code></a>, this function will
update the average entry/exit self refresh times on self refresh transitions.
These averages will be used when calculating how long to delay before
entering self refresh mode after activity.</p>
<dl class="function">
<dt id="c.drm_self_refresh_helper_alter_state">
void <code class="sig-name descname">drm_self_refresh_helper_alter_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_alter_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the atomic state for SR exit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>the state currently being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at the end of atomic check. This function checks the state for flags
incompatible with self refresh exit and changes them. This is a bit
disingenuous since userspace is expecting one thing and we’re giving it
another. However in order to keep self refresh entirely hidden from
userspace, this is required.</p>
<p>At the end, we queue up the self refresh entry work so we can enter PSR after
the desired delay.</p>
<dl class="function">
<dt id="c.drm_self_refresh_helper_init">
int <code class="sig-name descname">drm_self_refresh_helper_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes self refresh helpers for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>the crtc which supports self refresh supported displays</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero if successful or -errno on failure</p>
<dl class="function">
<dt id="c.drm_self_refresh_helper_cleanup">
void <code class="sig-name descname">drm_self_refresh_helper_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans up self refresh helpers for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>the crtc to cleanup</p>
</dd>
</dl>
</div>
<div class="section" id="hdcp-helper-functions-reference">
<h2>HDCP Helper Functions Reference<a class="headerlink" href="#hdcp-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_hdcp_check_ksvs_revoked">
int <code class="sig-name descname">drm_hdcp_check_ksvs_revoked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> drm_dev</em>, u8 *<em> ksvs</em>, u32<em> ksv_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdcp_check_ksvs_revoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the revoked status of the IDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm_dev</span></code></dt><dd><p>drm_device for which HDCP revocation check is requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ksvs</span></code></dt><dd><p>List of KSVs (HDCP receiver IDs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">ksv_count</span></code></dt><dd><p>KSV count passed in through <strong>ksvs</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function reads the HDCP System renewability Message(SRM Table)
from userspace as a firmware and parses it for the revoked HDCP
KSVs(Receiver IDs) detected by DCP LLC. Once the revoked KSVs are known,
revoked state of the KSVs in the list passed in by display drivers are
decided and response is sent.</p>
<p>SRM should be presented in the name of “display_hdcp_srm.bin”.</p>
<p>Format of the SRM table, that userspace needs to write into the binary file,
is defined at:
1. Renewability chapter on 55th page of HDCP 1.4 specification
<a class="reference external" href="https://www.digital-cp.com/sites/default/files/specifications">https://www.digital-cp.com/sites/default/files/specifications</a>/HDCP``20Specification````20Rev1_4_Secure``.pdf
2. Renewability chapter on 63rd page of HDCP 2.2 specification
<a class="reference external" href="https://www.digital-cp.com/sites/default/files/specifications">https://www.digital-cp.com/sites/default/files/specifications</a>/HDCP``20on````20HDMI````20Specification````20Rev2_2_Final1``.pdf</p>
<p><strong>Return</strong></p>
<p>Count of the revoked KSVs or -ve error number incase of the failure.</p>
<dl class="function">
<dt id="c.drm_connector_attach_content_protection_property">
int <code class="sig-name descname">drm_connector_attach_content_protection_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, bool<em> hdcp_content_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_content_protection_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach content protection property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector to attach CP property on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hdcp_content_type</span></code></dt><dd><p>is HDCP Content Type property needed for connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for content protection on select connectors.
Content Protection is intentionally vague to allow for different underlying
technologies, however it is most implemented by HDCP.</p>
<p>When hdcp_content_type is true enum property called HDCP Content Type is
created (if it is not already) and attached to the connector.</p>
<p>This property is used for sending the protected content’s stream type
from userspace to kernel on selected connectors. Protected content provider
will decide their type of their content and declare the same to kernel.</p>
<p>Content type will be used during the HDCP 2.2 authentication.
Content type will be set to <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.hdcp_content_type</span></code></a>.</p>
<p>The content protection will be set to <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.content_protection</span></code></a></p>
<p>When kernel triggered content protection state change like DESIRED-&gt;ENABLED
and ENABLED-&gt;DESIRED, will use <a class="reference internal" href="#c.drm_hdcp_update_content_protection" title="drm_hdcp_update_content_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_hdcp_update_content_protection()</span></code></a> to update
the content protection state of a connector.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_hdcp_update_content_protection">
void <code class="sig-name descname">drm_hdcp_update_content_protection</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, u64<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdcp_update_content_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the content protection state of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm_connector on which content protection state needs an update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">val</span></code></dt><dd><p>New state of the content protection property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by display drivers, to update the kernel triggered
content protection state changes of a drm_connector such as DESIRED-&gt;ENABLED
and ENABLED-&gt;DESIRED. No uevent for DESIRED-&gt;UNDESIRED or ENABLED-&gt;UNDESIRED,
as userspace is triggering such state change and kernel performs it without
fail.This function update the new state of the property into the connector’s
state and generate an uevent to notify the userspace.</p>
</div>
<div class="section" id="display-port-helper-functions-reference">
<h2>Display Port Helper Functions Reference<a class="headerlink" href="#display-port-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers at various abstraction
levels to deal with Display Port sink devices and related things like DP aux
channel transfers, EDID reading over DP aux channels, decoding certain DPCD
blocks, …</p>
<p>The DisplayPort AUX channel is an abstraction to allow generic, driver-
independent access to AUX functionality. Drivers can take advantage of
this by filling in the fields of the drm_dp_aux structure.</p>
<p>Transactions are described using a hardware-independent drm_dp_aux_msg
structure, which is passed into a driver’s .transfer() implementation.
Both native and I2C-over-AUX transactions are supported.</p>
<dl class="type">
<dt id="c.dp_sdp_header">
struct <code class="sig-name descname">dp_sdp_header</code><a class="headerlink" href="#c.dp_sdp_header" title="Permalink to this definition">¶</a></dt>
<dd><p>DP secondary data packet header</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dp_sdp_header {
  u8 HB0;
  u8 HB1;
  u8 HB2;
  u8 HB3;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HB0</span></code></dt><dd><p>Secondary Data Packet ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB1</span></code></dt><dd><p>Secondary Data Packet Type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB2</span></code></dt><dd><p>Secondary Data Packet Specific header, Byte 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB3</span></code></dt><dd><p>Secondary Data packet Specific header, Byte 1</p>
</dd>
</dl>
<dl class="type">
<dt id="c.dp_sdp">
struct <code class="sig-name descname">dp_sdp</code><a class="headerlink" href="#c.dp_sdp" title="Permalink to this definition">¶</a></dt>
<dd><p>DP secondary data packet</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dp_sdp {
  struct dp_sdp_header sdp_header;
  u8 db[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdp_header</span></code></dt><dd><p>DP secondary data packet header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">db</span></code></dt><dd><p>DP secondaray data packet data blocks
VSC SDP Payload for PSR
db[0]: Stereo Interface
db[1]: 0 - PSR State; 1 - Update RFB; 2 - CRC Valid
db[2]: CRC value bits 7:0 of the R or Cr component
db[3]: CRC value bits 15:8 of the R or Cr component
db[4]: CRC value bits 7:0 of the G or Y component
db[5]: CRC value bits 15:8 of the G or Y component
db[6]: CRC value bits 7:0 of the B or Cb component
db[7]: CRC value bits 15:8 of the B or Cb component
db[8] - db[31]: Reserved
VSC SDP Payload for Pixel Encoding/Colorimetry Format
db[0] - db[15]: Reserved
db[16]: Pixel Encoding and Colorimetry Formats
db[17]: Dynamic Range and Component Bit Depth
db[18]: Content Type
db[19] - db[31]: Reserved</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_aux_msg">
struct <code class="sig-name descname">drm_dp_aux_msg</code><a class="headerlink" href="#c.drm_dp_aux_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel transaction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux_msg {
  unsigned int address;
  u8 request;
  u8 reply;
  void *buffer;
  size_t size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>address of the (first) register to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>contains the type of transaction (see DP_AUX_* macros)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reply</span></code></dt><dd><p>upon completion, contains the reply type of the transaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>pointer to a transmission or reception buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of <strong>buffer</strong></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_aux_cec">
struct <code class="sig-name descname">drm_dp_aux_cec</code><a class="headerlink" href="#c.drm_dp_aux_cec" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort CEC-Tunneling-over-AUX</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux_cec {
  struct mutex lock;
  struct cec_adapter *adap;
  struct drm_connector *connector;
  struct delayed_work unregister_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>mutex protecting this struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adap</span></code></dt><dd><p>the CEC adapter for CEC-Tunneling-over-AUX support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>the connector this CEC adapter is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unregister_work</span></code></dt><dd><p>unregister the CEC adapter</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_aux">
struct <code class="sig-name descname">drm_dp_aux</code><a class="headerlink" href="#c.drm_dp_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux {
  const char *name;
  struct i2c_adapter ddc;
  struct device *dev;
  struct drm_crtc *crtc;
  struct mutex hw_mutex;
  struct work_struct crc_work;
  u8 crc_count;
  ssize_t (*transfer)(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg);
  unsigned i2c_nack_count;
  unsigned i2c_defer_count;
  struct drm_dp_aux_cec cec;
  bool is_remote;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>user-visible name of this AUX channel and the I2C-over-AUX adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddc</span></code></dt><dd><p>I2C adapter that can be used for I2C-over-AUX communication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to struct device that is the parent for this AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>backpointer to the crtc that is currently using this AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_mutex</span></code></dt><dd><p>internal mutex used for locking transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc_work</span></code></dt><dd><p>worker that captures CRCs for each frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc_count</span></code></dt><dd><p>counter of captured frame CRCs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt><dd><p>transfers a message representing a single AUX transaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_nack_count</span></code></dt><dd><p>Counts I2C NACKs, used for DP validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_defer_count</span></code></dt><dd><p>Counts I2C DEFERs, used for DP validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cec</span></code></dt><dd><p>struct containing fields used for CEC-Tunneling-over-AUX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_remote</span></code></dt><dd><p>Is this AUX CH actually using sideband messaging.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .dev field should be set to a pointer to the device that implements
the AUX channel.</p>
<p>The .name field may be used to specify the name of the I2C adapter. If set to
NULL, dev_name() of .dev will be used.</p>
<p>Drivers provide a hardware-specific implementation of how transactions
are executed via the .transfer() function. A pointer to a drm_dp_aux_msg
structure describing the transaction is passed into this function. Upon
success, the implementation should return the number of payload bytes
that were transferred, or a negative error-code on failure. Helpers
propagate errors from the .transfer() function, with the exception of
the -EBUSY error, which causes a transaction to be retried. On a short,
helpers will return -EPROTO to make it simpler to check for failure.</p>
<p>An AUX channel can also be used to transport I2C messages to a sink. A
typical application of that is to access an EDID that’s present in the
sink device. The .transfer() function can also be used to execute such
transactions. The <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> function registers an I2C
adapter that can be passed to <a class="reference internal" href="#c.drm_probe_ddc" title="drm_probe_ddc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_probe_ddc()</span></code></a>. Upon removal, drivers
should call <a class="reference internal" href="#c.drm_dp_aux_unregister" title="drm_dp_aux_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_unregister()</span></code></a> to remove the I2C adapter.
The I2C adapter uses long transfers by default; if a partial response is
received, the adapter will drop down to the size given by the partial
response for this transaction only.</p>
<p>Note that the aux helper code assumes that the .transfer() function
only modifies the reply field of the drm_dp_aux_msg structure.  The
retry logic and i2c helpers assume this is the case.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_readb">
ssize_t <code class="sig-name descname">drm_dp_dpcd_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, unsigned int<em> offset</em>, u8 *<em> valuep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">valuep</span></code></dt><dd><p>location where the value of the register will be stored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_writeb">
ssize_t <code class="sig-name descname">drm_dp_dpcd_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, unsigned int<em> offset</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>value to write to the register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="type">
<dt id="c.drm_dp_desc">
struct <code class="sig-name descname">drm_dp_desc</code><a class="headerlink" href="#c.drm_dp_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DP branch/sink device descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_desc {
  struct drm_dp_dpcd_ident ident;
  u32 quirks;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ident</span></code></dt><dd><p>DP device identification from DPCD 0x400 (sink) or 0x500 (branch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirks</span></code></dt><dd><p>Quirks; use <a class="reference internal" href="#c.drm_dp_has_quirk" title="drm_dp_has_quirk"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_has_quirk()</span></code></a> to query for the quirks.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_quirk">
enum <code class="sig-name descname">drm_dp_quirk</code><a class="headerlink" href="#c.drm_dp_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Port sink/branch device specific quirks</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_CONSTANT_N</span></code></dt><dd><p>The device requires main link attributes Mvid and Nvid to be limited
to 16 bits. So will give a constant value (0x8000) for compatability.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_NO_PSR</span></code></dt><dd><p>The device does not support PSR even if reports that it supports or
driver still need to implement proper handling for such device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_NO_SINK_COUNT</span></code></dt><dd><p>The device does not set SINK_COUNT to a non-zero value.
The driver should ignore SINK_COUNT during detection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD</span></code></dt><dd><p>The device supports MST DSC despite not supporting Virtual DPCD.
The DSC caps can be read from the physical aux instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_QUIRK_FORCE_DPCD_BACKLIGHT</span></code></dt><dd><p>The device is telling the truth when it says that it uses DPCD
backlight controls, even if the system’s firmware disagrees. This
quirk should be checked against both the ident and panel EDID.
When present, the driver should honor the DPCD backlight
capabilities advertised.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Display Port sink and branch devices in the wild have a variety of bugs, try
to collect them here. The quirks are shared, but it’s up to the drivers to
implement workarounds for them. Note that because some devices have
unreliable OUIDs, the EDID of sinks should also be checked for quirks using
<a class="reference internal" href="#c.drm_dp_get_edid_quirks" title="drm_dp_get_edid_quirks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_get_edid_quirks()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_dp_has_quirk">
bool <code class="sig-name descname">drm_dp_has_quirk</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a> *<em> desc</em>, u32<em> edid_quirks</em>, enum <a class="reference internal" href="#c.drm_dp_quirk" title="drm_dp_quirk">drm_dp_quirk</a><em> quirk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_has_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>does the DP device have a specific quirk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>Device decriptor filled by <a class="reference internal" href="#c.drm_dp_read_desc" title="drm_dp_read_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_read_desc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">edid_quirks</span></code></dt><dd><p>Optional quirk bitmask filled by <a class="reference internal" href="#c.drm_dp_get_edid_quirks" title="drm_dp_get_edid_quirks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_get_edid_quirks()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_quirk</span> <span class="pre">quirk</span></code></dt><dd><p>Quirk to query for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DP device identified by <strong>desc</strong> has <strong>quirk</strong>.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_read">
ssize_t <code class="sig-name descname">drm_dp_dpcd_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, unsigned int<em> offset</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a series of bytes from the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel (SST or MST)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the (first) register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>buffer to store the register values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>number of bytes in <strong>buffer</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_write">
ssize_t <code class="sig-name descname">drm_dp_dpcd_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, unsigned int<em> offset</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a series of bytes to the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel (SST or MST)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the (first) register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>buffer containing the values to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>number of bytes in <strong>buffer</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_read_link_status">
int <code class="sig-name descname">drm_dp_dpcd_read_link_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, u8<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>read DPCD link status (bytes 0x202-0x207)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">status</span></code></dt><dd><p>buffer to store the link status in (must be at least 6 bytes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_send_real_edid_checksum">
bool <code class="sig-name descname">drm_dp_send_real_edid_checksum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, u8<em> real_edid_checksum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_send_real_edid_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>send back real edid checksum value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">real_edid_checksum</span></code></dt><dd><p>real edid checksum for the last block</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True on success</p>
<dl class="function">
<dt id="c.drm_dp_downstream_max_clock">
int <code class="sig-name descname">drm_dp_downstream_max_clock</code><span class="sig-paren">(</span>const u8<em> dpcd</em>, const u8<em> port_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>extract branch device max pixel rate for legacy VGA converter or max TMDS clock rate for others</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns max clock in kHz on success or 0 if max clock not defined</p>
<dl class="function">
<dt id="c.drm_dp_downstream_max_bpc">
int <code class="sig-name descname">drm_dp_downstream_max_bpc</code><span class="sig-paren">(</span>const u8<em> dpcd</em>, const u8<em> port_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_bpc" title="Permalink to this definition">¶</a></dt>
<dd><p>extract branch device max bits per component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns max bpc on success or 0 if max bpc not defined</p>
<dl class="function">
<dt id="c.drm_dp_downstream_id">
int <code class="sig-name descname">drm_dp_downstream_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, char<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identify branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">id</span></code></dt><dd><p>DisplayPort branch device id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns branch device id on success or NULL on failure</p>
<dl class="function">
<dt id="c.drm_dp_downstream_debug">
void <code class="sig-name descname">drm_dp_downstream_debug</code><span class="sig-paren">(</span>struct seq_file *<em> m</em>, const u8<em> dpcd</em>, const u8<em> port_cap</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_debug" title="Permalink to this definition">¶</a></dt>
<dd><p>debug DP branch devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt><dd><p>pointer for debugfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_remote_aux_init">
void <code class="sig-name descname">drm_dp_remote_aux_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_remote_aux_init" title="Permalink to this definition">¶</a></dt>
<dd><p>minimally initialise a remote aux channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for remote aux channel in general. Merely initialize the crc work
struct.</p>
<dl class="function">
<dt id="c.drm_dp_aux_init">
void <code class="sig-name descname">drm_dp_aux_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_init" title="Permalink to this definition">¶</a></dt>
<dd><p>minimally initialise an aux channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you need to use the drm_dp_aux’s i2c adapter prior to registering it
with the outside world, call <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a> first. You must still
call <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> once the connector has been registered to
allow userspace access to the auxiliary DP channel.</p>
<dl class="function">
<dt id="c.drm_dp_aux_register">
int <code class="sig-name descname">drm_dp_aux_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_register" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise and register aux channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Automatically calls <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a> if this hasn’t been done yet.
This should only be called when the underlying <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> is
initialiazed already. Therefore the best place to call this is from
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.late_register</span></code></a>. Not that drivers which don’t follow this
will Oops when CONFIG_DRM_DP_AUX_CHARDEV is enabled.</p>
<p>Drivers which need to use the aux channel before that point (e.g. at driver
load time, before <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a> has been called) need to call
<a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_aux_unregister">
void <code class="sig-name descname">drm_dp_aux_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an AUX adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_psr_setup_time">
int <code class="sig-name descname">drm_dp_psr_setup_time</code><span class="sig-paren">(</span>const u8<em> psr_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_psr_setup_time" title="Permalink to this definition">¶</a></dt>
<dd><p>PSR setup in time usec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">psr_cap</span></code></dt><dd><p>PSR capabilities from DPCD</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>PSR setup time for the panel in microseconds,  negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_start_crc">
int <code class="sig-name descname">drm_dp_start_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_start_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>start capture of frame CRCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC displaying the frames whose CRCs are to be captured</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_stop_crc">
int <code class="sig-name descname">drm_dp_stop_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_stop_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>stop capture of frame CRCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_get_edid_quirks">
u32 <code class="sig-name descname">drm_dp_get_edid_quirks</code><span class="sig-paren">(</span>const struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_edid_quirks" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the EDID of a DP device to find additional DP-specific quirks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>The EDID to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>While OUIDs are meant to be used to recognize a DisplayPort device, a lot
of manufacturers don’t seem to like following standards and neglect to fill
the dev-ID in, making it impossible to only use OUIDs for determining
quirks in some cases. This function can be used to check the EDID and look
up any additional DP quirks. The bits returned by this function correspond
to the quirk bits in <a class="reference internal" href="#c.drm_dp_quirk" title="drm_dp_quirk"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_quirk</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>a bitmask of quirks, if any. The driver can check this using
<a class="reference internal" href="#c.drm_dp_has_quirk" title="drm_dp_has_quirk"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_has_quirk()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_dp_read_desc">
int <code class="sig-name descname">drm_dp_read_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a> *<em> desc</em>, bool<em> is_branch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>read sink/branch descriptor from DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt><dd><p>Device decriptor to fill from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_branch</span></code></dt><dd><p>true for branch devices, false for sink devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read DPCD 0x400 (sink) or 0x500 (branch) into <strong>desc</strong>. Also debug log the
identification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_max_slice_count">
u8 <code class="sig-name descname">drm_dp_dsc_sink_max_slice_count</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd</em>, bool<em> is_edp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_max_slice_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max slice count supported by the DSC sink.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_edp</span></code></dt><dd><p>true if its eDP, false for DP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the slice capabilities DPCD register from DSC sink to get
the maximum slice count supported. This is used to populate
the DSC parameters in the <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Maximum slice count supported by DSC sink or 0 its invalid</p>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_line_buf_depth">
u8 <code class="sig-name descname">drm_dp_dsc_sink_line_buf_depth</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_line_buf_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the line buffer depth in bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the DSC DPCD register to parse the line buffer depth in bits which is
number of bits of precision within the decoder line buffer supported by
the DSC sink. This is used to populate the DSC parameters in the
<a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Line buffer depth supported by DSC panel or 0 its invalid</p>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_supported_input_bpcs">
int <code class="sig-name descname">drm_dp_dsc_sink_supported_input_bpcs</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd</em>, u8<em> dsc_bpc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_supported_input_bpcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the input bits per component values supported by the DSC sink.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dsc_bpc</span></code></dt><dd><p>An array to be filled by this helper with supported
input bpcs.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the DSC DPCD from the sink device to parse the supported bits per
component values. This is used to populate the DSC parameters
in the <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Number of input BPC values parsed from the DPCD</p>
</div>
<div class="section" id="display-port-cec-helper-functions-reference">
<h2>Display Port CEC Helper Functions Reference<a class="headerlink" href="#display-port-cec-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions take care of supporting the CEC-Tunneling-over-AUX
feature of DisplayPort-to-HDMI adapters.</p>
<dl class="function">
<dt id="c.drm_dp_cec_irq">
void <code class="sig-name descname">drm_dp_cec_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>handle CEC interrupt, if any</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called when handling an IRQ_HPD request. If CEC-tunneling-over-AUX
is present, then it will check for a CEC_IRQ and handle it accordingly.</p>
<dl class="function">
<dt id="c.drm_dp_cec_register_connector">
void <code class="sig-name descname">drm_dp_cec_register_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_register_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A new connector was registered with associated CEC adapter name and
CEC adapter parent device. After registering the name and parent
drm_dp_cec_set_edid() is called to check if the connector supports
CEC and to register a CEC adapter if that is the case.</p>
<dl class="function">
<dt id="c.drm_dp_cec_unregister_connector">
void <code class="sig-name descname">drm_dp_cec_unregister_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_unregister_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the CEC adapter, if any</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
</div>
<div class="section" id="display-port-dual-mode-adaptor-helper-functions-reference">
<h2>Display Port Dual Mode Adaptor Helper Functions Reference<a class="headerlink" href="#display-port-dual-mode-adaptor-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Helper functions to deal with DP dual mode (aka. DP++) adaptors.</p>
<p>Type 1:
Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.</p>
<p>Type 2:
Adaptor registers and sink DDC bus can be accessed either via I2C or
I2C-over-AUX. Source devices may choose to implement either of these
access methods.</p>
<dl class="type">
<dt id="c.drm_lspcon_mode">
enum <code class="sig-name descname">drm_lspcon_mode</code><a class="headerlink" href="#c.drm_lspcon_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_INVALID</span></code></dt><dd><p>No LSPCON.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_LS</span></code></dt><dd><p>Level shifter mode of LSPCON
which drives DP++ to HDMI 1.4 conversion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_PCON</span></code></dt><dd><p>Protocol converter mode of LSPCON
which drives DP++ to HDMI 2.0 active conversion.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_dual_mode_type">
enum <code class="sig-name descname">drm_dp_dual_mode_type</code><a class="headerlink" href="#c.drm_dp_dual_mode_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_NONE</span></code></dt><dd><p>No DP dual mode adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_UNKNOWN</span></code></dt><dd><p>Could be either none or type 1 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_DVI</span></code></dt><dd><p>Type 1 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_HDMI</span></code></dt><dd><p>Type 1 HDMI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_DVI</span></code></dt><dd><p>Type 2 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_HDMI</span></code></dt><dd><p>Type 2 HDMI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_LSPCON</span></code></dt><dd><p>Level shifter / protocol converter</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_dual_mode_read">
ssize_t <code class="sig-name descname">drm_dp_dual_mode_read</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the DP dual mode adaptor register(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>register offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>buffer for return data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>sizo of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads <strong>size</strong> bytes from the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_write">
ssize_t <code class="sig-name descname">drm_dp_dual_mode_write</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, const void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to the DP dual mode adaptor register(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>register offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>buffer for write data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>sizo of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes <strong>size</strong> bytes to the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_detect">
enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a> <code class="sig-name descname">drm_dp_dual_mode_detect</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to identify the type of the DP dual mode adaptor used.</p>
<p>Note that when the answer is <strong>DRM_DP_DUAL_MODE_UNKNOWN</strong> it’s not
certain whether we’re dealing with a native HDMI port or
a type 1 DVI dual mode adaptor. The driver will have to use
some other hardware/driver specific mechanism to make that
distinction.</p>
<p><strong>Return</strong></p>
<p>The type of the DP dual mode adaptor used</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_max_tmds_clock">
int <code class="sig-name descname">drm_dp_dual_mode_max_tmds_clock</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_max_tmds_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Max TMDS clock for DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the max TMDS clock the adaptor supports based on the
type of the dual mode adaptor and the DP_DUAL_MODE_MAX_TMDS_CLOCK
register (on type2 adaptors). As some type 1 adaptors have
problems with registers (see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>)
we don’t read the register on those, instead we simply assume
a 165 MHz limit based on the specification.</p>
<p><strong>Return</strong></p>
<p>Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_get_tmds_output">
int <code class="sig-name descname">drm_dp_dual_mode_get_tmds_output</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter *<em> adapter</em>, bool *<em> enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_get_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the state of the TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">enabled</span></code></dt><dd><p>current state of the TMDS output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the state of the TMDS output buffers in the adaptor. For
type2 adaptors this is queried from the DP_DUAL_MODE_TMDS_OEN
register. As some type 1 adaptors have problems with registers
(see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>) we don’t read the
register on those, instead we simply assume that the buffers
are always enabled.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_set_tmds_output">
int <code class="sig-name descname">drm_dp_dual_mode_set_tmds_output</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter *<em> adapter</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_set_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable/disable TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>enable (as opposed to disable) the TMDS output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the state of the TMDS output buffers in the adaptor. For
type2 this is set via the DP_DUAL_MODE_TMDS_OEN register. As
some type 1 adaptors have problems with registers (see comments
in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>) we avoid touching the register,
making this function a no-op on type 1 adaptors.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_get_dual_mode_type_name">
const char * <code class="sig-name descname">drm_dp_get_dual_mode_type_name</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_dual_mode_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the DP dual mode adaptor type as a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>String representation of the DP dual mode adaptor type</p>
<dl class="function">
<dt id="c.drm_lspcon_get_mode">
int <code class="sig-name descname">drm_lspcon_get_mode</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_get_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C-over-aux adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>current lspcon mode of operation output variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>reading offset (0x80, 0x41)</p>
<p><strong>Return</strong></p>
<p>0 on success, sets the current_mode value to appropriate mode
-error on failure</p>
<dl class="function">
<dt id="c.drm_lspcon_set_mode">
int <code class="sig-name descname">drm_lspcon_set_mode</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_set_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C-over-aux adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">mode</span></code></dt><dd><p>required mode of operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>writing offset (0x80, 0x40)</p>
<p><strong>Return</strong></p>
<p>0 on success, -error on failure/timeout</p>
</div>
<div class="section" id="display-port-mst-helpers">
<h2>Display Port MST Helpers<a class="headerlink" href="#display-port-mst-helpers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Overview<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>These functions contain parts of the DisplayPort 1.2a MultiStream Transport
protocol. The helpers contain a topology manager and bandwidth manager.
The helpers encapsulate the sending and received of sideband msgs.</p>
<div class="section" id="topology-refcount-overview">
<h4>Topology refcount overview<a class="headerlink" href="#topology-refcount-overview" title="Permalink to this headline">¶</a></h4>
<p>The refcounting schemes for <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> and <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_port</span></code></a> are somewhat unusual. Both ports and branch devices have
two different kinds of refcounts: topology refcounts, and malloc refcounts.</p>
<p>Topology refcounts are not exposed to drivers, and are handled internally
by the DP MST helpers. The helpers use them in order to prevent the
in-memory topology state from being changed in the middle of critical
operations like changing the internal state of payload allocations. This
means each branch and port will be considered to be connected to the rest
of the topology until its topology refcount reaches zero. Additionally,
for ports this means that their associated <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> will stay
registered with userspace until the port’s refcount reaches 0.</p>
</div>
<div class="section" id="malloc-refcount-overview">
<h4>Malloc refcount overview<a class="headerlink" href="#malloc-refcount-overview" title="Permalink to this headline">¶</a></h4>
<p>Malloc references are used to keep a <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> or <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_branch</span></code></a> allocated even after all of its topology references have
been dropped, so that the driver or MST helpers can safely access each
branch’s last known state before it was disconnected from the topology.
When the malloc refcount of a port or branch reaches 0, the memory
allocation containing the <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> or <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_port</span></code></a> respectively will be freed.</p>
<p>For <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a>, malloc refcounts are not currently exposed
to drivers. As of writing this documentation, there are no drivers that
have a usecase for accessing <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> outside of the MST
helpers. Exposing this API to drivers in a race-free manner would take more
tweaking of the refcounting scheme, however patches are welcome provided
there is a legitimate driver usecase for this.</p>
</div>
<div class="section" id="refcount-relationships-in-a-topology">
<h4>Refcount relationships in a topology<a class="headerlink" href="#refcount-relationships-in-a-topology" title="Permalink to this headline">¶</a></h4>
<p>Let’s take a look at why the relationship between topology and malloc
refcounts is designed the way it is.</p>
<div class="figure align-default" id="id3">
<img alt="../_images/topology-figure-1.svg" src="../_images/topology-figure-1.svg" /><p class="caption"><span class="caption-text">An example of topology and malloc refs in a DP MST topology with two
active payloads. Topology refcount increments are indicated by solid
lines, and malloc refcount increments are indicated by dashed lines.
Each starts from the branch which incremented the refcount, and ends at
the branch to which the refcount belongs to, i.e. the arrow points the
same way as the C pointers used to reference a structure.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>As you can see in the above figure, every branch increments the topology
refcount of its children, and increments the malloc refcount of its
parent. Additionally, every payload increments the malloc refcount of its
assigned port by 1.</p>
<p>So, what would happen if MSTB #3 from the above figure was unplugged from
the system, but the driver hadn’t yet removed payload #2 from port #3? The
topology would start to look like the figure below.</p>
<div class="figure align-default" id="id4">
<img alt="../_images/topology-figure-2.svg" src="../_images/topology-figure-2.svg" /><p class="caption"><span class="caption-text">Ports and branch devices which have been released from memory are
colored grey, and references which have been removed are colored red.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Whenever a port or branch device’s topology refcount reaches zero, it will
decrement the topology refcounts of all its children, the malloc refcount
of its parent, and finally its own malloc refcount. For MSTB #4 and port
#4, this means they both have been disconnected from the topology and freed
from memory. But, because payload #2 is still holding a reference to port
#3, port #3 is removed from the topology but its <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a>
is still accessible from memory. This also means port #3 has not yet
decremented the malloc refcount of MSTB #3, so its <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_branch</span></code></a> will also stay allocated in memory until port #3’s
malloc refcount reaches 0.</p>
<p>This relationship is necessary because in order to release payload #2, we
need to be able to figure out the last relative of port #3 that’s still
connected to the topology. In this case, we would travel up the topology as
shown below.</p>
<div class="figure align-default">
<img alt="../_images/topology-figure-3.svg" src="../_images/topology-figure-3.svg" /></div>
<p>And finally, remove payload #2 by communicating with port #2 through
sideband transactions.</p>
</div>
</div>
<div class="section" id="functions-reference">
<h3>Functions Reference<a class="headerlink" href="#functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_dp_vcpi">
struct <code class="sig-name descname">drm_dp_vcpi</code><a class="headerlink" href="#c.drm_dp_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Virtual Channel Payload Identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_vcpi {
  int vcpi;
  int pbn;
  int aligned_pbn;
  int num_slots;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vcpi</span></code></dt><dd><p>Virtual channel ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbn</span></code></dt><dd><p>Payload Bandwidth Number for this channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aligned_pbn</span></code></dt><dd><p>PBN aligned with slot size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_slots</span></code></dt><dd><p>number of slots for this PBN</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_mst_port">
struct <code class="sig-name descname">drm_dp_mst_port</code><a class="headerlink" href="#c.drm_dp_mst_port" title="Permalink to this definition">¶</a></dt>
<dd><p>MST port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_port {
  struct kref topology_kref;
  struct kref malloc_kref;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
  struct drm_dp_mst_topology_ref_history topology_ref_history;
#endif;
  u8 port_num;
  bool input;
  bool mcs;
  bool ddps;
  u8 pdt;
  bool ldps;
  u8 dpcd_rev;
  u8 num_sdp_streams;
  u8 num_sdp_stream_sinks;
  uint16_t full_pbn;
  struct list_head next;
  struct drm_dp_mst_branch *mstb;
  struct drm_dp_aux aux;
  struct drm_dp_mst_branch *parent;
  struct drm_dp_vcpi vcpi;
  struct drm_connector *connector;
  struct drm_dp_mst_topology_mgr *mgr;
  struct edid *cached_edid;
  bool has_audio;
  bool fec_capable;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">topology_kref</span></code></dt><dd><p>refcount for this port’s lifetime in the topology,
only the DP MST helpers should need to touch this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">malloc_kref</span></code></dt><dd><p>refcount for the memory allocation containing this
structure. See <a class="reference internal" href="#c.drm_dp_mst_get_port_malloc" title="drm_dp_mst_get_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_port_malloc()</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_put_port_malloc" title="drm_dp_mst_put_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_port_malloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history</span></code></dt><dd><p>A history of each topology
reference/dereference. See CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_num</span></code></dt><dd><p>port number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input</span></code></dt><dd><p>if this port is an input port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mcs</span></code></dt><dd><p>message capability status - DP 1.2 spec. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddps</span></code></dt><dd><p>DisplayPort Device Plug Status - DP 1.2. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pdt</span></code></dt><dd><p>Peer Device Type. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ldps</span></code></dt><dd><p>Legacy Device Plug Status. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpcd_rev</span></code></dt><dd><p>DPCD revision of device on this port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sdp_streams</span></code></dt><dd><p>Number of simultaneous streams. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sdp_stream_sinks</span></code></dt><dd><p>Number of stream sinks. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">full_pbn</span></code></dt><dd><p>Max possible bandwidth for this port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>link to next port on this branch device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mstb</span></code></dt><dd><p>the branch device connected to this port, if there is one.
This should be considered protected for reading by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a>. There are two exceptions to this:
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.up_req_work</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.work</span></code></a>, which do not grab
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a> during reads but are the only
updaters of this list and are protected from writing concurrently
by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.probe_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux</span></code></dt><dd><p>i2c aux transport to talk to device connected to this port, protected
by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>branch device parent of this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vcpi</span></code></dt><dd><p>Virtual Channel Payload info for this port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>DRM connector this port is connected to. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p>topology manager this port lives under.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cached_edid</span></code></dt><dd><p>for DP logical ports - make tiling work by ensuring
that the EDID for all connectors is read immediately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_audio</span></code></dt><dd><p>Tracks whether the sink connector to this port is
audio-capable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST port endpoint on a device somewhere
in the MST topology.</p>
<dl class="type">
<dt id="c.drm_dp_mst_branch">
struct <code class="sig-name descname">drm_dp_mst_branch</code><a class="headerlink" href="#c.drm_dp_mst_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>MST branch device.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_branch {
  struct kref topology_kref;
  struct kref malloc_kref;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
  struct drm_dp_mst_topology_ref_history topology_ref_history;
#endif;
  struct list_head destroy_next;
  u8 rad[8];
  u8 lct;
  int num_ports;
  int msg_slots;
  struct list_head ports;
  struct drm_dp_mst_port *port_parent;
  struct drm_dp_mst_topology_mgr *mgr;
  struct drm_dp_sideband_msg_tx *tx_slots[2];
  int last_seqno;
  bool link_address_sent;
  u8 guid[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">topology_kref</span></code></dt><dd><p>refcount for this branch device’s lifetime in the
topology, only the DP MST helpers should need to touch this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">malloc_kref</span></code></dt><dd><p>refcount for the memory allocation containing this
structure. See <a class="reference internal" href="#c.drm_dp_mst_get_mstb_malloc" title="drm_dp_mst_get_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_mstb_malloc()</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_put_mstb_malloc" title="drm_dp_mst_put_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_mstb_malloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history</span></code></dt><dd><p>A history of each topology
reference/dereference. See CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_next</span></code></dt><dd><p>linked-list entry used by
drm_dp_delayed_destroy_work()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rad</span></code></dt><dd><p>Relative Address to talk to this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lct</span></code></dt><dd><p>Link count total to talk to this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ports</span></code></dt><dd><p>number of ports on the branch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_slots</span></code></dt><dd><p>one bit per transmitted msg slot.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ports</span></code></dt><dd><p>the list of ports on this branch device. This should be
considered protected for reading by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a>.
There are two exceptions to this:
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.up_req_work</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.work</span></code></a>, which do not grab
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a> during reads but are the only
updaters of this list and are protected from updating the list
concurrently by <strong>drm_dp_mst_topology_mgr.probe_lock</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_parent</span></code></dt><dd><p>pointer to the port parent, NULL if toplevel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p>topology manager for this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_slots</span></code></dt><dd><p>transmission slots for this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_seqno</span></code></dt><dd><p>last sequence number used to talk to this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_address_sent</span></code></dt><dd><p>if a link address message has been sent to this device yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">guid</span></code></dt><dd><p>guid for DP 1.2 branch device. port under this branch can be
identified by port #.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST branch device, there is one
primary branch device at the root, along with any other branches connected
to downstream port of parent branches.</p>
<dl class="type">
<dt id="c.drm_dp_mst_topology_mgr">
struct <code class="sig-name descname">drm_dp_mst_topology_mgr</code><a class="headerlink" href="#c.drm_dp_mst_topology_mgr" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort MST manager</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_topology_mgr {
  struct drm_private_obj base;
  struct drm_device *dev;
  const struct drm_dp_mst_topology_cbs *cbs;
  int max_dpcd_transaction_bytes;
  struct drm_dp_aux *aux;
  int max_payloads;
  int conn_base_id;
  struct drm_dp_sideband_msg_rx down_rep_recv;
  struct drm_dp_sideband_msg_rx up_req_recv;
  struct mutex lock;
  struct mutex probe_lock;
  bool mst_state : 1;
  bool payload_id_table_cleared : 1;
  bool is_waiting_for_dwn_reply : 1;
  struct drm_dp_mst_branch *mst_primary;
  u8 dpcd[DP_RECEIVER_CAP_SIZE];
  u8 sink_count;
  int pbn_div;
  const struct drm_private_state_funcs *funcs;
  struct mutex qlock;
  struct list_head tx_msg_downq;
  struct mutex payload_lock;
  struct drm_dp_vcpi **proposed_vcpis;
  struct drm_dp_payload *payloads;
  unsigned long payload_mask;
  unsigned long vcpi_mask;
  wait_queue_head_t tx_waitq;
  struct work_struct work;
  struct work_struct tx_work;
  struct list_head destroy_port_list;
  struct list_head destroy_branch_device_list;
  struct mutex delayed_destroy_lock;
  struct work_struct delayed_destroy_work;
  struct list_head up_req_list;
  struct mutex up_req_lock;
  struct work_struct up_req_work;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
  struct mutex topology_ref_history_lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base private object for atomic</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device pointer for adding i2c devices etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cbs</span></code></dt><dd><p>callbacks for connector addition and destruction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_dpcd_transaction_bytes</span></code></dt><dd><p>maximum number of bytes to read/write
in one go.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux</span></code></dt><dd><p>AUX channel for the DP MST connector this topolgy mgr is
controlling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_payloads</span></code></dt><dd><p>maximum number of payloads the GPU can generate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_base_id</span></code></dt><dd><p>DRM connector ID this mgr is connected to. Only used
to build the MST connector path value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">down_rep_recv</span></code></dt><dd><p>Message receiver state for down replies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_recv</span></code></dt><dd><p>Message receiver state for up requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protects <strong>mst_state</strong>, <strong>mst_primary</strong>, <strong>dpcd</strong>, and
<strong>payload_id_table_cleared</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_lock</span></code></dt><dd><p>Prevents <strong>work</strong> and <strong>up_req_work</strong>, the only writers of
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.mstb</span></code></a> and <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.ports</span></code></a>, from racing
while they update the topology.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mst_state</span></code></dt><dd><p>If this manager is enabled for an MST capable port. False
if no MST sink/branch devices is connected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_id_table_cleared</span></code></dt><dd><p>Whether or not we’ve cleared the payload
ID table for <strong>mst_primary</strong>. Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_waiting_for_dwn_reply</span></code></dt><dd><p>whether we’re waiting for a down reply.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mst_primary</span></code></dt><dd><p>Pointer to the primary/first branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpcd</span></code></dt><dd><p>Cache of DPCD for primary port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sink_count</span></code></dt><dd><p>Sink count from DEVICE_SERVICE_IRQ_VECTOR_ESI0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbn_div</span></code></dt><dd><p>PBN to slots divisor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Atomic helper callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qlock</span></code></dt><dd><p>protects <strong>tx_msg_downq</strong>, the <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.txslost</span></code></a> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_sideband_msg_tx.state</span></code> once they are queued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_msg_downq</span></code></dt><dd><p>List of pending down replies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_lock</span></code></dt><dd><p>Protect payload information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proposed_vcpis</span></code></dt><dd><p>Array of pointers for the new VCPI allocation. The
VCPI structure itself is <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.vcpi</span></code></a>, and the size of
this array is determined by <strong>max_payloads</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payloads</span></code></dt><dd><p>Array of payloads. The size of this array is determined
by <strong>max_payloads</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_mask</span></code></dt><dd><p>Elements of <strong>payloads</strong> actually in use. Since
reallocation of active outputs isn’t possible gaps can be created by
disabling outputs out of order compared to how they’ve been enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vcpi_mask</span></code></dt><dd><p>Similar to <strong>payload_mask</strong>, but for <strong>proposed_vcpis</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_waitq</span></code></dt><dd><p>Wait to queue stall for the tx worker.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Probe work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_work</span></code></dt><dd><p>Sideband transmit worker. This can nest within the main
<strong>work</strong> worker for each transaction <strong>work</strong> launches.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_port_list</span></code></dt><dd><p>List of to be destroyed connectors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_branch_device_list</span></code></dt><dd><p>List of to be destroyed branch
devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_destroy_lock</span></code></dt><dd><p>Protects <strong>destroy_port_list</strong> and
<strong>destroy_branch_device_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_destroy_work</span></code></dt><dd><p>Work item to destroy MST port and branch
devices, needed to avoid locking inversion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_list</span></code></dt><dd><p>List of pending up requests from the topology that
need to be processed, in chronological order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_lock</span></code></dt><dd><p>Protects <strong>up_req_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_work</span></code></dt><dd><p>Work item to process up requests received from the
topology. Needed to avoid blocking hotplug handling and sideband
transmissions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history_lock</span></code></dt><dd><p>protects
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_ref_history</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_ref_history</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct represents the toplevel displayport MST topology manager.
There should be one instance of this for every MST capable DP connector
on the GPU.</p>
<dl class="function">
<dt id="c.__drm_dp_mst_state_iter_get">
bool <code class="sig-name descname">__drm_dp_mst_state_iter_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> **<em> mgr</em>, struct drm_dp_mst_topology_state **<em> old_state</em>, struct drm_dp_mst_topology_state **<em> new_state</em>, int<em> i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_dp_mst_state_iter_get" title="Permalink to this definition">¶</a></dt>
<dd><p>private atomic state iterator function for macro-internal use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">**</span> <span class="pre">mgr</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">**</span> <span class="pre">old_state</span></code></dt><dd><p>optional pointer to the old <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code>
iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">**</span> <span class="pre">new_state</span></code></dt><dd><p>optional pointer to the new <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code>
iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by <a class="reference internal" href="#c.for_each_oldnew_mst_mgr_in_state" title="for_each_oldnew_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_mst_mgr_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_mst_mgr_in_state" title="for_each_old_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_mst_mgr_in_state()</span></code></a>, and <a class="reference internal" href="#c.for_each_new_mst_mgr_in_state" title="for_each_new_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_mst_mgr_in_state()</span></code></a>. Don’t
call this directly.</p>
<p><strong>Return</strong></p>
<p>True if the current <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> is a <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_topology_mgr</span></code></a>, false otherwise.</p>
<dl class="function">
<dt id="c.for_each_oldnew_mst_mgr_in_state">
<code class="sig-name descname">for_each_oldnew_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>old_state</em>, <em>new_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_state</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code> iteration cursor for the old
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_state</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code> iteration cursor for the new
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking both old and new state. This is useful in places where the state
delta needs to be considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_mst_mgr_in_state">
<code class="sig-name descname">for_each_old_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>old_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_state</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code> iteration cursor for the old
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking only the old state. This is useful in disable functions, where we
need the old state the hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_mst_mgr_in_state">
<code class="sig-name descname">for_each_new_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>new_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_state</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code> iteration cursor for the new
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking only the new state. This is useful in enable functions, where we
need the new state the hardware should be in when the atomic commit
operation has completed.</p>
<dl class="function">
<dt id="c.drm_dp_mst_get_port_malloc">
void <code class="sig-name descname">drm_dp_mst_get_port_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_port_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the malloc refcount of an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>. When <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>
reaches 0, the memory allocation for <strong>port</strong> will be released and <strong>port</strong> may
no longer be used.</p>
<p>Because <strong>port</strong> could potentially be freed at any time by the DP MST helpers
if <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a> reaches 0, including during a call to this
function, drivers that which to make use of <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> should
ensure that they grab at least one main malloc reference to their MST ports
in <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_cbs.add_connector</span></code>. This callback is called before
there is any chance for <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a> to reach 0.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_put_port_malloc" title="drm_dp_mst_put_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_port_malloc()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_put_port_malloc">
void <code class="sig-name descname">drm_dp_mst_put_port_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_put_port_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the malloc refcount of an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to decrement the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>. When <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>
reaches 0, the memory allocation for <strong>port</strong> will be released and <strong>port</strong> may
no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_get_port_malloc" title="drm_dp_mst_get_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_port_malloc()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_connector_late_register">
int <code class="sig-name descname">drm_dp_mst_connector_late_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_connector_late_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Late MST connector registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>The MST connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The MST port for this connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to register the remote aux device for this MST port. Drivers should
call this from their mst connector’s late_register hook to enable MST aux
devices.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_mst_connector_early_unregister">
void <code class="sig-name descname">drm_dp_mst_connector_early_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_connector_early_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Early MST connector unregistration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>The MST connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The MST port for this connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to unregister the remote aux device for this MST port, registered by
<a class="reference internal" href="#c.drm_dp_mst_connector_late_register" title="drm_dp_mst_connector_late_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_connector_late_register()</span></code></a>. Drivers should call this from their mst
connector’s early_unregister hook.</p>
<dl class="function">
<dt id="c.drm_dp_update_payload_part1">
int <code class="sig-name descname">drm_dp_update_payload_part1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_update_payload_part1" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to use.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-&gt;slots transitions,
this step just writes the VCPI to the MST device. For slots-&gt;0
transitions, this writes the updated VCPIs and removes the
remote VC payloads.</p>
<p>after calling this the driver should generate ACT and payload
packets.</p>
<dl class="function">
<dt id="c.drm_dp_update_payload_part2">
int <code class="sig-name descname">drm_dp_update_payload_part2</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_update_payload_part2" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to use.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-&gt;slots transitions,
this step writes the remote VC payload commands. For slots-&gt;0
this just resets some internal state.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_set_mst">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_set_mst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, bool<em> mst_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_set_mst" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the MST state for a topology manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to set state for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">mst_state</span></code></dt><dd><p>true to enable MST on this connector - false to disable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called by the driver when it detects an MST capable device plugged
into a DP MST capable port, or when a DP MST capable device is unplugged.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_suspend">
void <code class="sig-name descname">drm_dp_mst_topology_mgr_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend the MST manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to suspend</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tells the MST device that we can’t handle UP messages
anymore. This should stop it from sending any since we are suspended.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_resume">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, bool<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>resume the MST manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">sync</span></code></dt><dd><p>whether or not to perform topology reprobing synchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will fetch DPCD and see if the device is still there,
if it is, it will rewrite the MSTM control bits, and return.</p>
<p>If the device fails this returns -1, and the driver should do
a full MST reprobe, in case we were undocked.</p>
<p>During system resume (where it is assumed that the driver will be calling
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>) this function should be called beforehand with
<strong>sync</strong> set to true. In contexts like runtime resume where the driver is not
expected to be calling <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, this function should be
called with <strong>sync</strong> set to false in order to avoid deadlocking.</p>
<p><strong>Return</strong></p>
<p>-1 if the MST topology was removed while we were suspended, 0
otherwise.</p>
<dl class="function">
<dt id="c.drm_dp_mst_hpd_irq">
int <code class="sig-name descname">drm_dp_mst_hpd_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, u8 *<em> esi</em>, bool *<em> handled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_hpd_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>MST hotplug IRQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to notify irq for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">esi</span></code></dt><dd><p>4 bytes from SINK_COUNT_ESI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">handled</span></code></dt><dd><p>whether the hpd interrupt was consumed or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from the driver when it detects a short IRQ,
along with the value of the DEVICE_SERVICE_IRQ_VECTOR_ESI0. The
topology manager will process the sideband messages received as a result
of this.</p>
<dl class="function">
<dt id="c.drm_dp_mst_detect_port">
int <code class="sig-name descname">drm_dp_mst_detect_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_detect_port" title="Permalink to this definition">¶</a></dt>
<dd><p>get connection status for an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>DRM connector for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>The acquisition context to use for grabbing locks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>pointer to a port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current connection state for a port.</p>
<dl class="function">
<dt id="c.drm_dp_mst_port_has_audio">
bool <code class="sig-name descname">drm_dp_mst_port_has_audio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_port_has_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether port has audio capability or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>unverified pointer to a port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns whether the port supports audio or not.</p>
<dl class="function">
<dt id="c.drm_dp_mst_get_edid">
struct edid * <code class="sig-name descname">drm_dp_mst_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID for an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>toplevel connector to get EDID for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>unverified pointer to a port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns an EDID for the port connected to a connector,
It validates the pointer still exists so the caller doesn’t require a
reference.</p>
<dl class="function">
<dt id="c.drm_dp_find_vcpi_slots">
int <code class="sig-name descname">drm_dp_find_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, int<em> pbn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_find_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Find VCPI slots for this PBN value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>payload bandwidth to convert into slots.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the number of VCPI slots that will be required for the given PBN
value. This function is deprecated, and should not be used in atomic
drivers.</p>
<p><strong>Return</strong></p>
<p>The total slots required for this port, or error.</p>
<dl class="function">
<dt id="c.drm_dp_atomic_find_vcpi_slots">
int <code class="sig-name descname">drm_dp_atomic_find_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em>, int<em> pbn</em>, int<em> pbn_div</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_find_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and add VCPI slots to the state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>MST topology manager for the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to find vcpi slots for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>bandwidth required for the mode in PBN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn_div</span></code></dt><dd><p>divider for DSC mode that takes FEC into account</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates VCPI slots to <strong>port</strong>, replacing any previous VCPI allocations it
may have had. Any atomic drivers which support MST must call this function
in their <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check()</span></code></a> callback to change the
current VCPI allocation for the new state, but only when
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode_changed</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.connectors_changed</span></code></a> is set
to ensure compatibility with userspace applications that still use the
legacy modesetting UAPI.</p>
<p>Allocations set by this function are not checked against the bandwidth
restraints of <strong>mgr</strong> until the driver calls <a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a>.</p>
<p>Additionally, it is OK to call this function multiple times on the same
<strong>port</strong> as needed. It is not OK however, to call this function and
<a class="reference internal" href="#c.drm_dp_atomic_release_vcpi_slots" title="drm_dp_atomic_release_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_vcpi_slots()</span></code></a> in the same atomic check phase.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_release_vcpi_slots" title="drm_dp_atomic_release_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_vcpi_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>Total slots in the atomic state assigned for this port, or a negative error
code if the port no longer exists</p>
<dl class="function">
<dt id="c.drm_dp_atomic_release_vcpi_slots">
int <code class="sig-name descname">drm_dp_atomic_release_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_release_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Release allocated vcpi slots</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>MST topology manager for the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The port to release the VCPI slots from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases any VCPI slots that have been allocated to a port in the atomic
state. Any atomic drivers which support MST must call this function in
their <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check()</span></code></a> callback when the
connector will no longer have VCPI allocated (e.g. because its CRTC was
removed) when it had VCPI allocated in the previous atomic state.</p>
<p>It is OK to call this even if <strong>port</strong> has been removed from the system.
Additionally, it is OK to call this function multiple times on the same
<strong>port</strong> as needed. It is not OK however, to call this function and
<a class="reference internal" href="#c.drm_dp_atomic_find_vcpi_slots" title="drm_dp_atomic_find_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_vcpi_slots()</span></code></a> on the same <strong>port</strong> in a single atomic check
phase.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_find_vcpi_slots" title="drm_dp_atomic_find_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_vcpi_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 if all slots for this port were added back to
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_state.avail_slots</span></code> or negative error code</p>
<dl class="function">
<dt id="c.drm_dp_mst_allocate_vcpi">
bool <code class="sig-name descname">drm_dp_mst_allocate_vcpi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em>, int<em> pbn</em>, int<em> slots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_allocate_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a virtual channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to allocate a virtual channel for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>payload bandwidth number to request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">slots</span></code></dt><dd><p>returned number of slots for this PBN.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_mst_reset_vcpi_slots">
void <code class="sig-name descname">drm_dp_mst_reset_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_reset_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset number of slots to 0 for VCPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>unverified pointer to a port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This just resets the number of slots for the ports VCPI for later programming.</p>
<dl class="function">
<dt id="c.drm_dp_mst_deallocate_vcpi">
void <code class="sig-name descname">drm_dp_mst_deallocate_vcpi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_deallocate_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate a VCPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to deallocate vcpi for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called unconditionally, regardless of whether
<a class="reference internal" href="#c.drm_dp_mst_allocate_vcpi" title="drm_dp_mst_allocate_vcpi"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_allocate_vcpi()</span></code></a> succeeded or not.</p>
<dl class="function">
<dt id="c.drm_dp_check_act_status">
int <code class="sig-name descname">drm_dp_check_act_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_check_act_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Check ACT handled status.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the payload status bits in the DPCD for ACT handled completion.</p>
<dl class="function">
<dt id="c.drm_dp_calc_pbn_mode">
int <code class="sig-name descname">drm_dp_calc_pbn_mode</code><span class="sig-paren">(</span>int<em> clock</em>, int<em> bpp</em>, bool<em> dsc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_calc_pbn_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the PBN for a mode.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">clock</span></code></dt><dd><p>dot clock for the mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bpp</span></code></dt><dd><p>bpp for the mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">dsc</span></code></dt><dd><p>DSC mode. If true, bpp has units of 1/16 of a bit per pixel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This uses the formula in the spec to calculate the PBN value for a mode.</p>
<dl class="function">
<dt id="c.drm_dp_mst_dump_topology">
void <code class="sig-name descname">drm_dp_mst_dump_topology</code><span class="sig-paren">(</span>struct seq_file *<em> m</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_dump_topology" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt><dd><p>seq_file to dump output to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to dump current topology for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>helper to dump MST topology to a seq file for debugfs.</p>
<dl class="function">
<dt id="c.drm_dp_mst_add_affected_dsc_crtcs">
int <code class="sig-name descname">drm_dp_mst_add_affected_dsc_crtcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_add_affected_dsc_crtcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>Pointer to the new struct drm_dp_mst_topology_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>MST topology manager</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Whenever there is a change in mst topology
DSC configuration would have to be recalculated
therefore we need to trigger modeset on all affected
CRTCs in that topology</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_atomic_enable_dsc" title="drm_dp_mst_atomic_enable_dsc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_enable_dsc()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_enable_dsc">
int <code class="sig-name descname">drm_dp_mst_atomic_enable_dsc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em>, int<em> pbn</em>, int<em> pbn_div</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_enable_dsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set DSC Enable Flag to On/Off</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>Pointer to the new drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>Pointer to the affected MST Port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>Newly recalculated bw required for link with DSC enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn_div</span></code></dt><dd><p>Divider to calculate correct number of pbn per slot</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Boolean flag to enable or disable DSC on the port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables DSC on the given Port
by recalculating its vcpi from pbn provided
and sets dsc_enable flag to keep track of which
ports have DSC enabled</p>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_check">
int <code class="sig-name descname">drm_dp_mst_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the new state of an MST topology in an atomic update is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>Pointer to the new <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the given topology state for an atomic update to ensure that it’s
valid. This includes checking whether there’s enough bandwidth to support
the new VCPI allocations in the atomic update.</p>
<p>Any atomic drivers supporting DP MST must make sure to call this after
checking the rest of their state in their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check()</span></code></a> callback.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_find_vcpi_slots" title="drm_dp_atomic_find_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_vcpi_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_atomic_release_vcpi_slots" title="drm_dp_atomic_release_vcpi_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_vcpi_slots()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 if the new state is valid, negative error code otherwise.</p>
<dl class="function">
<dt id="c.drm_atomic_get_mst_topology_state">
struct drm_dp_mst_topology_state * <code class="sig-name descname">drm_atomic_get_mst_topology_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em> state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_mst_topology_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>MST topology manager, also the private object in this case</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps drm_atomic_get_priv_obj_state() passing in the MST atomic
state vtable so that the private object state returned is that of a MST
topology object. Also, <a class="reference internal" href="drm-kms.html#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a> expects the caller
to care of the locking, so warn if don’t hold the connection_mutex.</p>
<p><strong>Return</strong></p>
<p>The MST topology state or error pointer.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_init">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em> aux</em>, int<em> max_dpcd_transaction_bytes</em>, int<em> max_payloads</em>, int<em> conn_base_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a topology manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager struct to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device providing this structure - for i2c addition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt><dd><p>DP helper aux channel to talk to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_dpcd_transaction_bytes</span></code></dt><dd><p>hw specific DPCD transaction limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_payloads</span></code></dt><dd><p>maximum number of payloads this GPU can source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">conn_base_id</span></code></dt><dd><p>the connector object ID the MST device is connected to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, or negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_destroy">
void <code class="sig-name descname">drm_dp_mst_topology_mgr_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em> mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy topology manager.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt><dd><p>manager to destroy</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_mst_dsc_aux_for_port">
struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> * <code class="sig-name descname">drm_dp_mst_dsc_aux_for_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_dsc_aux_for_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the correct aux for DSC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The port to check. A leaf of the MST tree with an attached display.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Depending on the situation, DSC may be enabled via the endpoint aux,
the immediately upstream aux, or the connector’s physical aux.</p>
<p>This is both the correct aux to read DSC_CAPABILITY and the
correct aux to write DSC_ENABLED.</p>
<p>This operation can be expensive (up to four aux reads), so
the caller should cache the return.</p>
<p><strong>Return</strong></p>
<p>NULL if DSC cannot be enabled on this port, otherwise the aux device</p>
</div>
<div class="section" id="topology-lifetime-internals">
<h3>Topology Lifetime Internals<a class="headerlink" href="#topology-lifetime-internals" title="Permalink to this headline">¶</a></h3>
<p>These functions aren’t exported to drivers, but are documented here to help make
the MST topology helpers easier to understand</p>
<dl class="function">
<dt id="c.drm_dp_mst_get_mstb_malloc">
void <code class="sig-name descname">drm_dp_mst_get_mstb_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a> *<em> mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_mstb_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the malloc refcount of a branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*</span> <span class="pre">mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a>. When
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a> reaches 0, the memory allocation for <strong>mstb</strong>
will be released and <strong>mstb</strong> may no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_put_mstb_malloc" title="drm_dp_mst_put_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_mstb_malloc()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_put_mstb_malloc">
void <code class="sig-name descname">drm_dp_mst_put_mstb_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a> *<em> mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_put_mstb_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the malloc refcount of a branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*</span> <span class="pre">mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to decrement the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a>. When
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a> reaches 0, the memory allocation for <strong>mstb</strong>
will be released and <strong>mstb</strong> may no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_get_mstb_malloc" title="drm_dp_mst_get_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_mstb_malloc()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_try_get_mstb">
int <code class="sig-name descname">drm_dp_mst_topology_try_get_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a> *<em> mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_try_get_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a branch device unless it’s zero</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*</span> <span class="pre">mstb</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to grab a topology reference to <strong>mstb</strong>, if it hasn’t yet been
removed from the topology (e.g. <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_kref</span></code></a> has
reached 0). Holding a topology reference implies that a malloc reference
will be held to <strong>mstb</strong> as long as the user holds the topology reference.</p>
<p>Care should be taken to ensure that the user has at least one malloc
reference to <strong>mstb</strong>. If you already have a topology reference to <strong>mstb</strong>, you
should use <a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a> instead.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_mstb" title="drm_dp_mst_topology_put_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_mstb()</span></code></a></p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>1: A topology reference was grabbed successfully</p></li>
<li><p>0: <strong>port</strong> is no longer in the topology, no reference was grabbed</p></li>
</ul>
<dl class="function">
<dt id="c.drm_dp_mst_topology_get_mstb">
void <code class="sig-name descname">drm_dp_mst_topology_get_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a> *<em> mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_get_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*</span> <span class="pre">mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_refcount</span></code></a> without checking whether or
not it’s already reached 0. This is only valid to use in scenarios where
you are already guaranteed to have at least one active topology reference
to <strong>mstb</strong>. Otherwise, <a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a> must be used.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_mstb" title="drm_dp_mst_topology_put_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_mstb()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_put_mstb">
void <code class="sig-name descname">drm_dp_mst_topology_put_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a> *<em> mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_put_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>release a topology reference to a branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*</span> <span class="pre">mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to release the topology reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a topology reference from <strong>mstb</strong> by decrementing
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_kref</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_try_get_port">
int <code class="sig-name descname">drm_dp_mst_topology_try_get_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_try_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a port unless it’s zero</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to grab a topology reference to <strong>port</strong>, if it hasn’t yet been
removed from the topology (e.g. <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_kref</span></code></a> has reached
0). Holding a topology reference implies that a malloc reference will be
held to <strong>port</strong> as long as the user holds the topology reference.</p>
<p>Care should be taken to ensure that the user has at least one malloc
reference to <strong>port</strong>. If you already have a topology reference to <strong>port</strong>, you
should use <a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a> instead.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_port" title="drm_dp_mst_topology_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_port()</span></code></a></p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>1: A topology reference was grabbed successfully</p></li>
<li><p>0: <strong>port</strong> is no longer in the topology, no reference was grabbed</p></li>
</ul>
<dl class="function">
<dt id="c.drm_dp_mst_topology_get_port">
void <code class="sig-name descname">drm_dp_mst_topology_get_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_refcount</span></code></a> without checking whether or
not it’s already reached 0. This is only valid to use in scenarios where
you are already guaranteed to have at least one active topology reference
to <strong>port</strong>. Otherwise, <a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a> must be used.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_port" title="drm_dp_mst_topology_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_port()</span></code></a></p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_put_port">
void <code class="sig-name descname">drm_dp_mst_topology_put_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_put_port" title="Permalink to this definition">¶</a></dt>
<dd><p>release a topology reference to a port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to release the topology reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a topology reference from <strong>port</strong> by decrementing
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_kref</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a></p>
</div>
</div>
<div class="section" id="mipi-dbi-helper-functions-reference">
<h2>MIPI DBI Helper Functions Reference<a class="headerlink" href="#mipi-dbi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides helpers for MIPI Display Bus Interface (DBI)
compatible display controllers.</p>
<p>Many controllers for tiny lcd displays are MIPI compliant and can use this
library. If a controller uses registers 0x2A and 0x2B to set the area to
update and uses register 0x2C to write to frame memory, it is most likely
MIPI compliant.</p>
<p>Only MIPI Type 1 displays are supported since a full frame memory is needed.</p>
<p>There are 3 MIPI DBI implementation types:</p>
<ol class="upperalpha simple">
<li><p>Motorola 6800 type parallel bus</p></li>
<li><p>Intel 8080 type parallel bus</p></li>
<li><p>SPI type with 3 options:</p>
<ol class="arabic simple">
<li><p>9-bit with the Data/Command signal as the ninth bit</p></li>
<li><p>Same as above except it’s sent as 16 bits</p></li>
<li><p>8-bit with the Data/Command signal as a separate D/CX pin</p></li>
</ol>
</li>
</ol>
<p>Currently mipi_dbi only supports Type C options 1 and 3 with
<a class="reference internal" href="#c.mipi_dbi_spi_init" title="mipi_dbi_spi_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_spi_init()</span></code></a>.</p>
<dl class="type">
<dt id="c.mipi_dbi">
struct <code class="sig-name descname">mipi_dbi</code><a class="headerlink" href="#c.mipi_dbi" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI interface</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dbi {
  struct mutex cmdlock;
  int (*command)(struct mipi_dbi *dbi, u8 *cmd, u8 *param, size_t num);
  const u8 *read_commands;
  bool swap_bytes;
  struct gpio_desc *reset;
  struct spi_device *spi;
  struct gpio_desc *dc;
  void *tx_buf9;
  size_t tx_buf9_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmdlock</span></code></dt><dd><p>Command lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">command</span></code></dt><dd><p>Bus specific callback executing commands.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_commands</span></code></dt><dd><dl class="simple">
<dt>Array of read commands terminated by a zero entry.</dt><dd><p>Reading is disabled if this is NULL.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_bytes</span></code></dt><dd><p>Swap bytes in buffer before transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Optional reset gpio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dc</span></code></dt><dd><p>Optional D/C gpio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf9</span></code></dt><dd><p>Buffer used for Option 1 9-bit conversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf9_len</span></code></dt><dd><p>Size of tx_buf9.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dbi_dev">
struct <code class="sig-name descname">mipi_dbi_dev</code><a class="headerlink" href="#c.mipi_dbi_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dbi_dev {
  struct drm_device drm;
  struct drm_simple_display_pipe pipe;
  struct drm_connector connector;
  struct drm_display_mode mode;
  bool enabled;
  u16 *tx_buf;
  unsigned int rotation;
  unsigned int left_offset;
  unsigned int top_offset;
  struct backlight_device *backlight;
  struct regulator *regulator;
  struct mipi_dbi dbi;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p>Display pipe structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>Connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Fixed display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>Pipeline is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt><dd><p>Buffer used for transfer (copy clip rect area)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rotation</span></code></dt><dd><p>initial rotation in degrees Counter Clock Wise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">left_offset</span></code></dt><dd><dl class="simple">
<dt>Horizontal offset of the display relative to the</dt><dd><p>controller’s driver array</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_offset</span></code></dt><dd><dl class="simple">
<dt>Vertical offset of the display relative to the</dt><dd><p>controller’s driver array</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight</span></code></dt><dd><p>backlight device (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulator</span></code></dt><dd><p>power regulator (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbi</span></code></dt><dd><p>MIPI DBI interface</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dbi_command">
<code class="sig-name descname">mipi_dbi_command</code><span class="sig-paren">(</span><em>dbi</em>, <em>cmd</em>, <em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS command with optional parameter(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>Optional parameter(s)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send MIPI DCS command to the controller. Use <a class="reference internal" href="#c.mipi_dbi_command_read" title="mipi_dbi_command_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_command_read()</span></code></a> for
get/read.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_command_read">
int <code class="sig-name descname">mipi_dbi_command_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a> *<em> dbi</em>, u8<em> cmd</em>, u8 *<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command_read" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS read command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*</span> <span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">val</span></code></dt><dd><p>Value read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send MIPI DCS read command to the controller.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_command_buf">
int <code class="sig-name descname">mipi_dbi_command_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a> *<em> dbi</em>, u8<em> cmd</em>, u8 *<em> data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS command with parameter(s) in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*</span> <span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>Parameter buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Buffer length</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_buf_copy">
int <code class="sig-name descname">mipi_dbi_buf_copy</code><span class="sig-paren">(</span>void *<em> dst</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em>, bool<em> swap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_buf_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a framebuffer, transforming it if necessary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>The destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>The source framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>Clipping rectangle of the area to be copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">swap</span></code></dt><dd><p>When true, swap MSB/LSB of 16-bit values</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_pipe_update">
void <code class="sig-name descname">mipi_dbi_pipe_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em> pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_pipe_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Display pipe update helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>Simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt><dd><p>Old plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles framebuffer flushing and vblank events. Drivers can use
this as their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;update</span></code></a> callback.</p>
<dl class="function">
<dt id="c.mipi_dbi_enable_flush">
void <code class="sig-name descname">mipi_dbi_enable_flush</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a> *<em> dbidev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em> crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em> plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_enable_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI enable helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*</span> <span class="pre">dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">crtc_state</span></code></dt><dd><p>CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt><dd><p>Plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;enabled</span></code></a>, flushes the whole framebuffer and
enables the backlight. Drivers can use this in their
<a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;enable</span></code></a> callback.</p>
<p><strong>Note</strong></p>
<p>Drivers which don’t use <a class="reference internal" href="#c.mipi_dbi_pipe_update" title="mipi_dbi_pipe_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_pipe_update()</span></code></a> because they have custom
framebuffer flushing, can’t use this function since they both use the same
flushing code.</p>
<dl class="function">
<dt id="c.mipi_dbi_pipe_disable">
void <code class="sig-name descname">mipi_dbi_pipe_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em> pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_pipe_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI pipe disable helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt><dd><p>Display pipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables backlight if present, if not the display memory is
blanked. The regulator is disabled if in use. Drivers can use this as their
<a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;disable</span></code></a> callback.</p>
<dl class="function">
<dt id="c.mipi_dbi_dev_init_with_formats">
int <code class="sig-name descname">mipi_dbi_dev_init_with_formats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a> *<em> dbidev</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a> *<em> funcs</em>, const uint32_t *<em> formats</em>, unsigned int<em> format_count</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, unsigned int<em> rotation</em>, size_t<em> tx_buf_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_dev_init_with_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device initialization with custom formats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*</span> <span class="pre">dbidev</span></code></dt><dd><p>MIPI DBI device structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>Display pipe functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt><dd><p>Array of supported formats (DRM_FORMAT_*).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>Number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>Display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Initial rotation in degrees Counter Clock Wise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">tx_buf_size</span></code></dt><dd><p>Allocate a transmit buffer of this size.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up a <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a> with a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that
has one fixed <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> which is rotated according to <strong>rotation</strong>.
This mode is used to set the mode config min/max width/height properties.</p>
<p>Use <a class="reference internal" href="#c.mipi_dbi_dev_init" title="mipi_dbi_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_dev_init()</span></code></a> if you don’t need custom formats.</p>
<p><strong>Note</strong></p>
<p>Some of the helper functions expects RGB565 to be the default format and the
transmit buffer sized to fit that.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_dev_init">
int <code class="sig-name descname">mipi_dbi_dev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a> *<em> dbidev</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a> *<em> funcs</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_dev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*</span> <span class="pre">dbidev</span></code></dt><dd><p>MIPI DBI device structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>Display pipe functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>Display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Initial rotation in degrees Counter Clock Wise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up a <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a> with a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that
has one fixed <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> which is rotated according to <strong>rotation</strong>.
This mode is used to set the mode config min/max width/height properties.
Additionally <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi.tx_buf</span></code></a> is allocated.</p>
<p>Supported formats: Native RGB565 and emulated XRGB8888.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_release">
void <code class="sig-name descname">mipi_dbi_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> drm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_release" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver release helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function finalizes and frees <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi</span></code></a>.</p>
<p>Drivers can use this as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;release</span></code></a> callback.</p>
<dl class="function">
<dt id="c.mipi_dbi_hw_reset">
void <code class="sig-name descname">mipi_dbi_hw_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a> *<em> dbi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_hw_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Hardware reset of controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*</span> <span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset controller if the <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;reset</span></code></a> gpio is set.</p>
<dl class="function">
<dt id="c.mipi_dbi_display_is_on">
bool <code class="sig-name descname">mipi_dbi_display_is_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a> *<em> dbi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_display_is_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if display is on</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*</span> <span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks the Power Mode register (if readable) to see if
display output is turned on. This can be used to see if the bootloader
has already turned on the display avoiding flicker when the pipeline is
enabled.</p>
<p><strong>Return</strong></p>
<p>true if the display can be verified to be on, false otherwise.</p>
<dl class="function">
<dt id="c.mipi_dbi_poweron_reset">
int <code class="sig-name descname">mipi_dbi_poweron_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a> *<em> dbidev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_poweron_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI poweron and reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*</span> <span class="pre">dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the regulator if used and does a hardware and software
reset.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or a negative error code.</p>
<dl class="function">
<dt id="c.mipi_dbi_poweron_conditional_reset">
int <code class="sig-name descname">mipi_dbi_poweron_conditional_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a> *<em> dbidev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_poweron_conditional_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI poweron and conditional reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*</span> <span class="pre">dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the regulator if used and if the display is off, it
does a hardware and software reset. If <a class="reference internal" href="#c.mipi_dbi_display_is_on" title="mipi_dbi_display_is_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_display_is_on()</span></code></a> determines
that the display is on, no reset is performed.</p>
<p><strong>Return</strong></p>
<p>Zero if the controller was reset, 1 if the display was already on, or a
negative error code.</p>
<dl class="function">
<dt id="c.mipi_dbi_spi_cmd_max_speed">
u32 <code class="sig-name descname">mipi_dbi_spi_cmd_max_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a> *<em> spi</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_cmd_max_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>get the maximum SPI bus speed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The transfer buffer length.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many controllers have a max speed of 10MHz, but can be pushed way beyond
that. Increase reliability by running pixel data at max speed and the rest
at 10MHz, preventing transfer glitches from messing up the init settings.</p>
<dl class="function">
<dt id="c.mipi_dbi_spi_init">
int <code class="sig-name descname">mipi_dbi_spi_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a> *<em> spi</em>, struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a> *<em> dbi</em>, struct gpio_desc *<em> dc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize MIPI DBI SPI interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*</span> <span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">dc</span></code></dt><dd><p>D/C gpio (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;command</span></code></a>, enables <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;read_commands</span></code></a> for the
usual read commands. It should be followed by a call to <a class="reference internal" href="#c.mipi_dbi_dev_init" title="mipi_dbi_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_dev_init()</span></code></a> or
a driver-specific init.</p>
<p>If <strong>dc</strong> is set, a Type C Option 3 interface is assumed, if not
Type C Option 1.</p>
<p>If the SPI master driver doesn’t support the necessary bits per word,
the following transformation is used:</p>
<ul class="simple">
<li><p>9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.</p></li>
<li><p>16-bit: if big endian send as 8-bit, if little endian swap bytes</p></li>
</ul>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_spi_transfer">
int <code class="sig-name descname">mipi_dbi_spi_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a> *<em> spi</em>, u32<em> speed_hz</em>, u8<em> bpw</em>, const void *<em> buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI transfer helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">speed_hz</span></code></dt><dd><p>Override speed (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">bpw</span></code></dt><dd><p>Bits per word</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Buffer to transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Buffer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This SPI transfer helper breaks up the transfer of <strong>buf</strong> into chunks which
the SPI controller driver can handle.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dbi_debugfs_init">
int <code class="sig-name descname">mipi_dbi_debugfs_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor">drm_minor</a> *<em> minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_debugfs_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Create debugfs entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*</span> <span class="pre">minor</span></code></dt><dd><p>DRM minor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a ‘command’ debugfs file for sending commands to the
controller or getting the read command values.
Drivers can use this as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;debugfs_init</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<div class="section" id="mipi-dsi-helper-functions-reference">
<h2>MIPI DSI Helper Functions Reference<a class="headerlink" href="#mipi-dsi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers to deal with MIPI DSI
peripherals.</p>
<p>Helpers are provided for a number of standard MIPI DSI command as well as a
subset of the MIPI DCS command set.</p>
<dl class="type">
<dt id="c.mipi_dsi_msg">
struct <code class="sig-name descname">mipi_dsi_msg</code><a class="headerlink" href="#c.mipi_dsi_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write DSI buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_msg {
  u8 channel;
  u8 type;
  u16 flags;
  size_t tx_len;
  const void *tx_buf;
  size_t rx_len;
  void *rx_buf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>virtual channel id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>payload data type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags controlling this message transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_len</span></code></dt><dd><p>length of <strong>tx_buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt><dd><p>data to be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_len</span></code></dt><dd><p>length of <strong>rx_buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_buf</span></code></dt><dd><p>data to be read, or NULL</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_packet">
struct <code class="sig-name descname">mipi_dsi_packet</code><a class="headerlink" href="#c.mipi_dsi_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a MIPI DSI packet in protocol format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_packet {
  size_t size;
  u8 header[4];
  size_t payload_length;
  const u8 *payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size (in bytes) of the packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt><dd><p>the four bytes that make up the header (Data ID, Word Count or
Packet Data, and ECC)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_length</span></code></dt><dd><p>number of bytes in the payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload</span></code></dt><dd><p>a pointer to a buffer containing the payload, if any</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_host_ops">
struct <code class="sig-name descname">mipi_dsi_host_ops</code><a class="headerlink" href="#c.mipi_dsi_host_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI bus operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_host_ops {
  int (*attach)(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
  int (*detach)(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
  ssize_t (*transfer)(struct mipi_dsi_host *host, const struct mipi_dsi_msg *msg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>attach DSI device to DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>detach DSI device from DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt><dd><p>transmit a DSI packet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DSI packets transmitted by .transfer() are passed in as mipi_dsi_msg
structures. This structure contains information about the type of packet
being transmitted as well as the transmit and receive buffers. When an
error is encountered during transmission, this function will return a
negative error code. On success it shall return the number of bytes
transmitted for write packets or the number of bytes received for read
packets.</p>
<p>Note that typically DSI packet transmission is atomic, so the .transfer()
function will seldomly return anything other than the number of bytes
contained in the transmit buffer on success.</p>
<dl class="type">
<dt id="c.mipi_dsi_host">
struct <code class="sig-name descname">mipi_dsi_host</code><a class="headerlink" href="#c.mipi_dsi_host" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI host device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_host {
  struct device *dev;
  const struct mipi_dsi_host_ops *ops;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model device node for this DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>DSI host operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list management</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_device_info">
struct <code class="sig-name descname">mipi_dsi_device_info</code><a class="headerlink" href="#c.mipi_dsi_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for creating a mipi_dsi_device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_device_info {
  char type[DSI_DEV_NAME_SIZE];
  u32 channel;
  struct device_node *node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>DSI peripheral chip type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>DSI virtual channel assigned to peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>pointer to OF device node or NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is populated and passed to mipi_dsi_device_new to create a new
DSI device</p>
<dl class="type">
<dt id="c.mipi_dsi_device">
struct <code class="sig-name descname">mipi_dsi_device</code><a class="headerlink" href="#c.mipi_dsi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI peripheral device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_device {
  struct mipi_dsi_host *host;
  struct device dev;
  char name[DSI_DEV_NAME_SIZE];
  unsigned int channel;
  unsigned int lanes;
  enum mipi_dsi_pixel_format format;
  unsigned long mode_flags;
  unsigned long hs_rate;
  unsigned long lp_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">host</span></code></dt><dd><p>DSI host for this peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model device node for this peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>DSI peripheral chip type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>virtual channel assigned to the peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lanes</span></code></dt><dd><p>number of active data lanes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>pixel format for video mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_flags</span></code></dt><dd><p>DSI operation mode related flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hs_rate</span></code></dt><dd><p>maximum lane frequency for high speed mode in hertz, this should
be set to the real limits of the hardware, zero is only accepted for
legacy drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lp_rate</span></code></dt><dd><p>maximum lane frequency for low power mode in hertz, this should
be set to the real limits of the hardware, zero is only accepted for
legacy drivers</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_pixel_format_to_bpp">
int <code class="sig-name descname">mipi_dsi_pixel_format_to_bpp</code><span class="sig-paren">(</span>enum mipi_dsi_pixel_format<em> fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_pixel_format_to_bpp" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the number of bits per pixel for any given pixel format defined by the MIPI DSI specification</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mipi_dsi_pixel_format</span> <span class="pre">fmt</span></code></dt><dd><p>MIPI DSI pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits per pixel of the given pixel format.</p>
<dl class="type">
<dt id="c.mipi_dsi_dcs_tear_mode">
enum <code class="sig-name descname">mipi_dsi_dcs_tear_mode</code><a class="headerlink" href="#c.mipi_dsi_dcs_tear_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Tearing Effect Output Line mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VBLANK</span></code></dt><dd><p>the TE output line consists of V-Blanking
information only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VHBLANK</span></code></dt><dd><p>the TE output line consists of both
V-Blanking and H-Blanking information</p>
</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_driver">
struct <code class="sig-name descname">mipi_dsi_driver</code><a class="headerlink" href="#c.mipi_dsi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_driver {
  struct device_driver driver;
  int(*probe)(struct mipi_dsi_device *dsi);
  int(*remove)(struct mipi_dsi_device *dsi);
  void (*shutdown)(struct mipi_dsi_device *dsi);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>device driver model driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>callback for device binding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>callback for device unbinding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>called at shutdown time to quiesce the device</p>
</dd>
</dl>
<dl class="function">
<dt id="c.of_find_mipi_dsi_device_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="sig-name descname">of_find_mipi_dsi_device_by_node</code><span class="sig-paren">(</span>struct device_node *<em> np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_device_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI device matching a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>device tree node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>A pointer to the MIPI DSI device corresponding to <strong>np</strong> or NULL if no</dt><dd><p>such device exists (or has not been registered yet).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_device_register_full">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="sig-name descname">mipi_dsi_device_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a> *<em> host</em>, const struct <a class="reference internal" href="#c.mipi_dsi_device_info" title="mipi_dsi_device_info">mipi_dsi_device_info</a> *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>create a MIPI DSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>DSI host to which this device is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_device_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>pointer to template containing DSI device information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a MIPI DSI device by using the device information provided by
mipi_dsi_device_info template</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created MIPI DSI device, or, a pointer encoded
with an error</p>
<dl class="function">
<dt id="c.mipi_dsi_device_unregister">
void <code class="sig-name descname">mipi_dsi_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister MIPI DSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<dl class="function">
<dt id="c.of_find_mipi_dsi_host_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a> * <code class="sig-name descname">of_find_mipi_dsi_host_by_node</code><span class="sig-paren">(</span>struct device_node *<em> node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_host_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI host matching a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt><dd><p>device tree node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the MIPI DSI host corresponding to <strong>node</strong> or NULL if no
such device exists (or has not been registered yet).</p>
<dl class="function">
<dt id="c.mipi_dsi_attach">
int <code class="sig-name descname">mipi_dsi_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a DSI device to its DSI host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_detach">
int <code class="sig-name descname">mipi_dsi_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a DSI device from its DSI host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_short">
bool <code class="sig-name descname">mipi_dsi_packet_format_is_short</code><span class="sig-paren">(</span>u8<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_short" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the short format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt><dd><p>MIPI DSI data type of the packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a short packet, false
otherwise.</p>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_long">
bool <code class="sig-name descname">mipi_dsi_packet_format_is_long</code><span class="sig-paren">(</span>u8<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_long" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the long format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt><dd><p>MIPI DSI data type of the packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a long packet, false
otherwise.</p>
<dl class="function">
<dt id="c.mipi_dsi_create_packet">
int <code class="sig-name descname">mipi_dsi_create_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_packet" title="mipi_dsi_packet">mipi_dsi_packet</a> *<em> packet</em>, const struct <a class="reference internal" href="#c.mipi_dsi_msg" title="mipi_dsi_msg">mipi_dsi_msg</a> *<em> msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_create_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>create a packet from a message according to the DSI protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_packet</span> <span class="pre">*</span> <span class="pre">packet</span></code></dt><dd><p>pointer to a DSI packet structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>message to translate into a packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_shutdown_peripheral">
int <code class="sig-name descname">mipi_dsi_shutdown_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_shutdown_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Shutdown Peripheral command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_turn_on_peripheral">
int <code class="sig-name descname">mipi_dsi_turn_on_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_turn_on_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Turn On Peripheral command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_compression_mode">
ssize_t <code class="sig-name descname">mipi_dsi_compression_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_compression_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable DSC on the peripheral</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Whether to enable or disable the DSC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable or disable Display Stream Compression on the peripheral using the
default Picture Parameter Set and VESA DSC 1.1 algorithm.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_picture_parameter_set">
ssize_t <code class="sig-name descname">mipi_dsi_picture_parameter_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, const struct <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set">drm_dsc_picture_parameter_set</a> *<em> pps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_picture_parameter_set" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit the DSC PPS to the peripheral</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span> <span class="pre">*</span> <span class="pre">pps</span></code></dt><dd><p>VESA DSC 1.1 Picture Parameter Set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transmit the VESA DSC 1.1 Picture Parameter Set to the peripheral.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_generic_write">
ssize_t <code class="sig-name descname">mipi_dsi_generic_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, const void *<em> payload</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_write" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit data using a generic write packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">payload</span></code></dt><dd><p>buffer containing the payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of payload buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes transmitted on success or a negative error code
on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_generic_read">
ssize_t <code class="sig-name descname">mipi_dsi_generic_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, const void *<em> params</em>, size_t<em> num_params</em>, void *<em> data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_read" title="Permalink to this definition">¶</a></dt>
<dd><p>receive data using a generic read packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>buffer containing the request parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num_params</span></code></dt><dd><p>number of request parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>buffer in which to return the received data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of receive buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the number of parameters passed in.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully read or a negative error code on
failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write_buffer">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_write_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, const void *<em> data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit a DCS command with payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>buffer containing data to be transmitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of transmission buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u8<em> cmd</em>, const void *<em> data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS write command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>DCS command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>buffer containing the command payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>command payload length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_read">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u8<em> cmd</em>, void *<em> data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_read" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS read request command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>DCS command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>buffer in which to receive data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of receive buffer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes read or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_nop">
int <code class="sig-name descname">mipi_dsi_dcs_nop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_nop" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS nop packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_soft_reset">
int <code class="sig-name descname">mipi_dsi_dcs_soft_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a software reset of the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_power_mode">
int <code class="sig-name descname">mipi_dsi_dcs_get_power_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u8 *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_power_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>query the display module’s current power mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>return location for the current power mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_pixel_format">
int <code class="sig-name descname">mipi_dsi_dcs_get_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u8 *<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">format</span></code></dt><dd><p>return location for the pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_enter_sleep_mode">
int <code class="sig-name descname">mipi_dsi_dcs_enter_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_enter_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all unnecessary blocks inside the display module except interface communication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_exit_sleep_mode">
int <code class="sig-name descname">mipi_dsi_dcs_exit_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_exit_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>enable all blocks inside the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_off">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_off" title="Permalink to this definition">¶</a></dt>
<dd><p>stop displaying the image data on the display device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_on">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_on" title="Permalink to this definition">¶</a></dt>
<dd><p>start displaying the image data on the display device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_column_address">
int <code class="sig-name descname">mipi_dsi_dcs_set_column_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u16<em> start</em>, u16<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_column_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the column extent of the frame memory accessed by the host processor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>first column of frame memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">end</span></code></dt><dd><p>last column of frame memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_page_address">
int <code class="sig-name descname">mipi_dsi_dcs_set_page_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u16<em> start</em>, u16<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_page_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the page extent of the frame memory accessed by the host processor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>first page of frame memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">end</span></code></dt><dd><p>last page of frame memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_off">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_off" title="Permalink to this definition">¶</a></dt>
<dd><p>turn off the display module’s Tearing Effect output signal on the TE signal line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_on">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, enum <a class="reference internal" href="#c.mipi_dsi_dcs_tear_mode" title="mipi_dsi_dcs_tear_mode">mipi_dsi_dcs_tear_mode</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_on" title="Permalink to this definition">¶</a></dt>
<dd><p>turn on the display module’s Tearing Effect output signal on the TE signal line.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mipi_dsi_dcs_tear_mode</span> <span class="pre">mode</span></code></dt><dd><p>the Tearing Effect Output Line mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_pixel_format">
int <code class="sig-name descname">mipi_dsi_dcs_set_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u8<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">format</span></code></dt><dd><p>pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_scanline">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_scanline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u16<em> scanline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_scanline" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scanline to use as trigger for the Tearing Effect output signal of the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">scanline</span></code></dt><dd><p>scanline to use as trigger</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_brightness">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u16<em> brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the brightness value of the display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">brightness</span></code></dt><dd><p>brightness value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_display_brightness">
int <code class="sig-name descname">mipi_dsi_dcs_get_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em> dsi</em>, u16 *<em> brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the current brightness value of the display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">brightness</span></code></dt><dd><p>brightness value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_driver_register_full">
int <code class="sig-name descname">mipi_dsi_driver_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a> *<em> drv</em>, struct module *<em> owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver for DSI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt><dd><p>DSI driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt><dd><p>owner module</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_driver_unregister">
void <code class="sig-name descname">mipi_dsi_driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a> *<em> drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a driver for DSI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt><dd><p>DSI driver structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="display-stream-compression-helper-functions-reference">
<h2>Display Stream Compression Helper Functions Reference<a class="headerlink" href="#display-stream-compression-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>VESA specification for DP 1.4 adds a new feature called Display Stream
Compression (DSC) used to compress the pixel bits before sending it on
DP/eDP/MIPI DSI interface. DSC is required to be enabled so that the existing
display interfaces can support high resolutions at higher frames rates uisng
the maximum available link capacity of these interfaces.</p>
<p>These functions contain some common logic and helpers to deal with VESA
Display Stream Compression standard required for DSC on Display Port/eDP or
MIPI display interfaces.</p>
<dl class="type">
<dt id="c.drm_dsc_rc_range_parameters">
struct <code class="sig-name descname">drm_dsc_rc_range_parameters</code><a class="headerlink" href="#c.drm_dsc_rc_range_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>DSC Rate Control range parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_rc_range_parameters {
  u8 range_min_qp;
  u8 range_max_qp;
  u8 range_bpg_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">range_min_qp</span></code></dt><dd><p>Min Quantization Parameters allowed for this range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range_max_qp</span></code></dt><dd><p>Max Quantization Parameters allowed for this range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range_bpg_offset</span></code></dt><dd><p>Bits/group offset to apply to target for this group</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This defines different rate control parameters used by the DSC engine
to compress the frame.</p>
<dl class="type">
<dt id="c.drm_dsc_config">
struct <code class="sig-name descname">drm_dsc_config</code><a class="headerlink" href="#c.drm_dsc_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters required to configure DSC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_config {
  u8 line_buf_depth;
  u8 bits_per_component;
  bool convert_rgb;
  u8 slice_count;
  u16 slice_width;
  u16 slice_height;
  bool simple_422;
  u16 pic_width;
  u16 pic_height;
  u8 rc_tgt_offset_high;
  u8 rc_tgt_offset_low;
  u16 bits_per_pixel;
  u8 rc_edge_factor;
  u8 rc_quant_incr_limit1;
  u8 rc_quant_incr_limit0;
  u16 initial_xmit_delay;
  u16 initial_dec_delay;
  bool block_pred_enable;
  u8 first_line_bpg_offset;
  u16 initial_offset;
  u16 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
  struct drm_dsc_rc_range_parameters rc_range_params[DSC_NUM_BUF_RANGES];
  u16 rc_model_size;
  u8 flatness_min_qp;
  u8 flatness_max_qp;
  u8 initial_scale_value;
  u16 scale_decrement_interval;
  u16 scale_increment_interval;
  u16 nfl_bpg_offset;
  u16 slice_bpg_offset;
  u16 final_offset;
  bool vbr_enable;
  u8 mux_word_size;
  u16 slice_chunk_size;
  u16 rc_bits;
  u8 dsc_version_minor;
  u8 dsc_version_major;
  bool native_422;
  bool native_420;
  u8 second_line_bpg_offset;
  u16 nsl_bpg_offset;
  u16 second_line_offset_adj;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">line_buf_depth</span></code></dt><dd><p>Bits per component for previous reconstructed line buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_component</span></code></dt><dd><p>Bits per component to code (8/10/12)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">convert_rgb</span></code></dt><dd><p>Flag to indicate if RGB - YCoCg conversion is needed
True if RGB input, False if YCoCg input</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_count</span></code></dt><dd><p>Number fo slices per line used by the DSC encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_width</span></code></dt><dd><p>Width of each slice in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_height</span></code></dt><dd><p>Slice height in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simple_422</span></code></dt><dd><p>True if simple 4_2_2 mode is enabled else False</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_width</span></code></dt><dd><p>Width of the input display frame in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_height</span></code></dt><dd><p>Vertical height of the input display frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset_high</span></code></dt><dd><p>Offset to bits/group used by RC to determine QP adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset_low</span></code></dt><dd><p>Offset to bits/group used by RC to determine QP adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_pixel</span></code></dt><dd><p>Target bits per pixel with 4 fractional bits, bits_per_pixel &lt;&lt; 4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_edge_factor</span></code></dt><dd><p>Factor to determine if an edge is present based on the bits produced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit1</span></code></dt><dd><p>Slow down incrementing once the range reaches this value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit0</span></code></dt><dd><p>Slow down incrementing once the range reaches this value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay</span></code></dt><dd><p>Number of pixels to delay the initial transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_dec_delay</span></code></dt><dd><p>Initial decoder delay, number of pixel times that the decoder
accumulates data in its rate buffer before starting to decode
and output pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_pred_enable</span></code></dt><dd><p>True if block prediction is used to code any groups within the
picture. False if BP not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_line_bpg_offset</span></code></dt><dd><p>Number of additional bits allocated for each group on the first
line of slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_offset</span></code></dt><dd><p>Value to use for RC model offset at slice start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_buf_thresh</span></code></dt><dd><p>Thresholds defining each of the buffer ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_range_params</span></code></dt><dd><p>Parameters for each of the RC ranges defined in
<a class="reference internal" href="#c.drm_dsc_rc_range_parameters" title="drm_dsc_rc_range_parameters"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_rc_range_parameters</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_model_size</span></code></dt><dd><p>Total size of RC model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_min_qp</span></code></dt><dd><p>Minimum QP where flatness information is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_max_qp</span></code></dt><dd><p>Maximum QP where flatness information is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_scale_value</span></code></dt><dd><p>Initial value for the scale factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval</span></code></dt><dd><p>Specifies number of group times between decrementing the scale factor
at beginning of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_increment_interval</span></code></dt><dd><p>Number of group times between incrementing the scale factor value
used at the beginning of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nfl_bpg_offset</span></code></dt><dd><p>Non first line BPG offset to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_bpg_offset</span></code></dt><dd><p>BPG offset used to enforce slice bit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">final_offset</span></code></dt><dd><p>Final RC linear transformation offset value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vbr_enable</span></code></dt><dd><p>True if VBR mode is enabled, false if disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_word_size</span></code></dt><dd><p>Mux word size (in bits) for SSM mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_chunk_size</span></code></dt><dd><p>The (max) size in bytes of the “chunks” that are used in slice
multiplexing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_bits</span></code></dt><dd><p>Rate control buffer size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version_minor</span></code></dt><dd><p>DSC minor version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version_major</span></code></dt><dd><p>DSC major version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_422</span></code></dt><dd><p>True if Native 4:2:2 supported, else false</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_420</span></code></dt><dd><p>True if Native 4:2:0 supported else false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_bpg_offset</span></code></dt><dd><p>Additional bits/grp for seconnd line of slice for native 4:2:0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nsl_bpg_offset</span></code></dt><dd><p>Num of bits deallocated for each grp that is not in second line of
slice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_offset_adj</span></code></dt><dd><p>Offset adjustment for second line in Native 4:2:0 mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver populates this structure with all the parameters required
to configure the display stream compression on the source.</p>
<dl class="type">
<dt id="c.drm_dsc_picture_parameter_set">
struct <code class="sig-name descname">drm_dsc_picture_parameter_set</code><a class="headerlink" href="#c.drm_dsc_picture_parameter_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents 128 bytes of Picture Parameter Set</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_picture_parameter_set {
  u8 dsc_version;
  u8 pps_identifier;
  u8 pps_reserved;
  u8 pps_3;
  u8 pps_4;
  u8 bits_per_pixel_low;
  __be16 pic_height;
  __be16 pic_width;
  __be16 slice_height;
  __be16 slice_width;
  __be16 chunk_size;
  u8 initial_xmit_delay_high;
  u8 initial_xmit_delay_low;
  __be16 initial_dec_delay;
  u8 pps20_reserved;
  u8 initial_scale_value;
  __be16 scale_increment_interval;
  u8 scale_decrement_interval_high;
  u8 scale_decrement_interval_low;
  u8 pps26_reserved;
  u8 first_line_bpg_offset;
  __be16 nfl_bpg_offset;
  __be16 slice_bpg_offset;
  __be16 initial_offset;
  __be16 final_offset;
  u8 flatness_min_qp;
  u8 flatness_max_qp;
  __be16 rc_model_size;
  u8 rc_edge_factor;
  u8 rc_quant_incr_limit0;
  u8 rc_quant_incr_limit1;
  u8 rc_tgt_offset;
  u8 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
  __be16 rc_range_parameters[DSC_NUM_BUF_RANGES];
  u8 native_422_420;
  u8 second_line_bpg_offset;
  __be16 nsl_bpg_offset;
  __be16 second_line_offset_adj;
  u32 pps_long_94_reserved;
  u32 pps_long_98_reserved;
  u32 pps_long_102_reserved;
  u32 pps_long_106_reserved;
  u32 pps_long_110_reserved;
  u32 pps_long_114_reserved;
  u32 pps_long_118_reserved;
  u32 pps_long_122_reserved;
  __be16 pps_short_126_reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version</span></code></dt><dd><p>PPS0[3:0] - dsc_version_minor: Contains Minor version of DSC
PPS0[7:4] - dsc_version_major: Contains major version of DSC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_identifier</span></code></dt><dd><p>PPS1[7:0] - Application specific identifier that can be
used to differentiate between different PPS tables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_reserved</span></code></dt><dd><p>PPS2[7:0]- RESERVED Byte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_3</span></code></dt><dd><p>PPS3[3:0] - linebuf_depth: Contains linebuffer bit depth used to
generate the bitstream. (0x0 - 16 bits for DSC 1.2, 0x8 - 8 bits,
0xA - 10 bits, 0xB - 11 bits, 0xC - 12 bits, 0xD - 13 bits,
0xE - 14 bits for DSC1.2, 0xF - 14 bits for DSC 1.2.
PPS3[7:4] - bits_per_component: Bits per component for the original
pixels of the encoded picture.
0x0 = 16bpc (allowed only when dsc_version_minor = 0x2)
0x8 = 8bpc, 0xA = 10bpc, 0xC = 12bpc, 0xE = 14bpc (also
allowed only when dsc_minor_version = 0x2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_4</span></code></dt><dd><p>PPS4[1:0] -These are the most significant 2 bits of
compressed BPP bits_per_pixel[9:0] syntax element.
PPS4[2] - vbr_enable: 0 = VBR disabled, 1 = VBR enabled
PPS4[3] - simple_422: Indicates if decoder drops samples to
reconstruct the 4:2:2 picture.
PPS4[4] - Convert_rgb: Indicates if DSC color space conversion is
active.
PPS4[5] - blobk_pred_enable: Indicates if BP is used to code any
groups in picture
PPS4[7:6] - Reseved bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_pixel_low</span></code></dt><dd><p>PPS5[7:0] - This indicates the lower significant 8 bits of
the compressed BPP bits_per_pixel[9:0] element.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_height</span></code></dt><dd><p>PPS6[7:0], PPS7[7:0] -pic_height: Specifies the number of pixel rows
within the raster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_width</span></code></dt><dd><p>PPS8[7:0], PPS9[7:0] - pic_width: Number of pixel columns within
the raster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_height</span></code></dt><dd><p>PPS10[7:0], PPS11[7:0] - Slice height in units of pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_width</span></code></dt><dd><p>PPS12[7:0], PPS13[7:0] - Slice width in terms of pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code></dt><dd><p>PPS14[7:0], PPS15[7:0] - Size in units of bytes of the chunks
that are used for slice multiplexing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay_high</span></code></dt><dd><p>PPS16[1:0] - Most Significant two bits of initial transmission delay.
It specifies the number of pixel times that the encoder waits before
transmitting data from its rate buffer.
PPS16[7:2] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay_low</span></code></dt><dd><p>PPS17[7:0] - Least significant 8 bits of initial transmission delay.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_dec_delay</span></code></dt><dd><p>PPS18[7:0], PPS19[7:0] - Initial decoding delay which is the number
of pixel times that the decoder accumulates data in its rate buffer
before starting to decode and output pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps20_reserved</span></code></dt><dd><p>PPS20[7:0] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_scale_value</span></code></dt><dd><p>PPS21[5:0] - Initial rcXformScale factor used at beginning
of a slice.
PPS21[7:6] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_increment_interval</span></code></dt><dd><p>PPS22[7:0], PPS23[7:0] - Number of group times between incrementing
the rcXformScale factor at end of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval_high</span></code></dt><dd><p>PPS24[3:0] - Higher 4 bits indicating number of group times between
decrementing the rcXformScale factor at beginning of a slice.
PPS24[7:4] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval_low</span></code></dt><dd><p>PPS25[7:0] - Lower 8 bits of scale decrement interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps26_reserved</span></code></dt><dd><p>PPS26[7:0]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_line_bpg_offset</span></code></dt><dd><p>PPS27[4:0] - Number of additional bits that are allocated
for each group on first line of a slice.
PPS27[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nfl_bpg_offset</span></code></dt><dd><p>PPS28[7:0], PPS29[7:0] - Number of bits including frac bits
deallocated for each group for groups after the first line of slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_bpg_offset</span></code></dt><dd><p>PPS30, PPS31[7:0] - Number of bits that are deallocated for each
group to enforce the slice constraint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_offset</span></code></dt><dd><p>PPS32,33[7:0] - Initial value for rcXformOffset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">final_offset</span></code></dt><dd><p>PPS34,35[7:0] - Maximum end-of-slice value for rcXformOffset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_min_qp</span></code></dt><dd><p>PPS36[4:0] - Minimum QP at which flatness is signaled and
flatness QP adjustment is made.
PPS36[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_max_qp</span></code></dt><dd><p>PPS37[4:0] - Max QP at which flatness is signalled and
the flatness adjustment is made.
PPS37[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_model_size</span></code></dt><dd><p>PPS38,39[7:0] - Number of bits within RC Model.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_edge_factor</span></code></dt><dd><p>PPS40[3:0] - Ratio of current activity vs, previous
activity to determine presence of edge.
PPS40[7:4] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit0</span></code></dt><dd><p>PPS41[4:0] - QP threshold used in short term RC
PPS41[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit1</span></code></dt><dd><p>PPS42[4:0] - QP threshold used in short term RC
PPS42[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset</span></code></dt><dd><p>PPS43[3:0] - Lower end of the variability range around the target
bits per group that is allowed by short term RC.
PPS43[7:4]- Upper end of the variability range around the target
bits per group that i allowed by short term rc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_buf_thresh</span></code></dt><dd><p>PPS44[7:0] - PPS57[7:0] - Specifies the thresholds in RC model for
the 15 ranges defined by 14 thresholds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_range_parameters</span></code></dt><dd><p>PPS58[7:0] - PPS87[7:0]
Parameters that correspond to each of the 15 ranges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_422_420</span></code></dt><dd><p>PPS88[0] - 0 = Native 4:2:2 not used
1 = Native 4:2:2 used
PPS88[1] - 0 = Native 4:2:0 not use
1 = Native 4:2:0 used
PPS88[7:2] - Reserved 6 bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_bpg_offset</span></code></dt><dd><p>PPS89[4:0] - Additional bits/group budget for the
second line of a slice in Native 4:2:0 mode.
Set to 0 if DSC minor version is 1 or native420 is 0.
PPS89[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nsl_bpg_offset</span></code></dt><dd><p>PPS90[7:0], PPS91[7:0] - Number of bits that are deallocated
for each group that is not in the second line of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_offset_adj</span></code></dt><dd><p>PPS92[7:0], PPS93[7:0] - Used as offset adjustment for the second
line in Native 4:2:0 mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_94_reserved</span></code></dt><dd><p>PPS 94, 95, 96, 97 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_98_reserved</span></code></dt><dd><p>PPS 98, 99, 100, 101 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_102_reserved</span></code></dt><dd><p>PPS 102, 103, 104, 105 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_106_reserved</span></code></dt><dd><p>PPS 106, 107, 108, 109 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_110_reserved</span></code></dt><dd><p>PPS 110, 111, 112, 113 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_114_reserved</span></code></dt><dd><p>PPS 114 - 117 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_118_reserved</span></code></dt><dd><p>PPS 118 - 121 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_122_reserved</span></code></dt><dd><p>PPS 122- 125 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_short_126_reserved</span></code></dt><dd><p>PPS 126, 127 - reserved</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The VESA DSC standard defines picture parameter set (PPS) which display
stream compression encoders must communicate to decoders.
The PPS is encapsulated in 128 bytes (PPS 0 through PPS 127). The fields in
this structure are as per Table 4.1 in Vesa DSC specification v1.1/v1.2.
The PPS fields that span over more than a byte should be stored in Big Endian
format.</p>
<dl class="type">
<dt id="c.drm_dsc_pps_infoframe">
struct <code class="sig-name descname">drm_dsc_pps_infoframe</code><a class="headerlink" href="#c.drm_dsc_pps_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>DSC infoframe carrying the Picture Parameter Set Metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_pps_infoframe {
  struct dp_sdp_header pps_header;
  struct drm_dsc_picture_parameter_set pps_payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pps_header</span></code></dt><dd><p>Header for PPS as per DP SDP header format of type
<a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_payload</span></code></dt><dd><p>PPS payload fields as per DSC specification Table 4-1
as represented in <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents the DSC PPS infoframe required to send the Picture
Parameter Set metadata required before enabling VESA Display Stream
Compression. This is based on the DP Secondary Data Packet structure and
comprises of SDP Header as defined <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">struct</span></code> dp_sdp_header in drm_dp_helper.h
and PPS payload defined in <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_dsc_dp_pps_header_init">
void <code class="sig-name descname">drm_dsc_dp_pps_header_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header">dp_sdp_header</a> *<em> pps_header</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_dp_pps_header_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the PPS Header for DisplayPort as per the DP 1.4 spec.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span> <span class="pre">*</span> <span class="pre">pps_header</span></code></dt><dd><p>Secondary data packet header for DSC Picture
Parameter Set as defined in <a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DP 1.4 spec defines the secondary data packet for sending the
picture parameter infoframes from the source to the sink.
This function populates the SDP header defined in
<a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_dsc_pps_payload_pack">
void <code class="sig-name descname">drm_dsc_pps_payload_pack</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set">drm_dsc_picture_parameter_set</a> *<em> pps_payload</em>, const struct <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config">drm_dsc_config</a> *<em> dsc_cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_pps_payload_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Populates the DSC PPS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span> <span class="pre">*</span> <span class="pre">pps_payload</span></code></dt><dd><p>Bitwise struct for DSC Picture Parameter Set. This is defined
by <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dsc_config</span> <span class="pre">*</span> <span class="pre">dsc_cfg</span></code></dt><dd><p>DSC Configuration data filled by driver as defined by
<a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DSC source device sends a picture parameter set (PPS) containing the
information required by the sink to decode the compressed frame. Driver
populates the DSC PPS struct using the DSC configuration parameters in
the order expected by the DSC Display Sink device. For the DSC, the sink
device expects the PPS payload in big endian format for fields
that span more than 1 byte.</p>
<dl class="function">
<dt id="c.drm_dsc_compute_rc_parameters">
int <code class="sig-name descname">drm_dsc_compute_rc_parameters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config">drm_dsc_config</a> *<em> vdsc_cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_compute_rc_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Write rate control parameters to the dsc configuration defined in <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> in accordance with the DSC 1.2 specification. Some configuration fields must be present beforehand.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span> <span class="pre">*</span> <span class="pre">vdsc_cfg</span></code></dt><dd><p>DSC Configuration data partially filled by driver</p>
</dd>
</dl>
</div>
<div class="section" id="output-probing-helper-functions-reference">
<h2>Output Probing Helper Functions Reference<a class="headerlink" href="#output-probing-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides some helper code for output probing. It provides an
implementation of the core <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.fill_modes</span></code></a> interface with
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>It also provides support for polling connectors with a work item and for
generic hotplug interrupt handling where the driver doesn’t or cannot keep
track of a per-connector hpd interrupt.</p>
<p>This helper library can be used independently of the modeset helper library.
Drivers can also overwrite different parts e.g. use their own hotplug
handling code to avoid probing unrelated outputs.</p>
<p>The probe helpers share the function table structures with other display
helper libraries. See <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a> for the details.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_enable">
void <code class="sig-name descname">drm_kms_helper_poll_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>re-enable output polling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function re-enables the output polling work, after it has been
temporarily disabled using <a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a>, for example over
suspend/resume.</p>
<p>Drivers can call this helper from their device resume implementation. It is
not an error to call this even when output polling isn’t enabled.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they’re only call from suspend/resume
callbacks.</p>
<dl class="function">
<dt id="c.drm_helper_probe_detect">
int <code class="sig-name descname">drm_helper_probe_detect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em>, bool<em> force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>probe connector status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>acquire_ctx, or NULL to let this function handle locking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force</span></code></dt><dd><p>Whether destructive probe operations should be performed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls the detect callbacks of the connector.
This function returns <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_status</span></code></a>, or
if <strong>ctx</strong> is set, it might also return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_helper_probe_single_connector_modes">
int <code class="sig-name descname">drm_helper_probe_single_connector_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, uint32_t<em> maxX</em>, uint32_t<em> maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_single_connector_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>get complete set of display modes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">maxX</span></code></dt><dd><p>max width for modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">maxY</span></code></dt><dd><p>max height for modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the helper callbacks implemented by <strong>connector</strong> in struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs</span></code></a> try to detect all valid modes.  Modes will first
be added to the connector’s probed_modes list, then culled (based on validity
and the <strong>maxX</strong>, <strong>maxY</strong> parameters) and put into the normal modes list.</p>
<p>Intended to be used as a generic implementation of the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.fill_modes()</span></code></a> vfunc for drivers that use the CRTC helpers
for output mode filtering and detection.</p>
<p>The basic procedure is as follows</p>
<ol class="arabic">
<li><p>All modes currently on the connector’s modes list are marked as stale</p></li>
<li><p>New modes are added to the connector’s probed_modes list with
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>. New modes start their life with status as OK.
Modes are added from a single source using the following priority order.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.get_modes</span></code></a> vfunc</p></li>
<li><p>if the connector status is connector_status_connected, standard
VESA DMT modes up to 1024x768 are automatically added
(<a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_modes_noedid()</span></code></a>)</p></li>
</ul>
<p>Finally modes specified via the kernel command line (video=…) are
added in addition to what the earlier probes produced
(drm_helper_probe_add_cmdline_mode()). These modes are generated
using the VESA GTF/CVT formulas.</p>
</li>
<li><p>Modes are moved from the probed_modes list to the modes list. Potential
duplicates are merged together (see <a class="reference internal" href="drm-kms.html#c.drm_connector_list_update" title="drm_connector_list_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_update()</span></code></a>).
After this step the probed_modes list will be empty again.</p></li>
<li><p>Any non-stale mode on the modes list then undergoes validation</p>
<ul class="simple">
<li><p>drm_mode_validate_basic() performs basic sanity checks</p></li>
<li><p><a class="reference internal" href="drm-kms.html#c.drm_mode_validate_size" title="drm_mode_validate_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_validate_size()</span></code></a> filters out modes larger than <strong>maxX</strong> and <strong>maxY</strong>
(if specified)</p></li>
<li><p>drm_mode_validate_flag() checks the modes against basic connector
capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)</p></li>
<li><p>the optional <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.mode_valid</span></code></a> helper can perform
driver and/or sink specific checks</p></li>
<li><p>the optional <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>
helpers can perform driver and/or source specific checks which are also
enforced by the modeset/atomic helpers</p></li>
</ul>
</li>
<li><p>Any mode whose status is not OK is pruned from the connector’s modes list,
accompanied by a debug message indicating the reason for the mode’s
rejection (see <a class="reference internal" href="drm-kms.html#c.drm_mode_prune_invalid" title="drm_mode_prune_invalid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_prune_invalid()</span></code></a>).</p></li>
</ol>
<p><strong>Return</strong></p>
<p>The number of modes found on <strong>connector</strong>.</p>
<dl class="function">
<dt id="c.drm_kms_helper_hotplug_event">
void <code class="sig-name descname">drm_kms_helper_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>fire off KMS hotplug events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device whose connector state changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function fires off the uevent for userspace and also calls the
output_poll_changed function, which is most commonly used to inform the fbdev
emulation code and allow it to update the fbcon output configuration.</p>
<p>Drivers should call this from their hotplug handling code when a change is
detected. Note that this function does not do any output detection of its
own, like <a class="reference internal" href="#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_hpd_irq_event()</span></code></a> does - this is assumed to be done by the
driver already.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<dl class="function">
<dt id="c.drm_kms_helper_is_poll_worker">
bool <code class="sig-name descname">drm_kms_helper_is_poll_worker</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_is_poll_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>is <code class="docutils literal notranslate"><span class="pre">current</span></code> task an output poll worker?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <code class="docutils literal notranslate"><span class="pre">current</span></code> task is an output poll worker.  This can be used
to select distinct code paths for output polling versus other contexts.</p>
<p>One use case is to avoid a deadlock between the output poll worker and
the autosuspend worker wherein the latter waits for polling to finish
upon calling <a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a>, while the former waits for
runtime suspend to finish upon calling pm_runtime_get_sync() in a
connector -&gt;detect hook.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_disable">
void <code class="sig-name descname">drm_kms_helper_poll_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables the output polling work.</p>
<p>Drivers can call this helper from their device suspend implementation. It is
not an error to call this even when output polling isn’t enabled or already
disabled. Polling is re-enabled by calling <a class="reference internal" href="#c.drm_kms_helper_poll_enable" title="drm_kms_helper_poll_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_enable()</span></code></a>.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they’re only call from suspend/resume
callbacks.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_init">
void <code class="sig-name descname">drm_kms_helper_poll_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize and enable output polling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function intializes and then also enables output polling support for
<strong>dev</strong>. Drivers which do not have reliable hotplug support in hardware can use
this helper infrastructure to regularly poll such connectors for changes in
their connection state.</p>
<p>Drivers can control which connectors are polled by setting the
DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
connectors where probing live outputs can result in visual distortion drivers
should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
completely ignored by the polling logic.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_fini">
void <code class="sig-name descname">drm_kms_helper_poll_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling and clean it up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_helper_hpd_irq_event">
bool <code class="sig-name descname">drm_helper_hpd_irq_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_hpd_irq_event" title="Permalink to this definition">¶</a></dt>
<dd><p>hotplug processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this helper function to run a detect cycle on all connectors
which have the DRM_CONNECTOR_POLL_HPD flag set in their <code class="xref c c-type docutils literal notranslate"><span class="pre">polled</span></code> member. All
other connectors are ignored, which is useful to avoid reprobing fixed
panels.</p>
<p>This helper function is useful for drivers which can’t or don’t track hotplug
interrupts for each connector.</p>
<p>Drivers which support hotplug interrupts for each connector individually and
which have a more fine-grained detect logic should bypass this code and
directly call <a class="reference internal" href="#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a> in case the connector state
changed.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
</div>
<div class="section" id="edid-helper-functions-reference">
<h2>EDID Helper Functions Reference<a class="headerlink" href="#edid-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_eld_mnl">
int <code class="sig-name descname">drm_eld_mnl</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD monitor name length in bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an eld memory structure with mnl set</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad">
const uint8_t * <code class="sig-name descname">drm_eld_sad</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD structures.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an eld memory structure with sad_count set</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad_count">
int <code class="sig-name descname">drm_eld_sad_count</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an eld memory structure with sad_count set</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_calc_baseline_block_size">
int <code class="sig-name descname">drm_eld_calc_baseline_block_size</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_calc_baseline_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate baseline block size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an eld memory structure with mnl and sad_count set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for determining the payload size of the baseline block, in
bytes, for e.g. setting the Baseline_ELD_Len field in the ELD header block.</p>
<dl class="function">
<dt id="c.drm_eld_size">
int <code class="sig-name descname">drm_eld_size</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to a complete eld memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value does not include the vendor block. It’s vendor specific,
and comprises of the remaining bytes in the ELD memory buffer after
<a class="reference internal" href="#c.drm_eld_size" title="drm_eld_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_eld_size()</span></code></a> bytes of header and baseline block.</p>
<p>The returned value is guaranteed to be a multiple of 4.</p>
<dl class="function">
<dt id="c.drm_eld_get_spk_alloc">
u8 <code class="sig-name descname">drm_eld_get_spk_alloc</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_spk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get speaker allocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an ELD memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value is the speakers mask. User has to use <code class="docutils literal notranslate"><span class="pre">DRM_ELD_SPEAKER</span></code>
field definitions to identify speakers.</p>
<dl class="function">
<dt id="c.drm_eld_get_conn_type">
u8 <code class="sig-name descname">drm_eld_get_conn_type</code><span class="sig-paren">(</span>const uint8_t *<em> eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_conn_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device type hdmi/dp connected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt><dd><p>pointer to an ELD memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller need to use <code class="docutils literal notranslate"><span class="pre">DRM_ELD_CONN_TYPE_HDMI</span></code> or <code class="docutils literal notranslate"><span class="pre">DRM_ELD_CONN_TYPE_DP</span></code> to
identify the display type connected.</p>
<dl class="function">
<dt id="c.drm_edid_header_is_valid">
int <code class="sig-name descname">drm_edid_header_is_valid</code><span class="sig-paren">(</span>const u8 *<em> raw_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_header_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check the header of the base EDID block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">raw_edid</span></code></dt><dd><p>pointer to raw base EDID block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity check the header of the base EDID block.</p>
<p><strong>Return</strong></p>
<p>8 if the header is perfect, down to 0 if it’s totally wrong.</p>
<dl class="function">
<dt id="c.drm_edid_block_valid">
bool <code class="sig-name descname">drm_edid_block_valid</code><span class="sig-paren">(</span>u8 *<em> raw_edid</em>, int<em> block</em>, bool<em> print_bad_edid</em>, bool *<em> edid_corrupt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_block_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check the EDID block (base or extension)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">raw_edid</span></code></dt><dd><p>pointer to raw EDID block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block</span></code></dt><dd><p>type of block to validate (0 for base, extension otherwise)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">print_bad_edid</span></code></dt><dd><p>if true, dump bad EDID blocks to the console</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">edid_corrupt</span></code></dt><dd><p>if true, the header or checksum is invalid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate a base or extension EDID block and optionally dump bad blocks to
the console.</p>
<p><strong>Return</strong></p>
<p>True if the block is valid, false otherwise.</p>
<dl class="function">
<dt id="c.drm_edid_is_valid">
bool <code class="sig-name descname">drm_edid_is_valid</code><span class="sig-paren">(</span>struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check EDID data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity-check an entire EDID record (including extensions)</p>
<p><strong>Return</strong></p>
<p>True if the EDID data is valid, false otherwise.</p>
<dl class="function">
<dt id="c.drm_add_override_edid_modes">
int <code class="sig-name descname">drm_add_override_edid_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_override_edid_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes from override/firmware EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add modes from the override/firmware EDID, if available. Only to be used from
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> as a fallback for when DDC probe
failed during <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> and caused the override/firmware EDID to be
skipped.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_do_get_edid">
struct edid * <code class="sig-name descname">drm_do_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, int (<em>*get_edid_block</em>)(void *data, u8 *buf, unsigned int block, size_t len), void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_do_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data using a custom EDID block read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*data,</span> <span class="pre">u8</span> <span class="pre">*buf,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">block,</span> <span class="pre">size_t</span> <span class="pre">len)</span> <span class="pre">get_edid_block</span></code></dt><dd><p>EDID block read function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>private data passed to the block read function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the I2C adapter connected to the DDC bus is hidden behind a device that
exposes a different interface to read EDID blocks this function can be used
to get EDID data using a custom block read function.</p>
<p>As in the general case the DDC bus is accessible by the kernel at the I2C
level, drivers must make all reasonable efforts to expose it as an I2C
adapter and use <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> instead of abusing this function.</p>
<p>The EDID may be overridden using debugfs override_edid or firmare EDID
(drm_load_edid_firmware() and drm.edid_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_probe_ddc">
bool <code class="sig-name descname">drm_probe_ddc</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_probe_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>probe DDC presence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter to probe</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True on success, false on failure.</p>
<dl class="function">
<dt id="c.drm_get_edid">
struct edid * <code class="sig-name descname">drm_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data, if available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poke the given I2C channel to grab EDID data if possible.  If found,
attach it to the connector.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_get_edid_switcheroo">
struct edid * <code class="sig-name descname">drm_get_edid_switcheroo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid_switcheroo" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data for a vga_switcheroo output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> for laptops with dual GPUs using one set of
outputs. The wrapper adds the requisite vga_switcheroo calls to temporarily
switch DDC to the GPU which is retrieving EDID.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_edid_duplicate">
struct edid * <code class="sig-name descname">drm_edid_duplicate</code><span class="sig-paren">(</span>const struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an EDID and the extensions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID to duplicate</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to duplicated EDID or NULL on allocation failure.</p>
<dl class="function">
<dt id="c.drm_match_cea_mode">
u8 <code class="sig-name descname">drm_match_cea_mode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> to_match</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_match_cea_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>look for a CEA mode matching given mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">to_match</span></code></dt><dd><p>display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The CEA Video ID (VIC) of the mode or 0 if it isn’t a CEA-861
mode.</p>
<dl class="function">
<dt id="c.drm_edid_get_monitor_name">
void <code class="sig-name descname">drm_edid_get_monitor_name</code><span class="sig-paren">(</span>struct edid *<em> edid</em>, char *<em> name</em>, int<em> bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_get_monitor_name" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch the monitor name from the edid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>monitor EDID information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>pointer to a character array to hold the name of the monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bufsize</span></code></dt><dd><p>The size of the name buffer (should be at least 14 chars.)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_edid_to_sad">
int <code class="sig-name descname">drm_edid_to_sad</code><span class="sig-paren">(</span>struct edid *<em> edid</em>, struct cea_sad **<em> sads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts SADs from EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cea_sad</span> <span class="pre">**</span> <span class="pre">sads</span></code></dt><dd><p>pointer that will be set to the extracted SADs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found SADs or negative number on error.</p>
<dl class="function">
<dt id="c.drm_edid_to_speaker_allocation">
int <code class="sig-name descname">drm_edid_to_speaker_allocation</code><span class="sig-paren">(</span>struct edid *<em> edid</em>, u8 **<em> sadb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_speaker_allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts Speaker Allocation Data Blocks from EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">**</span> <span class="pre">sadb</span></code></dt><dd><p>pointer to the speaker block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found Speaker Allocation Blocks or negative number on
error.</p>
<dl class="function">
<dt id="c.drm_av_sync_delay">
int <code class="sig-name descname">drm_av_sync_delay</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_av_sync_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the HDMI/DP sink audio-video sync delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector associated with the HDMI/DP sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>the display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The HDMI/DP sink’s audio-video sync delay in milliseconds or 0 if
the sink doesn’t support audio or video.</p>
<dl class="function">
<dt id="c.drm_detect_hdmi_monitor">
bool <code class="sig-name descname">drm_detect_hdmi_monitor</code><span class="sig-paren">(</span>struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_hdmi_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>detect whether monitor is HDMI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>monitor EDID information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the CEA extension according to CEA-861-B.</p>
<p>Drivers that have added the modes parsed from EDID to drm_display_info
should use <a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info.is_hdmi</span></code></a> instead of calling this function.</p>
<p><strong>Return</strong></p>
<p>True if the monitor is HDMI, false if not or unknown.</p>
<dl class="function">
<dt id="c.drm_detect_monitor_audio">
bool <code class="sig-name descname">drm_detect_monitor_audio</code><span class="sig-paren">(</span>struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_monitor_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>check monitor audio capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID block to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Monitor should have CEA extension block.
If monitor has ‘basic audio’, but no CEA audio blocks, it’s ‘basic
audio’ only. If there is any audio extension block and supported
audio format, assume at least ‘basic audio’ support, even if ‘basic
audio’ is not defined in EDID.</p>
<p><strong>Return</strong></p>
<p>True if the monitor supports audio, false otherwise.</p>
<dl class="function">
<dt id="c.drm_default_rgb_quant_range">
enum hdmi_quantization_range <code class="sig-name descname">drm_default_rgb_quant_range</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_default_rgb_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>default RGB quantization range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>display mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the default RGB quantization range for the mode,
as specified in CEA-861.</p>
<p><strong>Return</strong></p>
<p>The default RGB quantization range for the mode</p>
<dl class="function">
<dt id="c.drm_add_edid_modes">
int <code class="sig-name descname">drm_add_edid_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, struct edid *<em> edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_edid_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes from EDID data, if available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt><dd><p>EDID data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector’s mode list. Also fills out the
<a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a> structure and ELD in <strong>connector</strong> with any information which
can be derived from the edid.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_add_modes_noedid">
int <code class="sig-name descname">drm_add_modes_noedid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, int<em> hdisplay</em>, int<em> vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_modes_noedid" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes for the connectors without EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt><dd><p>the horizontal display limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt><dd><p>the vertical display limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector’s mode list. Only when the
hdisplay/vdisplay is not beyond the given limit, it will be added.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
<dl class="function">
<dt id="c.drm_set_preferred_mode">
void <code class="sig-name descname">drm_set_preferred_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, int<em> hpref</em>, int<em> vpref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_set_preferred_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the preferred mode of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>connector whose mode list should be processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hpref</span></code></dt><dd><p>horizontal resolution of preferred mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vpref</span></code></dt><dd><p>vertical resolution of preferred mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks a mode as preferred if it matches the resolution specified by <strong>hpref</strong>
and <strong>vpref</strong>.</p>
<dl class="function">
<dt id="c.drm_hdmi_infoframe_set_hdr_metadata">
int <code class="sig-name descname">drm_hdmi_infoframe_set_hdr_metadata</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe *<em> frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_infoframe_set_hdr_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI DRM infoframe with HDR metadata from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>Connector state containing HDR metadata</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_from_display_mode">
int <code class="sig-name descname">drm_hdmi_avi_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI AVI infoframe with data from a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_colorspace">
void <code class="sig-name descname">drm_hdmi_avi_infoframe_colorspace</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_colorspace" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe colorspace information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>connector state</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_quant_range">
void <code class="sig-name descname">drm_hdmi_avi_infoframe_quant_range</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, enum hdmi_quantization_range<em> rgb_quant_range</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe quantization range information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hdmi_quantization_range</span> <span class="pre">rgb_quant_range</span></code></dt><dd><p>RGB quantization range (Q)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_bars">
void <code class="sig-name descname">drm_hdmi_avi_infoframe_bars</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em> conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe bar information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt><dd><p>connector state</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_hdmi_vendor_infoframe_from_display_mode">
int <code class="sig-name descname">drm_hdmi_vendor_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em> frame</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_vendor_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI infoframe with data from a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI vendor infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that there’s is a need to send HDMI vendor infoframes only when using a
4k or stereoscopic 3D mode. So when giving any other mode as input this
function will return -EINVAL, error that can be safely ignored.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="scdc-helper-functions-reference">
<h2>SCDC Helper Functions Reference<a class="headerlink" href="#scdc-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Status and Control Data Channel (SCDC) is a mechanism introduced by the
HDMI 2.0 specification. It is a point-to-point protocol that allows the
HDMI source and HDMI sink to exchange data. The same I2C interface that
is used to access EDID serves as the transport mechanism for SCDC.</p>
<dl class="function">
<dt id="c.drm_scdc_readb">
int <code class="sig-name descname">drm_scdc_readb</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, u8 *<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>offset of register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt><dd><p>return location for the register value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a single byte from SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_read" title="drm_scdc_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_scdc_read()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_writeb">
int <code class="sig-name descname">drm_scdc_writeb</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>offset of register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>return location for the register value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a single byte to SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_write" title="drm_scdc_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_scdc_write()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_read">
ssize_t <code class="sig-name descname">drm_scdc_read</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a block of data from SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>start offset of block to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>return location for the block to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the block to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of data from SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_write">
ssize_t <code class="sig-name descname">drm_scdc_write</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, u8<em> offset</em>, const void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a block of data to SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>start offset of block to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>block of data to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the block to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a block of data to SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_get_scrambling_status">
bool <code class="sig-name descname">drm_scdc_get_scrambling_status</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_get_scrambling_status" title="Permalink to this definition">¶</a></dt>
<dd><p>what is status of scrambling?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the scrambler status over SCDC, and checks the
scrambling status.</p>
<p><strong>Return</strong></p>
<p>True if the scrambling is enabled, false otherwise.</p>
<dl class="function">
<dt id="c.drm_scdc_set_scrambling">
bool <code class="sig-name descname">drm_scdc_set_scrambling</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_scrambling" title="Permalink to this definition">¶</a></dt>
<dd><p>enable scrambling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>bool to indicate if scrambling is to be enabled/disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes the TMDS config register over SCDC channel, and:
enables scrambling when enable = 1
disables scrambling when enable = 0</p>
<p><strong>Return</strong></p>
<p>True if scrambling is set/reset successfully, false otherwise.</p>
<dl class="function">
<dt id="c.drm_scdc_set_high_tmds_clock_ratio">
bool <code class="sig-name descname">drm_scdc_set_high_tmds_clock_ratio</code><span class="sig-paren">(</span>struct i2c_adapter *<em> adapter</em>, bool<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_high_tmds_clock_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>set TMDS clock ratio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">set</span></code></dt><dd><p>ret or reset the high clock ratio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><dl>
<dt>TMDS clock ratio calculations go like this:</dt><dd><p>TMDS character = 10 bit TMDS encoded value</p>
<p>TMDS character rate = The rate at which TMDS characters are
transmitted (Mcsc)</p>
<p>TMDS bit rate = 10x TMDS character rate</p>
</dd>
<dt>As per the spec:</dt><dd><p>TMDS clock rate for pixel clock &lt; 340 MHz = 1x the character
rate = 1/10 pixel clock rate</p>
<p>TMDS clock rate for pixel clock &gt; 340 MHz = 0.25x the character
rate = 1/40 pixel clock rate</p>
</dd>
<dt>Writes to the TMDS config register over SCDC channel, and:</dt><dd><p>sets TMDS clock ratio to 1/40 when set = 1</p>
<p>sets TMDS clock ratio to 1/10 when set = 0</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Return</strong></p>
<p>True if write is successful, false otherwise.</p>
</div>
<div class="section" id="hdmi-infoframes-helper-reference">
<h2>HDMI Infoframes Helper Reference<a class="headerlink" href="#hdmi-infoframes-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Strictly speaking this is not a DRM helper library but generally useable
by any driver interfacing with HDMI outputs like v4l or alsa drivers.
But it nicely fits into the overall topic of mode setting helper
libraries and hence is also included here.</p>
<dl class="type">
<dt id="c.hdr_sink_metadata">
struct <code class="sig-name descname">hdr_sink_metadata</code><a class="headerlink" href="#c.hdr_sink_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>HDR sink metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_sink_metadata {
  __u32 metadata_type;
  union {
    struct hdr_static_metadata hdmi_type1;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdmi_type1</span></code></dt><dd><p>HDR Metadata Infoframe.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Metadata Information read from Sink’s EDID</p>
<dl class="type">
<dt id="c.hdmi_infoframe">
union <code class="sig-name descname">hdmi_infoframe</code><a class="headerlink" href="#c.hdmi_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>overall union of all abstract infoframe representations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union hdmi_infoframe {
  struct hdmi_any_infoframe any;
  struct hdmi_avi_infoframe avi;
  struct hdmi_spd_infoframe spd;
  union hdmi_vendor_any_infoframe vendor;
  struct hdmi_audio_infoframe audio;
  struct hdmi_drm_infoframe drm;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">any</span></code></dt><dd><p>generic infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">avi</span></code></dt><dd><p>avi infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spd</span></code></dt><dd><p>spd infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>union of all vendor infoframes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio</span></code></dt><dd><p>audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm</span></code></dt><dd><p>Dynamic Range and Mastering infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used by the generic pack function. This works since all infoframes
have the same header which also indicates which type of infoframe should be
packed.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_init">
void <code class="sig-name descname">hdmi_avi_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI AVI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_check">
int <code class="sig-name descname">hdmi_avi_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI AVI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_avi_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_avi_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI AVI infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_avi_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI AVI infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_init">
int <code class="sig-name descname">hdmi_spd_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe *<em> frame</em>, const char *<em> vendor</em>, const char *<em> product</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI SPD infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">vendor</span></code></dt><dd><p>vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">product</span></code></dt><dd><p>product string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_check">
int <code class="sig-name descname">hdmi_spd_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI SPD infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_spd_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_spd_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI SPD infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_spd_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI SPD infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_init">
int <code class="sig-name descname">hdmi_audio_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI audio infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_check">
int <code class="sig-name descname">hdmi_audio_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI audio infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_audio_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_audio_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI audio infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_audio_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI Audio infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI Audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_init">
int <code class="sig-name descname">hdmi_vendor_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI vendor infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI vendor infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_check">
int <code class="sig-name descname">hdmi_vendor_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI vendor infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_vendor_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_vendor_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI vendor infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_vendor_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI Vendor infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI Vendor infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_init">
int <code class="sig-name descname">hdmi_drm_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI Dynaminc Range and mastering infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_check">
int <code class="sig-name descname">hdmi_drm_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI DRM infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent.
Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_drm_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_drm_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI DRM infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_drm_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI DRM infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_check">
int <code class="sig-name descname">hdmi_infoframe_check</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_infoframe_pack_only</code><span class="sig-paren">(</span>const union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_infoframe_pack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em> frame</em>, void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI infoframe, and write it to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_log">
void <code class="sig-name descname">hdmi_infoframe_log</code><span class="sig-paren">(</span>const char *<em> level</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em> frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_log" title="Permalink to this definition">¶</a></dt>
<dd><p>log info of HDMI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">level</span></code></dt><dd><p>logging level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hdmi_infoframe_unpack">
int <code class="sig-name descname">hdmi_infoframe_unpack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em> frame</em>, const void *<em> buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>unpack binary buffer to a HDMI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpacks the information contained in binary buffer <strong>buffer</strong> into a structured
<strong>frame</strong> of a HDMI infoframe.
Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="rectangle-utilities-reference">
<h2>Rectangle Utilities Reference<a class="headerlink" href="#rectangle-utilities-reference" title="Permalink to this headline">¶</a></h2>
<p>Utility functions to help manage rectangular areas for
clipping, scaling, etc. calculations.</p>
<dl class="type">
<dt id="c.drm_rect">
struct <code class="sig-name descname">drm_rect</code><a class="headerlink" href="#c.drm_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>two dimensional rectangle</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_rect {
  int x1, y1, x2, y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x1</span></code></dt><dd><p>horizontal starting coordinate (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y1</span></code></dt><dd><p>vertical starting coordinate (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x2</span></code></dt><dd><p>horizontal ending coordinate (exclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y2</span></code></dt><dd><p>vertical ending coordinate (exclusive)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FMT">
<code class="sig-name descname">DRM_RECT_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_ARG">
<code class="sig-name descname">DRM_RECT_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code></dt><dd><p>rectangle struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FP_FMT">
<code class="sig-name descname">DRM_RECT_FP_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_FP_ARG">
<code class="sig-name descname">DRM_RECT_FP_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code></dt><dd><p>rectangle struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for e.g. printing plane source rectangles, which are in 16.16
fixed point.</p>
<dl class="function">
<dt id="c.drm_rect_init">
void <code class="sig-name descname">drm_rect_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> x</em>, int<em> y</em>, int<em> width</em>, int<em> height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the rectangle from x/y/w/h</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>x coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>y coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_rect_adjust_size">
void <code class="sig-name descname">drm_rect_adjust_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> dw</em>, int<em> dh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the size of the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be adjusted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dw</span></code></dt><dd><p>horizontal adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dh</span></code></dt><dd><p>vertical adjustment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the size of rectangle <strong>r</strong> by <strong>dw</strong> in the horizontal direction,
and by <strong>dh</strong> in the vertical direction, while keeping the center
of <strong>r</strong> stationary.</p>
<p>Positive <strong>dw</strong> and <strong>dh</strong> increase the size, negative values decrease it.</p>
<dl class="function">
<dt id="c.drm_rect_translate">
void <code class="sig-name descname">drm_rect_translate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> dx</em>, int<em> dy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be tranlated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dx</span></code></dt><dd><p>horizontal translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dy</span></code></dt><dd><p>vertical translation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> by <strong>dx</strong> in the horizontal direction,
and by <strong>dy</strong> in the vertical direction.</p>
<dl class="function">
<dt id="c.drm_rect_translate_to">
void <code class="sig-name descname">drm_rect_translate_to</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> x</em>, int<em> y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle to an absolute position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be tranlated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>horizontal position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>vertical position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> to <strong>x</strong> in the horizontal direction,
and to <strong>y</strong> in the vertical direction.</p>
<dl class="function">
<dt id="c.drm_rect_downscale">
void <code class="sig-name descname">drm_rect_downscale</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> horz</em>, int<em> vert</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_downscale" title="Permalink to this definition">¶</a></dt>
<dd><p>downscale a rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be downscaled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">horz</span></code></dt><dd><p>horizontal downscale factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vert</span></code></dt><dd><p>vertical downscale factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide the coordinates of rectangle <strong>r</strong> by <strong>horz</strong> and <strong>vert</strong>.</p>
<dl class="function">
<dt id="c.drm_rect_width">
int <code class="sig-name descname">drm_rect_width</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_width" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle width</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle whose width is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_height">
int <code class="sig-name descname">drm_rect_height</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_height" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle height</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle whose height is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_visible">
bool <code class="sig-name descname">drm_rect_visible</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_visible" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if the the rectangle is visible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle whose visibility is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the rectangle is visible, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_equals">
bool <code class="sig-name descname">drm_rect_equals</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_equals" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if two rectangles are equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r1</span></code></dt><dd><p>first rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r2</span></code></dt><dd><p>second rectangle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the rectangles are equal, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_intersect">
bool <code class="sig-name descname">drm_rect_intersect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>intersect two rectangles</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r1</span></code></dt><dd><p>first rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r2</span></code></dt><dd><p>second rectangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the intersection of rectangles <strong>r1</strong> and <strong>r2</strong>.
<strong>r1</strong> will be overwritten with the intersection.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if rectangle <strong>r1</strong> is still visible after the operation,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_clip_scaled">
bool <code class="sig-name descname">drm_rect_clip_scaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> dst</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_clip_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a scaled clip operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt><dd><p>clip rectangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clip rectangle <strong>dst</strong> by rectangle <strong>clip</strong>. Clip rectangle <strong>src</strong> by the
the corresponding amounts, retaining the vertical and horizontal scaling
factors from <strong>src</strong> to <strong>dst</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if rectangle <strong>dst</strong> is still visible after being clipped,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_calc_hscale">
int <code class="sig-name descname">drm_rect_calc_hscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> dst</em>, int<em> min_hscale</em>, int<em> max_hscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_hscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the horizontal scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_hscale</span></code></dt><dd><p>minimum allowed horizontal scaling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_hscale</span></code></dt><dd><p>maximum allowed horizontal scaling factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the horizontal scaling factor as
(<strong>src</strong> width) / (<strong>dst</strong> width).</p>
<p>If the scale is below 1 &lt;&lt; 16, round down. If the scale is above
1 &lt;&lt; 16, round up. This will calculate the scale with the most
pessimistic limit calculation.</p>
<p><strong>Return</strong></p>
<p>The horizontal scaling factor, or errno of out of limits.</p>
<dl class="function">
<dt id="c.drm_rect_calc_vscale">
int <code class="sig-name descname">drm_rect_calc_vscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> dst</em>, int<em> min_vscale</em>, int<em> max_vscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_vscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the vertical scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_vscale</span></code></dt><dd><p>minimum allowed vertical scaling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_vscale</span></code></dt><dd><p>maximum allowed vertical scaling factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the vertical scaling factor as
(<strong>src</strong> height) / (<strong>dst</strong> height).</p>
<p>If the scale is below 1 &lt;&lt; 16, round down. If the scale is above
1 &lt;&lt; 16, round up. This will calculate the scale with the most
pessimistic limit calculation.</p>
<p><strong>Return</strong></p>
<p>The vertical scaling factor, or errno of out of limits.</p>
<dl class="function">
<dt id="c.drm_rect_debug_print">
void <code class="sig-name descname">drm_rect_debug_print</code><span class="sig-paren">(</span>const char *<em> prefix</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, bool<em> fixed_point</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_debug_print" title="Permalink to this definition">¶</a></dt>
<dd><p>print the rectangle information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt><dd><p>prefix string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fixed_point</span></code></dt><dd><p>rectangle is in 16.16 fixed point format</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_rect_rotate">
void <code class="sig-name descname">drm_rect_rotate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> width</em>, int<em> height</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be rotated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>Width of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>Height of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Transformation to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply <strong>rotation</strong> to the coordinates of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the untransformed coordinate
space.</p>
<dl class="function">
<dt id="c.drm_rect_rotate_inv">
void <code class="sig-name descname">drm_rect_rotate_inv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em> r</em>, int<em> width</em>, int<em> height</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse rotate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>rectangle to be rotated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>Width of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>Height of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Transformation whose inverse is to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the inverse of <strong>rotation</strong> to the coordinates
of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the original untransformed
coordinate space, so that you never have to flip
them when doing a rotatation and its inverse.
That is, if you do</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>drm_rect_rotate(&amp;r, width, height, rotation);
drm_rect_rotate_inv(&amp;r, width, height, rotation);
</pre></div>
</div>
<p>you will always get back the original rectangle.</p>
</div>
<div class="section" id="flip-work-helper-reference">
<h2>Flip-work Helper Reference<a class="headerlink" href="#flip-work-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Util to queue up work to run from work-queue context after flip/vblank.
Typically this can be used to defer unref of framebuffer’s, cursor
bo’s, etc until after vblank.  The APIs are all thread-safe.
Moreover, drm_flip_work_queue_task and drm_flip_work_queue can be called
in atomic context.</p>
<dl class="type">
<dt id="c.drm_flip_task">
struct <code class="sig-name descname">drm_flip_task</code><a class="headerlink" href="#c.drm_flip_task" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work task</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_flip_task {
  struct list_head node;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list entry element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data to pass to <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_flip_work.func</span></code></a></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_flip_work">
struct <code class="sig-name descname">drm_flip_work</code><a class="headerlink" href="#c.drm_flip_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work queue</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_flip_work {
  const char *name;
  drm_flip_func_t func;
  struct work_struct worker;
  struct list_head queued;
  struct list_head commited;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>debug name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>callback fxn called for each committed item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">worker</span></code></dt><dd><p>worker which calls <strong>func</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queued</span></code></dt><dd><p>queued tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commited</span></code></dt><dd><p>commited tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock to access queued and commited lists</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_flip_work_allocate_task">
struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a> * <code class="sig-name descname">drm_flip_work_allocate_task</code><span class="sig-paren">(</span>void *<em> data</em>, gfp_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_allocate_task" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a flip-work task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data associated to the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>allocator flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a drm_flip_task object and attach private data to it.</p>
<dl class="function">
<dt id="c.drm_flip_work_queue_task">
void <code class="sig-name descname">drm_flip_work_queue_task</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em> work</em>, struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a> *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue_task" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a specific task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>the task to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues task, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
<dl class="function">
<dt id="c.drm_flip_work_queue">
void <code class="sig-name descname">drm_flip_work_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em> work</em>, void *<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">val</span></code></dt><dd><p>the value to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues work, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
<dl class="function">
<dt id="c.drm_flip_work_commit">
void <code class="sig-name descname">drm_flip_work_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em> work</em>, struct workqueue_struct *<em> wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit queued work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt><dd><p>the work-queue to run the queued work on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trigger work previously queued by <a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_queue()</span></code></a> to run
on a workqueue.  The typical usage would be to queue work (via
<a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_queue()</span></code></a>) at any point (from vblank irq and/or
prior), and then from vblank irq commit the queued work.</p>
<dl class="function">
<dt id="c.drm_flip_work_init">
void <code class="sig-name descname">drm_flip_work_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em> work</em>, const char *<em> name</em>, drm_flip_func_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize flip-work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>the flip-work to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>debug name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm_flip_func_t</span> <span class="pre">func</span></code></dt><dd><p>the callback work function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes/allocates resources for the flip-work</p>
<dl class="function">
<dt id="c.drm_flip_work_cleanup">
void <code class="sig-name descname">drm_flip_work_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up flip-work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>the flip-work to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy resources allocated for the flip-work</p>
</div>
<div class="section" id="auxiliary-modeset-helpers">
<h2>Auxiliary Modeset Helpers<a class="headerlink" href="#auxiliary-modeset-helpers" title="Permalink to this headline">¶</a></h2>
<p>This helper library contains various one-off functions which don’t really fit
anywhere else in the DRM modeset helper library.</p>
<dl class="function">
<dt id="c.drm_helper_move_panel_connectors_to_head">
void <code class="sig-name descname">drm_helper_move_panel_connectors_to_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_move_panel_connectors_to_head" title="Permalink to this definition">¶</a></dt>
<dd><p>move panels to the front in the connector list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some userspace presumes that the first connected connector is the main
display, where it’s supposed to display e.g. the login screen. For
laptops, this should be the main panel. Use this function to sort all
(eDP/LVDS/DSI) panels to the front of the connector list, instead of
painstakingly trying to initialize them in the right order.</p>
<dl class="function">
<dt id="c.drm_helper_mode_fill_fb_struct">
void <code class="sig-name descname">drm_helper_mode_fill_fb_struct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> fb</em>, const struct drm_mode_fb_cmd2 *<em> mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_mode_fill_fb_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out framebuffer metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt><dd><p>drm_framebuffer object to fill out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt><dd><p>metadata from the userspace fb creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper can be used in a drivers fb_create callback to pre-fill the fb’s
metadata fields.</p>
<dl class="function">
<dt id="c.drm_crtc_init">
int <code class="sig-name descname">drm_crtc_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a> *<em> funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Legacy CRTC initialization function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt><dd><p>callbacks for the new CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a CRTC object with a default helper-provided primary plane and no
cursor plane.</p>
<p>Note that we make some assumptions about hardware limitations that may not be
true for all hardware:</p>
<ol class="arabic simple">
<li><p>Primary plane cannot be repositioned.</p></li>
<li><p>Primary plane cannot be scaled.</p></li>
<li><p>Primary plane must cover the entire CRTC.</p></li>
<li><p>Subpixel positioning is not supported.</p></li>
<li><p>The primary plane must always be on if the CRTC is enabled.</p></li>
</ol>
<p>This is purely a backwards compatibility helper for old drivers. Drivers
should instead implement their own primary plane. Atomic drivers must do so.
Drivers with the above hardware restriction can look into using <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_simple_display_pipe</span></code></a>, which encapsulates the above limitations into a nice
interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_mode_config_helper_suspend">
int <code class="sig-name descname">drm_mode_config_helper_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_helper_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Modeset suspend helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function takes care of suspending the modeset side. It disables
output polling if initialized, suspends fbdev if used and finally calls
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>.
If suspending fails, fbdev and polling is re-enabled.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on error.</p>
<p>See also:
<a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a> and <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_mode_config_helper_resume">
int <code class="sig-name descname">drm_mode_config_helper_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_helper_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Modeset resume helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function takes care of resuming the modeset side. It calls
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, resumes fbdev if used and enables output polling
if initiaized.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on error.</p>
<p>See also:
<a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> and <a class="reference internal" href="#c.drm_kms_helper_poll_enable" title="drm_kms_helper_poll_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_enable()</span></code></a>.</p>
</div>
<div class="section" id="of-dt-helpers">
<h2>OF/DT Helpers<a class="headerlink" href="#of-dt-helpers" title="Permalink to this headline">¶</a></h2>
<p>A set of helper functions to aid DRM drivers in parsing standard DT
properties.</p>
<dl class="function">
<dt id="c.drm_of_crtc_port_mask">
uint32_t <code class="sig-name descname">drm_of_crtc_port_mask</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct device_node *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_crtc_port_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered CRTC by port OF node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port OF node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a port OF node, return the possible mask of the corresponding
CRTC within a device’s list of CRTCs.  Returns zero if not found.</p>
<dl class="function">
<dt id="c.drm_of_find_possible_crtcs">
uint32_t <code class="sig-name descname">drm_of_find_possible_crtcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct device_node *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_find_possible_crtcs" title="Permalink to this definition">¶</a></dt>
<dd><p>find the possible CRTCs for an encoder port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>encoder port to scan for endpoints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan all endpoints attached to a port, locate their attached CRTCs,
and generate the DRM mask of CRTCs which may be attached to this
encoder.</p>
<p>See Documentation/devicetree/bindings/graph.txt for the bindings.</p>
<dl class="function">
<dt id="c.drm_of_component_match_add">
void <code class="sig-name descname">drm_of_component_match_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> master</em>, struct component_match **<em> matchptr</em>, int (<em>*compare</em>)(struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *, void *), struct device_node *<em> node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_component_match_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a component helper OF node match rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">master</span></code></dt><dd><p>master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">**</span> <span class="pre">matchptr</span></code></dt><dd><p>component match pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">compare</span></code></dt><dd><p>compare function used for matching component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt><dd><p>of_node</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_of_component_probe">
int <code class="sig-name descname">drm_of_component_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int (<em>*compare_of</em>)(struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *, void *), const struct <a class="reference internal" href="../driver-api/component.html#c.component_master_ops" title="component_master_ops">component_master_ops</a> *<em> m_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_component_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic probe function for a component based master</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>master device containing the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">compare_of</span></code></dt><dd><p>compare function used for matching components</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_master_ops</span> <span class="pre">*</span> <span class="pre">m_ops</span></code></dt><dd><p>component master ops to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the platform device OF node and bind all the components associated
with the master. Interface ports are added before the encoders in order to
satisfy their .bind requirements
See Documentation/devicetree/bindings/graph.txt for the bindings.</p>
<p>Returns zero if successful, or one of the standard error codes if it fails.</p>
<dl class="function">
<dt id="c.drm_of_find_panel_or_bridge">
int <code class="sig-name descname">drm_of_find_panel_or_bridge</code><span class="sig-paren">(</span>const struct device_node *<em> np</em>, int<em> port</em>, int<em> endpoint</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> **<em> panel</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> **<em> bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_find_panel_or_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>return connected panel or bridge device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>device tree node containing encoder output ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port</span></code></dt><dd><p>port in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">**</span> <span class="pre">panel</span></code></dt><dd><p>pointer to hold returned drm_panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">**</span> <span class="pre">bridge</span></code></dt><dd><p>pointer to hold returned drm_bridge</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a DT node’s port and endpoint number, find the connected node and
return either the associated struct drm_panel or drm_bridge device. Either
<strong>panel</strong> or <strong>bridge</strong> must not be NULL.</p>
<p>Returns zero if successful, or one of the standard error codes if it fails.</p>
<dl class="function">
<dt id="c.drm_of_lvds_get_dual_link_pixel_order">
int <code class="sig-name descname">drm_of_lvds_get_dual_link_pixel_order</code><span class="sig-paren">(</span>const struct device_node *<em> port1</em>, const struct device_node *<em> port2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_lvds_get_dual_link_pixel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LVDS dual-link pixel order</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">port1</span></code></dt><dd><p>First DT port node of the Dual-link LVDS source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">port2</span></code></dt><dd><p>Second DT port node of the Dual-link LVDS source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An LVDS dual-link connection is made of two links, with even pixels
transitting on one link, and odd pixels on the other link. This function
returns, for two ports of an LVDS dual-link source, which port shall transmit
the even and odd pixels, based on the requirements of the connected sink.</p>
<p>The pixel order is determined from the dual-lvds-even-pixels and
dual-lvds-odd-pixels properties in the sink’s DT port nodes. If those
properties are not present, or if their usage is not valid, this function
returns -EINVAL.</p>
<p>If either port is not connected, this function returns -EPIPE.</p>
<p><strong>port1</strong> and <strong>port2</strong> are typically DT sibling nodes, but may have different
parents when, for instance, two separate LVDS encoders carry the even and odd
pixels.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS - <strong>port1</strong> carries even pixels and <strong>port2</strong>
carries odd pixels</p></li>
<li><p>DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS - <strong>port1</strong> carries odd pixels and <strong>port2</strong>
carries even pixels</p></li>
<li><p>-EINVAL - <strong>port1</strong> and <strong>port2</strong> are not connected to a dual-link LVDS sink, or
the sink configuration is invalid</p></li>
<li><p>-EPIPE - when <strong>port1</strong> or <strong>port2</strong> are not connected</p></li>
</ul>
</div>
<div class="section" id="legacy-plane-helper-reference">
<h2>Legacy Plane Helper Reference<a class="headerlink" href="#legacy-plane-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library has two parts. The first part has support to implement
primary plane support on top of the normal CRTC configuration interface.
Since the legacy <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> interface ties the primary
plane together with the CRTC state this does not allow userspace to disable
the primary plane itself. The default primary plane only expose XRBG8888 and
ARGB8888 as valid pixel formats for the attached framebuffer.</p>
<p>Drivers are highly recommended to implement proper support for primary
planes, and newly merged drivers must not rely upon these transitional
helpers.</p>
<p>The second part also implements transitional helpers which allow drivers to
gradually switch to the atomic helper infrastructure for plane updates. Once
that switch is complete drivers shouldn’t use these any longer, instead using
the proper legacy implementations for update and disable plane hooks provided
by the atomic helpers.</p>
<p>Again drivers are strongly urged to switch to the new interfaces.</p>
<p>The plane helpers share the function table structures with other helpers,
specifically also the atomic helpers. See <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> for
the details.</p>
<dl class="function">
<dt id="c.drm_primary_helper_destroy">
void <code class="sig-name descname">drm_primary_helper_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_primary_helper_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane destruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt><dd><p>plane to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane destroy handler for primary planes.  This handler
is called during CRTC destruction.  We disable the primary plane, remove
it from the DRM plane list, and deallocate the plane structure.</p>
</div>
<div class="section" id="legacy-crtc-modeset-helper-functions-reference">
<h2>Legacy CRTC/Modeset Helper Functions Reference<a class="headerlink" href="#legacy-crtc-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The CRTC modeset helper library provides a default set_config implementation
in <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a>. Plus a few other convenience functions using
the same callbacks which drivers can use to e.g. restore the modeset
configuration on resume with <a class="reference internal" href="#c.drm_helper_resume_force_mode" title="drm_helper_resume_force_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_resume_force_mode()</span></code></a>.</p>
<p>Note that this helper library doesn’t track the current power state of CRTCs
and encoders. It can call callbacks like <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> even
though the hardware is already in the desired state. This deficiency has been
fixed in the atomic helpers.</p>
<p>The driver callbacks are mostly compatible with the atomic modeset helpers,
except for the handling of the primary plane: Atomic helpers require that the
primary plane is implemented as a real standalone plane and not directly tied
to the CRTC state. For easier transition this library provides functions to
implement the old semantics required by the CRTC helpers using the new plane
and atomic helper callbacks.</p>
<p>Drivers are strongly urged to convert to the atomic helpers (by way of first
converting to the plane helpers). New drivers must not use these functions
but need to implement the atomic interface instead, potentially using the
atomic helpers for that.</p>
<p>These legacy modeset helpers use the same function table structures as
all other modesetting helpers. See the documentation for struct
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_helper_encoder_in_use">
bool <code class="sig-name descname">drm_helper_encoder_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em> encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_encoder_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given encoder is in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt><dd><p>encoder to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>encoder</strong> is with the current mode setting output configuration
in use by any connector. This doesn’t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>encoder</strong> is used, false otherwise.</p>
<dl class="function">
<dt id="c.drm_helper_crtc_in_use">
bool <code class="sig-name descname">drm_helper_crtc_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_crtc_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given CRTC is in a mode_config</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>crtc</strong> is with the current mode setting output configuration
in use by any connector. This doesn’t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>crtc</strong> is used, false otherwise.</p>
<dl class="function">
<dt id="c.drm_helper_disable_unused_functions">
void <code class="sig-name descname">drm_helper_disable_unused_functions</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_disable_unused_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unused objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks through the entire mode setting configuration of <strong>dev</strong>. It
will remove any CRTC links of unused encoders and encoder links of
disconnected connectors. Then it will disable all unused encoders and CRTCs
either by calling their disable callback if available or by calling their
dpms callback with DRM_MODE_DPMS_OFF.</p>
<p><strong>NOTE</strong></p>
<p>This function is part of the legacy modeset helper library and will cause
major confusion with atomic drivers. This is because atomic helpers guarantee
to never call -&gt;disable() hooks on a disabled function, or -&gt;enable() hooks
on an enabled functions. <a class="reference internal" href="#c.drm_helper_disable_unused_functions" title="drm_helper_disable_unused_functions"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_disable_unused_functions()</span></code></a> on the other
hand throws such guarantees into the wind and calls disable hooks
unconditionally on unused functions.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_set_mode">
bool <code class="sig-name descname">drm_crtc_helper_set_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em> crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em> mode</em>, int<em> x</em>, int<em> y</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em> old_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>internal helper to set a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt><dd><p>CRTC to program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt><dd><p>mode to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>horizontal offset into the surface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>vertical offset into the surface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">old_fb</span></code></dt><dd><p>old framebuffer, for cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to set <strong>mode</strong> on <strong>crtc</strong>.  Give <strong>crtc</strong> and its associated connectors a chance
to fixup or reject the mode prior to trying to set it. This is an internal
helper that drivers could e.g. use to update properties that require the
entire output pipe to be disabled and re-enabled in a new configuration. For
example for changing whether audio is enabled on a hdmi link or for changing
panel fitter or dither attributes. It is also called by the
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function to drive the mode setting
sequence.</p>
<p><strong>Return</strong></p>
<p>True if the mode was set successfully, false otherwise.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_set_config">
int <code class="sig-name descname">drm_crtc_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em> set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em> ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt><dd><p>mode set configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>lock acquire context, not used here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function implements the of
<a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_config</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>It first tries to locate the best encoder for each connector by calling the
connector <strong>drm_connector_helper_funcs.best_encoder</strong> helper operation.</p>
<p>After locating the appropriate encoders, the helper function will call the
mode_fixup encoder and CRTC helper operations to adjust the requested mode,
or reject it completely in which case an error will be returned to the
application. If the new configuration after mode adjustment is identical to
the current configuration the helper function will return without performing
any other operation.</p>
<p>If the adjusted mode is identical to the current mode but changes to the
frame buffer need to be applied, the <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> function
will call the CRTC <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_set_base</span></code></a> helper operation.</p>
<p>If the adjusted mode differs from the current mode, or if the
-&gt;mode_set_base() helper operation is not provided, the helper function
performs a full mode set sequence by calling the -&gt;prepare(), -&gt;mode_set()
and -&gt;commit() CRTC and encoder helper operations, in that order.
Alternatively it can also use the dpms and disable helper operations. For
details see <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a>.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, for which this function is unsuitable. Instead drivers should use
<a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_set_config()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_helper_connector_dpms">
int <code class="sig-name descname">drm_helper_connector_dpms</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em> connector</em>, int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_connector_dpms" title="Permalink to this definition">¶</a></dt>
<dd><p>connector dpms helper implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt><dd><p>affected connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>DPMS mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a> helper function implements the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.dpms</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>This is the main helper function provided by the CRTC helper framework for
implementing the DPMS connector attribute. It computes the new desired DPMS
state for all encoders and CRTCs in the output mesh and calls the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.dpms</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> callbacks
provided by the driver.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, where DPMS is handled in the DRM core.</p>
<p><strong>Return</strong></p>
<p>Always returns 0.</p>
<dl class="function">
<dt id="c.drm_helper_resume_force_mode">
void <code class="sig-name descname">drm_helper_resume_force_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_resume_force_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>force-restore mode setting configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>drm_device which should be restored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which use the mode setting helpers can use this function to
force-restore the mode setting configuration e.g. on resume or when something
else might have trampled over the hw state (like some overzealous old BIOSen
tended to do).</p>
<p>This helper doesn’t provide a error return value since restoring the old
config should never fail due to resource allocation issues since the driver
has successfully set the restored configuration already. Hence this should
boil down to the equivalent of a few dpms on calls, which also don’t provide
an error code.</p>
<p>Drivers where simply restoring an old configuration again might fail (e.g.
due to slight differences in allocating shared resources when the
configuration is restored in a different order than when userspace set it up)
need to use their own restore logic.</p>
<p>This function is deprecated. New drivers should implement atomic mode-
setting and use the atomic suspend/resume helpers.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
<dl class="function">
<dt id="c.drm_helper_force_disable_all">
int <code class="sig-name descname">drm_helper_force_disable_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_force_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off all enabled CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device whose CRTCs to turn off</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may want to call this on unload to ensure that all displays are
unlit and the GPU is in a consistent, low power state. Takes modeset locks.</p>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers. For an atomic
version look at <a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<div class="section" id="shmem-gem-helper-reference">
<h2>SHMEM GEM Helper Reference<a class="headerlink" href="#shmem-gem-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides helpers for GEM objects backed by shmem buffers
allocated using anonymous pageable memory.</p>
<dl class="type">
<dt id="c.drm_gem_shmem_object">
struct <code class="sig-name descname">drm_gem_shmem_object</code><a class="headerlink" href="#c.drm_gem_shmem_object" title="Permalink to this definition">¶</a></dt>
<dd><p>GEM object backed by shmem</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_shmem_object {
  struct drm_gem_object base;
  struct mutex pages_lock;
  struct page **pages;
  unsigned int pages_use_count;
  int madv;
  struct list_head madv_list;
  unsigned int pages_mark_dirty_on_put    : 1;
  unsigned int pages_mark_accessed_on_put : 1;
  struct sg_table *sgt;
  struct mutex vmap_lock;
  void *vaddr;
  unsigned int vmap_use_count;
  bool map_cached;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_lock</span></code></dt><dd><p>Protects the page table and use count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages</span></code></dt><dd><p>Page table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_use_count</span></code></dt><dd><p>Reference count on the pages table.
The pages are put when the count reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">madv</span></code></dt><dd><p>State for madvise</p>
<p>0 is active/inuse.
A negative value is the object is purged.
Positive values are driver specific and not used by the helpers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">madv_list</span></code></dt><dd><p>List entry for madvise tracking</p>
<p>Typically used by drivers to track purgeable objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_mark_dirty_on_put</span></code></dt><dd><p>Mark pages as dirty when they are put.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_mark_accessed_on_put</span></code></dt><dd><p>Mark pages as accessed when they are put.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgt</span></code></dt><dd><p>Scatter/gather table for imported PRIME buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_lock</span></code></dt><dd><p>Protects the vmap address and use count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr</span></code></dt><dd><p>Kernel virtual address of the backing memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_use_count</span></code></dt><dd><p>Reference count on the virtual address.
The address are un-mapped when the count reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_cached</span></code></dt><dd><p>map object cached (instead of using writecombine).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DRM_GEM_SHMEM_DRIVER_OPS">
<code class="sig-name descname">DRM_GEM_SHMEM_DRIVER_OPS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_GEM_SHMEM_DRIVER_OPS" title="Permalink to this definition">¶</a></dt>
<dd><p>Default shmem GEM operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the shmem GEM operations in
the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_create">
struct <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object">drm_gem_shmem_object</a> * <code class="sig-name descname">drm_gem_shmem_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object with the given size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of the object to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a shmem GEM object.</p>
<p><strong>Return</strong></p>
<p>A struct drm_gem_shmem_object * on success or an ERR_PTR()-encoded negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_free_object">
void <code class="sig-name descname">drm_gem_shmem_free_object</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_free_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Free resources associated with a shmem GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up the GEM object state and frees the memory used to
store the object itself.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_pin">
int <code class="sig-name descname">drm_gem_shmem_pin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin backing pages for a shmem GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes sure the backing pages are pinned in memory while the
buffer is exported.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_unpin">
void <code class="sig-name descname">drm_gem_shmem_unpin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin backing pages for a shmem GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes the requirement that the backing pages are pinned in
memory.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_dumb_create">
int <code class="sig-name descname">drm_gem_shmem_dumb_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em> file</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct drm_mode_create_dumb *<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_dumb_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dumb shmem buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>DRM file structure to create the dumb buffer for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>IOCTL data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the pitch of the dumb buffer and rounds it up to an
integer number of bytes per pixel. Drivers for hardware that doesn’t have
any additional restrictions on the pitch can directly use this function as
their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p>For hardware with additional restrictions, drivers can adjust the fields
set up by userspace before calling into this function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_mmap">
int <code class="sig-name descname">drm_gem_shmem_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em>, struct vm_area_struct *<em> vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory-map a shmem GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>gem object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements an augmented version of the GEM DRM file mmap
operation for shmem objects. Drivers which employ the shmem helpers should
use this function as their <a class="reference internal" href="drm-mm.html#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.mmap</span></code></a> handler.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_print_info">
void <code class="sig-name descname">drm_gem_shmem_print_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em> p</em>, unsigned int<em> indent</em>, const struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_print_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_shmem_object</span></code></a> info for debugfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_gem_shmem_get_sg_table">
struct sg_table * <code class="sig-name descname">drm_gem_shmem_get_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_get_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a scatter/gather table of pinned pages for a shmem GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function exports a scatter/gather table suitable for PRIME usage by
calling the standard DMA mapping API.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or NULL on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_get_pages_sgt">
struct sg_table * <code class="sig-name descname">drm_gem_shmem_get_pages_sgt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em> obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_get_pages_sgt" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin pages, dma map them, and return a scatter/gather table for a shmem GEM object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a scatter/gather table suitable for driver usage. If
the sg table doesn’t exist, the pages are pinned, dma-mapped, and a sg
table created.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or errno on failure.</p>
<dl class="function">
<dt id="c.drm_gem_shmem_prime_import_sg_table">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="sig-name descname">drm_gem_shmem_prime_import_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em> dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em> attach</em>, struct sg_table *<em> sgt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_prime_import_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a shmem GEM object from another driver’s scatter/gather table of pinned pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt><dd><p>DMA-BUF attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sgt</span></code></dt><dd><p>Scatter/gather table of pinned pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function imports a scatter/gather table exported via DMA-BUF by
another driver. Drivers that use the shmem helpers should set this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>A pointer to a newly created GEM object or an ERR_PTR-encoded negative
error code on failure.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-uapi.html" class="btn btn-neutral float-right" title="Userland interfaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms.html" class="btn btn-neutral float-left" title="Kernel Mode Setting (KMS)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>