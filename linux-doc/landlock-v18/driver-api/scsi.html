

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SCSI Interfaces Guide &mdash; The Linux Kernel 5.7.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="libATA Developer’s Guide" href="libata.html" />
    <link rel="prev" title="Error Detection And Correction (EDAC) Devices" href="edac.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SCSI Interfaces Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#protocol-vs-bus">Protocol vs bus</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-of-the-linux-scsi-subsystem">Design of the Linux SCSI subsystem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scsi-upper-layer">SCSI upper layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sd-scsi-disk">sd (SCSI Disk)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sr-scsi-cd-rom">sr (SCSI CD-ROM)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#st-scsi-tape">st (SCSI Tape)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sg-scsi-generic">sg (SCSI Generic)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ch-scsi-media-changer">ch (SCSI Media Changer)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scsi-mid-layer">SCSI mid layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scsi-midlayer-implementation">SCSI midlayer implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transport-classes">Transport classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scsi-lower-layer">SCSI lower layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#host-bus-adapter-transport-types">Host Bus Adapter transport types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>SCSI Interfaces Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/scsi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scsi-interfaces-guide">
<h1>SCSI Interfaces Guide<a class="headerlink" href="#scsi-interfaces-guide" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>James Bottomley</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Rob Landley</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="protocol-vs-bus">
<h3>Protocol vs bus<a class="headerlink" href="#protocol-vs-bus" title="Permalink to this headline">¶</a></h3>
<p>Once upon a time, the Small Computer Systems Interface defined both a
parallel I/O bus and a data protocol to connect a wide variety of
peripherals (disk drives, tape drives, modems, printers, scanners,
optical drives, test equipment, and medical devices) to a host computer.</p>
<p>Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen
out of use, the SCSI command set is more widely used than ever to
communicate with devices over a number of different busses.</p>
<p>The <a class="reference external" href="http://www.t10.org/scsi-3.htm">SCSI protocol</a> is a big-endian
peer-to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16
bytes long, often followed by an associated data payload.</p>
<p>SCSI commands can be transported over just about any kind of bus, and
are the default protocol for storage devices attached to USB, SATA, SAS,
Fibre Channel, FireWire, and ATAPI devices. SCSI packets are also
commonly exchanged over Infiniband,
<a class="reference external" href="http://i2o.shadowconnect.com/faq.php">I2O</a>, TCP/IP
(<a class="reference external" href="https://en.wikipedia.org/wiki/ISCSI">iSCSI</a>), even <a class="reference external" href="http://cyberelk.net/tim/parport/parscsi.html">Parallel
ports</a>.</p>
</div>
<div class="section" id="design-of-the-linux-scsi-subsystem">
<h3>Design of the Linux SCSI subsystem<a class="headerlink" href="#design-of-the-linux-scsi-subsystem" title="Permalink to this headline">¶</a></h3>
<p>The SCSI subsystem uses a three layer design, with upper, mid, and low
layers. Every operation involving the SCSI subsystem (such as reading a
sector from a disk) uses one driver at each of the 3 levels: one upper
layer driver, one lower layer driver, and the SCSI midlayer.</p>
<p>The SCSI upper layer provides the interface between userspace and the
kernel, in the form of block and char device nodes for I/O and ioctl().
The SCSI lower layer contains drivers for specific hardware devices.</p>
<p>In between is the SCSI mid-layer, analogous to a network routing layer
such as the IPv4 stack. The SCSI mid-layer routes a packet based data
protocol between the upper layer’s /dev nodes and the corresponding
devices in the lower layer. It manages command queues, provides error
handling and power management functions, and responds to ioctl()
requests.</p>
</div>
</div>
<div class="section" id="scsi-upper-layer">
<h2>SCSI upper layer<a class="headerlink" href="#scsi-upper-layer" title="Permalink to this headline">¶</a></h2>
<p>The upper layer supports the user-kernel interface by providing device
nodes.</p>
<div class="section" id="sd-scsi-disk">
<h3>sd (SCSI Disk)<a class="headerlink" href="#sd-scsi-disk" title="Permalink to this headline">¶</a></h3>
<p>sd (sd_mod.o)</p>
</div>
<div class="section" id="sr-scsi-cd-rom">
<h3>sr (SCSI CD-ROM)<a class="headerlink" href="#sr-scsi-cd-rom" title="Permalink to this headline">¶</a></h3>
<p>sr (sr_mod.o)</p>
</div>
<div class="section" id="st-scsi-tape">
<h3>st (SCSI Tape)<a class="headerlink" href="#st-scsi-tape" title="Permalink to this headline">¶</a></h3>
<p>st (st.o)</p>
</div>
<div class="section" id="sg-scsi-generic">
<h3>sg (SCSI Generic)<a class="headerlink" href="#sg-scsi-generic" title="Permalink to this headline">¶</a></h3>
<p>sg (sg.o)</p>
</div>
<div class="section" id="ch-scsi-media-changer">
<h3>ch (SCSI Media Changer)<a class="headerlink" href="#ch-scsi-media-changer" title="Permalink to this headline">¶</a></h3>
<p>ch (ch.c)</p>
</div>
</div>
<div class="section" id="scsi-mid-layer">
<h2>SCSI mid layer<a class="headerlink" href="#scsi-mid-layer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scsi-midlayer-implementation">
<h3>SCSI midlayer implementation<a class="headerlink" href="#scsi-midlayer-implementation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="include-scsi-scsi-device-h">
<h4>include/scsi/scsi_device.h<a class="headerlink" href="#include-scsi-scsi-device-h" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="c.scsi_vpd">
struct <code class="sig-name descname">scsi_vpd</code><a class="headerlink" href="#c.scsi_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI Vital Product Data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scsi_vpd {
  struct rcu_head rcu;
  int len;
  unsigned char   data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>For <a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Length in bytes of <strong>data</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>VPD data as defined in various T10 SCSI standard documents.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.shost_for_each_device">
<code class="sig-name descname">shost_for_each_device</code><span class="sig-paren">(</span><em>sdev</em>, <em>shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shost_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all devices of a host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  This loop
takes a reference on each device and releases it at the end.  If
you break out of the loop, you must call scsi_device_put(sdev).</p>
<dl class="function">
<dt id="c.__shost_for_each_device">
<code class="sig-name descname">__shost_for_each_device</code><span class="sig-paren">(</span><em>sdev</em>, <em>shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__shost_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all devices of a host (UNLOCKED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason to use this is because you need to access the
device list in interrupt context.  Otherwise you really want to use
shost_for_each_device instead.</p>
<dl class="function">
<dt id="c.scsi_device_supports_vpd">
int <code class="sig-name descname">scsi_device_supports_vpd</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_supports_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>test if a device supports VPD pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the ‘try_vpd_pages’ flag is set it takes precedence.
Otherwise we will assume VPD pages are supported if the
SCSI level is at least SPC-3 and ‘skip_vpd_pages’ is not set.</p>
</div>
<div class="section" id="drivers-scsi-scsi-c">
<h4>drivers/scsi/scsi.c<a class="headerlink" href="#drivers-scsi-scsi-c" title="Permalink to this headline">¶</a></h4>
<p>Main file for the SCSI midlayer.</p>
<dl class="function">
<dt id="c.scsi_change_queue_depth">
int <code class="sig-name descname">scsi_change_queue_depth</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_change_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>change a device’s queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>number of commands allowed to be queued to the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the device queue depth and returns the new value.</p>
<dl class="function">
<dt id="c.scsi_track_queue_full">
int <code class="sig-name descname">scsi_track_queue_full</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_track_queue_full" title="Permalink to this definition">¶</a></dt>
<dd><p>track QUEUE_FULL events to adjust queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>Current number of outstanding SCSI commands on this device,
not counting the one returned as QUEUE_FULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This function will track successive QUEUE_FULL events on a</dt><dd><p>specific SCSI device to determine if and when there is a
need to adjust the queue depth on the device.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 - No change needed, &gt;0 - Adjust queue depth to this new depth,</dt><dd><dl class="simple">
<dt>-1 - Drop back to untagged operation using host-&gt;cmd_per_lun</dt><dd><p>as the untagged command depth</p>
</dd>
</dl>
</dd>
</dl>
<p>Lock Status: None held on entry</p>
<p><strong>Notes</strong></p>
<dl class="simple">
<dt>Low level drivers may call this at any time and we will do</dt><dd><p>“The Right Thing.”  We are interrupt context safe.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_get_vpd_page">
int <code class="sig-name descname">scsi_get_vpd_page</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, u8<em> page</em>, unsigned char *<em> buf</em>, int<em> buf_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_vpd_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Vital Product Data from a SCSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>The device to ask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">page</span></code></dt><dd><p>Which Vital Product Data to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>where to store the VPD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>number of bytes in the VPD buffer area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>SCSI devices may optionally supply Vital Product Data.  Each ‘page’
of VPD is defined in the appropriate SCSI document (eg SPC, SBC).
If the device supports this VPD page, this routine returns a pointer
to a buffer containing the data from that page.  The caller is
responsible for calling <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> on this pointer when it is no longer
needed.  If we cannot retrieve the VPD page this routine returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.scsi_report_opcode">
int <code class="sig-name descname">scsi_report_opcode</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, unsigned char *<em> buffer</em>, unsigned int<em> len</em>, unsigned char<em> opcode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_opcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out if a given command opcode is supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>scratch buffer (must be at least 20 bytes long)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">opcode</span></code></dt><dd><p>opcode for command to look up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the REPORT SUPPORTED OPERATION CODES to look up the given
opcode. Returns -EINVAL if RSOC fails, 0 if the command opcode is
unsupported and 1 if the device claims to support the command.</p>
<dl class="function">
<dt id="c.scsi_device_get">
int <code class="sig-name descname">scsi_device_get</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get an additional reference to a scsi_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>device to get a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets a reference to the scsi_device and increments the use count
of the underlying LLDD module.  You must hold host_lock of the
parent Scsi_Host or already have a reference when calling this.</p>
<p>This will fail if a device is deleted or cancelled, or when the LLD module
is in the process of being unloaded.</p>
<dl class="function">
<dt id="c.scsi_device_put">
void <code class="sig-name descname">scsi_device_put</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to a scsi_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>device to release a reference on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a reference to the scsi_device and decrements the use
count of the underlying LLDD module.  The device is freed once the last
user vanishes.</p>
<dl class="function">
<dt id="c.starget_for_each_device">
void <code class="sig-name descname">starget_for_each_device</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, void *<em> data</em>, void (<em>*fn</em>)(struct scsi_device *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.starget_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to walk all devices of a target</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>Opaque passed to each function call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt><dd><p>Function to call on each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  The devices have
a reference that must be released by scsi_host_put when breaking
out of the loop.</p>
<dl class="function">
<dt id="c.__starget_for_each_device">
void <code class="sig-name descname">__starget_for_each_device</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, void *<em> data</em>, void (<em>*fn</em>)(struct scsi_device *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__starget_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to walk all devices of a target (UNLOCKED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>parameter for callback <strong>fn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt><dd><p>callback function that is invoked for each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use starget_for_each_device instead.</p>
<dl class="function">
<dt id="c.__scsi_device_lookup_by_target">
struct scsi_device * <code class="sig-name descname">__scsi_device_lookup_by_target</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup_by_target" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the target (UNLOCKED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and
any access to the returned scsi_device. A scsi_device in state
SDEV_DEL is skipped.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers should use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup_by_target instead.</p>
<dl class="function">
<dt id="c.scsi_device_lookup_by_target">
struct scsi_device * <code class="sig-name descname">scsi_device_lookup_by_target</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup_by_target" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the target</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
<dl class="function">
<dt id="c.__scsi_device_lookup">
struct scsi_device * <code class="sig-name descname">__scsi_device_lookup</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, uint<em> channel</em>, uint<em> id</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the host (UNLOCKED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host. The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and any access
to the returned scsi_device.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup instead.</p>
<dl class="function">
<dt id="c.scsi_device_lookup">
struct scsi_device * <code class="sig-name descname">scsi_device_lookup</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, uint<em> channel</em>, uint<em> id</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
</div>
<div class="section" id="drivers-scsi-scsicam-c">
<h4>drivers/scsi/scsicam.c<a class="headerlink" href="#drivers-scsi-scsicam-c" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf">SCSI Common Access
Method</a> support
functions, for use with HDIO_GETGEO, etc.</p>
<dl class="function">
<dt id="c.scsi_bios_ptable">
unsigned char * <code class="sig-name descname">scsi_bios_ptable</code><span class="sig-paren">(</span>struct block_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_bios_ptable" title="Permalink to this definition">¶</a></dt>
<dd><p>Read PC partition table out of first sector of device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>from this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the first sector from the device and returns <code class="docutils literal notranslate"><span class="pre">0x42</span></code> bytes</dt><dd><p>starting at offset <code class="docutils literal notranslate"><span class="pre">0x1be</span></code>.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.</p>
<dl class="function">
<dt id="c.scsi_partsize">
bool <code class="sig-name descname">scsi_partsize</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> capacity</em>, int<em> geom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_partsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse cylinders/heads/sectors from PC partition table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>block device to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">geom</span></code></dt><dd><p>output in form of [hds, cylinders, sectors]</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the BIOS mapping/geometry used to create the partition
table, storing the results in <strong>geom</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> on failure, <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
<dl class="function">
<dt id="c.scsicam_bios_param">
int <code class="sig-name descname">scsicam_bios_param</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> capacity</em>, int *<em> ip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsicam_bios_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine geometry of a disk in cylinders/heads/sectors.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>which device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ip</span></code></dt><dd><p>return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>determine the BIOS mapping/geometry used for a drive in a</dt><dd><p>SCSI-CAM system, storing the results in ip as required
by the HDIO_GETGEO ioctl().</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-1 on failure, 0 on success.</p>
</div>
<div class="section" id="drivers-scsi-scsi-error-c">
<h4>drivers/scsi/scsi_error.c<a class="headerlink" href="#drivers-scsi-scsi-error-c" title="Permalink to this headline">¶</a></h4>
<p>Common SCSI error/timeout handling routines.</p>
<dl class="function">
<dt id="c.scsi_schedule_eh">
void <code class="sig-name descname">scsi_schedule_eh</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_schedule_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule EH for SCSI host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>SCSI host to invoke error handling on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule SCSI EH without scmd.</p>
<dl class="function">
<dt id="c.scsi_block_when_processing_errors">
int <code class="sig-name descname">scsi_block_when_processing_errors</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_when_processing_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevent cmds from being queued.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>Device on which we are performing recovery.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>We block until the host is out of error recovery, and then check to
see whether the host or the device is offline.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 when dev was taken offline by error recovery. 1 OK to proceed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_check_sense">
int <code class="sig-name descname">scsi_check_sense</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_check_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>Examine scsi cmd sense</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>Cmd to have sense checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>When a deferred error is detected the current command has
not been executed and needs retrying.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_eh_prep_cmnd">
void <code class="sig-name descname">scsi_eh_prep_cmnd</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em>, struct scsi_eh_save *<em> ses</em>, unsigned char *<em> cmnd</em>, int<em> cmnd_size</em>, unsigned<em> sense_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_prep_cmnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a scsi command info as part of error recovery</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>SCSI command structure to hijack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*</span> <span class="pre">ses</span></code></dt><dd><p>structure to save restore information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cmnd</span></code></dt><dd><p>CDB to send. Can be NULL if no new cmnd is needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmnd_size</span></code></dt><dd><p>size in bytes of <strong>cmnd</strong> (must be &lt;= BLK_MAX_CDB)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">sense_bytes</span></code></dt><dd><p>size of sense data to copy. or 0 (if != 0 <strong>cmnd</strong> is ignored)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to save a scsi command information before re-execution
as part of the error recovery process.  If <strong>sense_bytes</strong> is 0 the command
sent must be one that does not transfer any data.  If <strong>sense_bytes</strong> != 0
<strong>cmnd</strong> is ignored and this functions sets up a REQUEST_SENSE command
and cmnd buffers to read <strong>sense_bytes</strong> into <strong>scmd-&gt;sense_buffer</strong>.</p>
<dl class="function">
<dt id="c.scsi_eh_restore_cmnd">
void <code class="sig-name descname">scsi_eh_restore_cmnd</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em>, struct scsi_eh_save *<em> ses</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_restore_cmnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore a scsi command info as part of error recovery</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>SCSI command structure to restore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*</span> <span class="pre">ses</span></code></dt><dd><p>saved information from a coresponding call to scsi_eh_prep_cmnd</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo any damage done by above <a class="reference internal" href="#c.scsi_eh_prep_cmnd" title="scsi_eh_prep_cmnd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_prep_cmnd()</span></code></a>.</p>
<dl class="function">
<dt id="c.scsi_eh_finish_cmd">
void <code class="sig-name descname">scsi_eh_finish_cmd</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em>, struct list_head *<em> done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_finish_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a cmd that eh is finished with.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>Original SCSI cmd that eh has finished.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">done_q</span></code></dt><dd><p>Queue for processed commands.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We don’t want to use the normal command completion while we are are
still handling errors - it may cause other commands to be queued,
and that would disturb what we are doing.  Thus we really want to
keep a list of pending commands for final completion, and once we
are ready to leave error handling we handle completion for real.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_eh_get_sense">
int <code class="sig-name descname">scsi_eh_get_sense</code><span class="sig-paren">(</span>struct list_head *<em> work_q</em>, struct list_head *<em> done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_get_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device sense data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">work_q</span></code></dt><dd><p>Queue of commands to process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">done_q</span></code></dt><dd><p>Queue of processed commands.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>See if we need to request sense information.  if so, then get it
now, so we have a better idea of what to do.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This has the unfortunate side effect that if a shost adapter does
not automatically request sense information, we end up shutting
it down before we request it.</p>
<p>All drivers should request sense information internally these days,
so for now all I have to say is tough noogies if you end up in here.</p>
<dl class="simple">
<dt>XXX: Long term this code should go away, but that needs an audit of</dt><dd><p>all LLDDs first.</p>
</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_eh_ready_devs">
void <code class="sig-name descname">scsi_eh_ready_devs</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct list_head *<em> work_q</em>, struct list_head *<em> done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_ready_devs" title="Permalink to this definition">¶</a></dt>
<dd><p>check device ready state and recover if not.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host to be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">work_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for pending commands.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">done_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for processed commands.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_eh_flush_done_q">
void <code class="sig-name descname">scsi_eh_flush_done_q</code><span class="sig-paren">(</span>struct list_head *<em> done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_flush_done_q" title="Permalink to this definition">¶</a></dt>
<dd><p>finish processed commands or retry them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">done_q</span></code></dt><dd><p>list_head of processed commands.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_get_sense_info_fld">
bool <code class="sig-name descname">scsi_get_sense_info_fld</code><span class="sig-paren">(</span>const u8 *<em> sense_buffer</em>, int<em> sb_len</em>, u64 *<em> info_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_sense_info_fld" title="Permalink to this definition">¶</a></dt>
<dd><p>get information field from sense data (either fixed or descriptor format)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buffer</span></code></dt><dd><p>byte array of sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">info_out</span></code></dt><dd><p>pointer to 64 integer where 8 or 4 byte information
field will be placed if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if information field found, false if not found.</p>
</dd>
</dl>
</div>
<div class="section" id="drivers-scsi-scsi-devinfo-c">
<h4>drivers/scsi/scsi_devinfo.c<a class="headerlink" href="#drivers-scsi-scsi-devinfo-c" title="Permalink to this headline">¶</a></h4>
<p>Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
devices.</p>
<dl class="function">
<dt id="c.scsi_dev_info_list_add">
int <code class="sig-name descname">scsi_dev_info_list_add</code><span class="sig-paren">(</span>int<em> compatible</em>, char *<em> vendor</em>, char *<em> model</em>, char *<em> strflags</em>, blist_flags_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add one dev_info list entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">compatible</span></code></dt><dd><p>if true, null terminate short strings.  Otherwise space pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">vendor</span></code></dt><dd><p>vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">model</span></code></dt><dd><p>model (product) string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">strflags</span></code></dt><dd><p>integer string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>if strflags NULL, use this flag value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create and add one dev_info entry for <strong>vendor</strong>, <strong>model</strong>, <strong>strflags</strong> or
<strong>flag</strong>. If <strong>compatible</strong>, add to the tail of the list, do not space
pad, and set devinfo-&gt;compatible. The scsi_static_device_list entries
are added with <strong>compatible</strong> 1 and <strong>clfags</strong> NULL.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>0 OK, -error on failure.</p>
<dl class="function">
<dt id="c.scsi_dev_info_list_find">
struct scsi_dev_info_list * <code class="sig-name descname">scsi_dev_info_list_find</code><span class="sig-paren">(</span>const char *<em> vendor</em>, const char *<em> model</em>, enum scsi_devinfo_key<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a matching dev_info list entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">vendor</span></code></dt><dd><p>full vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">model</span></code></dt><dd><p>full model (product) string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>specify list to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Finds the first dev_info entry matching <strong>vendor</strong>, <strong>model</strong>
in list specified by <strong>key</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>pointer to matching entry, or ERR_PTR on failure.</p>
<dl class="function">
<dt id="c.scsi_dev_info_list_add_str">
int <code class="sig-name descname">scsi_dev_info_list_add_str</code><span class="sig-paren">(</span>char *<em> dev_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_add_str" title="Permalink to this definition">¶</a></dt>
<dd><p>parse dev_list and add to the scsi_dev_info_list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dev_list</span></code></dt><dd><p>string of device flags to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Parse dev_list, and add entries to the scsi_dev_info_list.
dev_list is of the form “vendor:product:flag,vendor:product:flag”.
dev_list is modified via strsep. Can be called for command line
addition, for proc or mabye a sysfs interface.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>0 if OK, -error on failure.</p>
<dl class="function">
<dt id="c.scsi_get_device_flags">
blist_flags_t <code class="sig-name descname">scsi_get_device_flags</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, const unsigned char *<em> vendor</em>, const unsigned char *<em> model</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_device_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get device specific flags from the dynamic device list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_device</span></code> to get flags for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">vendor</span></code></dt><dd><p>vendor name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">model</span></code></dt><dd><p>model name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search the global scsi_dev_info_list (specified by list zero)
for an entry matching <strong>vendor</strong> and <strong>model</strong>, if found, return the
matching flags value, else return the host or global default
settings.  Called during scan time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_exit_devinfo">
void <code class="sig-name descname">scsi_exit_devinfo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_exit_devinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>remove /proc/scsi/device_info &amp; the scsi_dev_info_list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_init_devinfo">
int <code class="sig-name descname">scsi_init_devinfo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_init_devinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the dynamic device list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add command line entries from scsi_dev_flags, then add
scsi_static_device_list entries to the scsi device info list.</p>
</div></blockquote>
</div>
<div class="section" id="drivers-scsi-scsi-ioctl-c">
<h4>drivers/scsi/scsi_ioctl.c<a class="headerlink" href="#drivers-scsi-scsi-ioctl-c" title="Permalink to this headline">¶</a></h4>
<p>Handle ioctl() calls for SCSI devices.</p>
<dl class="function">
<dt id="c.scsi_ioctl">
int <code class="sig-name descname">scsi_ioctl</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> cmd</em>, void __user *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch ioctl to scsi device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device receiving ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>which ioctl is it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>data associated with ioctl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.scsi_ioctl" title="scsi_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_ioctl()</span></code></a> function differs from most ioctls in that it
does not take a major/minor number as the dev field.  Rather, it takes
a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code>.</p>
</div>
<div class="section" id="drivers-scsi-scsi-lib-c">
<h4>drivers/scsi/scsi_lib.c<a class="headerlink" href="#drivers-scsi-scsi-lib-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI queuing library.</p>
<dl class="function">
<dt id="c.__scsi_execute">
int <code class="sig-name descname">__scsi_execute</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, const unsigned char *<em> cmd</em>, int<em> data_direction</em>, void *<em> buffer</em>, unsigned<em> bufflen</em>, unsigned char *<em> sense</em>, struct scsi_sense_hdr *<em> sshdr</em>, int<em> timeout</em>, int<em> retries</em>, u64<em> flags</em>, req_flags_t<em> rq_flags</em>, int *<em> resid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>insert request and wait for the result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>scsi command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_direction</span></code></dt><dd><p>data direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">bufflen</span></code></dt><dd><p>len of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">sense</span></code></dt><dd><p>optional sense buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*</span> <span class="pre">sshdr</span></code></dt><dd><p>optional decoded sense header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>request timeout in seconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of times to retry request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">flags</span></code></dt><dd><p>flags for -&gt;cmd_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_flags_t</span> <span class="pre">rq_flags</span></code></dt><dd><p>flags for -&gt;rq_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">resid</span></code></dt><dd><p>optional residual length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the scsi_cmnd result field if a command was executed, or a negative
Linux error code if we didn’t get that far.</p>
<dl class="function">
<dt id="c.scsi_device_from_queue">
struct scsi_device * <code class="sig-name descname">scsi_device_from_queue</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_from_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>return sdev associated with a request_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>The request queue to return the sdev from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the sdev associated with a request queue or NULL if the
request_queue does not reference a SCSI device.</p>
<dl class="function">
<dt id="c.scsi_mode_select">
int <code class="sig-name descname">scsi_mode_select</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> pf</em>, int<em> sp</em>, int<em> modepage</em>, unsigned char *<em> buffer</em>, int<em> len</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_mode_data *<em> data</em>, struct scsi_sense_hdr *<em> sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_select" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a mode select</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pf</span></code></dt><dd><p>Page format bit (1 == standard, 0 == vendor specific)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sp</span></code></dt><dd><p>Save page bit (0 == don’t save, 1 == save)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">modepage</span></code></dt><dd><p>mode page being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*</span> <span class="pre">sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns zero if successful; negative error number or scsi
status on error</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_mode_sense">
int <code class="sig-name descname">scsi_mode_sense</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> dbd</em>, int<em> modepage</em>, unsigned char *<em> buffer</em>, int<em> len</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_mode_data *<em> data</em>, struct scsi_sense_hdr *<em> sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a mode sense, falling back from 10 to six bytes if necessary.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dbd</span></code></dt><dd><p>set if mode sense will allow block descriptors to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">modepage</span></code></dt><dd><p>mode page being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*</span> <span class="pre">sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns zero if unsuccessful, or the header offset (either 4
or 8 depending on whether a six or ten byte command was
issued) if successful.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_test_unit_ready">
int <code class="sig-name descname">scsi_test_unit_ready</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_sense_hdr *<em> sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_test_unit_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>test if unit is ready</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*</span> <span class="pre">sshdr</span></code></dt><dd><p>outpout pointer for decoded sense information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns zero if unsuccessful or an error if TUR failed.  For
removable media, UNIT_ATTENTION sets -&gt;changed flag.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_device_set_state">
int <code class="sig-name descname">scsi_device_set_state</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, enum scsi_device_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the given device through the device state model.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">state</span></code></dt><dd><p>state to change to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns zero if successful or an error if the requested
transition is illegal.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sdev_evt_send">
void <code class="sig-name descname">sdev_evt_send</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, struct scsi_event *<em> evt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send" title="Permalink to this definition">¶</a></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_event</span> <span class="pre">*</span> <span class="pre">evt</span></code></dt><dd><p>event to send</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Assert scsi device event asynchronously.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sdev_evt_alloc">
struct scsi_event * <code class="sig-name descname">sdev_evt_alloc</code><span class="sig-paren">(</span>enum scsi_device_event<em> evt_type</em>, gfp_t<em> gfpflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a new scsi event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocates and returns a new scsi_event.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sdev_evt_send_simple">
void <code class="sig-name descname">sdev_evt_send_simple</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, enum scsi_device_event<em> evt_type</em>, gfp_t<em> gfpflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Assert scsi device event asynchronously, given an event type.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_device_quiesce">
int <code class="sig-name descname">scsi_device_quiesce</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_quiesce" title="Permalink to this definition">¶</a></dt>
<dd><p>Block user issued commands.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to quiesce.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This works by trying to transition to the SDEV_QUIESCE state
(which must be a legal transition).  When the device is in this
state, only special requests will be accepted, all others will
be deferred.  Since special requests may also be requeued requests,
a successful return doesn’t guarantee the device will be
totally quiescent.</p>
<p>Must be called with user context, may sleep.</p>
<p>Returns zero if unsuccessful or an error if not.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_device_resume">
void <code class="sig-name descname">scsi_device_resume</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart user issued commands to a quiesced device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to resume.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Moves the device from quiesced back to running and restarts the
queues.</p>
<p>Must be called with user context, may sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_internal_device_block_nowait">
int <code class="sig-name descname">scsi_internal_device_block_nowait</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_block_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>try to transition to the SDEV_BLOCK state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>device to block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pause SCSI command processing on the specified device. Does not sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_BLOCK state (which must be
a legal transition). When the device is in this state, command processing
is paused until the device leaves the SDEV_BLOCK state. See also
<a class="reference internal" href="#c.scsi_internal_device_unblock_nowait" title="scsi_internal_device_unblock_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_internal_device_unblock_nowait()</span></code></a>.</p>
<dl class="function">
<dt id="c.scsi_internal_device_unblock_nowait">
int <code class="sig-name descname">scsi_internal_device_unblock_nowait</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, enum scsi_device_state<em> new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_unblock_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>resume a device after a block request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>device to resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">new_state</span></code></dt><dd><p>state to set the device to after unblocking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the device queue for a previously suspended SCSI device. Does not
sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_RUNNING state or to one of
the offline states (which must be a legal transition) allowing the midlayer
to goose the queue for this device.</p>
<dl class="function">
<dt id="c.scsi_kmap_atomic_sg">
void * <code class="sig-name descname">scsi_kmap_atomic_sg</code><span class="sig-paren">(</span>struct scatterlist *<em> sgl</em>, int<em> sg_count</em>, size_t *<em> offset</em>, size_t *<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kmap_atomic_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>find and atomically map an sg-elemnt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt><dd><p>scatter-gather list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sg_count</span></code></dt><dd><p>number of segments in sg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">offset</span></code></dt><dd><p>offset in bytes into sg, on return offset into the mapped area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">len</span></code></dt><dd><p>bytes to map, on return number of bytes mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns virtual address of the start of the mapped page</p>
<dl class="function">
<dt id="c.scsi_kunmap_atomic_sg">
void <code class="sig-name descname">scsi_kunmap_atomic_sg</code><span class="sig-paren">(</span>void *<em> virt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kunmap_atomic_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">virt</span></code></dt><dd><p>virtual address to be unmapped</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_vpd_lun_id">
int <code class="sig-name descname">scsi_vpd_lun_id</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, char *<em> id</em>, size_t<em> id_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_vpd_lun_id" title="Permalink to this definition">¶</a></dt>
<dd><p>return a unique device identification</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>buffer for the identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">id_len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a unique device identification into <strong>id</strong> based
on the information in the VPD page 0x83 of the device.
The string will be formatted as a SCSI name string.</p>
<p>Returns the length of the identification or error on failure.
If the identifier is longer than the supplied buffer the actual
identifier length is returned and the buffer is not zero-padded.</p>
</div>
<div class="section" id="drivers-scsi-scsi-lib-dma-c">
<h4>drivers/scsi/scsi_lib_dma.c<a class="headerlink" href="#drivers-scsi-scsi-lib-dma-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI library functions depending on DMA (map and unmap scatter-gather
lists).</p>
<dl class="function">
<dt id="c.scsi_dma_map">
int <code class="sig-name descname">scsi_dma_map</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_map" title="Permalink to this definition">¶</a></dt>
<dd><p>perform DMA mapping against command’s sg lists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of sg lists actually used, zero if the sg lists
is NULL, or -ENOMEM if the mapping failed.</p>
<dl class="function">
<dt id="c.scsi_dma_unmap">
void <code class="sig-name descname">scsi_dma_unmap</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap command’s sg lists mapped by scsi_dma_map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
</div>
<div class="section" id="drivers-scsi-scsi-proc-c">
<h4>drivers/scsi/scsi_proc.c<a class="headerlink" href="#drivers-scsi-scsi-proc-c" title="Permalink to this headline">¶</a></h4>
<p>The functions in this file provide an interface between the PROC file
system and the SCSI device drivers It is mainly used for debugging,
statistics and to pass information directly to the lowlevel driver. I.E.
plumbing to manage /proc/scsi/*</p>
<dl class="function">
<dt id="c.scsi_proc_hostdir_add">
void <code class="sig-name descname">scsi_proc_hostdir_add</code><span class="sig-paren">(</span>struct scsi_host_template *<em> sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create directory in /proc for a scsi host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt><dd><p>owner of this directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets sht-&gt;proc_dir to the new directory.</p>
<dl class="function">
<dt id="c.scsi_proc_hostdir_rm">
void <code class="sig-name descname">scsi_proc_hostdir_rm</code><span class="sig-paren">(</span>struct scsi_host_template *<em> sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>remove directory in /proc for a scsi host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt><dd><p>owner of directory</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_proc_host_add">
void <code class="sig-name descname">scsi_proc_host_add</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add entry for this host to appropriate /proc dir</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host to add</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_proc_host_rm">
void <code class="sig-name descname">scsi_proc_host_rm</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>remove this host’s entry from /proc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>which host</p>
</dd>
</dl>
<dl class="function">
<dt id="c.proc_print_scsidevice">
int <code class="sig-name descname">proc_print_scsidevice</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_print_scsidevice" title="Permalink to this definition">¶</a></dt>
<dd><p>return data about this host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>A scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span></code> to output to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,
and revision.</p>
<dl class="function">
<dt id="c.scsi_add_single_device">
int <code class="sig-name descname">scsi_add_single_device</code><span class="sig-paren">(</span>uint<em> host</em>, uint<em> channel</em>, uint<em> id</em>, uint<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_single_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Respond to user request to probe for/add device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi add-single-device” to /proc/scsi/scsi.</p>
<p>does <a class="reference internal" href="#c.scsi_host_lookup" title="scsi_host_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_lookup()</span></code></a> and either user_scan() if that transport
type supports it, or else scsi_scan_host_selected()</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed exclusively at SCSI parallel busses.</p>
<dl class="function">
<dt id="c.scsi_remove_single_device">
int <code class="sig-name descname">scsi_remove_single_device</code><span class="sig-paren">(</span>uint<em> host</em>, uint<em> channel</em>, uint<em> id</em>, uint<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_single_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Respond to user request to remove a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi remove-single-device” to
/proc/scsi/scsi.  Does a <a class="reference internal" href="#c.scsi_device_lookup" title="scsi_device_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_device_lookup()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_device" title="scsi_remove_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_device()</span></code></a></p>
<dl class="function">
<dt id="c.proc_scsi_write">
ssize_t <code class="sig-name descname">proc_scsi_write</code><span class="sig-paren">(</span>struct file *<em> file</em>, const char __user *<em> buf</em>, size_t<em> length</em>, loff_t *<em> ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_write" title="Permalink to this definition">¶</a></dt>
<dd><p>handle writes to /proc/scsi/scsi</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>buffer to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of buf, at most PAGE_SIZE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt><dd><p>not used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this provides a legacy mechanism to add or remove devices by
Host, Channel, ID, and Lun.  To use,
“echo ‘scsi add-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” or
“echo ‘scsi remove-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” with
“0 1 2 3” replaced by the Host, Channel, Id, and Lun.</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed at parallel SCSI. Most modern busses (USB,
SATA, Firewire, Fibre Channel, etc) dynamically assign these values to
provide a unique identifier and nothing more.</p>
<dl class="function">
<dt id="c.proc_scsi_open">
int <code class="sig-name descname">proc_scsi_open</code><span class="sig-paren">(</span>struct inode *<em> inode</em>, struct file *<em> file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_open" title="Permalink to this definition">¶</a></dt>
<dd><p>glue function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>passed to single_open()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associates proc_scsi_show with this file</p>
<dl class="function">
<dt id="c.scsi_init_procfs">
int <code class="sig-name descname">scsi_init_procfs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_init_procfs" title="Permalink to this definition">¶</a></dt>
<dd><p>create scsi and scsi/scsi in procfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_exit_procfs">
void <code class="sig-name descname">scsi_exit_procfs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_exit_procfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove scsi/scsi and scsi from procfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<div class="section" id="drivers-scsi-scsi-netlink-c">
<h4>drivers/scsi/scsi_netlink.c<a class="headerlink" href="#drivers-scsi-scsi-netlink-c" title="Permalink to this headline">¶</a></h4>
<p>Infrastructure to provide async events from transports to userspace via
netlink, using a single NETLINK_SCSITRANSPORT protocol for all
transports. See <a class="reference external" href="http://marc.info/?l=linux-scsi&amp;m=115507374832500&amp;w=2">the original patch
submission</a> for
more details.</p>
<dl class="function">
<dt id="c.scsi_nl_rcv_msg">
void <code class="sig-name descname">scsi_nl_rcv_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_nl_rcv_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive message handler.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>socket receive buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Extracts message from a receive buffer.</dt><dd><p>Validates message header and calls appropriate transport message handler</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_netlink_init">
void <code class="sig-name descname">scsi_netlink_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by SCSI subsystem to initialize the SCSI transport netlink interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_netlink_exit">
void <code class="sig-name descname">scsi_netlink_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by SCSI subsystem to disable the SCSI transport netlink interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<div class="section" id="drivers-scsi-scsi-scan-c">
<h4>drivers/scsi/scsi_scan.c<a class="headerlink" href="#drivers-scsi-scsi-scan-c" title="Permalink to this headline">¶</a></h4>
<p>Scan a host to determine which (if any) devices are attached. The
general scanning/probing algorithm is as follows, exceptions are made to
it depending on device specific flags, compilation options, and global
variable (boot or module load time) settings. A specific LUN is scanned
via an INQUIRY command; if the LUN has a device attached, a scsi_device
is allocated and setup for it. For every id of every channel on the
given host, start by scanning LUN 0. Skip hosts that don’t respond at
all to a scan of LUN 0. Otherwise, if LUN 0 has a device attached,
allocate and setup a scsi_device for it. If target is SCSI-3 or up,
issue a REPORT LUN, and scan all of the LUNs returned by the REPORT LUN;
else, sequentially scan LUNs up until some maximum is reached, or a LUN
is seen that cannot have a device attached to it.</p>
<dl class="function">
<dt id="c.scsi_complete_async_scans">
int <code class="sig-name descname">scsi_complete_async_scans</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_complete_async_scans" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for asynchronous scans to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When this function returns, any host which started scanning before
this function was called will have finished its scan.  Hosts which
started scanning after this function was called may or may not have
finished.</p>
<dl class="function">
<dt id="c.scsi_unlock_floptical">
void <code class="sig-name descname">scsi_unlock_floptical</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, unsigned char *<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_unlock_floptical" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock device via a special MODE SENSE command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device to send command to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">result</span></code></dt><dd><p>area to store the result of the MODE SENSE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Send a vendor specific MODE SENSE (not a MODE SELECT) command.
Called for BLIST_KEY devices.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_alloc_sdev">
struct scsi_device * <code class="sig-name descname">scsi_alloc_sdev</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, u64<em> lun</em>, void *<em> hostdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and setup a scsi_Device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>which target to allocate a <code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_device</span></code> for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>which lun</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">hostdata</span></code></dt><dd><p>usually NULL and set by -&gt;slave_alloc instead</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate, initialize for io, and return a pointer to a scsi_Device.
Stores the <strong>shost</strong>, <strong>channel</strong>, <strong>id</strong>, and <strong>lun</strong> in the scsi_Device, and
adds scsi_Device to the appropriate list.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>scsi_Device pointer, or NULL on failure.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_target_reap_ref_release">
void <code class="sig-name descname">scsi_target_reap_ref_release</code><span class="sig-paren">(</span>struct kref *<em> kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_target_reap_ref_release" title="Permalink to this definition">¶</a></dt>
<dd><p>remove target from visibility</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt><dd><p>the reap_ref in the target being released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called on last put of reap_ref, which is the indication that no device
under this target is visible anymore, so render the target invisible in
sysfs.  Note: we have to be in user context here because the target reaps
should be done in places where the scsi device visibility is being removed.</p>
<dl class="function">
<dt id="c.scsi_alloc_target">
struct scsi_target * <code class="sig-name descname">scsi_alloc_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> parent</em>, int<em> channel</em>, uint<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_target" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a new or find an existing target</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent of the target (need not be a scsi host)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>target channel number (zero if no channels)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>target id number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return an existing target if one exists, provided it hasn’t already
gone into STARGET_DEL state, otherwise allocate a new target.</p>
<p>The target is returned with an incremented reference, so the caller
is responsible for both reaping and doing a last put</p>
<dl class="function">
<dt id="c.scsi_target_reap">
void <code class="sig-name descname">scsi_target_reap</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_target_reap" title="Permalink to this definition">¶</a></dt>
<dd><p>check to see if target is in use and destroy if not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>target to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used after removing a LUN or doing a last put of the target
it checks atomically that nothing is using the target and removes
it if so.</p>
<dl class="function">
<dt id="c.scsi_probe_lun">
int <code class="sig-name descname">scsi_probe_lun</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, unsigned char *<em> inq_result</em>, int<em> result_len</em>, blist_flags_t *<em> bflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_probe_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a single LUN using a SCSI INQUIRY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi_device to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">inq_result</span></code></dt><dd><p>area to store the INQUIRY result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">result_len</span></code></dt><dd><p>len of inq_result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*</span> <span class="pre">bflags</span></code></dt><dd><p>store any bflags found here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Probe the lun associated with <strong>req</strong> using a standard SCSI INQUIRY;</p>
<p>If the INQUIRY is successful, zero is returned and the
INQUIRY data is in <strong>inq_result</strong>; the scsi_level and INQUIRY length
are copied to the scsi_device any flags value is stored in <strong>*bflags</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_add_lun">
int <code class="sig-name descname">scsi_add_lun</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, unsigned char *<em> inq_result</em>, blist_flags_t *<em> bflags</em>, int<em> async</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and fully initialze a scsi_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>holds information to be stored in the new scsi_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">inq_result</span></code></dt><dd><p>holds the result of a previous INQUIRY to the LUN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*</span> <span class="pre">bflags</span></code></dt><dd><p>black/white list flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">async</span></code></dt><dd><p>1 if this device is being scanned asynchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize the scsi_device <strong>sdev</strong>.  Optionally set fields based
on values in <strong>*bflags</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device
SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_inq_str">
unsigned char * <code class="sig-name descname">scsi_inq_str</code><span class="sig-paren">(</span>unsigned char *<em> buf</em>, unsigned char *<em> inq</em>, unsigned<em> first</em>, unsigned<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_inq_str" title="Permalink to this definition">¶</a></dt>
<dd><p>print INQUIRY data from min to max index, strip trailing whitespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Output buffer with at least end-first+1 bytes of space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">inq</span></code></dt><dd><p>Inquiry buffer (input)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">first</span></code></dt><dd><p>Offset of string into inq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">end</span></code></dt><dd><p>Index after last character in inq</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_probe_and_add_lun">
int <code class="sig-name descname">scsi_probe_and_add_lun</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, u64<em> lun</em>, blist_flags_t *<em> bflagsp</em>, struct scsi_device **<em> sdevp</em>, enum scsi_scan_mode<em> rescan</em>, void *<em> hostdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_probe_and_add_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a LUN, if a LUN is found add it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>pointer to target device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>LUN of target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*</span> <span class="pre">bflagsp</span></code></dt><dd><p>store bflags here if not NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">**</span> <span class="pre">sdevp</span></code></dt><dd><p>probe the LUN corresponding to this scsi_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>if not equal to SCSI_SCAN_INITIAL skip some code only
needed on first scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">hostdata</span></code></dt><dd><p>passed to <a class="reference internal" href="#c.scsi_alloc_sdev" title="scsi_alloc_sdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_alloc_sdev()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Call scsi_probe_lun, if a LUN with an attached device is found,
allocate and set it up by calling scsi_add_lun.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device</p></li>
<li><dl class="simple">
<dt>SCSI_SCAN_TARGET_PRESENT: target responded, but no device is</dt><dd><p>attached at the LUN</p>
</dd>
</dl>
</li>
<li><p>SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</p></li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_sequential_lun_scan">
void <code class="sig-name descname">scsi_sequential_lun_scan</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, blist_flags_t<em> bflags</em>, int<em> scsi_level</em>, enum scsi_scan_mode<em> rescan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sequential_lun_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>sequentially scan a SCSI target</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>pointer to target structure to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">bflags</span></code></dt><dd><p>black/white list flag for LUN 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">scsi_level</span></code></dt><dd><p>Which version of the standard does this device adhere to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>passed to scsi_probe_add_lun()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generally, scan from LUN 1 (LUN 0 is assumed to already have been
scanned) to some maximum lun until a LUN is found with no device
attached. Use the bflags to figure out any oddities.</p>
<p>Modifies sdevscan-&gt;lun.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_report_lun_scan">
int <code class="sig-name descname">scsi_report_lun_scan</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em>, blist_flags_t<em> bflags</em>, enum scsi_scan_mode<em> rescan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_lun_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan using SCSI REPORT LUN results</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>which target</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">bflags</span></code></dt><dd><p>Zero or a mix of BLIST_NOLUN, BLIST_REPORTLUN2, or BLIST_NOREPORTLUN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>nonzero if we can skip code only needed on first scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.
Scan the resulting list of LUNs by calling scsi_probe_and_add_lun.</p>
<p>If BLINK_REPORTLUN2 is set, scan a target that supports more than 8
LUNs even if it’s older than SCSI-3.
If BLIST_NOREPORTLUN is set, return 1 always.
If BLIST_NOLUN is set, return 0 always.
If starget-&gt;no_report_luns is set, return 1 always.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0: scan completed (or no memory, so further scanning is futile)
1: could not scan with REPORT LUN</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_prep_async_scan">
struct async_scan_data * <code class="sig-name descname">scsi_prep_async_scan</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_prep_async_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for an async scan</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>the host which will be scanned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a cookie to be passed to <a class="reference internal" href="#c.scsi_finish_async_scan" title="scsi_finish_async_scan"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_finish_async_scan()</span></code></a></p>
<p>Tells the midlayer this host is going to do an asynchronous scan.
It reserves the host’s position in the scanning list and ensures
that other asynchronous scans started after this one won’t affect the
ordering of the discovered devices.</p>
<dl class="function">
<dt id="c.scsi_finish_async_scan">
void <code class="sig-name descname">scsi_finish_async_scan</code><span class="sig-paren">(</span>struct async_scan_data *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_finish_async_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous scan has finished</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">async_scan_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>cookie returned from earlier call to <a class="reference internal" href="#c.scsi_prep_async_scan" title="scsi_prep_async_scan"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_prep_async_scan()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the devices currently attached to this host have been found.
This function announces all the devices it has found to the rest
of the system.</p>
</div>
<div class="section" id="drivers-scsi-scsi-sysctl-c">
<h4>drivers/scsi/scsi_sysctl.c<a class="headerlink" href="#drivers-scsi-scsi-sysctl-c" title="Permalink to this headline">¶</a></h4>
<p>Set up the sysctl entry: “/dev/scsi/logging_level”
(DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.</p>
</div>
<div class="section" id="drivers-scsi-scsi-sysfs-c">
<h4>drivers/scsi/scsi_sysfs.c<a class="headerlink" href="#drivers-scsi-scsi-sysfs-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI sysfs interface routines.</p>
<dl class="function">
<dt id="c.scsi_remove_device">
void <code class="sig-name descname">scsi_remove_device</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a device from the scsi bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi_device to unregister</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_remove_target">
void <code class="sig-name descname">scsi_remove_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_target" title="Permalink to this definition">¶</a></dt>
<dd><p>try to remove a target and all its devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>generic starget or parent of generic stargets to be removed</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This is slightly racy.  It is possible that if the user
requests the addition of another device then the target won’t be
removed.</p>
</div>
<div class="section" id="drivers-scsi-hosts-c">
<h4>drivers/scsi/hosts.c<a class="headerlink" href="#drivers-scsi-hosts-c" title="Permalink to this headline">¶</a></h4>
<p>mid to lowlevel SCSI driver interface</p>
<dl class="function">
<dt id="c.scsi_remove_host">
void <code class="sig-name descname">scsi_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a scsi host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>a pointer to a scsi host to remove</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_add_host_with_dma">
int <code class="sig-name descname">scsi_add_host_with_dma</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dma_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_host_with_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>add a scsi host with dma device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host pointer to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>a struct device of type scsi class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dma_dev</span></code></dt><dd><p>dma device for the host</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>You rarely need to worry about this unless you’re in a
virtualised host environments, so use the simpler scsi_add_host()
function instead.</p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success / != 0 for error</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_alloc">
struct Scsi_Host * <code class="sig-name descname">scsi_host_alloc</code><span class="sig-paren">(</span>struct scsi_host_template *<em> sht</em>, int<em> privsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>register a scsi host adapter instance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt><dd><p>pointer to scsi host template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">privsize</span></code></dt><dd><p>extra bytes to allocate for driver</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<blockquote>
<div><p>Allocate a new Scsi_Host and perform basic initialization.
The host is not published to the scsi midlayer until scsi_add_host
is called.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>Pointer to a new Scsi_Host</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_lookup">
struct Scsi_Host * <code class="sig-name descname">scsi_host_lookup</code><span class="sig-paren">(</span>unsigned short<em> hostnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a Scsi_Host by host no</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">hostnum</span></code></dt><dd><p>host number to locate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>Return value:</dt><dd><p>A pointer to located Scsi_Host or NULL.</p>
<p>The caller must do a <a class="reference internal" href="#c.scsi_host_put" title="scsi_host_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_put()</span></code></a> to drop the reference
that <a class="reference internal" href="#c.scsi_host_get" title="scsi_host_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_get()</span></code></a> took. The <a class="reference internal" href="infrastructure.html#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> below dropped
the reference from <a class="reference internal" href="infrastructure.html#c.class_find_device" title="class_find_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_find_device()</span></code></a>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_get">
struct Scsi_Host * <code class="sig-name descname">scsi_host_get</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_get" title="Permalink to this definition">¶</a></dt>
<dd><p>inc a Scsi_Host ref count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_busy">
int <code class="sig-name descname">scsi_host_busy</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the host busy counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_put">
void <code class="sig-name descname">scsi_host_put</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_put" title="Permalink to this definition">¶</a></dt>
<dd><p>dec a Scsi_Host ref count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host to dec.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_queue_work">
int <code class="sig-name descname">scsi_queue_work</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct work_struct *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue work to the Scsi_Host workqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>Work to queue for execution.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>1 - work queued for execution
0 - work is already queued
-EINVAL - work queue doesn’t exist</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_flush_work">
void <code class="sig-name descname">scsi_flush_work</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_flush_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush a Scsi_Host’s workqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_host_complete_all_commands">
void <code class="sig-name descname">scsi_host_complete_all_commands</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_complete_all_commands" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate all running commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Scsi Host on which commands should be terminated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>Status to be set for the terminated commands</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no protection against modification of the number
of outstanding commands. It is the responsibility of the
caller to ensure that concurrent I/O submission and/or
completion is stopped when calling this function.</p>
<dl class="function">
<dt id="c.scsi_host_busy_iter">
void <code class="sig-name descname">scsi_host_busy_iter</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, bool (<em>*fn</em>)(struct scsi_cmnd *, void *, bool), void *<em> priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all busy commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*)(struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">bool)</span> <span class="pre">fn</span></code></dt><dd><p>Function to call on each busy command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt><dd><p>Data pointer passed to <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If locking against concurrent command completions is required
ithas to be provided by the caller</p>
</div>
<div class="section" id="drivers-scsi-scsi-common-c">
<h4>drivers/scsi/scsi_common.c<a class="headerlink" href="#drivers-scsi-scsi-common-c" title="Permalink to this headline">¶</a></h4>
<p>general support functions</p>
<dl class="function">
<dt id="c.scsi_device_type">
const char * <code class="sig-name descname">scsi_device_type</code><span class="sig-paren">(</span>unsigned<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 17-char string indicating device type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt><dd><p>type number to look up</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsilun_to_int">
u64 <code class="sig-name descname">scsilun_to_int</code><span class="sig-paren">(</span>struct scsi_lun *<em> scsilun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsilun_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a scsi_lun to an int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*</span> <span class="pre">scsilun</span></code></dt><dd><p>struct scsi_lun to be converted.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Convert <strong>scsilun</strong> from a struct scsi_lun to a four-byte host byte-ordered
integer, and return the result. The caller must check for
truncation before using this function.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>For a description of the LUN format, post SCSI-3 see the SCSI
Architecture Model, for SCSI-3 see the SCSI Controller Commands.</p>
<p>Given a struct scsi_lun of: d2 04 0b 03 00 00 00 00, this function
returns the integer: 0x0b03d204</p>
<p>This encoding will return a standard integer LUN for LUNs smaller
than 256, which typically use a single level LUN structure with
addressing method 0.</p>
</div></blockquote>
<dl class="function">
<dt id="c.int_to_scsilun">
void <code class="sig-name descname">int_to_scsilun</code><span class="sig-paren">(</span>u64<em> lun</em>, struct scsi_lun *<em> scsilun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int_to_scsilun" title="Permalink to this definition">¶</a></dt>
<dd><p>reverts an int into a scsi_lun</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>integer to be reverted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*</span> <span class="pre">scsilun</span></code></dt><dd><p>struct scsi_lun to be set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Reverts the functionality of the scsilun_to_int, which packed
an 8-byte lun value into an int. This routine unpacks the int
back into the lun value.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Given an integer : 0x0b03d204, this function returns a
struct scsi_lun of: d2 04 0b 03 00 00 00 00</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_normalize_sense">
bool <code class="sig-name descname">scsi_normalize_sense</code><span class="sig-paren">(</span>const u8 *<em> sense_buffer</em>, int<em> sb_len</em>, struct scsi_sense_hdr *<em> sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_normalize_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>normalize main elements from either fixed or descriptor sense data format into a common format.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buffer</span></code></dt><dd><p>byte array containing sense data returned by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*</span> <span class="pre">sshdr</span></code></dt><dd><p>pointer to instance of structure that common
elements are written to.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The “main elements” from sense data are: response_code, sense_key,
asc, ascq and additional_length (only for descriptor format).</p>
<p>Typically this function can be called after a device has
responded to a SCSI command with the CHECK_CONDITION status.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if valid sense data information found, else false;</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_sense_desc_find">
const u8 * <code class="sig-name descname">scsi_sense_desc_find</code><span class="sig-paren">(</span>const u8 *<em> sense_buffer</em>, int<em> sb_len</em>, int<em> desc_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sense_desc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>search for a given descriptor type in descriptor sense data format.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buffer</span></code></dt><dd><p>byte array of descriptor format sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc_type</span></code></dt><dd><p>value of descriptor type to find
(e.g. 0 -&gt; information)</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>only valid when sense data is in descriptor format</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>pointer to start of (first) descriptor if found else NULL</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_build_sense_buffer">
void <code class="sig-name descname">scsi_build_sense_buffer</code><span class="sig-paren">(</span>int<em> desc</em>, u8 *<em> buf</em>, u8<em> key</em>, u8<em> asc</em>, u8<em> ascq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_build_sense_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>build sense data in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc</span></code></dt><dd><p>Sense format (non-zero == descriptor format,
0 == fixed format)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt><dd><p>Sense key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">asc</span></code></dt><dd><p>Additional sense code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ascq</span></code></dt><dd><p>Additional sense code qualifier</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_set_sense_information">
int <code class="sig-name descname">scsi_set_sense_information</code><span class="sig-paren">(</span>u8 *<em> buf</em>, int<em> buf_len</em>, u64<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_information" title="Permalink to this definition">¶</a></dt>
<dd><p>set the information field in a formatted sense data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">info</span></code></dt><dd><p>64-bit information value to be set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
<dl class="function">
<dt id="c.scsi_set_sense_field_pointer">
int <code class="sig-name descname">scsi_set_sense_field_pointer</code><span class="sig-paren">(</span>u8 *<em> buf</em>, int<em> buf_len</em>, u16<em> fp</em>, u8<em> bp</em>, bool<em> cd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_field_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>set the field pointer sense key specific information in a formatted sense data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">fp</span></code></dt><dd><p>field pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">bp</span></code></dt><dd><p>bit pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cd</span></code></dt><dd><p>command/data bit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="transport-classes">
<h3>Transport classes<a class="headerlink" href="#transport-classes" title="Permalink to this headline">¶</a></h3>
<p>Transport classes are service libraries for drivers in the SCSI lower
layer, which expose transport attributes in sysfs.</p>
<div class="section" id="fibre-channel-transport">
<h4>Fibre Channel transport<a class="headerlink" href="#fibre-channel-transport" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_fc.c defines transport attributes
for Fibre Channel.</p>
<dl class="function">
<dt id="c.fc_get_event_number">
u32 <code class="sig-name descname">fc_get_event_number</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.fc_get_event_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the next sequential FC event number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We could have inlined this, but it would have required fc_event_seq to
be exposed. For now, live with the subroutine call.
Atomic used to avoid lock/unlock…</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_host_post_fc_event">
void <code class="sig-name descname">fc_host_post_fc_event</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, u32<em> event_number</em>, enum fc_host_event_code<em> event_code</em>, u32<em> data_len</em>, char *<em> data_buf</em>, u64<em> vendor_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_fc_event" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to do the work of posting an event on an fc_host.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">data_buf</span></code></dt><dd><p>pointer to event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>value for Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_host_post_event">
void <code class="sig-name descname">fc_host_post_event</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, u32<em> event_number</em>, enum fc_host_event_code<em> event_code</em>, u32<em> event_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_event" title="Permalink to this definition">¶</a></dt>
<dd><p>called to post an even on an fc_host.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_data</span></code></dt><dd><p>32bits of data for the event being posted</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_host_post_vendor_event">
void <code class="sig-name descname">fc_host_post_vendor_event</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, u32<em> event_number</em>, u32<em> data_len</em>, char *<em> data_buf</em>, u64<em> vendor_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_vendor_event" title="Permalink to this definition">¶</a></dt>
<dd><p>called to post a vendor unique event on an fc_host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">data_buf</span></code></dt><dd><p>pointer to vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_host_fpin_rcv">
void <code class="sig-name descname">fc_host_fpin_rcv</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, u32<em> fpin_len</em>, char *<em> fpin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_fpin_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to process a received FPIN.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>host the FPIN was received on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">fpin_len</span></code></dt><dd><p>length of FPIN payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">fpin_buf</span></code></dt><dd><p>pointer to FPIN payload</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_eh_timed_out">
enum blk_eh_timer_return <code class="sig-name descname">fc_eh_timed_out</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_eh_timed_out" title="Permalink to this definition">¶</a></dt>
<dd><p>FC Transport I/O timeout intercept handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>The SCSI command which timed out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine protects against error handlers getting invoked while a
rport is in a blocked state, typically due to a temporarily loss of
connectivity. If the error handlers are allowed to proceed, requests
to abort i/o, reset the target, etc will likely fail as there is no way
to communicate with the device to perform the requested function. These
failures may result in the midlayer taking the device offline, requiring
manual intervention to restore operation.</p>
<p>This routine, called whenever an i/o times out, validates the state of
the underlying rport. If the rport is blocked, it returns
EH_RESET_TIMER, which will continue to reschedule the timeout.
Eventually, either the device will return, or devloss_tmo will fire,
and when the timeout then fires, it will be handled normally.
If the rport is not blocked, normal error handling continues.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_remove_host">
void <code class="sig-name descname">fc_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>called to terminate any fc_transport-related elements for a scsi host.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Which <code class="xref c c-type docutils literal notranslate"><span class="pre">Scsi_Host</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is expected to be called immediately preceding the
a driver’s call to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>.</p>
<dl class="simple">
<dt>WARNING: A driver utilizing the fc_transport, which fails to call</dt><dd><p>this routine prior to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>, will leave dangling
objects in /sys/class/fc_remote_ports. Access to any of these
objects can result in a system crash !!!</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_remote_port_add">
struct fc_rport * <code class="sig-name descname">fc_remote_port_add</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, int<em> channel</em>, struct fc_rport_identifiers *<em> ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_add" title="Permalink to this definition">¶</a></dt>
<dd><p>notify fc transport of the existence of a remote FC port.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>Channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport_identifiers</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>The world wide names, fc address, and FC4 port
roles for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it’s FC address (port_id), and the FC4 roles that are
active for the port.</p>
<p>For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it’s target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.</p>
<p>This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.</p>
<p>Whenever a remote port is allocated, a new fc_remote_port class
device is created.</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_remote_port_delete">
void <code class="sig-name descname">fc_remote_port_delete</code><span class="sig-paren">(</span>struct fc_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the fc transport that a remote port is no longer in existence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>The remote port that no longer exists</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc_host. We do this under 2 conditions:</p>
<ol class="arabic simple">
<li><p>If the port was a scsi target, we delay its deletion by “blocking” it.
This allows the port to temporarily disappear, then reappear without
disrupting the SCSI device tree attached to it. During the “blocked”
period the port will still exist.</p></li>
<li><p>If the port was a scsi target and disappears for longer than we
expect, we’ll delete the port and the tear down the SCSI device tree
attached to it. However, we want to semi-persist the target id assigned
to that port if it eventually does exist. The port structure will
remain (although with minimal information) so that the target id
bindings also remain.</p></li>
</ol>
<p>If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc_remote_port class device.</p>
<p>If the remote port is an FCP Target, the port will be placed in a
temporary blocked state. From the LLDD’s perspective, the rport no
longer exists. From the SCSI midlayer’s perspective, the SCSI target
exists, but all sdevs on it are blocked from further I/O. The following
is then expected.</p>
<blockquote>
<div><p>If the remote port does not return (signaled by a LLDD call to
<a class="reference internal" href="#c.fc_remote_port_add" title="fc_remote_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">fc_remote_port_add()</span></code></a>) within the dev_loss_tmo timeout, then the
scsi target is removed - killing all outstanding i/o and removing the
scsi devices attached to it. The port structure will be marked Not
Present and be partially cleared, leaving only enough information to
recognize the remote port relative to the scsi target id binding if
it later appears.  The port will remain as long as there is a valid
binding (e.g. until the user changes the binding type or unloads the
scsi host with the binding).</p>
<p>If the remote port returns within the dev_loss_tmo value (and matches
according to the target id binding type), the port structure will be
reused. If it is no longer a SCSI target, the target will be torn
down. If it continues to be a SCSI target, then the target will be
unblocked (allowing i/o to be resumed), and a scan will be activated
to ensure that all luns are detected.</p>
</div></blockquote>
<p>Called from normal process context only - cannot be called from interrupt.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_remote_port_rolechg">
void <code class="sig-name descname">fc_remote_port_rolechg</code><span class="sig-paren">(</span>struct fc_rport *<em> rport</em>, u32<em> roles</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_rolechg" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the fc transport that the roles on a remote may have changed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>The remote port that changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">roles</span></code></dt><dd><p>New roles for this port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that the
roles on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn’t normal error processing
will take place).</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_block_rport">
int <code class="sig-name descname">fc_block_rport</code><span class="sig-paren">(</span>struct fc_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_rport" title="Permalink to this definition">¶</a></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>Remote port that scsi_eh is trying to recover.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.fc_block_scsi_eh">
int <code class="sig-name descname">fc_block_scsi_eh</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmnd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_scsi_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmnd</span></code></dt><dd><p>SCSI command that scsi_eh is trying to recover</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.fc_vport_create">
struct fc_vport * <code class="sig-name descname">fc_vport_create</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, int<em> channel</em>, struct fc_vport_identifiers *<em> ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Admin App or LLDD requests creation of a vport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host the virtual port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport_identifiers</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>The world wide names, FC4 port roles, etc for
the virtual port.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
<dl class="function">
<dt id="c.fc_vport_terminate">
int <code class="sig-name descname">fc_vport_terminate</code><span class="sig-paren">(</span>struct fc_vport *<em> vport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Admin App or LLDD requests termination of a vport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport</span> <span class="pre">*</span> <span class="pre">vport</span></code></dt><dd><p>fc_vport to be terminated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the LLDD vport_delete() function, then deallocates and removes
the vport from the shost and object tree.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<div class="section" id="iscsi-transport-class">
<h4>iSCSI transport class<a class="headerlink" href="#iscsi-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.</p>
<dl class="function">
<dt id="c.iscsi_create_flashnode_sess">
struct iscsi_bus_flash_session * <code class="sig-name descname">iscsi_create_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, int<em> index</em>, struct iscsi_transport *<em> transport</em>, int<em> dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode session entry in sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of flashnode to add in sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode session attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode sess on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.iscsi_create_flashnode_conn">
struct iscsi_bus_flash_conn * <code class="sig-name descname">iscsi_create_flashnode_conn</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct iscsi_bus_flash_session *<em> fnode_sess</em>, struct iscsi_transport *<em> transport</em>, int<em> dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode conn entry in sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt><dd><p>pointer to the parent flashnode session entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode connection attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode conn on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.iscsi_find_flashnode_sess">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">iscsi_find_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, void *<em> data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *dev, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode session entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>pointer to data containing value to use for comparison</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt><dd><p>function pointer that does actual comparison</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode session object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode session device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.iscsi_find_flashnode_conn">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">iscsi_find_flashnode_conn</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session *<em> fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode connection entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt><dd><p>pointer to parent flashnode session entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode connection object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode connection device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.iscsi_destroy_flashnode_sess">
void <code class="sig-name descname">iscsi_destroy_flashnode_sess</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session *<em> fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy flashnode session entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt><dd><p>pointer to flashnode session entry to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the flashnode session entry and all children flashnode connection
entries from sysfs</p>
<dl class="function">
<dt id="c.iscsi_destroy_all_flashnode">
void <code class="sig-name descname">iscsi_destroy_all_flashnode</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_all_flashnode" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy all flashnode session entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys all the flashnode session entries and all corresponding children
flashnode connection entries from sysfs</p>
<dl class="function">
<dt id="c.iscsi_scan_finished">
int <code class="sig-name descname">iscsi_scan_finished</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, unsigned long<em> time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_scan_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to report when running scans are done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">time</span></code></dt><dd><p>scan run time</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by drives like qla4xxx to report to the scsi
layer when the scans it kicked off at module load time are done.</p>
<dl class="function">
<dt id="c.iscsi_block_scsi_eh">
int <code class="sig-name descname">iscsi_block_scsi_eh</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_block_scsi_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>block scsi eh until session state has transistioned</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>scsi cmd passed to scsi eh handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the session is down this function will wait for the recovery
timer to fire or for the session to be logged back in. If the
recovery timer fires then FAST_IO_FAIL is returned. The caller
should pass this error value to the scsi eh.</p>
<dl class="function">
<dt id="c.iscsi_unblock_session">
void <code class="sig-name descname">iscsi_unblock_session</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em> session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_unblock_session" title="Permalink to this definition">¶</a></dt>
<dd><p>set a session as logged in and start IO.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt><dd><p>iscsi session</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a session as ready to accept IO.</p>
<dl class="function">
<dt id="c.iscsi_create_session">
struct iscsi_cls_session * <code class="sig-name descname">iscsi_create_session</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct iscsi_transport *<em> transport</em>, int<em> dd_size</em>, unsigned int<em> target_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_session" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi class session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt><dd><p>iscsi transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">target_id</span></code></dt><dd><p>which target</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport.</p>
<dl class="function">
<dt id="c.iscsi_create_conn">
struct iscsi_cls_conn * <code class="sig-name descname">iscsi_create_conn</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em> session</em>, int<em> dd_size</em>, uint32_t<em> cid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi class connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt><dd><p>iscsi cls session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">cid</span></code></dt><dd><p>connection id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport. The connection
is child of the session so cid must be unique for all connections
on the session.</p>
<p>Since we do not support MCS, cid will normally be zero. In some cases
for software iscsi we could be trying to preallocate a connection struct
in which case there could be two connection structs and cid would be
non-zero.</p>
<dl class="function">
<dt id="c.iscsi_destroy_conn">
int <code class="sig-name descname">iscsi_destroy_conn</code><span class="sig-paren">(</span>struct iscsi_cls_conn *<em> conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy iscsi class connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt><dd><p>iscsi cls session</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport.</p>
<dl class="function">
<dt id="c.iscsi_session_event">
int <code class="sig-name descname">iscsi_session_event</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em> session</em>, enum iscsi_uevent_e<em> event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send session destr. completion event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt><dd><p>iscsi class session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iscsi_uevent_e</span> <span class="pre">event</span></code></dt><dd><p>type of event</p>
</dd>
</dl>
</div>
<div class="section" id="serial-attached-scsi-sas-transport-class">
<h4>Serial Attached SCSI (SAS) transport class<a class="headerlink" href="#serial-attached-scsi-sas-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_sas.c defines transport
attributes for Serial Attached SCSI, a variant of SATA aimed at large
high-end systems.</p>
<p>The SAS transport class contains common code to deal with SAS HBAs, an
aproximated representation of SAS topologies in the driver model, and
various sysfs attributes to expose these topologies and management
interfaces to userspace.</p>
<p>In addition to the basic SCSI core objects this transport class
introduces two additional intermediate objects: The SAS PHY as
represented by struct sas_phy defines an “outgoing” PHY on a SAS HBA or
Expander, and the SAS remote PHY represented by struct sas_rphy defines
an “incoming” PHY on a SAS Expander or end device. Note that this is
purely a software concept, the underlying hardware for a PHY and a
remote PHY is the exactly the same.</p>
<p>There is no concept of a SAS port in this code, users can see what PHYs
form a wide port based on the port_identifier attribute, which is the
same for all PHYs in a port.</p>
<dl class="function">
<dt id="c.sas_remove_children">
void <code class="sig-name descname">sas_remove_children</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_children" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a devices SAS data structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device belonging to the sas object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given object</p>
<dl class="function">
<dt id="c.sas_remove_host">
void <code class="sig-name descname">sas_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a Scsi_Host’s SAS data structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the
Scsi_Host as well.</p>
<p><strong>Note</strong></p>
<p>Do not call <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a> on the Scsi_Host any more, as it is
already removed.</p>
<dl class="function">
<dt id="c.sas_get_address">
u64 <code class="sig-name descname">sas_get_address</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_get_address" title="Permalink to this definition">¶</a></dt>
<dd><p>return the SAS address of the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the SAS address of the scsi device</p>
<dl class="function">
<dt id="c.sas_tlr_supported">
unsigned int <code class="sig-name descname">sas_tlr_supported</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_tlr_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>checking TLR bit in vpd 0x90</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check Transport Layer Retries are supported or not.
If vpd page 0x90 is present, TRL is supported.</p>
<dl class="function">
<dt id="c.sas_disable_tlr">
void <code class="sig-name descname">sas_disable_tlr</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_disable_tlr" title="Permalink to this definition">¶</a></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag to 0.</p>
<dl class="function">
<dt id="c.sas_enable_tlr">
void <code class="sig-name descname">sas_enable_tlr</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_enable_tlr" title="Permalink to this definition">¶</a></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag 1.</p>
<dl class="function">
<dt id="c.sas_phy_alloc">
struct sas_phy * <code class="sig-name descname">sas_phy_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> parent</em>, int<em> number</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates and initialize a SAS PHY structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt><dd><p>Phy index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS PHY structure.  It will be added in the device tree
below the device specified by <strong>parent</strong>, which has to be either a Scsi_Host
or sas_rphy.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_phy_add">
int <code class="sig-name descname">sas_phy_add</code><span class="sig-paren">(</span>struct sas_phy *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS PHY to the device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>The PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS PHY to the rest of the system.</p>
<dl class="function">
<dt id="c.sas_phy_free">
void <code class="sig-name descname">sas_phy_free</code><span class="sig-paren">(</span>struct sas_phy *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>SAS PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PHY that has not
successfully been added using <a class="reference internal" href="#c.sas_phy_add" title="sas_phy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_phy_add()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_phy_delete">
void <code class="sig-name descname">sas_phy_delete</code><span class="sig-paren">(</span>struct sas_phy *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>SAS PHY to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PHY.  If the SAS PHY has an
associated remote PHY it is removed before.</p>
<dl class="function">
<dt id="c.scsi_is_sas_phy">
int <code class="sig-name descname">scsi_is_sas_phy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a struct device represents a SAS PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_port_add">
int <code class="sig-name descname">sas_port_add</code><span class="sig-paren">(</span>struct sas_port *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS port to the device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>publishes a port to the rest of the system</p>
<dl class="function">
<dt id="c.sas_port_free">
void <code class="sig-name descname">sas_port_free</code><span class="sig-paren">(</span>struct sas_port *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS PORT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>SAS PORT to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PORT.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PORT that has not
successfully been added using <a class="reference internal" href="#c.sas_port_add" title="sas_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_port_add()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_port_delete">
void <code class="sig-name descname">sas_port_delete</code><span class="sig-paren">(</span>struct sas_port *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS PORT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>SAS PORT to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PORT.  If the SAS PORT has an
associated phys, unlink them from the port as well.</p>
<dl class="function">
<dt id="c.scsi_is_sas_port">
int <code class="sig-name descname">scsi_is_sas_port</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_port" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a struct device represents a SAS port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS Port, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_port_get_phy">
struct sas_phy * <code class="sig-name descname">sas_port_get_phy</code><span class="sig-paren">(</span>struct sas_port *<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_get_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>try to take a reference on a port member</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sas_port_add_phy">
void <code class="sig-name descname">sas_port_add_phy</code><span class="sig-paren">(</span>struct sas_port *<em> port</em>, struct sas_phy *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>add another phy to a port to form a wide port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to add the phy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>phy to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a port is initially created, it is empty (has no phys).  All
ports must have at least one phy to operated, and all wide ports
must have at least two.  The current code makes no difference
between ports and wide ports, but the only object that can be
connected to a remote device is a port, so ports must be formed on
all devices with phys if they’re connected to anything.</p>
<dl class="function">
<dt id="c.sas_port_delete_phy">
void <code class="sig-name descname">sas_port_delete_phy</code><span class="sig-paren">(</span>struct sas_port *<em> port</em>, struct sas_phy *<em> phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a phy from a port or wide port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt><dd><p>port to remove the phy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt><dd><p>phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is used for tearing down ports again.  It must be
done to every port or wide port before calling sas_port_delete.</p>
<dl class="function">
<dt id="c.sas_end_device_alloc">
struct sas_rphy * <code class="sig-name descname">sas_end_device_alloc</code><span class="sig-paren">(</span>struct sas_port *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_end_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>which port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_expander_alloc">
struct sas_rphy * <code class="sig-name descname">sas_expander_alloc</code><span class="sig-paren">(</span>struct sas_port *<em> parent</em>, enum sas_device_type<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_expander_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>which port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sas_device_type</span> <span class="pre">type</span></code></dt><dd><p>SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_rphy_add">
int <code class="sig-name descname">sas_rphy_add</code><span class="sig-paren">(</span>struct sas_rphy *<em> rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS remote PHY to the device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*</span> <span class="pre">rphy</span></code></dt><dd><p>The remote PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS remote PHY to the rest of the system.</p>
<dl class="function">
<dt id="c.sas_rphy_free">
void <code class="sig-name descname">sas_rphy_free</code><span class="sig-paren">(</span>struct sas_rphy *<em> rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS remote PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*</span> <span class="pre">rphy</span></code></dt><dd><p>SAS remote PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS remote PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a remote
PHY that has not successfully been added using
<a class="reference internal" href="#c.sas_rphy_add" title="sas_rphy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_add()</span></code></a> (or has been <a class="reference internal" href="#c.sas_rphy_remove" title="sas_rphy_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_remove()</span></code></a>’d)</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_rphy_delete">
void <code class="sig-name descname">sas_rphy_delete</code><span class="sig-paren">(</span>struct sas_rphy *<em> rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and free SAS remote PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*</span> <span class="pre">rphy</span></code></dt><dd><p>SAS remote PHY to remove and free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY and frees it.</p>
<dl class="function">
<dt id="c.sas_rphy_unlink">
void <code class="sig-name descname">sas_rphy_unlink</code><span class="sig-paren">(</span>struct sas_rphy *<em> rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink SAS remote PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*</span> <span class="pre">rphy</span></code></dt><dd><p>SAS remote phy to unlink from its parent port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes port reference to an rphy</p>
<dl class="function">
<dt id="c.sas_rphy_remove">
void <code class="sig-name descname">sas_rphy_remove</code><span class="sig-paren">(</span>struct sas_rphy *<em> rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS remote PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*</span> <span class="pre">rphy</span></code></dt><dd><p>SAS remote phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY.</p>
<dl class="function">
<dt id="c.scsi_is_sas_rphy">
int <code class="sig-name descname">scsi_is_sas_rphy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_rphy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a struct device represents a SAS remote PHY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS remote PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
<dl class="function">
<dt id="c.sas_attach_transport">
struct scsi_transport_template * <code class="sig-name descname">sas_attach_transport</code><span class="sig-paren">(</span>struct sas_function_template *<em> ft</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_attach_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate SAS transport template</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_function_template</span> <span class="pre">*</span> <span class="pre">ft</span></code></dt><dd><p>SAS transport class function template</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sas_release_transport">
void <code class="sig-name descname">sas_release_transport</code><span class="sig-paren">(</span>struct scsi_transport_template *<em> t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_release_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>release SAS transport template instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
<div class="section" id="sata-transport-class">
<h4>SATA transport class<a class="headerlink" href="#sata-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The SATA transport is handled by libata, which has its own book of
documentation in this directory.</p>
</div>
<div class="section" id="parallel-scsi-spi-transport-class">
<h4>Parallel SCSI (SPI) transport class<a class="headerlink" href="#parallel-scsi-spi-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_spi.c defines transport
attributes for traditional (fast/wide/ultra) SCSI busses.</p>
<dl class="function">
<dt id="c.spi_schedule_dv_device">
void <code class="sig-name descname">spi_schedule_dv_device</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_schedule_dv_device" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule domain validation to occur on the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>The device to validate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Identical to spi_dv_device() above, except that the DV will be
scheduled to occur in a workqueue later.  All memory allocations
are atomic, so may be called from any context including those holding
SCSI locks.</p>
</div></blockquote>
<dl class="function">
<dt id="c.spi_display_xfer_agreement">
void <code class="sig-name descname">spi_display_xfer_agreement</code><span class="sig-paren">(</span>struct scsi_target *<em> starget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_display_xfer_agreement" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the current target transfer agreement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*</span> <span class="pre">starget</span></code></dt><dd><p>The target for which to display the agreement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each SPI port is required to maintain a transfer agreement for each
other port on the bus.  This function prints a one-line summary of
the current agreement; more detailed information is available in sysfs.</p>
<dl class="function">
<dt id="c.spi_populate_tag_msg">
int <code class="sig-name descname">spi_populate_tag_msg</code><span class="sig-paren">(</span>unsigned char *<em> msg</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_populate_tag_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>place a tag message in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt><dd><p>pointer to the area to place the tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>pointer to the scsi command for the tag</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>designed to create the correct type of tag message for the
particular request.  Returns the size of the tag message.
May return 0 if TCQ is disabled for this device.</p>
</div></blockquote>
</div>
<div class="section" id="scsi-rdma-srp-transport-class">
<h4>SCSI RDMA (SRP) transport class<a class="headerlink" href="#scsi-rdma-srp-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_srp.c defines transport
attributes for SCSI over Remote Direct Memory Access.</p>
<dl class="function">
<dt id="c.srp_tmo_valid">
int <code class="sig-name descname">srp_tmo_valid</code><span class="sig-paren">(</span>int<em> reconnect_delay</em>, int<em> fast_io_fail_tmo</em>, long<em> dev_loss_tmo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_tmo_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check timeout combination validity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reconnect_delay</span></code></dt><dd><p>Reconnect delay in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fast_io_fail_tmo</span></code></dt><dd><p>Fast I/O fail timeout in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">dev_loss_tmo</span></code></dt><dd><p>Device loss timeout in seconds.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The combination of the timeout parameters must be such that SCSI commands
are finished in a reasonable time. Hence do not allow the fast I/O fail
timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to
exceed that limit if failing I/O fast has been disabled. Furthermore, these
parameters must be such that multipath can detect failed paths timely.
Hence do not allow all three parameters to be disabled simultaneously.</p>
<dl class="function">
<dt id="c.srp_start_tl_fail_timers">
void <code class="sig-name descname">srp_start_tl_fail_timers</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_start_tl_fail_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>start the transport layer failure timers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the transport layer fast I/O failure and device loss timers. Do not
modify a timer that was already started.</p>
<dl class="function">
<dt id="c.srp_reconnect_rport">
int <code class="sig-name descname">srp_reconnect_rport</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_reconnect_rport" title="Permalink to this definition">¶</a></dt>
<dd><p>reconnect to an SRP target port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks SCSI command queueing before invoking reconnect() such that
queuecommand() won’t be invoked concurrently with reconnect() from outside
the SCSI EH. This is important since a reconnect() implementation may
reallocate resources needed by queuecommand().</p>
<p><strong>Notes</strong></p>
<ul class="simple">
<li><p>This function neither waits until outstanding requests have finished nor
tries to abort these. It is the responsibility of the reconnect()
function to finish outstanding commands before reconnecting to the target
port.</p></li>
<li><p>It is the responsibility of the caller to ensure that the resources
reallocated by the reconnect() function won’t be used while this function
is in progress. One possible strategy is to invoke this function from
the context of the SCSI EH thread only. Another possible strategy is to
lock the rport mutex inside each SCSI LLD callback that can be invoked by
the SCSI EH (the scsi_host_template.eh_*() functions and also the
scsi_host_template.queuecommand() function).</p></li>
</ul>
<dl class="function">
<dt id="c.srp_timed_out">
enum blk_eh_timer_return <code class="sig-name descname">srp_timed_out</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_timed_out" title="Permalink to this definition">¶</a></dt>
<dd><p>SRP transport intercept of the SCSI timeout EH</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">scmd</span></code></dt><dd><p>SCSI command.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a timeout occurs while an rport is in the blocked state, ask the SCSI
EH to continue waiting (BLK_EH_RESET_TIMER). Otherwise let the SCSI core
handle the timeout (BLK_EH_DONE).</p>
<p><strong>Note</strong></p>
<p>This function is called from soft-IRQ context and with the request
queue lock held.</p>
<dl class="function">
<dt id="c.srp_rport_get">
void <code class="sig-name descname">srp_rport_get</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increment rport reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.srp_rport_put">
void <code class="sig-name descname">srp_rport_put</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement rport reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.srp_rport_add">
struct srp_rport * <code class="sig-name descname">srp_rport_add</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct srp_rport_identifiers *<em> ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SRP remote port to the device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport_identifiers</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>The port id for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a port to the rest of the system.</p>
<dl class="function">
<dt id="c.srp_rport_del">
void <code class="sig-name descname">srp_rport_del</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a SRP remote port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP remote port to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SRP remote port.</p>
<dl class="function">
<dt id="c.srp_remove_host">
void <code class="sig-name descname">srp_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a Scsi_Host’s SRP data structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SRP remote ports for a given Scsi_Host.
Must be called just before scsi_remove_host for SRP HBAs.</p>
<dl class="function">
<dt id="c.srp_stop_rport_timers">
void <code class="sig-name descname">srp_stop_rport_timers</code><span class="sig-paren">(</span>struct srp_rport *<em> rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_stop_rport_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the transport layer recovery timers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*</span> <span class="pre">rport</span></code></dt><dd><p>SRP remote port for which to stop the timers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.srp_remove_host" title="srp_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">srp_remove_host()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>. The caller
must hold a reference on the rport (rport-&gt;dev) and on the SCSI host
(rport-&gt;dev.parent).</p>
<dl class="function">
<dt id="c.srp_attach_transport">
struct scsi_transport_template * <code class="sig-name descname">srp_attach_transport</code><span class="sig-paren">(</span>struct srp_function_template *<em> ft</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_attach_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate SRP transport template</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_function_template</span> <span class="pre">*</span> <span class="pre">ft</span></code></dt><dd><p>SRP transport class function template</p>
</dd>
</dl>
<dl class="function">
<dt id="c.srp_release_transport">
void <code class="sig-name descname">srp_release_transport</code><span class="sig-paren">(</span>struct scsi_transport_template *<em> t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_release_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>release SRP transport template instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="scsi-lower-layer">
<h2>SCSI lower layer<a class="headerlink" href="#scsi-lower-layer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="host-bus-adapter-transport-types">
<h3>Host Bus Adapter transport types<a class="headerlink" href="#host-bus-adapter-transport-types" title="Permalink to this headline">¶</a></h3>
<p>Many modern device controllers use the SCSI command set as a protocol to
communicate with their devices through many different types of physical
connections.</p>
<p>In SCSI language a bus capable of carrying SCSI commands is called a
“transport”, and a controller connecting to such a bus is called a “host
bus adapter” (HBA).</p>
<div class="section" id="debug-transport">
<h4>Debug transport<a class="headerlink" href="#debug-transport" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_debug.c simulates a host adapter with a
variable number of disks (or disk like devices) attached, sharing a
common amount of RAM. Does a lot of checking to make sure that we are
not getting blocks mixed up, and panics the kernel if anything out of
the ordinary is seen.</p>
<p>To be more realistic, the simulated devices have the transport
attributes of SAS disks.</p>
<p>For documentation see <a class="reference external" href="http://sg.danny.cz/sg/sdebug26.html">http://sg.danny.cz/sg/sdebug26.html</a></p>
</div>
<div class="section" id="todo">
<h4>todo<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h4>
<p>Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel,
FireWire, ATAPI devices, Infiniband, I2O, Parallel ports,
netlink…</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="libata.html" class="btn btn-neutral float-right" title="libATA Developer’s Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="edac.html" class="btn btn-neutral float-left" title="Error Detection And Correction (EDAC) Devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>