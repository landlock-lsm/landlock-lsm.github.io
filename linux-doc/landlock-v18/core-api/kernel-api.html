

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux Kernel API &mdash; The Linux Kernel 5.7.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Concurrency Managed Workqueue (cmwq)" href="workqueue.html" />
    <link rel="prev" title="Core API Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Linux Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list-management-functions">List Management Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-c-library-functions">Basic C Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-kernel-library-functions">Basic Kernel Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crc-and-math-functions-in-linux">CRC and Math Functions in Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-ipc-facilities">Kernel IPC facilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fifo-buffer">FIFO Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relay-interface-support">relay interface support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-support">Module Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interfaces">Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security-framework">Security Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audit-interfaces">Audit Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accounting-framework">Accounting Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-devices">Block Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#char-devices">Char devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-framework">Clock Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-primitives">Synchronization Primitives</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="symbol-namespaces.html">Symbol Namespaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>The Linux Kernel API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/kernel-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-kernel-api">
<h1>The Linux Kernel API<a class="headerlink" href="#the-linux-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-management-functions">
<h2>List Management Functions<a class="headerlink" href="#list-management-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.INIT_LIST_HEAD">
void <code class="sig-name descname">INIT_LIST_HEAD</code><span class="sig-paren">(</span>struct list_head *<em> list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_LIST_HEAD" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a list_head structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>list_head structure to be initialized.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the list_head to point to itself.  If it is a list header,
the result is an empty list.</p>
<dl class="function">
<dt id="c.list_add">
void <code class="sig-name descname">list_add</code><span class="sig-paren">(</span>struct list_head *<em> new</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<dl class="function">
<dt id="c.list_add_tail">
void <code class="sig-name descname">list_add_tail</code><span class="sig-paren">(</span>struct list_head *<em> new</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list head to add it before</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<dl class="function">
<dt id="c.list_del">
void <code class="sig-name descname">list_del</code><span class="sig-paren">(</span>struct list_head *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
<dl class="function">
<dt id="c.list_replace">
void <code class="sig-name descname">list_replace</code><span class="sig-paren">(</span>struct list_head *<em> old</em>, struct list_head *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
<dl class="function">
<dt id="c.list_replace_init">
void <code class="sig-name descname">list_replace_init</code><span class="sig-paren">(</span>struct list_head *<em> old</em>, struct list_head *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_init" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one and initialize the old one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
<dl class="function">
<dt id="c.list_swap">
void <code class="sig-name descname">list_swap</code><span class="sig-paren">(</span>struct list_head *<em> entry1</em>, struct list_head *<em> entry2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_swap" title="Permalink to this definition">¶</a></dt>
<dd><p>replace entry1 with entry2 and re-add entry1 at entry2’s position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry1</span></code></dt><dd><p>the location to place entry2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry2</span></code></dt><dd><p>the location to place entry1</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_del_init">
void <code class="sig-name descname">list_del_init</code><span class="sig-paren">(</span>struct list_head *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_move">
void <code class="sig-name descname">list_move</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another’s head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head that will precede our entry</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_move_tail">
void <code class="sig-name descname">list_move_tail</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another’s tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_bulk_move_tail">
void <code class="sig-name descname">list_bulk_move_tail</code><span class="sig-paren">(</span>struct list_head *<em> head</em>, struct list_head *<em> first</em>, struct list_head *<em> last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_bulk_move_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>move a subsection of a list to its tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">first</span></code></dt><dd><p>first entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">last</span></code></dt><dd><p>last entry to move, can be the same as first</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move all entries between <strong>first</strong> and including <strong>last</strong> before <strong>head</strong>.
All three entries must belong to the same linked list.</p>
<dl class="function">
<dt id="c.list_is_first">
int <code class="sig-name descname">list_is_first</code><span class="sig-paren">(</span>const struct list_head *<em> list</em>, const struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_first" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>tests whether <strong>list</strong> is the first entry in list <strong>head</strong></p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_is_last">
int <code class="sig-name descname">list_is_last</code><span class="sig-paren">(</span>const struct list_head *<em> list</em>, const struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_empty">
int <code class="sig-name descname">list_empty</code><span class="sig-paren">(</span>const struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_empty_careful">
int <code class="sig-name descname">list_empty_careful</code><span class="sig-paren">(</span>const struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the list to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a> it.</p>
<dl class="function">
<dt id="c.list_rotate_left">
void <code class="sig-name descname">list_rotate_left</code><span class="sig-paren">(</span>struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_rotate_to_front">
void <code class="sig-name descname">list_rotate_to_front</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_to_front" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate list to specific item.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>The desired new front of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>The head of the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rotates list so that <strong>list</strong> becomes the new front of the list.</p>
<dl class="function">
<dt id="c.list_is_singular">
int <code class="sig-name descname">list_is_singular</code><span class="sig-paren">(</span>const struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_cut_position">
void <code class="sig-name descname">list_cut_position</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em>, struct list_head *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>an entry within head, could be the head itself
and if so we won’t cut the list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
<dl class="function">
<dt id="c.list_cut_before">
void <code class="sig-name descname">list_cut_before</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em>, struct list_head *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_before" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two, before given entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>an entry within head, could be the head itself</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to but
excluding <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>.  You should pass
in <strong>entry</strong> an element you know is on <strong>head</strong>.  <strong>list</strong> should
be an empty list or a list you do not care about losing
its data.
If <strong>entry</strong> == <strong>head</strong>, all entries on <strong>head</strong> are moved to
<strong>list</strong>.</p>
<dl class="function">
<dt id="c.list_splice">
void <code class="sig-name descname">list_splice</code><span class="sig-paren">(</span>const struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail">
void <code class="sig-name descname">list_splice_tail</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_init">
void <code class="sig-name descname">list_splice_init</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_splice_tail_init">
void <code class="sig-name descname">list_splice_tail_init</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_entry">
<code class="sig-name descname">list_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_first_entry">
<code class="sig-name descname">list_first_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_last_entry">
<code class="sig-name descname">list_last_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_last_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_first_entry_or_null">
<code class="sig-name descname">list_first_entry_or_null</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry_or_null" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<dl class="function">
<dt id="c.list_next_entry">
<code class="sig-name descname">list_next_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_prev_entry">
<code class="sig-name descname">list_prev_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prev_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prev element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each">
<code class="sig-name descname">list_for_each</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_continue">
<code class="sig-name descname">list_for_each_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over a list, continuing after the current position.</p>
<dl class="function">
<dt id="c.list_for_each_prev">
<code class="sig-name descname">list_for_each_prev</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_safe">
<code class="sig-name descname">list_for_each_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev_safe">
<code class="sig-name descname">list_for_each_prev_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry">
<code class="sig-name descname">list_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_reverse">
<code class="sig-name descname">list_for_each_entry_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_prepare_entry">
<code class="sig-name descname">list_prepare_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prepare_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a start point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue">
<code class="sig-name descname">list_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_reverse">
<code class="sig-name descname">list_for_each_entry_continue_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards from the given point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from">
<code class="sig-name descname">list_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_reverse">
<code class="sig-name descname">list_for_each_entry_from_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe">
<code class="sig-name descname">list_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_safe_continue">
<code class="sig-name descname">list_for_each_entry_safe_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue list iteration safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_from">
<code class="sig-name descname">list_for_each_entry_safe_from</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list from current point safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_reverse">
<code class="sig-name descname">list_for_each_entry_safe_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
<dl class="function">
<dt id="c.list_safe_reset_next">
<code class="sig-name descname">list_safe_reset_next</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_safe_reset_next" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a stale list_for_each_entry_safe loop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the loop cursor used in the list_for_each_entry_safe loop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>temporary storage used in list_for_each_entry_safe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
<dl class="function">
<dt id="c.hlist_unhashed">
int <code class="sig-name descname">hlist_unhashed</code><span class="sig-paren">(</span>const struct hlist_node *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed" title="Permalink to this definition">¶</a></dt>
<dd><p>Has node been removed from list and reinitialized?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not that not all removal functions will leave a node in unhashed
state.  For example, <a class="reference internal" href="#c.hlist_nulls_del_init_rcu" title="hlist_nulls_del_init_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_init_rcu()</span></code></a> does leave the
node in unhashed state, but hlist_nulls_del() does not.</p>
<dl class="function">
<dt id="c.hlist_unhashed_lockless">
int <code class="sig-name descname">hlist_unhashed_lockless</code><span class="sig-paren">(</span>const struct hlist_node *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of hlist_unhashed for lockless use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.hlist_unhashed" title="hlist_unhashed"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_unhashed()</span></code></a> must be used in lockless contexts
to avoid potential load-tearing.  The READ_ONCE() is paired with the
various WRITE_ONCE() in hlist helpers that are defined below.</p>
<dl class="function">
<dt id="c.hlist_empty">
int <code class="sig-name descname">hlist_empty</code><span class="sig-paren">(</span>const struct hlist_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the specified hlist_head structure an empty hlist?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>Structure to check.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_del">
void <code class="sig-name descname">hlist_del</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the specified hlist_node from its list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in hashed state.  Use
<a class="reference internal" href="#c.hlist_del_init" title="hlist_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_init()</span></code></a> or similar instead to unhash <strong>n</strong>.</p>
<dl class="function">
<dt id="c.hlist_del_init">
void <code class="sig-name descname">hlist_del_init</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the specified hlist_node from its list and initialize</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in unhashed state.</p>
<dl class="function">
<dt id="c.hlist_add_head">
void <code class="sig-name descname">hlist_add_head</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry at the beginning of the hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>hlist head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<dl class="function">
<dt id="c.hlist_add_before">
void <code class="sig-name descname">hlist_add_before</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_node *<em> next</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry before the one specified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">next</span></code></dt><dd><p>hlist node to add it before, which must be non-NULL</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_add_behind">
void <code class="sig-name descname">hlist_add_behind</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_node *<em> prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry after the one specified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt><dd><p>hlist node to add it after, which must be non-NULL</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_add_fake">
void <code class="sig-name descname">hlist_add_fake</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_fake" title="Permalink to this definition">¶</a></dt>
<dd><p>create a fake hlist consisting of a single headless node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>Node to make a fake list out of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This makes <strong>n</strong> appear to be its own predecessor on a headless hlist.
The point of this is to allow things like <a class="reference internal" href="#c.hlist_del" title="hlist_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del()</span></code></a> to work correctly
in cases where there is no list.</p>
<dl class="function">
<dt id="c.hlist_fake">
bool <code class="sig-name descname">hlist_fake</code><span class="sig-paren">(</span>struct hlist_node *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_fake" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>Node to check for being a self-referential fake hlist.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_is_singular_node">
bool <code class="sig-name descname">hlist_is_singular_node</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_is_singular_node" title="Permalink to this definition">¶</a></dt>
<dd><p>is node the only element of the specified hlist?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>Node to check for singularity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>Header for potentially singular list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the node is the only node of the head without
accessing head, thus avoiding unnecessary cache misses.</p>
<dl class="function">
<dt id="c.hlist_move_list">
void <code class="sig-name descname">hlist_move_list</code><span class="sig-paren">(</span>struct hlist_head *<em> old</em>, struct hlist_head *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_move_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Move an hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>hlist_head for old list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>hlist_head for new list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move a list from one list head to another. Fixup the pprev
reference of the first entry if it exists.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry">
<code class="sig-name descname">hlist_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue">
<code class="sig-name descname">hlist_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from">
<code class="sig-name descname">hlist_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_safe">
<code class="sig-name descname">hlist_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<div class="section" id="basic-c-library-functions">
<h2>Basic C Library Functions<a class="headerlink" href="#basic-c-library-functions" title="Permalink to this headline">¶</a></h2>
<p>When writing drivers, you cannot in general use routines which are from
the C Library. Some of the functions have been found generally useful
and they are listed below. The behaviour of these functions may vary
slightly from those defined by ANSI, and these deviations are noted in
the text.</p>
<div class="section" id="string-conversions">
<h3>String Conversions<a class="headerlink" href="#string-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.simple_strtoull">
unsigned long long <code class="sig-name descname">simple_strtoull</code><span class="sig-paren">(</span>const char *<em> cp</em>, char **<em> endp</em>, unsigned int<em> base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoull instead.</p>
<dl class="function">
<dt id="c.simple_strtoul">
unsigned long <code class="sig-name descname">simple_strtoul</code><span class="sig-paren">(</span>const char *<em> cp</em>, char **<em> endp</em>, unsigned int<em> base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoul instead.</p>
<dl class="function">
<dt id="c.simple_strtol">
long <code class="sig-name descname">simple_strtol</code><span class="sig-paren">(</span>const char *<em> cp</em>, char **<em> endp</em>, unsigned int<em> base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtol instead.</p>
<dl class="function">
<dt id="c.simple_strtoll">
long long <code class="sig-name descname">simple_strtoll</code><span class="sig-paren">(</span>const char *<em> cp</em>, char **<em> endp</em>, unsigned int<em> base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoll instead.</p>
<dl class="function">
<dt id="c.vsnprintf">
int <code class="sig-name descname">vsnprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, va_list<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function generally follows C99 vsnprintf, but has some
extensions and a few limitations:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">``n``</span></code> is unsupported</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">``p``*</span></code> is handled by pointer()</p></li>
</ul>
</div></blockquote>
<p>See pointer() or Documentation/core-api/printk-formats.rst for more
extensive description.</p>
<p><strong>Please update the documentation in both places when making changes</strong></p>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
‘0’, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing ‘0’), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a>.</p>
<dl class="function">
<dt id="c.vscnprintf">
int <code class="sig-name descname">vscnprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, va_list<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vscnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which have been written into
the <strong>buf</strong> not including the trailing ‘0’. If <strong>size</strong> is == 0 the function
returns 0.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.snprintf">
int <code class="sig-name descname">snprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
<strong>size</strong>, the resulting string is truncated.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.scnprintf">
int <code class="sig-name descname">scnprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.scnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters written into <strong>buf</strong> not including
the trailing ‘0’. If <strong>size</strong> is == 0 the function returns 0.</p>
<dl class="function">
<dt id="c.vsprintf">
int <code class="sig-name descname">vsprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, const char *<em> fmt</em>, va_list<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> or <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.sprintf">
int <code class="sig-name descname">sprintf</code><span class="sig-paren">(</span>char *<em> buf</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a> or <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.vbin_printf">
int <code class="sig-name descname">vbin_printf</code><span class="sig-paren">(</span>u32 *<em> bin_buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, va_list<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vbin_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args’ binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt><dd><p>The buffer to place args’ binary value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer(by words(32bits), not characters)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format follows C99 vsnprintf, except <code class="docutils literal notranslate"><span class="pre">n</span></code> is ignored, and its argument
is skipped.</p>
<p>The return value is the number of words(32bits) which would be generated for
the given input.</p>
<p><strong>NOTE</strong></p>
<p>If the return value is greater than <strong>size</strong>, the resulting bin_buf is NOT
valid for <a class="reference internal" href="#c.bstr_printf" title="bstr_printf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bstr_printf()</span></code></a>.</p>
<dl class="function">
<dt id="c.bstr_printf">
int <code class="sig-name descname">bstr_printf</code><span class="sig-paren">(</span>char *<em> buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, const u32 *<em> bin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bstr_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string from binary arguments and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt><dd><p>Binary arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function like C99 vsnprintf, but the difference is that vsnprintf gets
arguments from stack, and bstr_printf gets arguments from <strong>bin_buf</strong> which is
a binary buffer that generated by vbin_printf.</p>
<dl class="simple">
<dt>The format follows C99 vsnprintf, but has some extensions:</dt><dd><p>see vsnprintf comment for details.</p>
</dd>
</dl>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
‘0’, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing ‘0’), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<dl class="function">
<dt id="c.bprintf">
int <code class="sig-name descname">bprintf</code><span class="sig-paren">(</span>u32 *<em> bin_buf</em>, size_t<em> size</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.bprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args’ binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt><dd><p>The buffer to place args’ binary value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer(by words(32bits), not characters)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of words(u32) written
into <strong>bin_buf</strong>.</p>
<dl class="function">
<dt id="c.vsscanf">
int <code class="sig-name descname">vsscanf</code><span class="sig-paren">(</span>const char *<em> buf</em>, const char *<em> fmt</em>, va_list<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>format of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sscanf">
int <code class="sig-name descname">sscanf</code><span class="sig-paren">(</span>const char *<em> buf</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>formatting of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>resulting arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kstrtol">
int <code class="sig-name descname">kstrtol</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, long *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the simple_strtoull. Return code must be checked.</p>
<dl class="function">
<dt id="c.kstrtoul">
int <code class="sig-name descname">kstrtoul</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, unsigned long *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the simple_strtoull. Return code must be checked.</p>
<dl class="function">
<dt id="c.kstrtoull">
int <code class="sig-name descname">kstrtoull</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, unsigned long long *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoll">
int <code class="sig-name descname">kstrtoll</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, long long *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtouint">
int <code class="sig-name descname">kstrtouint</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, unsigned int *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtouint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoint">
int <code class="sig-name descname">kstrtoint</code><span class="sig-paren">(</span>const char *<em> s</em>, unsigned int<em> base</em>, int *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtobool">
int <code class="sig-name descname">kstrtobool</code><span class="sig-paren">(</span>const char *<em> s</em>, bool *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtobool" title="Permalink to this definition">¶</a></dt>
<dd><p>convert common user inputs into boolean values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>input string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns 0 iff the first character is one of ‘Yy1Nn0’, or
[oO][NnFf] for “on” and “off”. Otherwise it will return -EINVAL.  Value
pointed to by res is updated upon finding a match.</p>
<dl class="function">
<dt id="c.string_get_size">
void <code class="sig-name descname">string_get_size</code><span class="sig-paren">(</span>u64<em> size</em>, u64<em> blk_size</em>, const enum string_size_units<em> units</em>, char *<em> buf</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.string_get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>get the size in the specified units</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>The size to be converted in blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">blk_size</span></code></dt><dd><p>Size of the block (use 1 for size in bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">string_size_units</span> <span class="pre">units</span></code></dt><dd><p>units to use (powers of 1000 or 1024)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>buffer to format to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a string formatted to 3 significant figures
giving the size in the required units.  <strong>buf</strong> should have room for
at least 9 bytes and will always be zero terminated.</p>
<dl class="function">
<dt id="c.string_unescape">
int <code class="sig-name descname">string_unescape</code><span class="sig-paren">(</span>char *<em> src</em>, char *<em> dst</em>, size_t<em> size</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.string_unescape" title="Permalink to this definition">¶</a></dt>
<dd><p>unquote characters in the given string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source buffer (escaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination buffer (unescaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the destination buffer (0 to unlimit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>combination of the flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function unquotes characters in the given string.</p>
<p>Because the size of the output will be the same as or less than the size of
the input, the transformation may be performed in place.</p>
<p>Caller must provide valid source and destination pointers. Be aware that
destination buffer will always be NULL-terminated. Source string must be
NULL-terminated as well.  The supported flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UNESCAPE_SPACE:
        &#39;\f&#39; - form feed
        &#39;\n&#39; - new line
        &#39;\r&#39; - carriage return
        &#39;\t&#39; - horizontal tab
        &#39;\v&#39; - vertical tab
UNESCAPE_OCTAL:
        &#39;\NNN&#39; - byte with octal value NNN (1 to 3 digits)
UNESCAPE_HEX:
        &#39;\xHH&#39; - byte with hexadecimal value HH (1 to 2 digits)
UNESCAPE_SPECIAL:
        &#39;\&quot;&#39; - double quote
        &#39;\\&#39; - backslash
        &#39;\a&#39; - alert (BEL)
        &#39;\e&#39; - escape
UNESCAPE_ANY:
        all previous together
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The amount of the characters processed to the destination buffer excluding
trailing ‘0’ is returned.</p>
<dl class="function">
<dt id="c.string_escape_mem">
int <code class="sig-name descname">string_escape_mem</code><span class="sig-paren">(</span>const char *<em> src</em>, size_t<em> isz</em>, char *<em> dst</em>, size_t<em> osz</em>, unsigned int<em> flags</em>, const char *<em> only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.string_escape_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>quote characters in the given memory buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source buffer (unescaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">isz</span></code></dt><dd><p>source buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination buffer (escaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">osz</span></code></dt><dd><p>destination buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>combination of the flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">only</span></code></dt><dd><p>NULL-terminated string containing characters used to limit
the selected escape class. If characters are included in <strong>only</strong>
that would not normally be escaped by the classes selected
in <strong>flags</strong>, they will be copied to <strong>dst</strong> unescaped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process of escaping byte buffer includes several parts. They are applied
in the following sequence.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The character is matched to the printable class, if asked, and in
case of match it passes through to the output.</p></li>
<li><p>The character is not matched to the one from <strong>only</strong> string and thus
must go as-is to the output.</p></li>
<li><p>The character is checked if it falls into the class given by <strong>flags</strong>.
<code class="docutils literal notranslate"><span class="pre">ESCAPE_OCTAL</span></code> and <code class="docutils literal notranslate"><span class="pre">ESCAPE_HEX</span></code> are going last since they cover any
character. Note that they actually can’t go together, otherwise
<code class="docutils literal notranslate"><span class="pre">ESCAPE_HEX</span></code> will be ignored.</p></li>
</ol>
</div></blockquote>
<p>Caller must provide valid source and destination pointers. Be aware that
destination buffer will not be NULL-terminated, thus caller have to append
it if needs.   The supported flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%ESCAPE_SPACE: (special white space, not space itself)
        &#39;\f&#39; - form feed
        &#39;\n&#39; - new line
        &#39;\r&#39; - carriage return
        &#39;\t&#39; - horizontal tab
        &#39;\v&#39; - vertical tab
%ESCAPE_SPECIAL:
        &#39;\\&#39; - backslash
        &#39;\a&#39; - alert (BEL)
        &#39;\e&#39; - escape
%ESCAPE_NULL:
        &#39;\0&#39; - null
%ESCAPE_OCTAL:
        &#39;\NNN&#39; - byte with octal value NNN (3 digits)
%ESCAPE_ANY:
        all previous together
%ESCAPE_NP:
        escape only non-printable characters (checked by isprint)
%ESCAPE_ANY_NP:
        all previous together
%ESCAPE_HEX:
        &#39;\xHH&#39; - byte with hexadecimal value HH (2 digits)
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The total size of the escaped output that would be generated for
the given input and flags. To check whether the output was
truncated, compare the return value to osz. There is room left in
dst for a ‘0’ terminator if and only if ret &lt; osz.</p>
</div>
<div class="section" id="string-manipulation">
<h3>String Manipulation<a class="headerlink" href="#string-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.strncasecmp">
int <code class="sig-name descname">strncasecmp</code><span class="sig-paren">(</span>const char *<em> s1</em>, const char *<em> s2</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncasecmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Case insensitive, length-limited string comparison</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt><dd><p>The other string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>the maximum number of characters to compare</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strcpy">
char * <code class="sig-name descname">strcpy</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strncpy">
char * <code class="sig-name descname">strncpy</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a length-limited, C-string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum number of bytes to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The result is not <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> if the source exceeds
<strong>count</strong> bytes.</p>
<p>In the case where the length of <strong>src</strong> is less than  that  of
count, the remainder of <strong>dest</strong> will be padded with <code class="docutils literal notranslate"><span class="pre">NUL</span></code>.</p>
<dl class="function">
<dt id="c.strlcpy">
size_t <code class="sig-name descname">strlcpy</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatible with <code class="docutils literal notranslate"><span class="pre">*BSD</span></code>: the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> does.</p>
<dl class="function">
<dt id="c.strscpy">
ssize_t <code class="sig-name descname">strscpy</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Size of destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.  The
behavior is undefined if the string buffers overlap.  The destination
buffer is always NUL terminated, unless it’s zero-sized.</p>
<p>Preferred to <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a> since the API doesn’t require reading memory
from the src string beyond the specified “count” bytes, and since
the return value is easier to error-check than <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a>’s.
In addition, the implementation is robust to the string changing out
from underneath it, unlike the current <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a> implementation.</p>
<p>Preferred to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> since it always returns a valid string, and
doesn’t unnecessarily force the tail of the destination buffer to be
zeroed.  If zeroing is desired please use <a class="reference internal" href="#c.strscpy_pad" title="strscpy_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy_pad()</span></code></a>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The number of characters copied (not including the trailing <code class="docutils literal notranslate"><span class="pre">NUL</span></code>)</p></li>
<li><p>-E2BIG if count is 0 or <strong>src</strong> was truncated.</p></li>
</ul>
<dl class="function">
<dt id="c.strscpy_pad">
ssize_t <code class="sig-name descname">strscpy_pad</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Size of destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.  The
behavior is undefined if the string buffers overlap.  The destination
buffer is always <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminated, unless it’s zero-sized.</p>
<p>If the source string is shorter than the destination buffer, zeros
the tail of the destination buffer.</p>
<p>For full explanation of why you may want to consider using the
‘strscpy’ functions please see the function docstring for <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The number of characters copied (not including the trailing <code class="docutils literal notranslate"><span class="pre">NUL</span></code>)</p></li>
<li><p>-E2BIG if count is 0 or <strong>src</strong> was truncated.</p></li>
</ul>
<dl class="function">
<dt id="c.strcat">
char * <code class="sig-name descname">strcat</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append one <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>The string to be appended to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>The string to append to it</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strncat">
char * <code class="sig-name descname">strncat</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>The string to be appended to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>The string to append to it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum numbers of bytes to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that in contrast to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a>, <a class="reference internal" href="#c.strncat" title="strncat"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncat()</span></code></a> ensures the result is
terminated.</p>
<dl class="function">
<dt id="c.strlcat">
size_t <code class="sig-name descname">strlcat</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>The string to be appended to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>The string to append to it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the destination buffer.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strcmp">
int <code class="sig-name descname">strcmp</code><span class="sig-paren">(</span>const char *<em> cs</em>, const char *<em> ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt><dd><p>Another string</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strncmp">
int <code class="sig-name descname">strncmp</code><span class="sig-paren">(</span>const char *<em> cs</em>, const char *<em> ct</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two length-limited strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt><dd><p>Another string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum number of bytes to compare</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strchr">
char * <code class="sig-name descname">strchr</code><span class="sig-paren">(</span>const char *<em> s</em>, int<em> c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code> is considered part of the string, and can
be searched for.</p>
<dl class="function">
<dt id="c.strchrnul">
char * <code class="sig-name descname">strchrnul</code><span class="sig-paren">(</span>const char *<em> s</em>, int<em> c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchrnul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return a character in a string, or end of string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to first occurrence of ‘c’ in s. If c is not found, then
return a pointer to the null byte at the end of s.</p>
<dl class="function">
<dt id="c.strrchr">
char * <code class="sig-name descname">strrchr</code><span class="sig-paren">(</span>const char *<em> s</em>, int<em> c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strrchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the last occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strnchr">
char * <code class="sig-name descname">strnchr</code><span class="sig-paren">(</span>const char *<em> s</em>, size_t<em> count</em>, int<em> c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in a length limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of characters to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code> is considered part of the string, and can
be searched for.</p>
<dl class="function">
<dt id="c.skip_spaces">
char * <code class="sig-name descname">skip_spaces</code><span class="sig-paren">(</span>const char *<em> str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skip_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading whitespace from <strong>str</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>The string to be stripped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the first non-whitespace character in <strong>str</strong>.</p>
<dl class="function">
<dt id="c.strim">
char * <code class="sig-name descname">strim</code><span class="sig-paren">(</span>char *<em> s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strim" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading and trailing whitespace from <strong>s</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be stripped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the first trailing whitespace is replaced with a <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code>
in the given string <strong>s</strong>. Returns a pointer to the first non-whitespace
character in <strong>s</strong>.</p>
<dl class="function">
<dt id="c.strlen">
size_t <code class="sig-name descname">strlen</code><span class="sig-paren">(</span>const char *<em> s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be sized</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strnlen">
size_t <code class="sig-name descname">strnlen</code><span class="sig-paren">(</span>const char *<em> s</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be sized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum number of bytes to search</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strspn">
size_t <code class="sig-name descname">strspn</code><span class="sig-paren">(</span>const char *<em> s</em>, const char *<em> accept</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which only contain letters in <strong>accept</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">accept</span></code></dt><dd><p>The string to search for</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strcspn">
size_t <code class="sig-name descname">strcspn</code><span class="sig-paren">(</span>const char *<em> s</em>, const char *<em> reject</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which does not contain letters in <strong>reject</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">reject</span></code></dt><dd><p>The string to avoid</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strpbrk">
char * <code class="sig-name descname">strpbrk</code><span class="sig-paren">(</span>const char *<em> cs</em>, const char *<em> ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strpbrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a set of characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt><dd><p>The characters to search for</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strsep">
char * <code class="sig-name descname">strsep</code><span class="sig-paren">(</span>char **<em> s</em>, const char *<em> ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strsep" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string into tokens</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt><dd><p>The characters to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.strsep" title="strsep"><code class="xref c c-func docutils literal notranslate"><span class="pre">strsep()</span></code></a> updates <strong>s</strong> to point after the token, ready for the next call.</p>
<p>It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)</p>
<dl class="function">
<dt id="c.sysfs_streq">
bool <code class="sig-name descname">sysfs_streq</code><span class="sig-paren">(</span>const char *<em> s1</em>, const char *<em> s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_streq" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if strings are equal, modulo trailing newline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt><dd><p>one string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt><dd><p>another string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns true iff two strings are equal, treating both
NUL and newline-then-NUL as equivalent string terminations.  It’s
geared for use with sysfs input strings, which generally terminate
with newlines but are compared against values without newlines.</p>
<dl class="function">
<dt id="c.match_string">
int <code class="sig-name descname">match_string</code><span class="sig-paren">(</span>const char *const *<em> array</em>, size_t<em> n</em>, const char *<em> string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of strings in the array or -1 for NULL terminated arrays</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">string</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine will look for a string in an array of strings up to the
n-th element in the array or until the first NULL element.</p>
<p>Historically the value of -1 for <strong>n</strong>, was used to search in arrays that
are NULL terminated. However, the function does not make a distinction
when finishing the search: either <strong>n</strong> elements have been compared OR
the first NULL element was found.</p>
<p><strong>Return</strong></p>
<p>index of a <strong>string</strong> in the <strong>array</strong> if matches, or <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__sysfs_match_string">
int <code class="sig-name descname">__sysfs_match_string</code><span class="sig-paren">(</span>const char *const *<em> array</em>, size_t<em> n</em>, const char *<em> str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sysfs_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of strings in the array or -1 for NULL terminated arrays</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns index of <strong>str</strong> in the <strong>array</strong> or -EINVAL, just like <a class="reference internal" href="#c.match_string" title="match_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">match_string()</span></code></a>.
Uses sysfs_streq instead of strcmp for matching.</p>
<p>This routine will look for a string in an array of strings up to the
n-th element in the array or until the first NULL element.</p>
<p>Historically the value of -1 for <strong>n</strong>, was used to search in arrays that
are NULL terminated. However, the function does not make a distinction
when finishing the search: either <strong>n</strong> elements have been compared OR
the first NULL element was found.</p>
<dl class="function">
<dt id="c.memset">
void * <code class="sig-name descname">memset</code><span class="sig-paren">(</span>void *<em> s</em>, int<em> c</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory with the given value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> to access IO space, use memset_io() instead.</p>
<dl class="function">
<dt id="c.memset16">
void * <code class="sig-name descname">memset16</code><span class="sig-paren">(</span>uint16_t *<em> s</em>, uint16_t<em> v</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset16" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint16_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint16_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint16_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset32">
void * <code class="sig-name descname">memset32</code><span class="sig-paren">(</span>uint32_t *<em> s</em>, uint32_t<em> v</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset32" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint32_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint32_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint32_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset64">
void * <code class="sig-name descname">memset64</code><span class="sig-paren">(</span>uint64_t *<em> s</em>, uint64_t<em> v</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset64" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint64_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint64_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint64_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memcpy">
void * <code class="sig-name descname">memcpy</code><span class="sig-paren">(</span>void *<em> dest</em>, const void *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You should not use this function to access IO space, use memcpy_toio()
or memcpy_fromio() instead.</p>
<dl class="function">
<dt id="c.memmove">
void * <code class="sig-name descname">memmove</code><span class="sig-paren">(</span>void *<em> dest</em>, const void *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memmove" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a>, <a class="reference internal" href="#c.memmove" title="memmove"><code class="xref c c-func docutils literal notranslate"><span class="pre">memmove()</span></code></a> copes with overlapping areas.</p>
<dl class="function">
<dt id="c.memcmp">
__visible int <code class="sig-name descname">memcmp</code><span class="sig-paren">(</span>const void *<em> cs</em>, const void *<em> ct</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two areas of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt><dd><p>One area of memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt><dd><p>Another area of memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bcmp">
int <code class="sig-name descname">bcmp</code><span class="sig-paren">(</span>const void *<em> a</em>, const void *<em> b</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 0 if and only if the buffers have identical contents.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt><dd><p>pointer to first buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>pointer to second buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of buffers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sign or magnitude of a non-zero return value has no particular
meaning, and architectures may implement their own more efficient <a class="reference internal" href="#c.bcmp" title="bcmp"><code class="xref c c-func docutils literal notranslate"><span class="pre">bcmp()</span></code></a>. So
while this particular implementation is a simple (tail) call to memcmp, do
not rely on anything but whether the return value is zero or non-zero.</p>
<dl class="function">
<dt id="c.memscan">
void * <code class="sig-name descname">memscan</code><span class="sig-paren">(</span>void *<em> addr</em>, int<em> c</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memscan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or 1 byte past
the area if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.strstr">
char * <code class="sig-name descname">strstr</code><span class="sig-paren">(</span>const char *<em> s1</em>, const char *<em> s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt><dd><p>The string to search for</p>
</dd>
</dl>
<dl class="function">
<dt id="c.strnstr">
char * <code class="sig-name descname">strnstr</code><span class="sig-paren">(</span>const char *<em> s1</em>, const char *<em> s2</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt><dd><p>The string to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>the maximum number of characters to search</p>
</dd>
</dl>
<dl class="function">
<dt id="c.memchr">
void * <code class="sig-name descname">memchr</code><span class="sig-paren">(</span>const void *<em> s</em>, int<em> c</em>, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.memchr_inv">
void * <code class="sig-name descname">memchr_inv</code><span class="sig-paren">(</span>const void *<em> start</em>, int<em> c</em>, size_t<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an unmatching character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>Find a character other than c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first character other than <strong>c</strong>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
if the whole buffer contains just <strong>c</strong>.</p>
<dl class="function">
<dt id="c.strreplace">
char * <code class="sig-name descname">strreplace</code><span class="sig-paren">(</span>char *<em> s</em>, char<em> old</em>, char<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all occurrences of character in string.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to operate on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">old</span></code></dt><dd><p>The character being replaced.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">new</span></code></dt><dd><p>The character <strong>old</strong> is replaced with.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to the nul byte at the end of <strong>s</strong>.</p>
<dl class="function">
<dt id="c.sysfs_match_string">
<code class="sig-name descname">sysfs_match_string</code><span class="sig-paren">(</span><em>_a</em>, <em>_s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_a</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_s</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for <a class="reference internal" href="#c.__sysfs_match_string" title="__sysfs_match_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sysfs_match_string()</span></code></a>. Calculates the size of <strong>a</strong> automatically.</p>
<dl class="function">
<dt id="c.strstarts">
bool <code class="sig-name descname">strstarts</code><span class="sig-paren">(</span>const char *<em> str</em>, const char *<em> prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strstarts" title="Permalink to this definition">¶</a></dt>
<dd><p>does <strong>str</strong> start with <strong>prefix</strong>?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>string to examine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt><dd><p>prefix to look for.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.memzero_explicit">
void <code class="sig-name descname">memzero_explicit</code><span class="sig-paren">(</span>void *<em> s</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memzero_explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory (e.g. sensitive keying data) with 0s.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>usually using <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> is just fine (!), but in cases
where clearing out _local_ data at the end of a scope is
necessary, <a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal notranslate"><span class="pre">memzero_explicit()</span></code></a> should be used instead in
order to prevent the compiler from optimising away zeroing.</p>
<p><a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal notranslate"><span class="pre">memzero_explicit()</span></code></a> doesn’t need an arch-specific version as
it just invokes the one of <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> implicitly.</p>
<dl class="function">
<dt id="c.kbasename">
const char * <code class="sig-name descname">kbasename</code><span class="sig-paren">(</span>const char *<em> path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kbasename" title="Permalink to this definition">¶</a></dt>
<dd><p>return the last part of a pathname.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt><dd><p>path to extract the filename from.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.memcpy_and_pad">
void <code class="sig-name descname">memcpy_and_pad</code><span class="sig-paren">(</span>void *<em> dest</em>, size_t<em> dest_len</em>, const void *<em> src</em>, size_t<em> count</em>, int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy_and_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one buffer to another with padding</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dest_len</span></code></dt><dd><p>The destination buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of bytes to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>Character to use for padding if space is left in destination.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.str_has_prefix">
size_t <code class="sig-name descname">str_has_prefix</code><span class="sig-paren">(</span>const char *<em> str</em>, const char *<em> prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.str_has_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a string has a given prefix</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>The string to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt><dd><p>The string to see if <strong>str</strong> starts with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>A common way to test a prefix of a string is to do:</dt><dd><p>strncmp(str, prefix, sizeof(prefix) - 1)</p>
</dd>
</dl>
<p>But this can lead to bugs due to typos, or if prefix is a pointer
and not a constant. Instead use <a class="reference internal" href="#c.str_has_prefix" title="str_has_prefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">str_has_prefix()</span></code></a>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>strlen(<strong>prefix</strong>) if <strong>str</strong> starts with <strong>prefix</strong></p></li>
<li><p>0 if <strong>str</strong> does not start with <strong>prefix</strong></p></li>
</ul>
<dl class="function">
<dt id="c.kstrdup">
char * <code class="sig-name descname">kstrdup</code><span class="sig-paren">(</span>const char *<em> s</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="function">
<dt id="c.kstrdup_const">
const char * <code class="sig-name descname">kstrdup_const</code><span class="sig-paren">(</span>const char *<em> s</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally duplicate an existing const string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Strings allocated by kstrdup_const should be freed by kfree_const.</p>
<p><strong>Return</strong></p>
<p>source string if it is in .rodata section otherwise
fallback to kstrdup.</p>
<dl class="function">
<dt id="c.kstrndup">
char * <code class="sig-name descname">kstrndup</code><span class="sig-paren">(</span>const char *<em> s</em>, size_t<em> max</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrndup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>read at most <strong>max</strong> chars from <strong>s</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Use <a class="reference internal" href="#c.kmemdup_nul" title="kmemdup_nul"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmemdup_nul()</span></code></a> instead if the size is known exactly.</p>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="function">
<dt id="c.kmemdup">
void * <code class="sig-name descname">kmemdup</code><span class="sig-paren">(</span>const void *<em> src</em>, size_t<em> len</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate region of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>memory region to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>memory region length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>src</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
<dl class="function">
<dt id="c.kmemdup_nul">
char * <code class="sig-name descname">kmemdup_nul</code><span class="sig-paren">(</span>const char *<em> s</em>, size_t<em> len</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a NUL-terminated string from unterminated data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The data to stringify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The size of the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> with NUL-termination or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in
case of error</p>
<dl class="function">
<dt id="c.memdup_user">
void * <code class="sig-name descname">memdup_user</code><span class="sig-paren">(</span>const void __user *<em> src</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an ERR_PTR() on failure.  Result is physically
contiguous, to be freed by <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<dl class="function">
<dt id="c.vmemdup_user">
void * <code class="sig-name descname">vmemdup_user</code><span class="sig-paren">(</span>const void __user *<em> src</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmemdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an ERR_PTR() on failure.  Result may be not
physically contiguous.  Use <a class="reference internal" href="mm-api.html#c.kvfree" title="kvfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree()</span></code></a> to free.</p>
<dl class="function">
<dt id="c.strndup_user">
char * <code class="sig-name descname">strndup_user</code><span class="sig-paren">(</span>const char __user *<em> s</em>, long<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strndup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an existing string from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>The string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Maximum number of bytes to copy, including the trailing NUL.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or an ERR_PTR() in case of error</p>
<dl class="function">
<dt id="c.memdup_user_nul">
void * <code class="sig-name descname">memdup_user_nul</code><span class="sig-paren">(</span>const void __user *<em> src</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space and NUL-terminate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an ERR_PTR() on failure.</p>
</div>
</div>
<div class="section" id="basic-kernel-library-functions">
<h2>Basic Kernel Library Functions<a class="headerlink" href="#basic-kernel-library-functions" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides more basic utility functions.</p>
<div class="section" id="bit-operations">
<h3>Bit Operations<a class="headerlink" href="#bit-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.set_bit">
void <code class="sig-name descname">set_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.clear_bit">
void <code class="sig-name descname">clear_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
<dl class="function">
<dt id="c.change_bit">
void <code class="sig-name descname">change_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.test_and_set_bit">
bool <code class="sig-name descname">test_and_set_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
<dl class="function">
<dt id="c.test_and_clear_bit">
bool <code class="sig-name descname">test_and_clear_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
<dl class="function">
<dt id="c.test_and_change_bit">
bool <code class="sig-name descname">test_and_change_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
<dl class="function">
<dt id="c.__set_bit">
void <code class="sig-name descname">__set_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
<dl class="function">
<dt id="c.__clear_bit">
void <code class="sig-name descname">__clear_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">clear_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
<dl class="function">
<dt id="c.__change_bit">
void <code class="sig-name descname">__change_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">change_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
<dl class="function">
<dt id="c.__test_and_set_bit">
bool <code class="sig-name descname">__test_and_set_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
<dl class="function">
<dt id="c.__test_and_clear_bit">
bool <code class="sig-name descname">__test_and_clear_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
<dl class="function">
<dt id="c.__test_and_change_bit">
bool <code class="sig-name descname">__test_and_change_bit</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
<dl class="function">
<dt id="c.test_bit">
bool <code class="sig-name descname">test_bit</code><span class="sig-paren">(</span>long<em> nr</em>, const volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a bit is set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>bit number to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<dl class="function">
<dt id="c.clear_bit_unlock">
void <code class="sig-name descname">clear_bit_unlock</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit in memory, for unlock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides release barrier semantics.</p>
<dl class="function">
<dt id="c.__clear_bit_unlock">
void <code class="sig-name descname">__clear_bit_unlock</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_bit_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a non-atomic operation but implies a release barrier before the
memory operation. It can be used for an unlock if no other CPUs can
concurrently modify other bits in the word.</p>
<dl class="function">
<dt id="c.test_and_set_bit_lock">
bool <code class="sig-name descname">test_and_set_bit_lock</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value, for lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides acquire barrier semantics if
the returned value is 0.
It can be used to implement bit locks.</p>
<dl class="function">
<dt id="c.clear_bit_unlock_is_negative_byte">
bool <code class="sig-name descname">clear_bit_unlock_is_negative_byte</code><span class="sig-paren">(</span>long<em> nr</em>, volatile unsigned long *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit_unlock_is_negative_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit in memory and test if bottom byte is negative, for unlock.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides release barrier semantics.</p>
<p>This is a bit of a one-trick-pony for the filemap code, which clears
PG_locked and tests PG_waiters,</p>
</div>
<div class="section" id="bitmap-operations">
<h3>Bitmap Operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this headline">¶</a></h3>
<p>bitmaps provide an array of bits, implemented using an an
array of unsigned longs.  The number of valid bits in a
given bitmap does _not_ need to be an exact multiple of
BITS_PER_LONG.</p>
<p>The possible unused bits in the last, partially used word
of a bitmap are ‘don’t care’.  The implementation makes
no particular effort to keep them zero.  It ensures that
their value will not affect the results of any operation.
The bitmap operations that return Boolean (bitmap_empty,
for example) or scalar (bitmap_weight, for example) results
carefully filter out these unused bits from impacting their
results.</p>
<p>The byte ordering of bitmaps is more natural on little
endian architectures.  See the big-endian headers
include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
for the best explanations of this ordering.</p>
<p>The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used
to declare an array named ‘name’ of just enough unsigned longs to
contain all bit positions from 0 to ‘bits’ - 1.</p>
<p>The available bitmap operations and their rough meaning in the
case that the bitmap is a single unsigned long are thus:</p>
<p>The generated code is more efficient when nbits is known at
compile-time and at most BITS_PER_LONG.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bitmap_zero(dst, nbits)                     *dst = 0UL
bitmap_fill(dst, nbits)                     *dst = ~0UL
bitmap_copy(dst, src, nbits)                *dst = *src
bitmap_and(dst, src1, src2, nbits)          *dst = *src1 &amp; *src2
bitmap_or(dst, src1, src2, nbits)           *dst = *src1 | *src2
bitmap_xor(dst, src1, src2, nbits)          *dst = *src1 ^ *src2
bitmap_andnot(dst, src1, src2, nbits)       *dst = *src1 &amp; ~(*src2)
bitmap_complement(dst, src, nbits)          *dst = ~(*src)
bitmap_equal(src1, src2, nbits)             Are *src1 and *src2 equal?
bitmap_intersects(src1, src2, nbits)        Do *src1 and *src2 overlap?
bitmap_subset(src1, src2, nbits)            Is *src1 a subset of *src2?
bitmap_empty(src, nbits)                    Are all bits zero in *src?
bitmap_full(src, nbits)                     Are all bits set in *src?
bitmap_weight(src, nbits)                   Hamming Weight: number set bits
bitmap_set(dst, pos, nbits)                 Set specified bit area
bitmap_clear(dst, pos, nbits)               Clear specified bit area
bitmap_find_next_zero_area(buf, len, pos, n, mask)  Find bit free area
bitmap_find_next_zero_area_off(buf, len, pos, n, mask, mask_off)  as above
bitmap_next_clear_region(map, :c:type:`start`, :c:type:`end`, nbits)  Find next clear region
bitmap_next_set_region(map, :c:type:`start`, :c:type:`end`, nbits)  Find next set region
bitmap_for_each_clear_region(map, rs, re, start, end)
                                            Iterate over all clear regions
bitmap_for_each_set_region(map, rs, re, start, end)
                                            Iterate over all set regions
bitmap_shift_right(dst, src, n, nbits)      *dst = *src &gt;&gt; n
bitmap_shift_left(dst, src, n, nbits)       *dst = *src &lt;&lt; n
bitmap_cut(dst, src, first, n, nbits)       Cut n bits from first, copy rest
bitmap_replace(dst, old, new, mask, nbits)  *dst = (*old &amp; ~(*mask)) | (*new &amp; *mask)
bitmap_remap(dst, src, old, new, nbits)     *dst = map(old, new)(src)
bitmap_bitremap(oldbit, old, new, nbits)    newbit = map(old, new)(oldbit)
bitmap_onto(dst, orig, relmap, nbits)       *dst = orig relative to relmap
bitmap_fold(dst, orig, sz, nbits)           dst bits = orig bits mod sz
bitmap_parse(buf, buflen, dst, nbits)       Parse bitmap dst from kernel buf
bitmap_parse_user(ubuf, ulen, dst, nbits)   Parse bitmap dst from user buf
bitmap_parselist(buf, dst, nbits)           Parse bitmap dst from kernel buf
bitmap_parselist_user(buf, dst, nbits)      Parse bitmap dst from user buf
bitmap_find_free_region(bitmap, bits, order)  Find and allocate bit region
bitmap_release_region(bitmap, pos, order)   Free specified bit region
bitmap_allocate_region(bitmap, pos, order)  Allocate specified bit region
bitmap_from_arr32(dst, buf, nbits)          Copy nbits from u32[] buf to dst
bitmap_to_arr32(buf, src, nbits)            Copy nbits from buf to u32[] dst
bitmap_get_value8(map, start)               Get 8bit value from map at start
bitmap_set_value8(map, value, start)        Set 8bit value to map at start
</pre></div>
</div>
<p>Note, bitmap_zero() and bitmap_fill() operate over the region of
unsigned longs, that is, bits behind bitmap till the unsigned long
boundary will be zeroed or filled as well. Consider to use
bitmap_clear() or bitmap_set() to make explicit zeroing or filling
respectively.</p>
<p>Also the following operations in asm/bitops.h apply to bitmaps.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set_bit(bit, addr)                  *addr |= bit
clear_bit(bit, addr)                *addr &amp;= ~bit
change_bit(bit, addr)               *addr ^= bit
test_bit(bit, addr)                 Is bit set in *addr?
test_and_set_bit(bit, addr)         Set bit and return old value
test_and_clear_bit(bit, addr)       Clear bit and return old value
test_and_change_bit(bit, addr)      Change bit and return old value
find_first_zero_bit(addr, nbits)    Position first zero bit in *addr
find_first_bit(addr, nbits)         Position first set bit in *addr
find_next_zero_bit(addr, nbits, bit)
                                    Position next zero bit in *addr &gt;= bit
find_next_bit(addr, nbits, bit)     Position next set bit in *addr &gt;= bit
find_next_and_bit(addr1, addr2, nbits, bit)
                                    Same as find_next_bit, but in
                                    (*addr1 &amp; *addr2)
</pre></div>
</div>
<dl class="function">
<dt id="c.__bitmap_shift_right">
void <code class="sig-name descname">__bitmap_shift_right</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> src</em>, unsigned<em> shift</em>, unsigned<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_right" title="Permalink to this definition">¶</a></dt>
<dd><p>logical right shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">shift</span></code></dt><dd><p>shift by this many bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting right (dividing) means moving bits in the MS -&gt; LS bit
direction.  Zeros are fed into the vacated MS positions and the
LS bits shifted off the bottom are lost.</p>
<dl class="function">
<dt id="c.__bitmap_shift_left">
void <code class="sig-name descname">__bitmap_shift_left</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> src</em>, unsigned int<em> shift</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_left" title="Permalink to this definition">¶</a></dt>
<dd><p>logical left shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt><dd><p>shift by this many bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting left (multiplying) means moving bits in the LS -&gt; MS
direction.  Zeros are fed into the vacated LS bit positions
and those MS bits shifted off the top are lost.</p>
<dl class="function">
<dt id="c.bitmap_cut">
void <code class="sig-name descname">bitmap_cut</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> src</em>, unsigned int<em> first</em>, unsigned int<em> cut</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>remove bit region from bitmap and right shift remaining bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination bitmap, might overlap with src</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>31                                   63
|                                    |
10000000 11000001 11110010 00010101  10000000 11000001 01110010 00010101</p>
<blockquote>
<div><blockquote>
<div><div class="line-block">
<div class="line">|              |                                    |</div>
</div>
</div></blockquote>
<p>16  14             0                                   32</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">first</span></code></dt><dd><p>start bit of region to be removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cut</span></code></dt><dd><p>number of bits to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff the n-th bit of <strong>src</strong> is set and
n is less than <strong>first</strong>, or the m-th bit of <strong>src</strong> is set for any
m such that <strong>first</strong> &lt;= n &lt; nbits, and m = n + <strong>cut</strong>.</p>
<p>In pictures, example for a big-endian 32-bit architecture:</p>
<p>if <strong>cut</strong> is 3, and <strong>first</strong> is 14, bits 14-16 in <strong>src</strong> are cut and <strong>dst</strong> is:</p>
<p>31                                   63
|                                    |
10110000 00011000 00110010 00010101  00010000 00011000 00101110 01000010</p>
<blockquote>
<div><div class="line-block">
<div class="line">|                                    |</div>
</div>
<dl class="simple">
<dt>14 (bit 17     0                                   32</dt><dd><p>from <strong>src</strong>)</p>
</dd>
</dl>
</div></blockquote>
<p>Note that <strong>dst</strong> and <strong>src</strong> might overlap partially or entirely.</p>
<p>This is implemented in the obvious way, with a shift and carry
step for each moved bit. Optimisation is left as an exercise
for the compiler.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area_off">
unsigned long <code class="sig-name descname">bitmap_find_next_zero_area_off</code><span class="sig-paren">(</span>unsigned long *<em> map</em>, unsigned long<em> size</em>, unsigned long<em> start</em>, unsigned int<em> nr</em>, unsigned long<em> align_mask</em>, unsigned long<em> align_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area_off" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>The address to base the search on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>The bitmap size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>The bitnumber to start searching at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>The number of zeroed bits we’re looking for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt><dd><p>Alignment mask for zero area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_offset</span></code></dt><dd><p>Alignment offset for zero area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus <strong>align_offset</strong>
is multiple of that power of 2.</p>
<dl class="function">
<dt id="c.bitmap_parse_user">
int <code class="sig-name descname">bitmap_parse_user</code><span class="sig-paren">(</span>const char __user *<em> ubuf</em>, unsigned int<em> ulen</em>, unsigned long *<em> maskp</em>, int<em> nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse_user" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string in a user buffer into a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt><dd><p>pointer to user buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bitmap_print_to_pagebuf">
int <code class="sig-name descname">bitmap_print_to_pagebuf</code><span class="sig-paren">(</span>bool<em> list</em>, char *<em> buf</em>, const unsigned long *<em> maskp</em>, int<em> nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_pagebuf" title="Permalink to this definition">¶</a></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">list</span></code></dt><dd><p>indicates whether the bitmap must be list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>page aligned buffer into which string is placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt><dd><p>pointer to bitmap to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Output format is a comma-separated list of decimal numbers and
ranges if list is specified or hex digits grouped into comma-separated
sets of 8 digits/set. Returns the number of characters written to buf.</p>
<p>It is assumed that <strong>buf</strong> is a pointer into a PAGE_SIZE, page-aligned
area and that sufficient storage remains at <strong>buf</strong> to accommodate the
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> output. Returns the number of characters
actually printed to <strong>buf</strong>, excluding terminating ‘0’.</p>
<dl class="function">
<dt id="c.bitmap_parselist">
int <code class="sig-name descname">bitmap_parselist</code><span class="sig-paren">(</span>const char *<em> buf</em>, unsigned long *<em> maskp</em>, int<em> nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list format ASCII string to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>read user string from this buffer; must be terminated
with a 0 or n.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt><dd><p>write resulting mask here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>number of bits in mask to be written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.
Optionally each range can be postfixed to denote that only parts of it
should be set. The range will divided to groups of specific size.
From each group will be used only defined amount of bits.
Syntax: range:used_size/group_size</p>
<p><strong>Example</strong></p>
<p>0-1023:2/256 ==&gt; 0,1,256,257,512,513,768,769</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on invalid input strings. Error values:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>: wrong region format</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>: invalid character in string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ERANGE</span></code>: bit number specified too large for mask</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EOVERFLOW</span></code>: integer overflow in the input parameters</p></li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.bitmap_parselist_user">
int <code class="sig-name descname">bitmap_parselist_user</code><span class="sig-paren">(</span>const char __user *<em> ubuf</em>, unsigned int<em> ulen</em>, unsigned long *<em> maskp</em>, int<em> nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist_user" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt><dd><p>pointer to user buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <a class="reference internal" href="#c.bitmap_parselist" title="bitmap_parselist"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_parselist()</span></code></a>, providing it with user buffer.</p>
<dl class="function">
<dt id="c.bitmap_parse">
int <code class="sig-name descname">bitmap_parse</code><span class="sig-paren">(</span>const char *<em> start</em>, unsigned int<em> buflen</em>, unsigned long *<em> maskp</em>, int<em> nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string into a bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">start</span></code></dt><dd><p>pointer to buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0 or n. In that case,
UINT_MAX may be provided instead of string length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (<code class="docutils literal notranslate"><span class="pre">-EOVERFLOW</span></code>), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> is returned for illegal
characters. Grouping such as “1,,5”, “,44”, “,” or “” is allowed.
Leading, embedded and trailing whitespace accepted.</p>
<dl class="function">
<dt id="c.bitmap_find_free_region">
int <code class="sig-name descname">bitmap_find_free_region</code><span class="sig-paren">(</span>unsigned long *<em> bitmap</em>, unsigned int<em> bits</em>, int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_free_region" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned mem region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a region of free (zero) bits in a <strong>bitmap</strong> of <strong>bits</strong> bits and
allocate them (set them to one).  Only consider regions of length
a power (<strong>order</strong>) of two, aligned to that power of two, which
makes the search algorithm much faster.</p>
<p>Return the bit offset in bitmap of the allocated region,
or -errno on failure.</p>
<dl class="function">
<dt id="c.bitmap_release_region">
void <code class="sig-name descname">bitmap_release_region</code><span class="sig-paren">(</span>unsigned long *<em> bitmap</em>, unsigned int<em> pos</em>, int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release allocated bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>beginning of bit region to release</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the complement to __bitmap_find_free_region() and releases
the found region (by clearing it in the bitmap).</p>
<p>No return value.</p>
<dl class="function">
<dt id="c.bitmap_allocate_region">
int <code class="sig-name descname">bitmap_allocate_region</code><span class="sig-paren">(</span>unsigned long *<em> bitmap</em>, unsigned int<em> pos</em>, int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_allocate_region" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>beginning of bit region to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate (set bits in) a specified region of a bitmap.</p>
<p>Return 0 on success, or <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> if specified region wasn’t
free (not all bits were zero).</p>
<dl class="function">
<dt id="c.bitmap_copy_le">
void <code class="sig-name descname">bitmap_copy_le</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> src</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_copy_le" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a bitmap, putting the bits into little-endian order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>bitmap to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in the bitmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Require nbits % BITS_PER_LONG == 0.</p>
<dl class="function">
<dt id="c.bitmap_from_arr32">
void <code class="sig-name descname">bitmap_from_arr32</code><span class="sig-paren">(</span>unsigned long *<em> bitmap</em>, const u32 *<em> buf</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_arr32" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of u32 array of bits to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt><dd><p>array of unsigned longs, the destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>array of u32 (in host byte order), the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="c.bitmap_to_arr32">
void <code class="sig-name descname">bitmap_to_arr32</code><span class="sig-paren">(</span>u32 *<em> buf</em>, const unsigned long *<em> bitmap</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_arr32" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of bitmap to a u32 array of bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>array of u32 (in host byte order), the dest bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt><dd><p>array of unsigned longs, the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="c.bitmap_pos_to_ord">
int <code class="sig-name descname">bitmap_pos_to_ord</code><span class="sig-paren">(</span>const unsigned long *<em> buf</em>, unsigned int<em> pos</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_pos_to_ord" title="Permalink to this definition">¶</a></dt>
<dd><p>find ordinal of set bit at given position in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to a bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>a bit position in <strong>buf</strong> (0 &lt;= <strong>pos</strong> &lt; <strong>nbits</strong>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of valid bit positions in <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the bit at position <strong>pos</strong> in <strong>buf</strong> (of length <strong>nbits</strong>) to the
ordinal of which set bit it is.  If it is not set or if <strong>pos</strong>
is not a valid bit position, map to -1.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>pos</strong>
values 4 through 7 will get mapped to 0 through 3, respectively,
and other <strong>pos</strong> values will get mapped to -1.  When <strong>pos</strong> value 7
gets mapped to (returns) <strong>ord</strong> value 3 in this example, that means
that bit 7 is the 3rd (starting with 0th) set bit in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>bits</strong> are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_ord_to_pos">
unsigned int <code class="sig-name descname">bitmap_ord_to_pos</code><span class="sig-paren">(</span>const unsigned long *<em> buf</em>, unsigned int<em> ord</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_ord_to_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find position of n-th set bit in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>pointer to bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ord</span></code></dt><dd><p>ordinal bit position (n-th set bit, n &gt;= 0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of valid bit positions in <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the ordinal offset of bit <strong>ord</strong> in <strong>buf</strong> to its position in <strong>buf</strong>.
Value of <strong>ord</strong> should be in range 0 &lt;= <strong>ord</strong> &lt; weight(buf). If <strong>ord</strong>
&gt;= weight(buf), returns <strong>nbits</strong>.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>ord</strong>
values 0 through 3 will get mapped to 4 through 7, respectively,
and all other <strong>ord</strong> values returns <strong>nbits</strong>.  When <strong>ord</strong> value 3
gets mapped to (returns) <strong>pos</strong> value 7 in this example, that means
that the 3rd set bit (starting with 0th) is at position 7 in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>nbits</strong>-1 are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_remap">
void <code class="sig-name descname">bitmap_remap</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> src</em>, const unsigned long *<em> old</em>, const unsigned long *<em> new</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to another bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>remapped result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>subset to be remapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>defines domain of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>defines range of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight ‘w’ of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>If either of the <strong>old</strong> and <strong>new</strong> bitmaps are empty, or if <strong>src</strong> and
<strong>dst</strong> point to the same location, then this routine copies <strong>src</strong>
to <strong>dst</strong>.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to <strong>src</strong>, placing the result in
<strong>dst</strong>, clearing any bits previously set in <strong>dst</strong>.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>src</strong> comes into this routine
with bits 1, 5 and 7 set, then <strong>dst</strong> should leave with bits 1,
13 and 15 set.</p>
<dl class="function">
<dt id="c.bitmap_bitremap">
int <code class="sig-name descname">bitmap_bitremap</code><span class="sig-paren">(</span>int<em> oldbit</em>, const unsigned long *<em> old</em>, const unsigned long *<em> new</em>, int<em> bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_bitremap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to a single bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oldbit</span></code></dt><dd><p>bit position to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>defines domain of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>defines range of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight ‘w’ of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to bit position <strong>oldbit</strong>, returning
the new bit position.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>oldbit</strong> is 5, then this routine
returns 13.</p>
<dl class="function">
<dt id="c.bitmap_onto">
void <code class="sig-name descname">bitmap_onto</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> orig</em>, const unsigned long *<em> relmap</em>, unsigned int<em> bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_onto" title="Permalink to this definition">¶</a></dt>
<dd><p>translate one bitmap relative to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>resulting translated bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt><dd><p>original untranslated bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">relmap</span></code></dt><dd><p>bitmap relative to which translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff there exists some m such that the
n-th bit of <strong>relmap</strong> is set, the m-th bit of <strong>orig</strong> is set, and
the n-th bit of <strong>relmap</strong> is also the m-th _set_ bit of <strong>relmap</strong>.
(If you understood the previous sentence the first time your
read it, you’re overqualified for your current job.)</p>
<p>In other words, <strong>orig</strong> is mapped onto (surjectively) <strong>dst</strong>,
using the map { &lt;n, m&gt; | the n-th bit of <strong>relmap</strong> is the
m-th set bit of <strong>relmap</strong> }.</p>
<p>Any set bits in <strong>orig</strong> above bit number W, where W is the
weight of (number of set bits in) <strong>relmap</strong> are mapped nowhere.
In particular, if for all bits m set in <strong>orig</strong>, m &gt;= W, then
<strong>dst</strong> will end up empty.  In situations where the possibility
of such an empty result is not desired, one way to avoid it is
to use the <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> operator, below, to first fold the
<strong>orig</strong> bitmap over itself so that all its set bits x are in the
range 0 &lt;= x &lt; W.  The <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> operator does this by
setting the bit (m % W) in <strong>dst</strong>, for each bit (m) set in <strong>orig</strong>.</p>
<dl>
<dt>Example [1] for bitmap_onto():</dt><dd><p>Let’s say <strong>relmap</strong> has bits 30-39 set, and <strong>orig</strong> has bits
1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
<strong>dst</strong> will have bits 31, 33, 35, 37 and 39 set.</p>
<p>When bit 0 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the first bit (if any)
that is turned on in <strong>relmap</strong>.  Since bit 0 was off in the
above example, we leave off that bit (bit 30) in <strong>dst</strong>.</p>
<p>When bit 1 is set in <strong>orig</strong> (as in the above example), it
means turn on the bit in <strong>dst</strong> corresponding to whatever
is the second bit that is turned on in <strong>relmap</strong>.  The second
bit in <strong>relmap</strong> that was turned on in the above example was
bit 31, so we turned on bit 31 in <strong>dst</strong>.</p>
<p>Similarly, we turned on bits 33, 35, 37 and 39 in <strong>dst</strong>,
because they were the 4th, 6th, 8th and 10th set bits
set in <strong>relmap</strong>, and the 4th, 6th, 8th and 10th bits of
<strong>orig</strong> (i.e. bits 3, 5, 7 and 9) were also set.</p>
<p>When bit 11 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the twelfth bit that is
turned on in <strong>relmap</strong>.  In the above example, there were
only ten bits turned on in <strong>relmap</strong> (30..39), so that bit
11 was set in <strong>orig</strong> had no affect on <strong>dst</strong>.</p>
</dd>
<dt>Example [2] for bitmap_fold() + bitmap_onto():</dt><dd><p>Let’s say <strong>relmap</strong> has these ten bits set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>40 41 42 43 45 48 53 61 74 95
</pre></div>
</div>
<p>(for the curious, that’s 40 plus the first ten terms of the
Fibonacci sequence.)</p>
<p>Further lets say we use the following code, invoking
<a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> then bitmap_onto, as suggested above to
avoid the possibility of an empty <strong>dst</strong> result:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long *tmp;     // a temporary bitmap&#39;s bits

bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
bitmap_onto(dst, tmp, relmap, bits);
</pre></div>
</div>
<p>Then this table shows what various values of <strong>dst</strong> would be, for
various <strong>orig</strong>’s.  I list the zero-based positions of each set bit.
The tmp column shows the intermediate result, as computed by
using <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> to fold the <strong>orig</strong> bitmap modulo ten
(the weight of <strong>relmap</strong>):</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 30%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>orig</strong></p></td>
<td><p>tmp</p></td>
<td><p><strong>dst</strong></p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>41</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>9</p></td>
<td><p>95</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>0</p></td>
<td><p>40 <a class="footnote-reference brackets" href="#f1" id="id1">1</a></p></td>
</tr>
<tr class="row-even"><td><p>1 3 5 7</p></td>
<td><p>1 3 5 7</p></td>
<td><p>41 43 48 61</p></td>
</tr>
<tr class="row-odd"><td><p>0 1 2 3 4</p></td>
<td><p>0 1 2 3 4</p></td>
<td><p>40 41 42 43 45</p></td>
</tr>
<tr class="row-even"><td><p>0 9 18 27</p></td>
<td><p>0 9 8 7</p></td>
<td><p>40 61 74 95</p></td>
</tr>
<tr class="row-odd"><td><p>0 10 20 30</p></td>
<td><p>0</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p>0 11 22 33</p></td>
<td><p>0 1 2 3</p></td>
<td><p>40 41 42 43</p></td>
</tr>
<tr class="row-odd"><td><p>0 12 24 36</p></td>
<td><p>0 2 4 6</p></td>
<td><p>40 42 45 53</p></td>
</tr>
<tr class="row-even"><td><p>78 102 211</p></td>
<td><p>1 2 8</p></td>
<td><p>41 42 74 <a class="footnote-reference brackets" href="#f1" id="id2">1</a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>For these marked lines, if we hadn’t first done <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a>
into tmp, then the <strong>dst</strong> result would have been empty.</p>
</dd>
</dl>
<p>If either of <strong>orig</strong> or <strong>relmap</strong> is empty (no set bits), then <strong>dst</strong>
will be returned empty.</p>
<p>If (as explained above) the only set bits in <strong>orig</strong> are in positions
m where m &gt;= W, (where W is the weight of <strong>relmap</strong>) then <strong>dst</strong> will
once again be returned empty.</p>
<p>All bits in <strong>dst</strong> not set by the above rule are cleared.</p>
<dl class="function">
<dt id="c.bitmap_fold">
void <code class="sig-name descname">bitmap_fold</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, const unsigned long *<em> orig</em>, unsigned int<em> sz</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_fold" title="Permalink to this definition">¶</a></dt>
<dd><p>fold larger bitmap into smaller, modulo specified size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>resulting smaller bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt><dd><p>original larger bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt><dd><p>specified size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each bit oldbit in <strong>orig</strong>, set bit oldbit mod <strong>sz</strong> in <strong>dst</strong>.
Clear all other bits in <strong>dst</strong>.  See further the comment and
Example [2] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_onto()</span></code></a> for why and how to use this.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area">
unsigned long <code class="sig-name descname">bitmap_find_next_zero_area</code><span class="sig-paren">(</span>unsigned long *<em> map</em>, unsigned long<em> size</em>, unsigned long<em> start</em>, unsigned int<em> nr</em>, unsigned long<em> align_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>The address to base the search on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>The bitmap size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>The bitnumber to start searching at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>The number of zeroed bits we’re looking for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt><dd><p>Alignment mask for zero area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds is multiples of that
power of 2. A <strong>align_mask</strong> of 0 means no alignment is required.</p>
<dl class="function">
<dt id="c.bitmap_or_equal">
bool <code class="sig-name descname">bitmap_or_equal</code><span class="sig-paren">(</span>const unsigned long *<em> src1</em>, const unsigned long *<em> src2</em>, const unsigned long *<em> src3</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_or_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the or of two bitmaps is equal to a third</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src1</span></code></dt><dd><p>Pointer to bitmap 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src2</span></code></dt><dd><p>Pointer to bitmap 2 will be or’ed with bitmap 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src3</span></code></dt><dd><p>Pointer to bitmap 3. Compare to the result of <strong>*src1</strong> | <strong>*src2</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if (<strong>*src1</strong> | <strong>*src2</strong>) == <strong>*src3</strong>, false otherwise</p>
<dl class="function">
<dt id="c.BITMAP_FROM_U64">
<code class="sig-name descname">BITMAP_FROM_U64</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.BITMAP_FROM_U64" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent u64 value in the format suitable for bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>u64 value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Linux bitmaps are internally arrays of unsigned longs, i.e. 32-bit
integers in 32-bit environment, and 64-bit integers in 64-bit one.</p>
<p>There are four combinations of endianness and length of the word in linux
ABIs: LE64, BE64, LE32 and BE32.</p>
<p>On 64-bit kernels 64-bit LE and BE numbers are naturally ordered in
bitmaps and therefore don’t require any special handling.</p>
<p>On 32-bit kernels 32-bit LE ABI orders lo word of 64-bit number in memory
prior to hi, and 32-bit BE orders hi word prior to lo. The bitmap on the
other hand is represented as an array of 32-bit words and the position of
bit N may therefore be calculated as: word #(N/32) and bit #(N``32``) in that
word.  For example, bit #42 is located at 10th position of 2nd word.
It matches 32-bit LE ABI, and we can simply let the compiler store 64-bit
values in memory as it usually does. But for BE we need to swap hi and lo
words manually.</p>
<p>With all that, the macro <a class="reference internal" href="#c.BITMAP_FROM_U64" title="BITMAP_FROM_U64"><code class="xref c c-func docutils literal notranslate"><span class="pre">BITMAP_FROM_U64()</span></code></a> does explicit reordering of hi and
lo parts of u64.  For LE32 it does nothing, and for BE environment it swaps
hi and lo words, as is expected by bitmap.</p>
<dl class="function">
<dt id="c.bitmap_from_u64">
void <code class="sig-name descname">bitmap_from_u64</code><span class="sig-paren">(</span>unsigned long *<em> dst</em>, u64<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and swap words within u64.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">mask</span></code></dt><dd><p>source bitmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In 32-bit Big Endian kernel, when using <code class="docutils literal notranslate"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[*]</span></code>
to read u64 mask, we will get the wrong word.
That is <code class="docutils literal notranslate"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[0]</span></code> gets the upper 32 bits,
but we expect the lower 32-bits of u64.</p>
<dl class="function">
<dt id="c.bitmap_get_value8">
unsigned long <code class="sig-name descname">bitmap_get_value8</code><span class="sig-paren">(</span>const unsigned long *<em> map</em>, unsigned long<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_get_value8" title="Permalink to this definition">¶</a></dt>
<dd><p>get an 8-bit value within a memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>address to the bitmap memory region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>bit offset of the 8-bit value; must be a multiple of 8</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the 8-bit value located at the <strong>start</strong> bit offset within the <strong>src</strong>
memory region.</p>
<dl class="function">
<dt id="c.bitmap_set_value8">
void <code class="sig-name descname">bitmap_set_value8</code><span class="sig-paren">(</span>unsigned long *<em> map</em>, unsigned long<em> value</em>, unsigned long<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_set_value8" title="Permalink to this definition">¶</a></dt>
<dd><p>set an 8-bit value within a memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>address to the bitmap memory region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">value</span></code></dt><dd><p>the 8-bit value; values wider than 8 bits may clobber bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>bit offset of the 8-bit value; must be a multiple of 8</p>
</dd>
</dl>
</div>
<div class="section" id="command-line-parsing">
<h3>Command-line Parsing<a class="headerlink" href="#command-line-parsing" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.get_option">
int <code class="sig-name descname">get_option</code><span class="sig-paren">(</span>char **<em> str</em>, int *<em> pint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse integer from an option string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt><dd><p>option string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">pint</span></code></dt><dd><p>(output) integer value parsed from <strong>str</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read an int from an option string; if available accept a subsequent
comma as well.</p>
<p>Return values:
0 - no int in string
1 - int found, no subsequent comma
2 - int found including a subsequent comma
3 - hyphen found to denote a range</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_options">
char * <code class="sig-name descname">get_options</code><span class="sig-paren">(</span>const char *<em> str</em>, int<em> nints</em>, int *<em> ints</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a string into a list of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt><dd><p>String to be parsed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nints</span></code></dt><dd><p>size of integer array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ints</span></code></dt><dd><p>integer array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function parses a string containing a comma-separated
list of integers, a hyphen-separated range of _positive_ integers,
or a combination of both.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.</p>
<p>Return value is the character in the string which caused
the parse to end (typically a null terminator, if <strong>str</strong> is
completely parseable).</p>
</div></blockquote>
<dl class="function">
<dt id="c.memparse">
unsigned long long <code class="sig-name descname">memparse</code><span class="sig-paren">(</span>const char *<em> ptr</em>, char **<em> retptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memparse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string with mem suffixes into a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt><dd><p>Where parse begins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">retptr</span></code></dt><dd><p>(output) Optional pointer to next char after parse completes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Parses a string into a number.  The number stored at <strong>ptr</strong> is
potentially suffixed with K, M, G, T, P, E.</p>
</div></blockquote>
</div>
<div class="section" id="sorting">
<h3>Sorting<a class="headerlink" href="#sorting" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sort_r">
void <code class="sig-name descname">sort_r</code><span class="sig-paren">(</span>void *<em> base</em>, size_t<em> num</em>, size_t<em> size</em>, cmp_r_func_t<em> cmp_func</em>, swap_func_t<em> swap_func</em>, const void *<em> priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sort_r" title="Permalink to this definition">¶</a></dt>
<dd><p>sort an array of elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">base</span></code></dt><dd><p>pointer to data to sort</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>number of elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of each element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmp_r_func_t</span> <span class="pre">cmp_func</span></code></dt><dd><p>pointer to comparison function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_func_t</span> <span class="pre">swap_func</span></code></dt><dd><p>pointer to swap function or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt><dd><p>third argument passed to comparison function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does a heapsort on the given array.  You may provide
a swap_func function if you need to do something more than a memory
copy (e.g. fix up pointers or auxiliary data), but the built-in swap
avoids a slow retpoline and so is significantly faster.</p>
<p>Sorting time is O(n log n) both on average and worst-case. While
quicksort is slightly faster on average, it suffers from exploitable
O(n*n) worst-case behavior and extra memory requirements that make
it less suitable for kernel use.</p>
<dl class="function">
<dt id="c.list_sort">
void <code class="sig-name descname">list_sort</code><span class="sig-paren">(</span>void *<em> priv</em>, struct list_head *<em> head</em>, int (<em>*cmp</em>)(void *priv, struct list_head *a, struct list_head *b)<span class="sig-paren">)</span><a class="headerlink" href="#c.list_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt><dd><p>private data, opaque to <a class="reference internal" href="#c.list_sort" title="list_sort"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_sort()</span></code></a>, passed to <strong>cmp</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the list to sort</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*priv,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*a,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*b)</span> <span class="pre">cmp</span></code></dt><dd><p>the elements comparison function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The comparison funtion <strong>cmp</strong> must return &gt; 0 if <strong>a</strong> should sort after
<strong>b</strong> (“<strong>a</strong> &gt; <strong>b</strong>” if you want an ascending sort), and &lt;= 0 if <strong>a</strong> should
sort before <strong>b</strong> <em>or</em> their original order should be preserved.  It is
always called with the element that came first in the input in <strong>a</strong>,
and list_sort is a stable sort, so it is not necessary to distinguish
the <strong>a</strong> &lt; <strong>b</strong> and <strong>a</strong> == <strong>b</strong> cases.</p>
<p>This is compatible with two styles of <strong>cmp</strong> function:
- The traditional style which returns &lt;0 / =0 / &gt;0, or
- Returning a boolean 0/1.
The latter offers a chance to save a few cycles in the comparison
(which is used by e.g. plug_ctx_cmp() in block/blk-mq.c).</p>
<p>A good way to write a multi-word comparison is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (a-&gt;high != b-&gt;high)
        return a-&gt;high &gt; b-&gt;high;
if (a-&gt;middle != b-&gt;middle)
        return a-&gt;middle &gt; b-&gt;middle;
return a-&gt;low &gt; b-&gt;low;
</pre></div>
</div>
<p>This mergesort is as eager as possible while always performing at least
2:1 balanced merges.  Given two pending sublists of size 2^k, they are
merged to a size-2^(k+1) list as soon as we have 2^k following elements.</p>
<p>Thus, it will avoid cache thrashing as long as 3*2^k elements can
fit into the cache.  Not quite as good as a fully-eager bottom-up
mergesort, but it does use 0.2*n fewer comparisons, so is faster in
the common case that everything fits into L1.</p>
<p>The merging is controlled by “count”, the number of elements in the
pending lists.  This is beautiully simple code, but rather subtle.</p>
<p>Each time we increment “count”, we set one bit (bit k) and clear
bits k-1 .. 0.  Each time this happens (except the very first time
for each bit, when count increments to 2^k), we merge two lists of
size 2^k into one list of size 2^(k+1).</p>
<p>This merge happens exactly when the count reaches an odd multiple of
2^k, which is when we have 2^k elements pending in smaller lists,
so it’s safe to merge away two lists of size 2^k.</p>
<p>After this happens twice, we have created two lists of size 2^(k+1),
which will be merged into a list of size 2^(k+2) before we create
a third list of size 2^(k+1), so there are never more than two pending.</p>
<p>The number of pending lists of size 2^k is determined by the
state of bit k of “count” plus two extra pieces of information:</p>
<ul class="simple">
<li><p>The state of bit k-1 (when k == 0, consider bit -1 always set), and</p></li>
<li><p>Whether the higher-order bits are zero or non-zero (i.e.
is count &gt;= 2^(k+1)).</p></li>
</ul>
<p>There are six states we distinguish.  “x” represents some arbitrary
bits, and “y” represents some arbitrary non-zero bits:
0:  00x: 0 pending of size 2^k;           x pending of sizes &lt; 2^k
1:  01x: 0 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
2: x10x: 0 pending of size 2^k; 2^k     + x pending of sizes &lt; 2^k
3: x11x: 1 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
4: y00x: 1 pending of size 2^k; 2^k     + x pending of sizes &lt; 2^k
5: y01x: 2 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
(merge and loop back to state 2)</p>
<p>We gain lists of size 2^k in the 2-&gt;3 and 4-&gt;5 transitions (because
bit k-1 is set while the more significant bits are non-zero) and
merge them away in the 5-&gt;2 transition.  Note in particular that just
before the 5-&gt;2 transition, all lower-order bits are 11 (state 3),
so there is one list of each smaller size.</p>
<p>When we reach the end of the input, we merge all the pending
lists, from smallest to largest.  If you work through cases 2 to
5 above, you can see that the number of elements we merge with a list
of size 2^k varies from 2^(k-1) (cases 3 and 5 when x == 0) to
2^(k+1) - 1 (second merge of case 5 when x == 2^(k-1) - 1).</p>
</div>
<div class="section" id="text-searching">
<h3>Text Searching<a class="headerlink" href="#text-searching" title="Permalink to this headline">¶</a></h3>
<p>INTRODUCTION</p>
<blockquote>
<div><p>The textsearch infrastructure provides text searching facilities for
both linear and non-linear data. Individual search algorithms are
implemented in modules and chosen by the user.</p>
</div></blockquote>
<p>ARCHITECTURE</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  User
  +----------------+
  |        finish()|&lt;--------------(6)-----------------+
  |get_next_block()|&lt;--------------(5)---------------+ |
  |                |                     Algorithm   | |
  |                |                    +------------------------------+
  |                |                    |  init()   find()   destroy() |
  |                |                    +------------------------------+
  |                |       Core API           ^       ^          ^
  |                |      +---------------+  (2)     (4)        (8)
  |             (1)|-----&gt;| prepare()     |---+       |          |
  |             (3)|-----&gt;| find()/next() |-----------+          |
  |             (7)|-----&gt;| destroy()     |----------------------+
  +----------------+      +---------------+

(1) User configures a search by calling textsearch_prepare() specifying
    the search parameters such as the pattern and algorithm name.
(2) Core requests the algorithm to allocate and initialize a search
    configuration according to the specified parameters.
(3) User starts the search(es) by calling textsearch_find() or
    textsearch_next() to fetch subsequent occurrences. A state variable
    is provided to the algorithm to store persistent variables.
(4) Core eventually resets the search offset and forwards the find()
    request to the algorithm.
(5) Algorithm calls get_next_block() provided by the user continuously
    to fetch the data to be searched in block by block.
(6) Algorithm invokes finish() after the last call to get_next_block
    to clean up any leftovers from get_next_block. (Optional)
(7) User destroys the configuration by calling textsearch_destroy().
(8) Core notifies the algorithm to destroy algorithm specific
    allocations. (Optional)
</pre></div>
</div>
<p>USAGE</p>
<blockquote>
<div><p>Before a search can be performed, a configuration must be created
by calling <a class="reference internal" href="#c.textsearch_prepare" title="textsearch_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_prepare()</span></code></a> specifying the searching algorithm,
the pattern to look for and flags. As a flag, you can set TS_IGNORECASE
to perform case insensitive matching. But it might slow down
performance of algorithm, so you should use it at own your risk.
The returned configuration may then be used for an arbitrary
amount of times and even in parallel as long as a separate struct
ts_state variable is provided to every instance.</p>
<p>The actual search is performed by either calling
<a class="reference internal" href="#c.textsearch_find_continuous" title="textsearch_find_continuous"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find_continuous()</span></code></a> for linear data or by providing
an own get_next_block() implementation and
calling <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a>. Both functions return
the position of the first occurrence of the pattern or UINT_MAX if
no match was found. Subsequent occurrences can be found by calling
<a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> regardless of the linearity of the data.</p>
<p>Once you’re done using a configuration it must be given back via
textsearch_destroy.</p>
</div></blockquote>
<p>EXAMPLE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pos;
struct ts_config *conf;
struct ts_state state;
const char *pattern = &quot;chicken&quot;;
const char *example = &quot;We dance the funky chicken&quot;;

conf = textsearch_prepare(&quot;kmp&quot;, pattern, strlen(pattern),
                          GFP_KERNEL, TS_AUTOLOAD);
if (IS_ERR(conf)) {
    err = PTR_ERR(conf);
    goto errout;
}

pos = textsearch_find_continuous(conf, &amp;state, example, strlen(example));
if (pos != UINT_MAX)
    panic(&quot;Oh my god, dancing chickens at %d\n&quot;, pos);

textsearch_destroy(conf);
</pre></div>
</div>
<dl class="function">
<dt id="c.textsearch_register">
int <code class="sig-name descname">textsearch_register</code><span class="sig-paren">(</span>struct ts_ops *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a textsearch module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>operations lookup table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their presence. The specified &amp;**ops** must have <code class="docutils literal notranslate"><span class="pre">name</span></code> set to a
unique identifier and the callbacks find(), init(), get_pattern(),
and get_pattern_len() must be implemented.</p>
<p>Returns 0 or -EEXISTS if another module has already registered
with same name.</p>
<dl class="function">
<dt id="c.textsearch_unregister">
int <code class="sig-name descname">textsearch_unregister</code><span class="sig-paren">(</span>struct ts_ops *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a textsearch module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>operations lookup table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their disappearance for examples when the module gets unloaded.
The <code class="xref c c-type docutils literal notranslate"><span class="pre">ops</span></code> parameter must be the same as the one during the
registration.</p>
<p>Returns 0 on success or -ENOENT if no matching textsearch
registration was found.</p>
<dl class="function">
<dt id="c.textsearch_find_continuous">
unsigned int <code class="sig-name descname">textsearch_find_continuous</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em>, struct ts_state *<em> state</em>, const void *<em> data</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find_continuous" title="Permalink to this definition">¶</a></dt>
<dd><p>search a pattern in continuous/linear data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>search state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>data to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simplified version of <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a> for continuous/linear data.
Call <a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> to retrieve subsequent matches.</p>
<p>Returns the position of first occurrence of the pattern or
<code class="docutils literal notranslate"><span class="pre">UINT_MAX</span></code> if no occurrence was found.</p>
<dl class="function">
<dt id="c.textsearch_prepare">
struct ts_config * <code class="sig-name descname">textsearch_prepare</code><span class="sig-paren">(</span>const char *<em> algo</em>, const void *<em> pattern</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">algo</span></code></dt><dd><p>name of search algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">pattern</span></code></dt><dd><p>pattern data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of pattern</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>search flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the search algorithm module and creates a new textsearch
configuration for the specified pattern.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The format of the pattern may not be compatible between</dt><dd><p>the various search algorithms.</p>
</dd>
</dl>
<p>Returns a new textsearch configuration according to the specified
parameters or a ERR_PTR(). If a zero length pattern is passed, this
function returns EINVAL.</p>
<dl class="function">
<dt id="c.textsearch_destroy">
void <code class="sig-name descname">textsearch_destroy</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a search configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all references of the configuration and frees
up the memory.</p>
<dl class="function">
<dt id="c.textsearch_next">
unsigned int <code class="sig-name descname">textsearch_next</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em>, struct ts_state *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_next" title="Permalink to this definition">¶</a></dt>
<dd><p>continue searching for a pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>search state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continues a search looking for more occurrences of the pattern.
<a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a> must be called to find the first occurrence
in order to reset the state.</p>
<p>Returns the position of the next occurrence of the pattern or
UINT_MAX if not match was found.</p>
<dl class="function">
<dt id="c.textsearch_find">
unsigned int <code class="sig-name descname">textsearch_find</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em>, struct ts_state *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find" title="Permalink to this definition">¶</a></dt>
<dd><p>start searching for a pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>search state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the position of first occurrence of the pattern or
UINT_MAX if no match was found.</p>
<dl class="function">
<dt id="c.textsearch_get_pattern">
void * <code class="sig-name descname">textsearch_get_pattern</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>return head of the pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
<dl class="function">
<dt id="c.textsearch_get_pattern_len">
unsigned int <code class="sig-name descname">textsearch_get_pattern_len</code><span class="sig-paren">(</span>struct ts_config *<em> conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern_len" title="Permalink to this definition">¶</a></dt>
<dd><p>return length of the pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="crc-and-math-functions-in-linux">
<h2>CRC and Math Functions in Linux<a class="headerlink" href="#crc-and-math-functions-in-linux" title="Permalink to this headline">¶</a></h2>
<div class="section" id="crc-functions">
<h3>CRC Functions<a class="headerlink" href="#crc-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.crc4">
uint8_t <code class="sig-name descname">crc4</code><span class="sig-paren">(</span>uint8_t<em> c</em>, uint64_t<em> x</em>, int<em> bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc4" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the 4-bit crc of a value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">c</span></code></dt><dd><p>starting crc4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">x</span></code></dt><dd><p>value to checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in <strong>x</strong> to checksum</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the crc4 value of <strong>x</strong>, using polynomial 0b10111.</p>
<p>The <strong>x</strong> value is treated as left-aligned, and bits above <strong>bits</strong> are ignored
in the crc calculations.</p>
<dl class="function">
<dt id="c.crc7_be">
u8 <code class="sig-name descname">crc7_be</code><span class="sig-paren">(</span>u8<em> crc</em>, const u8 *<em> buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc7_be" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CRC7 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC7 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>any</p>
<p><strong>Description</strong></p>
<p>Returns the updated CRC7 value.
The CRC7 is left-aligned in the byte (the lsbit is always 0), as that
makes the computation easier, and all callers want it in that form.</p>
<dl class="function">
<dt id="c.crc8_populate_msb">
void <code class="sig-name descname">crc8_populate_msb</code><span class="sig-paren">(</span>u8<em> table</em>, u8<em> polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_msb" title="Permalink to this definition">¶</a></dt>
<dd><p>fill crc table for given polynomial in reverse bit order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">table</span></code></dt><dd><p>table to be filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt><dd><p>polynomial for which table is to be filled.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc8_populate_lsb">
void <code class="sig-name descname">crc8_populate_lsb</code><span class="sig-paren">(</span>u8<em> table</em>, u8<em> polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_lsb" title="Permalink to this definition">¶</a></dt>
<dd><p>fill crc table for given polynomial in regular bit order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">table</span></code></dt><dd><p>table to be filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt><dd><p>polynomial for which table is to be filled.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc8">
u8 <code class="sig-name descname">crc8</code><span class="sig-paren">(</span>const u8<em> table</em>, u8 *<em> pdata</em>, size_t<em> nbytes</em>, u8<em> crc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate a crc8 over the given input data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">table</span></code></dt><dd><p>crc table used for calculation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">pdata</span></code></dt><dd><p>pointer to data buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes in data buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">crc</span></code></dt><dd><p>previous returned crc8 value.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc16">
u16 <code class="sig-name descname">crc16</code><span class="sig-paren">(</span>u16<em> crc</em>, u8 const *<em> buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the CRC-16 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value.</p>
<dl class="function">
<dt id="c.crc32_le_generic">
u32 __pure <code class="sig-name descname">crc32_le_generic</code><span class="sig-paren">(</span>u32<em> crc</em>, unsigned char const *<em> p</em>, size_t<em> len</em>, const u32 ( *<em> tab</em>, u32<em> polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_le_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise little-endian Ethernet AUTODIN II CRC32/CRC32C</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>seed value for computation.  ~0 for Ethernet, sometimes 0 for other
uses, or the previous crc32/crc32c value if computing incrementally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>pointer to buffer over which CRC32/CRC32C is run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of buffer <strong>p</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt><dd><p>little-endian Ethernet table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>CRC32/CRC32c LE polynomial</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc32_generic_shift">
u32 __attribute_const__ <code class="sig-name descname">crc32_generic_shift</code><span class="sig-paren">(</span>u32<em> crc</em>, size_t<em> len</em>, u32<em> polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_generic_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <strong>len</strong> 0 bytes to crc, in logarithmic time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>The original little-endian CRC (i.e. lsbit is x^31 coefficient)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The number of bytes. <strong>crc</strong> is multiplied by x^(8***len**)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>The modulus used to reduce the result to 32 bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s possible to parallelize CRC computations by computing a CRC
over separate ranges of a buffer, then summing them.
This shifts the given CRC by 8*len bits (i.e. produces the same effect
as appending len bytes of zero to the data), in time proportional
to log(len).</p>
<dl class="function">
<dt id="c.crc32_be_generic">
u32 __pure <code class="sig-name descname">crc32_be_generic</code><span class="sig-paren">(</span>u32<em> crc</em>, unsigned char const *<em> p</em>, size_t<em> len</em>, const u32 ( *<em> tab</em>, u32<em> polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_be_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise big-endian Ethernet AUTODIN II CRC32</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>pointer to buffer over which CRC32 is run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of buffer <strong>p</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt><dd><p>big-endian Ethernet table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>CRC32 BE polynomial</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt">
u16 <code class="sig-name descname">crc_ccitt</code><span class="sig-paren">(</span>u16<em> crc</em>, u8 const *<em> buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC (CRC-CCITT variant) for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt_false">
u16 <code class="sig-name descname">crc_ccitt_false</code><span class="sig-paren">(</span>u16<em> crc</em>, u8 const *<em> buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt_false" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC (CRC-CCITT-FALSE variant) for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.crc_itu_t">
u16 <code class="sig-name descname">crc_itu_t</code><span class="sig-paren">(</span>u16<em> crc</em>, const u8 *<em> buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_itu_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the CRC-ITU-T for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value</p>
</div>
<div class="section" id="base-2-log-and-power-functions">
<h3>Base 2 log and power Functions<a class="headerlink" href="#base-2-log-and-power-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.is_power_of_2">
bool <code class="sig-name descname">is_power_of_2</code><span class="sig-paren">(</span>unsigned long<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_power_of_2" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a value is a power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>the value to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether some value is a power of two, where zero is
<em>not</em> considered a power of two.</p>
<p><strong>Return</strong></p>
<p>true if <strong>n</strong> is a power of 2, otherwise false.</p>
<dl class="function">
<dt id="c.__roundup_pow_of_two">
unsigned long <code class="sig-name descname">__roundup_pow_of_two</code><span class="sig-paren">(</span>unsigned long<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__roundup_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round up to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>value to round up</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__rounddown_pow_of_two">
unsigned long <code class="sig-name descname">__rounddown_pow_of_two</code><span class="sig-paren">(</span>unsigned long<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__rounddown_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round down to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>value to round down</p>
</dd>
</dl>
<dl class="function">
<dt id="c.const_ilog2">
<code class="sig-name descname">const_ilog2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.const_ilog2" title="Permalink to this definition">¶</a></dt>
<dd><p>log base 2 of 32-bit or a 64-bit constant unsigned value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this where sparse expects a true constant expression, e.g. for array
indices.</p>
<dl class="function">
<dt id="c.ilog2">
<code class="sig-name descname">ilog2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilog2" title="Permalink to this definition">¶</a></dt>
<dd><p>log base 2 of 32-bit or a 64-bit unsigned value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>constant-capable log of base 2 calculation
- this can be used to initialise global variables from constant data, hence
the massive ternary operator construction</p>
<p>selects the appropriately-sized optimised version depending on sizeof(n)</p>
<dl class="function">
<dt id="c.roundup_pow_of_two">
<code class="sig-name descname">roundup_pow_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.roundup_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round the given value up to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value up to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
<dl class="function">
<dt id="c.rounddown_pow_of_two">
<code class="sig-name descname">rounddown_pow_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rounddown_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round the given value down to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value down to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
<dl class="function">
<dt id="c.order_base_2">
<code class="sig-name descname">order_base_2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.order_base_2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the (rounded up) base 2 order of the argument</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The first few values calculated by this routine:</dt><dd><p>ob2(0) = 0
ob2(1) = 0
ob2(2) = 1
ob2(3) = 2
ob2(4) = 2
ob2(5) = 3
… and so on.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bits_per">
<code class="sig-name descname">bits_per</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bits_per" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the number of bits required for the argument</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is constant-capable and can be used for compile time
initializations, e.g bitfields.</p>
<p>The first few values calculated by this routine:
bf(0) = 1
bf(1) = 1
bf(2) = 2
bf(3) = 2
bf(4) = 3
… and so on.</p>
</div>
<div class="section" id="integer-power-functions">
<h3>Integer power Functions<a class="headerlink" href="#integer-power-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.int_pow">
u64 <code class="sig-name descname">int_pow</code><span class="sig-paren">(</span>u64<em> base</em>, unsigned int<em> exp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int_pow" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the exponentiation of the given base and exponent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">base</span></code></dt><dd><p>base which will be raised to the given power</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">exp</span></code></dt><dd><p>power to be raised to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes: pow(base, exp), i.e. <strong>base</strong> raised to the <strong>exp</strong> power</p>
<dl class="function">
<dt id="c.int_sqrt">
unsigned long <code class="sig-name descname">int_sqrt</code><span class="sig-paren">(</span>unsigned long<em> x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the integer square root</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">x</span></code></dt><dd><p>integer of which to calculate the sqrt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes: floor(sqrt(x))</p>
<dl class="function">
<dt id="c.int_sqrt64">
u32 <code class="sig-name descname">int_sqrt64</code><span class="sig-paren">(</span>u64<em> x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int_sqrt64" title="Permalink to this definition">¶</a></dt>
<dd><p>strongly typed int_sqrt function when minimum 64 bit input is expected.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">x</span></code></dt><dd><p>64bit integer of which to calculate the sqrt</p>
</dd>
</dl>
</div>
<div class="section" id="division-functions">
<h3>Division Functions<a class="headerlink" href="#division-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.do_div">
<code class="sig-name descname">do_div</code><span class="sig-paren">(</span><em>n</em>, <em>base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_div" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 2 values: calculate remainder and update new dividend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>uint64_t dividend (will be updated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>uint32_t divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Summary:
<code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">remainder</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">%</span> <span class="pre">base;</span></code>
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">/</span> <span class="pre">base;</span></code></p>
<p><strong>Return</strong></p>
<p>(uint32_t)remainder</p>
<p><strong>NOTE</strong></p>
<p>macro parameter <strong>n</strong> is evaluated multiple times,
beware of side effects!</p>
<dl class="function">
<dt id="c.div_u64_rem">
u64 <code class="sig-name descname">div_u64_rem</code><span class="sig-paren">(</span>u64<em> dividend</em>, u32<em> divisor</em>, u32 *<em> remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 32bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt><dd><p>pointer to unsigned 32bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<p>This is commonly provided by 32bit archs to provide an optimized 64bit
divide.</p>
<dl class="function">
<dt id="c.div_s64_rem">
s64 <code class="sig-name descname">div_s64_rem</code><span class="sig-paren">(</span>s64<em> dividend</em>, s32<em> divisor</em>, s32 *<em> remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt><dd><p>signed 32bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt><dd><p>pointer to signed 32bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<dl class="function">
<dt id="c.div64_u64_rem">
u64 <code class="sig-name descname">div64_u64_rem</code><span class="sig-paren">(</span>u64<em> dividend</em>, u64<em> divisor</em>, u64 *<em> remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt><dd><p>pointer to unsigned 64bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<dl class="function">
<dt id="c.div64_u64">
u64 <code class="sig-name descname">div64_u64</code><span class="sig-paren">(</span>u64<em> dividend</em>, u64<em> divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
<dl class="function">
<dt id="c.div64_s64">
s64 <code class="sig-name descname">div64_s64</code><span class="sig-paren">(</span>s64<em> dividend</em>, s64<em> divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_s64" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">divisor</span></code></dt><dd><p>signed 64bit divisor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
<dl class="function">
<dt id="c.div_u64">
u64 <code class="sig-name descname">div_u64</code><span class="sig-paren">(</span>u64<em> dividend</em>, u32<em> divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 32bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 32bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the most common 64bit divide and should be used if possible,
as many 32bit archs can optimize this variant better than a full 64bit
divide.</p>
<dl class="function">
<dt id="c.div_s64">
s64 <code class="sig-name descname">div_s64</code><span class="sig-paren">(</span>s64<em> dividend</em>, s32<em> divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 32bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt><dd><p>signed 32bit divisor</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DIV64_U64_ROUND_CLOSEST">
<code class="sig-name descname">DIV64_U64_ROUND_CLOSEST</code><span class="sig-paren">(</span><em>dividend</em>, <em>divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DIV64_U64_ROUND_CLOSEST" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 64bit divisor rounded to nearest integer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide unsigned 64bit dividend by unsigned 64bit divisor
and round to closest integer.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor rounded to nearest integer</p>
<dl class="function">
<dt>
s64 <code class="sig-name descname">div_s64_rem</code><span class="sig-paren">(</span>s64<em> dividend</em>, s32<em> divisor</em>, s32 *<em> remainder</em><span class="sig-paren">)</span></dt>
<dd><p>signed 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt><dd><p>64bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt><dd><p>64bit remainder</p>
</dd>
</dl>
<dl class="function">
<dt>
u64 <code class="sig-name descname">div64_u64_rem</code><span class="sig-paren">(</span>u64<em> dividend</em>, u64<em> divisor</em>, u64 *<em> remainder</em><span class="sig-paren">)</span></dt>
<dd><p>unsigned 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>64bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt><dd><p>64bit remainder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implementation is a comparable to algorithm used by div64_u64.
But this operation, which includes math for calculating the remainder,
is kept distinct to avoid slowing down the div64_u64 operation on 32bit
systems.</p>
<dl class="function">
<dt>
u64 <code class="sig-name descname">div64_u64</code><span class="sig-paren">(</span>u64<em> dividend</em>, u64<em> divisor</em><span class="sig-paren">)</span></dt>
<dd><p>unsigned 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>64bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implementation is a modified version of the algorithm proposed
by the book ‘Hacker’s Delight’.  The original source and full proof
can be found here and is available for use without restriction.</p>
<p>‘<a class="reference external" href="http://www.hackersdelight.org/hdcodetxt/divDouble.c.txt">http://www.hackersdelight.org/hdcodetxt/divDouble.c.txt</a>’</p>
<dl class="function">
<dt>
s64 <code class="sig-name descname">div64_s64</code><span class="sig-paren">(</span>s64<em> dividend</em>, s64<em> divisor</em><span class="sig-paren">)</span></dt>
<dd><p>signed 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">divisor</span></code></dt><dd><p>64bit divisor</p>
</dd>
</dl>
<dl class="function">
<dt id="c.gcd">
unsigned long <code class="sig-name descname">gcd</code><span class="sig-paren">(</span>unsigned long<em> a</em>, unsigned long<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate and return the greatest common divisor of 2 unsigned longs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>first value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b</span></code></dt><dd><p>second value</p>
</dd>
</dl>
</div>
<div class="section" id="uuid-guid">
<h3>UUID/GUID<a class="headerlink" href="#uuid-guid" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.generate_random_uuid">
void <code class="sig-name descname">generate_random_uuid</code><span class="sig-paren">(</span>unsigned char<em> uuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generate_random_uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a random UUID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">uuid</span></code></dt><dd><p>where to put the generated UUID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Random UUID interface</p>
<p>Used to create a Boot ID or a filesystem UUID/GUID, but can be
useful for other kernel drivers.</p>
<dl class="function">
<dt id="c.uuid_is_valid">
bool <code class="sig-name descname">uuid_is_valid</code><span class="sig-paren">(</span>const char *<em> uuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uuid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>checks if a UUID string is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uuid</span></code></dt><dd><p>UUID string to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>It checks if the UUID string is following the format:</dt><dd><p>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</p>
</dd>
</dl>
<p>where x is a hex digit.</p>
<p><strong>Return</strong></p>
<p>true if input is valid UUID string.</p>
</div>
</div>
<div class="section" id="kernel-ipc-facilities">
<h2>Kernel IPC facilities<a class="headerlink" href="#kernel-ipc-facilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ipc-utilities">
<h3>IPC utilities<a class="headerlink" href="#ipc-utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.ipc_init">
int <code class="sig-name descname">ipc_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The various sysv ipc resources (semaphores, messages and shared
memory) are initialised.</p>
<p>A callback routine is registered into the memory hotplug notifier
chain: since msgmni scales to lowmem this callback routine will be
called upon successful memory add / remove to recompute msmgni.</p>
<dl class="function">
<dt id="c.ipc_init_ids">
void <code class="sig-name descname">ipc_init_ids</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc identifiers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the sequence range to use for the ipc identifier range (limited
below ipc_mni) then initialise the keys hashtable and ids idr.</p>
<dl class="function">
<dt id="c.ipc_init_proc_interface">
void <code class="sig-name descname">ipc_init_proc_interface</code><span class="sig-paren">(</span>const char *<em> path</em>, const char *<em> header</em>, int<em> ids</em>, int (<em>*show</em>)(struct seq_file *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_proc_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>create a proc interface for sysipc types using a seq_file interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt><dd><p>Path in procfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">header</span></code></dt><dd><p>Banner to be printed at the beginning of the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ids</span></code></dt><dd><p>ipc id table to iterate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">show</span></code></dt><dd><p>show routine.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.ipc_findkey">
struct kern_ipc_perm * <code class="sig-name descname">ipc_findkey</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, key_t<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_findkey" title="Permalink to this definition">¶</a></dt>
<dd><p>find a key in an ipc identifier set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_t</span> <span class="pre">key</span></code></dt><dd><p>key to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked pointer to the ipc structure if found or NULL
otherwise. If key is found ipc points to the owning ipc structure</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_addid">
int <code class="sig-name descname">ipc_addid</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, struct kern_ipc_perm *<em> new</em>, int<em> limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_addid" title="Permalink to this definition">¶</a></dt>
<dd><p>add an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">limit</span></code></dt><dd><p>limit for the number of used ids</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry ‘new’ to the ipc ids idr. The permissions object is
initialised and the first free entry is set up and the index assigned
is returned. The ‘new’ entry is returned in a locked state on success.</p>
<p>On failure the entry is not locked and a negative err-code is returned.
The caller must use ipc_rcu_putref() to free the identifier.</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipcget_new">
int <code class="sig-name descname">ipcget_new</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct ipc_ids *<em> ids</em>, const struct ipc_ops *<em> ops</em>, struct ipc_params *<em> params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the actual creation routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, sys_semget() and sys_shmget()
when the key is IPC_PRIVATE.</p>
<dl class="function">
<dt id="c.ipc_check_perms">
int <code class="sig-name descname">ipc_check_perms</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct kern_ipc_perm *<em> ipcp</em>, const struct ipc_ops *<em> ops</em>, struct ipc_params *<em> params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_check_perms" title="Permalink to this definition">¶</a></dt>
<dd><p>check security and permissions for an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the actual security routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget(), sys_semget() and sys_shmget()
when the key is not IPC_PRIVATE and that key already exists in the
ds IDR.</p>
<p>On success, the ipc id is returned.</p>
<p>It is called with ipc_ids.rwsem and ipcp-&gt;lock held.</p>
<dl class="function">
<dt id="c.ipcget_public">
int <code class="sig-name descname">ipcget_public</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct ipc_ids *<em> ids</em>, const struct ipc_ops *<em> ops</em>, struct ipc_params *<em> params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_public" title="Permalink to this definition">¶</a></dt>
<dd><p>get an ipc object or create a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the actual creation routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, sys_semget() and sys_shmget()
when the key is not IPC_PRIVATE.
It adds a new entry if the key is not found and does some permission
/ security checkings if the key is found.</p>
<p>On success, the ipc id is returned.</p>
<dl class="function">
<dt id="c.ipc_kht_remove">
void <code class="sig-name descname">ipc_kht_remove</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, struct kern_ipc_perm *<em> ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_kht_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc from the key hashtable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc perm structure containing the key to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_rmid">
void <code class="sig-name descname">ipc_rmid</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, struct kern_ipc_perm *<em> ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc perm structure containing the identifier to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_set_key_private">
void <code class="sig-name descname">ipc_set_key_private</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, struct kern_ipc_perm *<em> ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_set_key_private" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the key of an existing ipc to IPC_PRIVATE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc perm structure containing the key to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipcperms">
int <code class="sig-name descname">ipcperms</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct kern_ipc_perm *<em> ipcp</em>, short<em> flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcperms" title="Permalink to this definition">¶</a></dt>
<dd><p>check ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short</span> <span class="pre">flag</span></code></dt><dd><p>desired permission set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check user, group, other permissions for access
to ipc resources. return 0 if allowed</p>
<p><strong>flag</strong> will most probably be 0 or <code class="docutils literal notranslate"><span class="pre">S_...UGO</span></code> from &lt;linux/stat.h&gt;</p>
<dl class="function">
<dt id="c.kernel_to_ipc64_perm">
void <code class="sig-name descname">kernel_to_ipc64_perm</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em> in</em>, struct ipc64_perm *<em> out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_to_ipc64_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert kernel ipc permissions to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt><dd><p>kernel permissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt><dd><p>new style ipc permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the kernel object <strong>in</strong> into a set of permissions descriptions
for returning to userspace (<strong>out</strong>).</p>
<dl class="function">
<dt id="c.ipc64_perm_to_ipc_perm">
void <code class="sig-name descname">ipc64_perm_to_ipc_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em> in</em>, struct ipc_perm *<em> out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc64_perm_to_ipc_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert new ipc permissions to old</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt><dd><p>new style ipc permissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt><dd><p>old style ipc permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the new style permissions object <strong>in</strong> into a compatibility
object and store it into the <strong>out</strong> pointer.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_idr">
struct kern_ipc_perm * <code class="sig-name descname">ipc_obtain_object_idr</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_idr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>ipc id to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and return associated ipc object.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_check">
struct kern_ipc_perm * <code class="sig-name descname">ipc_obtain_object_check</code><span class="sig-paren">(</span>struct ipc_ids *<em> ids</em>, int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_check" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>ipc id to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.ipc_obtain_object_idr" title="ipc_obtain_object_idr"><code class="xref c c-func docutils literal notranslate"><span class="pre">ipc_obtain_object_idr()</span></code></a> but also checks the ipc object
sequence number.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipcget">
int <code class="sig-name descname">ipcget</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct ipc_ids *<em> ids</em>, const struct ipc_ops *<em> ops</em>, struct ipc_params *<em> params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget" title="Permalink to this definition">¶</a></dt>
<dd><p>Common sys_*get() code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>operations to be called on ipc object creation, permission checks
and further checks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>the parameters needed by the previous operations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common routine called by sys_msgget(), sys_semget() and sys_shmget().</p>
<dl class="function">
<dt id="c.ipc_update_perm">
int <code class="sig-name descname">ipc_update_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em> in</em>, struct kern_ipc_perm *<em> out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_update_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>update the permissions of an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt><dd><p>the permission given as input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt><dd><p>the permission of the ipc to set.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.ipcctl_obtain_check">
struct kern_ipc_perm * <code class="sig-name descname">ipcctl_obtain_check</code><span class="sig-paren">(</span>struct ipc_namespace *<em> ns</em>, struct ipc_ids *<em> ids</em>, int<em> id</em>, int<em> cmd</em>, struct ipc64_perm *<em> perm</em>, int<em> extra_perm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcctl_obtain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve an ipc object and check permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt><dd><p>the table of ids where to look for the ipc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>the id of the ipc to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>the cmd to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">perm</span></code></dt><dd><p>the permission to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extra_perm</span></code></dt><dd><p>one extra permission parameter used by msq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does some common audit and permissions check for some IPC_XXX
cmd and is called from semctl_down, shmctl_down and msgctl_down.</p>
<dl class="simple">
<dt>It:</dt><dd><ul class="simple">
<li><p>retrieves the ipc object with the given id in the given table.</p></li>
<li><p>performs some audit and permission check, depending on the given cmd</p></li>
<li><p>returns a pointer to the ipc object or otherwise, the corresponding
error.</p></li>
</ul>
</dd>
</dl>
<p>Call holding the both the rwsem and the rcu read lock.</p>
<dl class="function">
<dt id="c.ipc_parse_version">
int <code class="sig-name descname">ipc_parse_version</code><span class="sig-paren">(</span>int *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>ipc call version</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>pointer to command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
The <strong>cmd</strong> value is turned from an encoding command and version into
just the command code.</p>
</div>
</div>
<div class="section" id="fifo-buffer">
<h2>FIFO Buffer<a class="headerlink" href="#fifo-buffer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo-interface">
<h3>kfifo interface<a class="headerlink" href="#kfifo-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.DECLARE_KFIFO_PTR">
<code class="sig-name descname">DECLARE_KFIFO_PTR</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO_PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo pointer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DECLARE_KFIFO">
<code class="sig-name descname">DECLARE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
</dl>
<dl class="function">
<dt id="c.INIT_KFIFO">
<code class="sig-name descname">INIT_KFIFO</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a fifo declared by DECLARE_KFIFO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo datatype</p>
</dd>
</dl>
<dl class="function">
<dt id="c.DEFINE_KFIFO">
<code class="sig-name descname">DEFINE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to define and initialize a fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo datatype</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>the macro can be used for global and local fifo data type variables.</p>
<dl class="function">
<dt id="c.kfifo_initialized">
<code class="sig-name descname">kfifo_initialized</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the fifo is initialized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if fifo is initialized, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.
Assumes the fifo was 0 before.</p>
<dl class="function">
<dt id="c.kfifo_esize">
<code class="sig-name descname">kfifo_esize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_esize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the element managed by the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_recsize">
<code class="sig-name descname">kfifo_recsize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_recsize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the record length field</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_size">
<code class="sig-name descname">kfifo_size</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the fifo in elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_reset">
<code class="sig-name descname">kfifo_reset</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>removes the entire fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>usage of <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset()</span></code></a> is dangerous. It should be only called when the
fifo is exclusived locked or when it is secured that no other thread is
accessing the fifo.</p>
<dl class="function">
<dt id="c.kfifo_reset_out">
<code class="sig-name descname">kfifo_reset_out</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset_out" title="Permalink to this definition">¶</a></dt>
<dd><p>skip fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The usage of <a class="reference internal" href="#c.kfifo_reset_out" title="kfifo_reset_out"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset_out()</span></code></a> is safe until it will be only called
from the reader thread and there is only one concurrent reader. Otherwise
it is dangerous and must be handled in the same way as <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset()</span></code></a>.</p>
<dl class="function">
<dt id="c.kfifo_len">
<code class="sig-name descname">kfifo_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_len" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of used elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty">
<code class="sig-name descname">kfifo_is_empty</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty_spinlocked">
<code class="sig-name descname">kfifo_is_empty_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock to be used for locking</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty_spinlocked_noirqsave">
<code class="sig-name descname">kfifo_is_empty_spinlocked_noirqsave</code><span class="sig-paren">(</span><em>fifo</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty_spinlocked_noirqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty using a spinlock for locking, doesn’t disable interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock to be used for locking</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_full">
<code class="sig-name descname">kfifo_is_full</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is full</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_avail">
<code class="sig-name descname">kfifo_avail</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of unused elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_skip">
<code class="sig-name descname">kfifo_skip</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_skip" title="Permalink to this definition">¶</a></dt>
<dd><p>skip output data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_peek_len">
<code class="sig-name descname">kfifo_peek_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek_len" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the size of the next fifo record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the size of the next fifo record in number of bytes.</p>
<dl class="function">
<dt id="c.kfifo_alloc">
<code class="sig-name descname">kfifo_alloc</code><span class="sig-paren">(</span><em>fifo</em>, <em>size</em>, <em>gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>dynamically allocates a new fifo buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>pointer to the fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro dynamically allocates a new fifo buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
The fifo will be release with <a class="reference internal" href="#c.kfifo_free" title="kfifo_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_free()</span></code></a>.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_free">
<code class="sig-name descname">kfifo_free</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>the fifo to be freed</p>
</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_init">
<code class="sig-name descname">kfifo_init</code><span class="sig-paren">(</span><em>fifo</em>, <em>buffer</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a fifo using a preallocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>the fifo to assign the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>the preallocated buffer to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the size of the internal buffer, this have to be a power of 2</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes a fifo using a preallocated buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_put">
<code class="sig-name descname">kfifo_put</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>the data to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given value into the fifo.
It returns 0 if the fifo was full. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_get">
<code class="sig-name descname">kfifo_get</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>address where to store the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro reads the data from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_peek">
<code class="sig-name descname">kfifo_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo without removing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>address where to store the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the data from the fifo without removing it from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in">
<code class="sig-name descname">kfifo_in</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given buffer into the fifo and returns the
number of copied elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in_spinlocked">
<code class="sig-name descname">kfifo_in_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given values buffer into the fifo and returns the
number of copied elements.</p>
<dl class="function">
<dt id="c.kfifo_in_spinlocked_noirqsave">
<code class="sig-name descname">kfifo_in_spinlocked_noirqsave</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in_spinlocked_noirqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into fifo using a spinlock for locking, don’t disable interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.kfifo_in_spinlocked" title="kfifo_in_spinlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_in_spinlocked()</span></code></a> but uses spin_lock/unlock()
for locking and doesn’t disable interrupts.</p>
<dl class="function">
<dt id="c.kfifo_out">
<code class="sig-name descname">kfifo_out</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get some data from the fifo and return the numbers of elements
copied.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_out_spinlocked">
<code class="sig-name descname">kfifo_out_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied.</p>
<dl class="function">
<dt id="c.kfifo_out_spinlocked_noirqsave">
<code class="sig-name descname">kfifo_out_spinlocked_noirqsave</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_spinlocked_noirqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo using a spinlock for locking, don’t disable interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.kfifo_out_spinlocked" title="kfifo_out_spinlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_out_spinlocked()</span></code></a> which uses spin_lock/unlock()
for locking and doesn’t disable interrupts.</p>
<dl class="function">
<dt id="c.kfifo_from_user">
<code class="sig-name descname">kfifo_from_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>from</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>puts some data from user space into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from</span></code></dt><dd><p>pointer to the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>the length of the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>pointer to output variable to store the number of copied bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the <strong>from</strong> into the
fifo, depending of the available space and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_to_user">
<code class="sig-name descname">kfifo_to_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>to</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_to_user" title="Permalink to this definition">¶</a></dt>
<dd><p>copies data from the fifo into user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to</span></code></dt><dd><p>where the data must be copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>the size of the destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>pointer to output variable to store the number of copied bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the fifo into the
<strong>to</strong> buffer and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_prepare">
<code class="sig-name descname">kfifo_dma_in_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgl</span></code></dt><dd><p>pointer to the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nents</span></code></dt><dd><p>number of entries in the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of elements to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA input.
It returns the number entries in the scatterlist array.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_finish">
<code class="sig-name descname">kfifo_dma_in_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA IN operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of bytes to received</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA IN operation. The in counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_prepare">
<code class="sig-name descname">kfifo_dma_out_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgl</span></code></dt><dd><p>pointer to the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nents</span></code></dt><dd><p>number of entries in the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of elements to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA output which at most <strong>len</strong> bytes
to transfer.
It returns the number entries in the scatterlist array.
A zero means there is no space available and the scatterlist is not filled.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_finish">
<code class="sig-name descname">kfifo_dma_out_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA OUT operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of bytes transferred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA OUT operation. The out counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_out_peek">
<code class="sig-name descname">kfifo_out_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>gets some data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied. The data is not removed from the fifo.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
</div>
</div>
<div class="section" id="relay-interface-support">
<h2>relay interface support<a class="headerlink" href="#relay-interface-support" title="Permalink to this headline">¶</a></h2>
<p>Relay interface support is designed to provide an efficient mechanism
for tools and facilities to relay large amounts of data from kernel
space to user space.</p>
<div class="section" id="relay-interface">
<h3>relay interface<a class="headerlink" href="#relay-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.relay_buf_full">
int <code class="sig-name descname">relay_buf_full</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_full" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer full?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>channel buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 1 if the buffer is full, 0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_reset">
void <code class="sig-name descname">relay_reset</code><span class="sig-paren">(</span>struct rchan *<em> chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>the channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.</p>
<p>NOTE. Care should be taken that the channel isn’t actually
being used by anything when this call is made.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_open">
struct rchan * <code class="sig-name descname">relay_open</code><span class="sig-paren">(</span>const char *<em> base_filename</em>, struct dentry *<em> parent</em>, size_t<em> subbuf_size</em>, size_t<em> n_subbufs</em>, struct rchan_callbacks *<em> cb</em>, void *<em> private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_open" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new relay channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt><dd><p>base name of files to create, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for buffering only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>dentry of parent directory, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for root directory or buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">subbuf_size</span></code></dt><dd><p>size of sub-buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n_subbufs</span></code></dt><dd><p>number of sub-buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_callbacks</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt><dd><p>client callback functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt><dd><p>user-defined data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns channel pointer if successful, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<p>Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0…base_filenameN-1.  File
permissions will be <code class="docutils literal notranslate"><span class="pre">S_IRUSR</span></code>.</p>
<p>If opening a buffer (<strong>parent</strong> = NULL) that you later wish to register
in a filesystem, call <a class="reference internal" href="#c.relay_late_setup_files" title="relay_late_setup_files"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_late_setup_files()</span></code></a> once the <strong>parent</strong> dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_late_setup_files">
int <code class="sig-name descname">relay_late_setup_files</code><span class="sig-paren">(</span>struct rchan *<em> chan</em>, const char *<em> base_filename</em>, struct dentry *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_late_setup_files" title="Permalink to this definition">¶</a></dt>
<dd><p>triggers file creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>channel to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt><dd><p>base name of files to create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>dentry of parent directory, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for root directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if successful, non-zero otherwise.</p>
<p>Use to setup files for a previously buffer-only channel created
by <a class="reference internal" href="#c.relay_open" title="relay_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_open()</span></code></a> with a NULL parent dentry.</p>
<p>For example, this is useful for perfomring early tracing in kernel,
before VFS is up and then exposing the early results once the dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_switch_subbuf">
size_t <code class="sig-name descname">relay_switch_subbuf</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em>, size_t<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_switch_subbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch to a new sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>size of current event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns either the length passed in or 0 if full.</p>
<p>Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_subbufs_consumed">
void <code class="sig-name descname">relay_subbufs_consumed</code><span class="sig-paren">(</span>struct rchan *<em> chan</em>, unsigned int<em> cpu</em>, size_t<em> subbufs_consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_subbufs_consumed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the buffer’s sub-buffers-consumed count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>the channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the cpu associated with the channel buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">subbufs_consumed</span></code></dt><dd><p>number of sub-buffers to add to current buf’s count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adds to the channel buffer’s consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.</p>
<p>NOTE. Kernel clients don’t need to call this function if the channel
mode is ‘overwrite’.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_close">
void <code class="sig-name descname">relay_close</code><span class="sig-paren">(</span>struct rchan *<em> chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>the channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Closes all channel buffers and frees the channel.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_flush">
void <code class="sig-name descname">relay_flush</code><span class="sig-paren">(</span>struct rchan *<em> chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>the channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Flushes all channel buffers, i.e. forces buffer switch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_mmap_buf">
int <code class="sig-name descname">relay_mmap_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em>, struct vm_area_struct *<em> vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_mmap_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap channel buffer to process address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt><dd><p>vm_area_struct describing memory to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if ok, negative on error</p>
<p>Caller should already have grabbed mmap_sem.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_alloc_buf">
void * <code class="sig-name descname">relay_alloc_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em>, size_t *<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_alloc_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>the buffer struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt><dd><p>total size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns a pointer to the resulting buffer, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if unsuccessful. The
passed in size will get page aligned, if it isn’t already.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_create_buf">
struct rchan_buf * <code class="sig-name descname">relay_create_buf</code><span class="sig-paren">(</span>struct rchan *<em> chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_create_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>the relay channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns channel buffer if successful, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_channel">
void <code class="sig-name descname">relay_destroy_channel</code><span class="sig-paren">(</span>struct kref *<em> kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>free the channel struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt><dd><p>target kernel reference that contains the relay channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Should only be called from kref_put().</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_buf">
void <code class="sig-name descname">relay_destroy_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy an rchan_buf struct and associated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>the buffer struct</p>
</dd>
</dl>
<dl class="function">
<dt id="c.relay_remove_buf">
void <code class="sig-name descname">relay_remove_buf</code><span class="sig-paren">(</span>struct kref *<em> kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_remove_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt><dd><p>target kernel reference that contains the relay buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Removes the file from the filesystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
kref_put().</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_buf_empty">
int <code class="sig-name descname">relay_buf_empty</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer empty?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>channel buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 1 if the buffer is empty, 0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.wakeup_readers">
void <code class="sig-name descname">wakeup_readers</code><span class="sig-paren">(</span>struct irq_work *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeup_readers" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up readers waiting on a channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>contains the channel buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is the function used to defer reader waking</p>
</div></blockquote>
<dl class="function">
<dt id="c.__relay_reset">
void <code class="sig-name descname">__relay_reset</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em>, unsigned int<em> init</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>the channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">init</span></code></dt><dd><p>1 if this is a first-time initialization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>See <a class="reference internal" href="#c.relay_reset" title="relay_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_reset()</span></code></a> for description of effect.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_close_buf">
void <code class="sig-name descname">relay_close_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>close a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>channel buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_open">
int <code class="sig-name descname">relay_file_open</code><span class="sig-paren">(</span>struct inode *<em> inode</em>, struct file *<em> filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_open" title="Permalink to this definition">¶</a></dt>
<dd><p>open file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt><dd><p>the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Increments the channel buffer refcount.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_mmap">
int <code class="sig-name descname">relay_file_mmap</code><span class="sig-paren">(</span>struct file *<em> filp</em>, struct vm_area_struct *<em> vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt><dd><p>the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt><dd><p>the vma describing what to map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Calls upon <a class="reference internal" href="#c.relay_mmap_buf" title="relay_mmap_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_mmap_buf()</span></code></a> to map the file into user space.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_poll">
__poll_t <code class="sig-name descname">relay_file_poll</code><span class="sig-paren">(</span>struct file *<em> filp</em>, poll_table *<em> wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>poll file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt><dd><p>the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt><dd><p>poll table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Poll implemention.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_release">
int <code class="sig-name descname">relay_file_release</code><span class="sig-paren">(</span>struct inode *<em> inode</em>, struct file *<em> filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt><dd><p>the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Decrements the channel refcount, as the filesystem is
no longer using it.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_subbuf_avail">
size_t <code class="sig-name descname">relay_file_read_subbuf_avail</code><span class="sig-paren">(</span>size_t<em> read_pos</em>, struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_subbuf_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>return bytes available in sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt><dd><p>file read position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.relay_file_read_start_pos">
size_t <code class="sig-name descname">relay_file_read_start_pos</code><span class="sig-paren">(</span>size_t<em> read_pos</em>, struct rchan_buf *<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_start_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find the first available byte to read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt><dd><p>file read position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the <strong>read_pos</strong> is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_end_pos">
size_t <code class="sig-name descname">relay_file_read_end_pos</code><span class="sig-paren">(</span>struct rchan_buf *<em> buf</em>, size_t<em> read_pos</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_end_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>return the new read position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt><dd><p>file read position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to be read</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="module-support">
<h2>Module Support<a class="headerlink" href="#module-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-loading">
<h3>Module Loading<a class="headerlink" href="#module-loading" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__request_module">
int <code class="sig-name descname">__request_module</code><span class="sig-paren">(</span>bool<em> wait</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.__request_module" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load a kernel module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait</span></code></dt><dd><p>wait (or not) for the operation to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>printf style format string for the name of the module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>arguments as specified in the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load a module using the user mode module loader. The function returns
zero on success or a negative errno code or positive exit code from
“modprobe” on failure. Note that a successful module load does not mean
the module did not then unload and exit on an error of its own. Callers
must check that the service they requested is now available not blindly
invoke it.</p>
<p>If module auto-loading support is disabled then this function
simply returns -ENOENT.</p>
</div>
<div class="section" id="inter-module-support">
<h3>Inter Module support<a class="headerlink" href="#inter-module-support" title="Permalink to this headline">¶</a></h3>
<p>Refer to the file kernel/module.c for more information.</p>
</div>
</div>
<div class="section" id="hardware-interfaces">
<h2>Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.synchronize_hardirq">
bool <code class="sig-name descname">synchronize_hardirq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending hard IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this
function while holding a resource the IRQ handler may need you
will deadlock. It does not take associated threaded handlers
into account.</p>
<p>Do not use this for shutdown scenarios where you must be sure
that all parts (hardirq and threaded handler) have completed.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div><p>This function may be called - with care - from IRQ context.</p>
<p>It does not check whether there is an interrupt in flight at the
hardware level, but not serviced yet, as this might deadlock when
called with interrupts disabled and the target CPU of the interrupt
is the current CPU.</p>
</div></blockquote>
<dl class="function">
<dt id="c.synchronize_irq">
void <code class="sig-name descname">synchronize_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>Can only be called from preemptible code as it might sleep when
an interrupt thread is associated to <strong>irq</strong>.</p>
<p>It optionally makes sure (when the irq chip supports that method)
that the interrupt is not pending in any CPU and waiting for
service.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_affinity_notifier">
int <code class="sig-name descname">irq_set_affinity_notifier</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, struct <a class="reference internal" href="genericirq.html#c.irq_affinity_notify" title="irq_affinity_notify">irq_affinity_notify</a> *<em> notify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>control notification of IRQ affinity changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt for which to enable/disable notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt><dd><p>Context for notification, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to disable
notification.  Function pointers must be initialised;
the other fields will be initialised by this function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Must be called in process context.  Notification may only be enabled
after the IRQ is allocated and must be disabled before the IRQ is
freed using <a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_vcpu_affinity">
int <code class="sig-name descname">irq_set_vcpu_affinity</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void *<em> vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_vcpu_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity for the interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt number to set affinity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vcpu_info</span></code></dt><dd><p>vCPU specific data or pointer to a percpu array of vCPU
specific data for percpu_devid interrupts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function uses the vCPU specific data to set the vCPU
affinity for an irq. The vCPU specific data is passed from
outside, such as KVM. One example code path is as below:
KVM -&gt; IOMMU -&gt; <a class="reference internal" href="#c.irq_set_vcpu_affinity" title="irq_set_vcpu_affinity"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_set_vcpu_affinity()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_irq_nosync">
void <code class="sig-name descname">disable_irq_nosync</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq without waiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>, this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
<p>This function may be called from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_irq">
void <code class="sig-name descname">disable_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq and wait for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_hardirq">
bool <code class="sig-name descname">disable_hardirq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>disables an irq and waits for hardirq completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this function while
holding a resource the hard IRQ handler may need you will deadlock.</p>
<p>When used to optimistically disable an interrupt from atomic context
the return value must be checked.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div><p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.enable_irq">
void <code class="sig-name descname">enable_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Undoes the effect of one call to <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
<p>This function may be called from IRQ context only when
desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irq_wake">
int <code class="sig-name descname">irq_set_irq_wake</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, unsigned int<em> on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>control irq power management wakeup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt to control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt><dd><p>enable/disable power management wakeup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enable/disable power management wakeup mode, which is
disabled by default.  Enables and disables must match,
just as they match for non-wakeup mode support.</p>
<p>Wakeup mode lets this IRQ wake the system from sleep
states like “suspend to RAM”.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>irq enable/disable state is completely orthogonal</dt><dd><p>to the enable/disable state of irq wake. An irq can be
disabled with <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> and still wake the system as
long as the irq has wake enabled. If this does not hold,
then the underlying irq chip and the related driver need
to be investigated.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.irq_wake_thread">
void <code class="sig-name descname">irq_wake_thread</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_wake_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the irq thread for the action identified by dev_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>Device identity for which the thread should be woken</p>
</dd>
</dl>
<dl class="function">
<dt id="c.free_irq">
const void * <code class="sig-name descname">free_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>Device identity to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<p>Returns the devname argument passed to request_irq.</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_threaded_irq">
int <code class="sig-name descname">request_threaded_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, irq_handler_t<em> thread_fn</em>, unsigned long<em> irqflags</em>, const char *<em> devname</em>, void *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_threaded_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts
If NULL and thread_fn != NULL the default
primary handler is installed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt><dd><p>Function called from the irq handler thread
If NULL, no irq thread is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>A cookie passed back to the handler function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.</p>
<p>If you want to set up a threaded irq handler for your device
then you need to supply <strong>handler</strong> and <strong>thread_fn</strong>. <strong>handler</strong> is
still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it
needs to disable the interrupt on the device and return
IRQ_WAKE_THREAD which will wake up the handler thread and run
<strong>thread_fn</strong>. This split handler design is necessary to support
shared interrupts.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.</p>
<p>Flags:</p>
<p>IRQF_SHARED             Interrupt is shared
IRQF_TRIGGER_*          Specify active edge(s) or level</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_any_context_irq">
int <code class="sig-name descname">request_any_context_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> flags</em>, const char *<em> name</em>, void *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_any_context_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>A cookie passed back to the handler function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It selects either a
hardirq or threaded handling method depending on the
context.</p>
<p>On failure, it returns a negative value. On success,
it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_percpu_is_enabled">
bool <code class="sig-name descname">irq_percpu_is_enabled</code><span class="sig-paren">(</span>unsigned int<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_percpu_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the per cpu irq is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Linux irq number to check for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called from a non migratable context. Returns the enable
state of a per cpu interrupt on the current cpu.</p>
<dl class="function">
<dt id="c.free_percpu_irq">
void <code class="sig-name descname">free_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, void __percpu *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_percpu_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>Device identity to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a percpu interrupt handler. The handler is removed, but
the interrupt line is not disabled. This must be done on each
CPU before calling this function. The function does not return
until any executing interrupts for this IRQ have completed.</p>
<p>This function must not be called from interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__request_percpu_irq">
int <code class="sig-name descname">__request_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, irq_handler_t<em> handler</em>, unsigned long<em> flags</em>, const char *<em> devname</em>, void __percpu *<em> dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Interrupt type flags (IRQF_TIMER only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt><dd><p>An ascii name for the claiming device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>A percpu cookie passed back to the handler function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt on the local CPU. If the interrupt is supposed to be
enabled on other CPUs, it has to be done on each CPU using
enable_percpu_irq().</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU’s instance of
that variable.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_get_irqchip_state">
int <code class="sig-name descname">irq_get_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, enum irqchip_irq_state<em> which</em>, bool *<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the irqchip state of a interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line that is forwarded to a VM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>One of IRQCHIP_STATE_* the caller wants to know about</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">state</span></code></dt><dd><p>a pointer to a boolean where the state is to be storeed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call snapshots the internal irqchip state of an
interrupt, returning into <strong>state</strong> the bit corresponding to
stage <strong>which</strong></p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irqchip_state">
int <code class="sig-name descname">irq_set_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em> irq</em>, enum irqchip_irq_state<em> which</em>, bool<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a forwarded interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt line that is forwarded to a VM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt><dd><p>State to be restored (one of IRQCHIP_STATE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">val</span></code></dt><dd><p>Value corresponding to <strong>which</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call sets the internal irqchip state of an interrupt,
depending on the value of <strong>which</strong>.</p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
</div>
<div class="section" id="dma-channels">
<h3>DMA Channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_dma">
int <code class="sig-name descname">request_dma</code><span class="sig-paren">(</span>unsigned int<em> dmanr</em>, const char *<em> device_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve a system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt><dd><p>DMA channel number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">device_id</span></code></dt><dd><p>reserving device ID string, used in /proc/dma</p>
</dd>
</dl>
<dl class="function">
<dt id="c.free_dma">
void <code class="sig-name descname">free_dma</code><span class="sig-paren">(</span>unsigned int<em> dmanr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>free a reserved system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt><dd><p>DMA channel number</p>
</dd>
</dl>
</div>
<div class="section" id="resources-management">
<h3>Resources Management<a class="headerlink" href="#resources-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_resource_conflict">
struct resource * <code class="sig-name descname">request_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em> root</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, conflict resource on error.</p>
<dl class="function">
<dt id="c.find_next_iomem_res">
int <code class="sig-name descname">find_next_iomem_res</code><span class="sig-paren">(</span>resource_size_t<em> start</em>, resource_size_t<em> end</em>, unsigned long<em> flags</em>, unsigned long<em> desc</em>, bool<em> first_lvl</em>, struct resource *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_iomem_res" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>start address of the resource searched for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">end</span></code></dt><dd><p>end address of same resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags which the resource must have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>descriptor the resource must have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">first_lvl</span></code></dt><dd><p>walk only the first level children, if set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>return ptr, if resource found</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>caller must specify <strong>start</strong>, <strong>end</strong>, <strong>flags</strong>, and <strong>desc</strong> (which may be
IORES_DESC_NONE).</p>
<p>If a resource is found, returns 0 and <strong>***res is overwritten with the part
of the resource that’s within [**start</strong>..**end**]; if none is found, returns
-ENODEV.  Returns -EINVAL for invalid parameters.</p>
<p>This function walks the whole tree and not just first level children
unless <strong>first_lvl</strong> is true.</p>
<dl class="function">
<dt id="c.reallocate_resource">
int <code class="sig-name descname">reallocate_resource</code><span class="sig-paren">(</span>struct resource *<em> root</em>, struct resource *<em> old</em>, resource_size_t<em> newsize</em>, struct resource_constraint *<em> constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reallocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a slot in the resource tree given range &amp; alignment. The resource will be relocated if the new size cannot be reallocated in the current location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">newsize</span></code></dt><dd><p>new size of the resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource_constraint</span> <span class="pre">*</span> <span class="pre">constraint</span></code></dt><dd><p>the size and alignment constraints to be met.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.lookup_resource">
struct resource * <code class="sig-name descname">lookup_resource</code><span class="sig-paren">(</span>struct resource *<em> root</em>, resource_size_t<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>find an existing resource by a resource start address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the resource if found, NULL otherwise</p>
<dl class="function">
<dt id="c.insert_resource_conflict">
struct resource * <code class="sig-name descname">insert_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em> parent</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent of the new resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, conflict resource if the resource can’t be inserted.</p>
<p>This function is equivalent to request_resource_conflict when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become children of
the new resource.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.insert_resource_expand_to_fit">
void <code class="sig-name descname">insert_resource_expand_to_fit</code><span class="sig-paren">(</span>struct resource *<em> root</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_expand_to_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a resource into the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a resource into the resource tree, possibly expanding it in order
to make it encompass any conflicting resources.</p>
<dl class="function">
<dt id="c.resource_alignment">
resource_size_t <code class="sig-name descname">resource_alignment</code><span class="sig-paren">(</span>struct resource *<em> res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.resource_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate resource’s alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>resource pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns alignment on success, 0 (invalid alignment) on failure.</p>
<dl class="function">
<dt id="c.release_mem_region_adjustable">
int <code class="sig-name descname">release_mem_region_adjustable</code><span class="sig-paren">(</span>struct resource *<em> parent</em>, resource_size_t<em> start</em>, resource_size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_mem_region_adjustable" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>resource region size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hot-delete.  The requested region
is released from a currently busy memory resource.  The requested region
must either match exactly or fit into a single busy resource entry.  In
the latter case, the remaining resource is adjusted accordingly.
Existing children of the busy memory resource must be immutable in the
request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li><p>Additional release conditions, such as overlapping region, can be
supported after they are confirmed as valid cases.</p></li>
<li><p>When a busy memory resource gets split into two entries, the code
assumes that all children remain in the lower address entry for
simplicity.  Enhance this logic when necessary.</p></li>
</ul>
<dl class="function">
<dt id="c.request_resource">
int <code class="sig-name descname">request_resource</code><span class="sig-paren">(</span>struct resource *<em> root</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code on error.</p>
<dl class="function">
<dt id="c.release_resource">
int <code class="sig-name descname">release_resource</code><span class="sig-paren">(</span>struct resource *<em> old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>resource pointer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.walk_iomem_res_desc">
int <code class="sig-name descname">walk_iomem_res_desc</code><span class="sig-paren">(</span>unsigned long<em> desc</em>, unsigned long<em> flags</em>, u64<em> start</em>, u64<em> end</em>, void *<em> arg</em>, int (<em>*func</em>)(struct resource *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.walk_iomem_res_desc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>I/O resource descriptor. Use IORES_DESC_NONE to skip <strong>desc</strong> check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>I/O resource flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>function argument for the callback <strong>func</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">func</span></code></dt><dd><p>callback function that is called for each qualifying resource area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ranges. This walks through whole tree and not just first level children.
All the memory ranges which overlap start,end and also match flags and
desc are valid candidates.</p>
<p><strong>NOTE</strong></p>
<p>For a new descriptor search, define a new IORES_DESC in
&lt;linux/ioport.h&gt; and set it in ‘desc’ of a target resource entry.</p>
<dl class="function">
<dt id="c.region_intersects">
int <code class="sig-name descname">region_intersects</code><span class="sig-paren">(</span>resource_size_t<em> start</em>, size_t<em> size</em>, unsigned long<em> flags</em>, unsigned long<em> desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.region_intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>determine intersection of region with known resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>region start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags of resource (in iomem_resource)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>descriptor of resource (in iomem_resource) or IORES_DESC_NONE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the specified region partially overlaps or fully eclipses a
resource identified by <strong>flags</strong> and <strong>desc</strong> (optional with IORES_DESC_NONE).
Return REGION_DISJOINT if the region does not overlap <strong>flags</strong>/<strong>desc</strong>,
return REGION_MIXED if the region overlaps <strong>flags</strong>/<strong>desc</strong> and another
resource, and return REGION_INTERSECTS if the region overlaps <strong>flags</strong>/<strong>desc</strong>
and no other defined resource. Note that REGION_INTERSECTS is also
returned in the case when the specified region overlaps RAM and undefined
memory holes.</p>
<p>region_intersect() is used by memory remapping functions to ensure
the user is not remapping RAM and is a vast speed up over walking
through the resource table page by page.</p>
<dl class="function">
<dt id="c.allocate_resource">
int <code class="sig-name descname">allocate_resource</code><span class="sig-paren">(</span>struct resource *<em> root</em>, struct resource *<em> new</em>, resource_size_t<em> size</em>, resource_size_t<em> min</em>, resource_size_t<em> max</em>, resource_size_t<em> align</em>, resource_size_t (<em>*alignf</em>)(void *, const struct resource *, resource_size_t, resource_size_t), void *<em> alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate empty slot in the resource tree given range &amp; alignment. The resource will be reallocated with a new size if it was already allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>requested resource region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt><dd><p>minimum boundary to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">max</span></code></dt><dd><p>maximum boundary to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requested, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span> <span class="pre">alignf</span></code></dt><dd><p>alignment function, optional, called if not NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">alignf_data</span></code></dt><dd><p>arbitrary data to pass to the <strong>alignf</strong> function</p>
</dd>
</dl>
<dl class="function">
<dt id="c.insert_resource">
int <code class="sig-name descname">insert_resource</code><span class="sig-paren">(</span>struct resource *<em> parent</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent of the new resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EBUSY if the resource can’t be inserted.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.remove_resource">
int <code class="sig-name descname">remove_resource</code><span class="sig-paren">(</span>struct resource *<em> old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>resource to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EINVAL if the resource is not valid.</p>
<p>This function removes a resource previously inserted by <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a>
or <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a>, and moves the children (if any) up to
where they were before.  <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a> and <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a>
insert a new resource, and move any conflicting resources down to the
children of the new resource.</p>
<p><a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a>, <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a> and <a class="reference internal" href="#c.remove_resource" title="remove_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">remove_resource()</span></code></a> are
intended for producers of resources, such as FW modules and bus drivers.</p>
<dl class="function">
<dt id="c.adjust_resource">
int <code class="sig-name descname">adjust_resource</code><span class="sig-paren">(</span>struct resource *<em> res</em>, resource_size_t<em> start</em>, resource_size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.adjust_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a resource’s start and size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt><dd><p>resource to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>new start value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>new size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an existing resource, change its start and size to match the
arguments.  Returns 0 on success, -EBUSY if it can’t fit.
Existing children of the resource are assumed to be immutable.</p>
<dl class="function">
<dt id="c.__request_region">
struct resource * <code class="sig-name descname">__request_region</code><span class="sig-paren">(</span>struct resource *<em> parent</em>, resource_size_t<em> start</em>, resource_size_t<em> n</em>, const char *<em> name</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new busy resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt><dd><p>resource region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>reserving caller’s ID string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>IO resource flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__release_region">
void <code class="sig-name descname">__release_region</code><span class="sig-paren">(</span>struct resource *<em> parent</em>, resource_size_t<em> start</em>, resource_size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt><dd><p>resource region size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The described resource region must match a currently busy region.</p>
<dl class="function">
<dt id="c.devm_request_resource">
int <code class="sig-name descname">devm_request_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct resource *<em> root</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for which to request the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt><dd><p>root of the resource tree from which to request the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>descriptor of the resource to request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a device-managed version of <a class="reference internal" href="#c.request_resource" title="request_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_resource()</span></code></a>. There is usually
no need to release resources requested by this function explicitly since
that will be taken care of when the device is unbound from its driver.
If for some reason the resource needs to be released explicitly, because
of ordering issues for example, drivers must call <a class="reference internal" href="#c.devm_release_resource" title="devm_release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_release_resource()</span></code></a>
rather than the regular <a class="reference internal" href="#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_resource()</span></code></a>.</p>
<p>When a conflict is detected between any existing resources and the newly
requested resource, an error message will be printed.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.devm_release_resource">
void <code class="sig-name descname">devm_release_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct resource *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously requested resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for which to release the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>descriptor of the resource to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a resource previously requested using <a class="reference internal" href="#c.devm_request_resource" title="devm_request_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_request_resource()</span></code></a>.</p>
<dl class="function">
<dt id="c.devm_request_free_mem_region">
struct resource * <code class="sig-name descname">devm_request_free_mem_region</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct resource *<em> base</em>, unsigned long<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_free_mem_region" title="Permalink to this definition">¶</a></dt>
<dd><p>find free region for device private memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device struct to bind the resource to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">base</span></code></dt><dd><p>resource tree to look in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size in bytes of the device memory to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to find an empty range of physical address big enough to
contain the new resource, so that it can later be hotplugged as ZONE_DEVICE
memory, which in turn allocates struct pages.</p>
</div>
<div class="section" id="mtrr-handling">
<h3>MTRR Handling<a class="headerlink" href="#mtrr-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.arch_phys_wc_add">
int <code class="sig-name descname">arch_phys_wc_add</code><span class="sig-paren">(</span>unsigned long<em> base</em>, unsigned long<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_phys_wc_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a WC MTRR and handle errors if PAT is unavailable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>Physical base address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>Size of region</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PAT is available, this does nothing.  If PAT is unavailable, it
attempts to add a WC MTRR covering size bytes starting at base and
logs an error if this fails.</p>
<p>The called should provide a power of two size on an equivalent
power of two boundary.</p>
<p>Drivers must store the return value to pass to mtrr_del_wc_if_needed,
but drivers should not try to interpret that return value.</p>
</div>
</div>
<div class="section" id="security-framework">
<h2>Security Framework<a class="headerlink" href="#security-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.security_init">
int <code class="sig-name descname">security_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.security_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the security framework</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called early in the kernel initialization sequence.</p>
<dl class="function">
<dt id="c.security_add_hooks">
void <code class="sig-name descname">security_add_hooks</code><span class="sig-paren">(</span>struct security_hook_list *<em> hooks</em>, int<em> count</em>, char *<em> lsm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_add_hooks" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a modules hooks to the hook lists.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">security_hook_list</span> <span class="pre">*</span> <span class="pre">hooks</span></code></dt><dd><p>the hooks to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of hooks to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">lsm</span></code></dt><dd><p>the name of the security module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM has to register its hooks with the infrastructure.</p>
<dl class="function">
<dt id="c.lsm_cred_alloc">
int <code class="sig-name descname">lsm_cred_alloc</code><span class="sig-paren">(</span>struct cred *<em> cred</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_cred_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite cred blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">cred</span></code></dt><dd><p>the cred that needs a blob</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the cred blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_early_cred">
void <code class="sig-name descname">lsm_early_cred</code><span class="sig-paren">(</span>struct cred *<em> cred</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_early_cred" title="Permalink to this definition">¶</a></dt>
<dd><p>during initialization allocate a composite cred blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">cred</span></code></dt><dd><p>the cred that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the cred blob for all the modules</p>
<dl class="function">
<dt id="c.lsm_file_alloc">
int <code class="sig-name descname">lsm_file_alloc</code><span class="sig-paren">(</span>struct file *<em> file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_file_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite file blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>the file that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the file blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_inode_alloc">
int <code class="sig-name descname">lsm_inode_alloc</code><span class="sig-paren">(</span>struct inode *<em> inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_inode_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite inode blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt><dd><p>the inode that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the inode blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_task_alloc">
int <code class="sig-name descname">lsm_task_alloc</code><span class="sig-paren">(</span>struct task_struct *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_task_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite task blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>the task that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the task blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_ipc_alloc">
int <code class="sig-name descname">lsm_ipc_alloc</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em> kip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_ipc_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite ipc blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">kip</span></code></dt><dd><p>the ipc that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the ipc blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_msg_msg_alloc">
int <code class="sig-name descname">lsm_msg_msg_alloc</code><span class="sig-paren">(</span>struct msg_msg *<em> mp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_msg_msg_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite msg_msg blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*</span> <span class="pre">mp</span></code></dt><dd><p>the msg_msg that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the ipc blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.lsm_early_task">
void <code class="sig-name descname">lsm_early_task</code><span class="sig-paren">(</span>struct task_struct *<em> task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_early_task" title="Permalink to this definition">¶</a></dt>
<dd><p>during initialization allocate a composite task blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt><dd><p>the task that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the task blob for all the modules</p>
<dl class="function">
<dt id="c.lsm_superblock_alloc">
int <code class="sig-name descname">lsm_superblock_alloc</code><span class="sig-paren">(</span>struct super_block *<em> sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_superblock_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a composite superblock blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt><dd><p>the superblock that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the superblock blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can’t be allocated.</p>
<dl class="function">
<dt id="c.securityfs_create_file">
struct dentry * <code class="sig-name descname">securityfs_create_file</code><span class="sig-paren">(</span>const char *<em> name</em>, umode_t<em> mode</em>, struct dentry *<em> parent</em>, void *<em> data</em>, const struct file_operations *<em> fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the securityfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>a pointer to a struct file_operations that should be used for
this file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_dir">
struct dentry * <code class="sig-name descname">securityfs_create_dir</code><span class="sig-paren">(</span>const char *<em> name</em>, struct dentry *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>a pointer to a string containing the name of the directory to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_symlink">
struct dentry * <code class="sig-name descname">securityfs_create_symlink</code><span class="sig-paren">(</span>const char *<em> name</em>, struct dentry *<em> parent</em>, const char *<em> target</em>, const struct inode_operations *<em> iops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symlink in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>a pointer to a string containing the name of the symlink to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>a pointer to the parent dentry for the symlink.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt><dd><p>a pointer to a string containing the name of the symlink’s target.
If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the <strong>iops</strong> parameter needs to be
setup to handle .readlink and .get_link inode_operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode_operations</span> <span class="pre">*</span> <span class="pre">iops</span></code></dt><dd><p>a pointer to the struct inode_operations to use for the symlink. If
this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the default simple_symlink_inode
operations will be used.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symlink in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_remove">
void <code class="sig-name descname">securityfs_remove</code><span class="sig-paren">(</span>struct dentry *<em> dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a file or directory from the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt><dd><p>a pointer to a the dentry of the file or directory to be removed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
<a class="reference internal" href="#c.securityfs_create_file" title="securityfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed. No automatic cleanup of files will happen when a module is
removed; you are responsible here.</p>
</div>
<div class="section" id="audit-interfaces">
<h2>Audit Interfaces<a class="headerlink" href="#audit-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.audit_log_start">
struct audit_buffer * <code class="sig-name descname">audit_log_start</code><span class="sig-paren">(</span>struct audit_context *<em> ctx</em>, gfp_t<em> gfp_mask</em>, int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_start" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an audit buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>audit_context (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>type of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns audit_buffer pointer on success or NULL on error.</p>
<p>Obtain an audit buffer.  This routine does locking to obtain the
audit buffer, but then no locking is required for calls to
audit_log_*format.  If the task (ctx) is a task that is currently in a
syscall, then the syscall is marked as auditable and an audit record
will be written at syscall exit.  If there is no associated task, then
task context (ctx) should be NULL.</p>
<dl class="function">
<dt id="c.audit_log_format">
void <code class="sig-name descname">audit_log_format</code><span class="sig-paren">(</span>struct audit_buffer *<em> ab</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>format a message into the audit buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt><dd><p>audit_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>optional parameters matching <strong>fmt</strong> string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the work is done in audit_log_vformat.</p>
<dl class="function">
<dt id="c.audit_log_end">
void <code class="sig-name descname">audit_log_end</code><span class="sig-paren">(</span>struct audit_buffer *<em> ab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_end" title="Permalink to this definition">¶</a></dt>
<dd><p>end one audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt><dd><p>the audit_buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can not do a netlink send inside an irq context because it blocks (last
arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
queue and a tasklet is scheduled to remove them from the queue outside the
irq context.  May be called in any context.</p>
<dl class="function">
<dt id="c.audit_log">
void <code class="sig-name descname">audit_log</code><span class="sig-paren">(</span>struct audit_context *<em> ctx</em>, gfp_t<em> gfp_mask</em>, int<em> type</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log an audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>audit context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>type of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable parameters matching the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a convenience function that calls audit_log_start,
audit_log_vformat, and audit_log_end.  It may be called
in any context.</p>
<dl class="function">
<dt id="c.audit_alloc">
int <code class="sig-name descname">audit_alloc</code><span class="sig-paren">(</span>struct task_struct *<em> tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an audit context block for a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filter on the task information and allocate a per-task audit context
if necessary.  Doing so turns on system call auditing for the
specified task.  This is called from copy_process, so no lock is
needed.</p>
<dl class="function">
<dt id="c.__audit_free">
void <code class="sig-name descname">__audit_free</code><span class="sig-paren">(</span>struct task_struct *<em> tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a per-task audit context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt><dd><p>task whose audit context block to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from copy_process and do_exit</p>
<dl class="function">
<dt id="c.__audit_syscall_entry">
void <code class="sig-name descname">__audit_syscall_entry</code><span class="sig-paren">(</span>int<em> major</em>, unsigned long<em> a1</em>, unsigned long<em> a2</em>, unsigned long<em> a3</em>, unsigned long<em> a4</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in an audit record at syscall entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major syscall type (function)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a1</span></code></dt><dd><p>additional syscall register 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a2</span></code></dt><dd><p>additional syscall register 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a3</span></code></dt><dd><p>additional syscall register 3</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a4</span></code></dt><dd><p>additional syscall register 4</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in audit context at syscall entry.  This only happens if the
audit context was created when the task was created and the state or
filters demand the audit context be built.  If the state from the
per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,
then the record will be written at syscall exit time (otherwise, it
will only be written if another part of the kernel requests that it
be written).</p>
<dl class="function">
<dt id="c.__audit_syscall_exit">
void <code class="sig-name descname">__audit_syscall_exit</code><span class="sig-paren">(</span>int<em> success</em>, long<em> return_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate audit context after a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">success</span></code></dt><dd><p>success value of the syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">return_code</span></code></dt><dd><p>return value of the syscall</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down after system call.  If the audit context has been marked as
auditable (either because of the AUDIT_RECORD_CONTEXT state from
filtering, or because some other part of the kernel wrote an audit
message), then write out the syscall information.  In call cases,
free the names stored from getname().</p>
<dl class="function">
<dt id="c.__audit_reusename">
struct filename * <code class="sig-name descname">__audit_reusename</code><span class="sig-paren">(</span>const __user char *<em> uptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_reusename" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out filename with info from existing entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">__user</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uptr</span></code></dt><dd><p>userland ptr to pathname</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the audit_names list for the current audit context. If there is an
existing entry with a matching “uptr” then return the filename
associated with that audit_name. If not, return NULL.</p>
<dl class="function">
<dt id="c.__audit_getname">
void <code class="sig-name descname">__audit_getname</code><span class="sig-paren">(</span>struct filename *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_getname" title="Permalink to this definition">¶</a></dt>
<dd><p>add a name to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a name to the list of audit names for this context.
Called from fs/namei.c:getname().</p>
<dl class="function">
<dt id="c.__audit_inode">
void <code class="sig-name descname">__audit_inode</code><span class="sig-paren">(</span>struct filename *<em> name</em>, const struct dentry *<em> dentry</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>store the inode and device from a lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name being audited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt><dd><p>dentry being audited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>attributes for this particular entry</p>
</dd>
</dl>
<dl class="function">
<dt id="c.auditsc_get_stamp">
int <code class="sig-name descname">auditsc_get_stamp</code><span class="sig-paren">(</span>struct audit_context *<em> ctx</em>, struct timespec64 *<em> t</em>, unsigned int *<em> serial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.auditsc_get_stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get local copies of audit_context values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt><dd><p>audit_context for the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>timespec64 to store time recorded in the audit_context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">serial</span></code></dt><dd><p>serial value that is recorded in the audit_context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also sets the context as auditable.</p>
<dl class="function">
<dt id="c.__audit_mq_open">
void <code class="sig-name descname">__audit_mq_open</code><span class="sig-paren">(</span>int<em> oflag</em>, umode_t<em> mode</em>, struct mq_attr *<em> attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ open</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oflag</span></code></dt><dd><p>open flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt><dd><p>queue attributes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_sendrecv">
void <code class="sig-name descname">__audit_mq_sendrecv</code><span class="sig-paren">(</span>mqd_t<em> mqdes</em>, size_t<em> msg_len</em>, unsigned int<em> msg_prio</em>, const struct timespec64 *<em> abs_timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_sendrecv" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ timed send/receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">msg_len</span></code></dt><dd><p>Message length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msg_prio</span></code></dt><dd><p>Message priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">abs_timeout</span></code></dt><dd><p>Message timeout in absolute time</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_notify">
void <code class="sig-name descname">__audit_mq_notify</code><span class="sig-paren">(</span>mqd_t<em> mqdes</em>, const struct sigevent *<em> notification</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigevent</span> <span class="pre">*</span> <span class="pre">notification</span></code></dt><dd><p>Notification event</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_getsetattr">
void <code class="sig-name descname">__audit_mq_getsetattr</code><span class="sig-paren">(</span>mqd_t<em> mqdes</em>, struct mq_attr *<em> mqstat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_getsetattr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ get/set attribute</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">mqstat</span></code></dt><dd><p>MQ flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_obj">
void <code class="sig-name descname">__audit_ipc_obj</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em> ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt><dd><p>ipc permissions</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_set_perm">
void <code class="sig-name descname">__audit_ipc_set_perm</code><span class="sig-paren">(</span>unsigned long<em> qbytes</em>, uid_t<em> uid</em>, gid_t<em> gid</em>, umode_t<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_set_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for new ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">qbytes</span></code></dt><dd><p>msgq bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uid_t</span> <span class="pre">uid</span></code></dt><dd><p>msgq user id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gid_t</span> <span class="pre">gid</span></code></dt><dd><p>msgq group id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>msgq mode (permissions)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called only after audit_ipc_obj().</p>
<dl class="function">
<dt id="c.__audit_socketcall">
int <code class="sig-name descname">__audit_socketcall</code><span class="sig-paren">(</span>int<em> nargs</em>, unsigned long *<em> args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_socketcall" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_socketcall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nargs</span></code></dt><dd><p>number of args, which should not be more than AUDITSC_ARGS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>args array</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_fd_pair">
void <code class="sig-name descname">__audit_fd_pair</code><span class="sig-paren">(</span>int<em> fd1</em>, int<em> fd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_fd_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for pipe and socketpair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd1</span></code></dt><dd><p>the first file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd2</span></code></dt><dd><p>the second file descriptor</p>
</dd>
</dl>
<dl class="function">
<dt id="c.__audit_sockaddr">
int <code class="sig-name descname">__audit_sockaddr</code><span class="sig-paren">(</span>int<em> len</em>, void *<em> a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_bind, sys_connect, sys_sendto</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>data length in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt><dd><p>data address in kernel space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or NULL context or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.audit_signal_info_syscall">
int <code class="sig-name descname">audit_signal_info_syscall</code><span class="sig-paren">(</span>struct task_struct *<em> t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_signal_info_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>record signal info for syscalls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>task being signaled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the audit subsystem is being terminated, record the task (pid)
and uid that is doing that.</p>
<dl class="function">
<dt id="c.__audit_log_bprm_fcaps">
int <code class="sig-name descname">__audit_log_bprm_fcaps</code><span class="sig-paren">(</span>struct linux_binprm *<em> bprm</em>, const struct cred *<em> new</em>, const struct cred *<em> old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_bprm_fcaps" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about a loading bprm and relevant fcaps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*</span> <span class="pre">bprm</span></code></dt><dd><p>pointer to the bprm being processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the proposed new credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the old credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simply check if the proc already has the caps given by the file and if not
store the priv escalation info for later auditing at the end of the syscall</p>
<p>-Eric</p>
<dl class="function">
<dt id="c.__audit_log_capset">
void <code class="sig-name descname">__audit_log_capset</code><span class="sig-paren">(</span>const struct cred *<em> new</em>, const struct cred *<em> old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_capset" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about the arguments to the capset syscall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the new credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the old (current) credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the arguments userspace sent to sys_capset for later printing by the
audit system if applicable</p>
<dl class="function">
<dt id="c.audit_core_dumps">
void <code class="sig-name descname">audit_core_dumps</code><span class="sig-paren">(</span>long<em> signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_core_dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about processes that end abnormally</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">signr</span></code></dt><dd><p>signal value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a process ends with a core dump, something fishy is going on and we
should record the event for investigation.</p>
<dl class="function">
<dt id="c.audit_seccomp">
void <code class="sig-name descname">audit_seccomp</code><span class="sig-paren">(</span>unsigned long<em> syscall</em>, long<em> signr</em>, int<em> code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_seccomp" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about a seccomp action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syscall</span></code></dt><dd><p>syscall number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">signr</span></code></dt><dd><p>signal value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>the seccomp action</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the information associated with a seccomp action. Event filtering for
seccomp actions that are not to be logged is done in seccomp_log().
Therefore, this function forces auditing independent of the audit_enabled
and dummy context state because seccomp actions should be logged even when
audit is not in use.</p>
<dl class="function">
<dt id="c.audit_rule_change">
int <code class="sig-name descname">audit_rule_change</code><span class="sig-paren">(</span>int<em> type</em>, int<em> seq</em>, void *<em> data</em>, size_t<em> datasz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_rule_change" title="Permalink to this definition">¶</a></dt>
<dd><p>apply all rules to the specified message type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">seq</span></code></dt><dd><p>netlink audit message sequence (serial) number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>payload data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">datasz</span></code></dt><dd><p>size of payload data</p>
</dd>
</dl>
<dl class="function">
<dt id="c.audit_list_rules_send">
int <code class="sig-name descname">audit_list_rules_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> request_skb</em>, int<em> seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_list_rules_send" title="Permalink to this definition">¶</a></dt>
<dd><p>list the audit rules</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">request_skb</span></code></dt><dd><p>skb of request we are replying to (used to target the reply)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">seq</span></code></dt><dd><p>netlink audit message sequence (serial) number</p>
</dd>
</dl>
<dl class="function">
<dt id="c.parent_len">
int <code class="sig-name descname">parent_len</code><span class="sig-paren">(</span>const char *<em> path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parent_len" title="Permalink to this definition">¶</a></dt>
<dd><p>find the length of the parent portion of a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt><dd><p>pathname of which to determine length</p>
</dd>
</dl>
<dl class="function">
<dt id="c.audit_compare_dname_path">
int <code class="sig-name descname">audit_compare_dname_path</code><span class="sig-paren">(</span>const struct qstr *<em> dname</em>, const char *<em> path</em>, int<em> parentlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_compare_dname_path" title="Permalink to this definition">¶</a></dt>
<dd><p>compare given dentry name with last component in given path. Return of 0 indicates a match.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">dname</span></code></dt><dd><p>dentry name that we’re comparing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt><dd><p>full pathname that we’re comparing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">parentlen</span></code></dt><dd><p>length of the parent if known. Passing in AUDIT_NAME_FULL
here indicates that we must compute this value.</p>
</dd>
</dl>
</div>
<div class="section" id="accounting-framework">
<h2>Accounting Framework<a class="headerlink" href="#accounting-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sys_acct">
long <code class="sig-name descname">sys_acct</code><span class="sig-paren">(</span>const char __user *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_acct" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable process accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>file name for accounting records or NULL to shutdown accounting</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative errno values for failure.</p>
<p><a class="reference internal" href="#c.sys_acct" title="sys_acct"><code class="xref c c-func docutils literal notranslate"><span class="pre">sys_acct()</span></code></a> is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.</p>
<dl class="function">
<dt id="c.acct_collect">
void <code class="sig-name descname">acct_collect</code><span class="sig-paren">(</span>long<em> exitcode</em>, int<em> group_dead</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>collect accounting information into pacct_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">exitcode</span></code></dt><dd><p>task exit code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">group_dead</span></code></dt><dd><p>not 0, if this thread is the last one in the process.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.acct_process">
void <code class="sig-name descname">acct_process</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.acct_process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>handles process accounting for an exiting task</p>
</div>
<div class="section" id="block-devices">
<h2>Block Devices<a class="headerlink" href="#block-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.blk_queue_flag_set">
void <code class="sig-name descname">blk_queue_flag_set</code><span class="sig-paren">(</span>unsigned int<em> flag</em>, struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_set" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically set a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_flag_clear">
void <code class="sig-name descname">blk_queue_flag_clear</code><span class="sig-paren">(</span>unsigned int<em> flag</em>, struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically clear a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be cleared</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_flag_test_and_set">
bool <code class="sig-name descname">blk_queue_flag_test_and_set</code><span class="sig-paren">(</span>unsigned int<em> flag</em>, struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_test_and_set" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically test and set a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the previous value of <strong>flag</strong> - 0 if the flag was not set and 1 if
the flag was already set.</p>
<dl class="function">
<dt id="c.blk_op_str">
const char * <code class="sig-name descname">blk_op_str</code><span class="sig-paren">(</span>unsigned int<em> op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_op_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return string XXX in the REQ_OP_XXX.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt><dd><p>REQ_OP_XXX.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Centralize block layer function to convert REQ_OP_XXX into
string format. Useful in the debugging and tracing bio or request. For
invalid REQ_OP_XXX it returns string “UNKNOWN”.</p>
<dl class="function">
<dt id="c.blk_sync_queue">
void <code class="sig-name descname">blk_sync_queue</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_sync_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel any pending callbacks on a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
that the callbacks might use. The caller must already have made sure
that its -&gt;make_request_fn will not re-add plugging prior to calling
this function.</p>
<p>This function does not cancel any asynchronous activity arising
out of elevator or throttling code. That would require elevator_exit()
and blkcg_exit_queue() to be called with queue lock initialized.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_pm_only">
void <code class="sig-name descname">blk_set_pm_only</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_pm_only" title="Permalink to this definition">¶</a></dt>
<dd><p>increment pm_only counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue pointer</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_cleanup_queue">
void <code class="sig-name descname">blk_cleanup_queue</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cleanup_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue to shutdown</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>q</strong> DYING, drain all pending requests, mark <strong>q</strong> DEAD, destroy and
put it.  All future requests will be failed immediately with -ENODEV.</p>
<dl class="function">
<dt id="c.blk_get_request">
struct request * <code class="sig-name descname">blk_get_request</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> op</em>, blk_mq_req_flags_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue to allocate a request for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt><dd><p>operation (REQ_OP_*) and REQ_* flags, e.g. REQ_SYNC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>BLK_MQ_REQ_* flags, e.g. BLK_MQ_REQ_NOWAIT.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.generic_make_request">
blk_qc_t <code class="sig-name descname">generic_make_request</code><span class="sig-paren">(</span>struct bio *<em> bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>The bio describing the location in memory and on the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> is used to make I/O requests of block
devices. It is passed a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>, which describes the I/O that needs
to be done.</p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> does not return any status.  The
success/failure status of the request, along with notification of
completion, is delivered asynchronously through the bio-&gt;bi_end_io
function described (one day) else where.</p>
<p>The caller of generic_make_request must make sure that bi_io_vec
are set to describe the memory buffer, and that bi_dev and bi_sector are
set to describe the device address, and the
bi_end_io and optionally bi_private are set to describe how
completion notification should be signaled.</p>
<p>generic_make_request and the drivers it calls may use bi_next if this
bio happens to be merged with someone else, and may resubmit the bio to
a lower device by calling into generic_make_request recursively, which
means the bio should NOT be touched after the call to -&gt;make_request_fn.</p>
<dl class="function">
<dt id="c.direct_make_request">
blk_qc_t <code class="sig-name descname">direct_make_request</code><span class="sig-paren">(</span>struct bio *<em> bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.direct_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer directly to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>The bio describing the location in memory and on the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function behaves like <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a>, but does not protect
against recursion.  Must only be used if the called driver is known
to not call generic_make_request (or direct_make_request) again from
its make_request function.  (Calling direct_make_request again from
a workqueue is perfectly fine as that doesn’t recurse).</p>
<dl class="function">
<dt id="c.submit_bio">
blk_qc_t <code class="sig-name descname">submit_bio</code><span class="sig-paren">(</span>struct bio *<em> bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio to the block device layer for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> is very similar in purpose to <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a>, and
uses that function to do most of the work. Both are fairly rough
interfaces; <strong>bio</strong> must be presetup and ready for I/O.</p>
<dl class="function">
<dt id="c.blk_insert_cloned_request">
blk_status_t <code class="sig-name descname">blk_insert_cloned_request</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_insert_cloned_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for stacking drivers to submit a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the queue to submit the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the request being queued</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_err_bytes">
unsigned int <code class="sig-name descname">blk_rq_err_bytes</code><span class="sig-paren">(</span>const struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_err_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>determine number of bytes till the next failure boundary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to examine</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A request could be merge of IOs which require different failure
handling.  This function determines the number of bytes which
can be failed from the beginning of the request without
crossing into area which need to be retried further.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>The number of bytes to fail.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_update_request">
bool <code class="sig-name descname">blk_update_request</code><span class="sig-paren">(</span>struct request *<em> req</em>, blk_status_t<em> error</em>, unsigned int<em> nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_update_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Special helper function for request stacking drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt><dd><p>the request being processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt><dd><p>block status code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt><dd><p>number of bytes to complete <strong>req</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ends I/O on a number of bytes attached to <strong>req</strong>, but doesn’t complete
the request structure even if <strong>req</strong> doesn’t have leftover.
If <strong>req</strong> has leftover, sets it up for the next range of segments.</p>
<p>This special helper function is only for request stacking drivers
(e.g. request-based dm) so that they can handle partial completion.
Actual device drivers should use blk_mq_end_request instead.</p>
<p>Passing the result of blk_rq_bytes() as <strong>nr_bytes</strong> guarantees
<code class="docutils literal notranslate"><span class="pre">false</span></code> return from this function.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div><p>The RQF_SPECIAL_PAYLOAD flag is ignored on purpose in both
blk_rq_bytes() and in <a class="reference internal" href="#c.blk_update_request" title="blk_update_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_update_request()</span></code></a>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">false</span></code> - this request doesn’t have any more data
<code class="docutils literal notranslate"><span class="pre">true</span></code>  - this request has more data</p>
</div></blockquote>
<dl class="function">
<dt id="c.rq_flush_dcache_pages">
void <code class="sig-name descname">rq_flush_dcache_pages</code><span class="sig-paren">(</span>struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rq_flush_dcache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to flush all pages in a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the request to be flushed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Flush all pages in <strong>rq</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_lld_busy">
int <code class="sig-name descname">blk_lld_busy</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_lld_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if underlying low-level drivers of a device are busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the queue of the device being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if underlying low-level drivers of a device are busy.
If the drivers want to export their busy state, they must set own
exporting function using blk_queue_lld_busy() first.</p>
<p>Basically, this function is used only by request stacking drivers
to stop dispatching requests to underlying devices when underlying
devices are busy.  This behavior helps more I/O merging on the queue
of the request stacking driver and prevents I/O throughput regression
on burst I/O load.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 - Not busy (The request stacking driver should dispatch request)
1 - Busy (The request stacking driver should stop dispatching request)</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_unprep_clone">
void <code class="sig-name descname">blk_rq_unprep_clone</code><span class="sig-paren">(</span>struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unprep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to free all bios in a cloned request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the clone request to be cleaned up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free all bios in <strong>rq</strong> for a cloned request.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_prep_clone">
int <code class="sig-name descname">blk_rq_prep_clone</code><span class="sig-paren">(</span>struct request *<em> rq</em>, struct request *<em> rq_src</em>, struct bio_set *<em> bs</em>, gfp_t<em> gfp_mask</em>, int (<em>*bio_ctr</em>)(struct bio *, struct bio *, void *), void *<em> data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_prep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to setup clone request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the request to be setup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq_src</span></code></dt><dd><p>original request to be cloned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt><dd><p>bio_set that bios for clone are allocated from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation mask for bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">bio_ctr</span></code></dt><dd><p>setup function to be called for each clone bio.
Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> for success, non <code class="docutils literal notranslate"><span class="pre">0</span></code> for failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>private data to be passed to <strong>bio_ctr</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Clones bios in <strong>rq_src</strong> to <strong>rq</strong>, and copies attributes of <strong>rq_src</strong> to <strong>rq</strong>.
Also, pages which the original bios are pointing to are not copied
and the cloned bios just point same pages.
So cloned bios must be completed before original bios, which means
the caller must complete <strong>rq</strong> before <strong>rq_src</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_start_plug">
void <code class="sig-name descname">blk_start_plug</code><span class="sig-paren">(</span>struct blk_plug *<em> plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize blk_plug and track it inside the task_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> that needs to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> indicates to the block layer an intent by the caller
to submit multiple I/O requests in a batch.  The block layer may use
this hint to defer submitting I/Os from the caller until <a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a>
is called.  However, the block layer may choose to submit requests
before a call to <a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a> if the number of queued I/Os
exceeds <code class="docutils literal notranslate"><span class="pre">BLK_MAX_REQUEST_COUNT</span></code>, or if the size of the I/O is larger than
<code class="docutils literal notranslate"><span class="pre">BLK_PLUG_FLUSH_SIZE</span></code>.  The queued I/Os may also be submitted early if
the task schedules (see below).</p>
<p>Tracking blk_plug inside the task_struct will help with auto-flushing the
pending I/O should the task end up blocking between <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> and
<a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a>. This is important from a performance perspective, but
also ensures that we don’t deadlock. For instance, if the task is blocking
for a memory allocation, memory reclaim could end up wanting to free a
page belonging to that request that is currently residing in our private
plug. By flushing the pending I/O when the process goes to sleep, we avoid
this kind of deadlock.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_finish_plug">
void <code class="sig-name descname">blk_finish_plug</code><span class="sig-paren">(</span>struct blk_plug *<em> plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_finish_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the end of a batch of submitted I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> passed to <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Indicate that a batch of I/O submissions is complete.  This function
must be paired with an initial call to <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a>.  The intent
is to allow the block layer to optimize I/O submission.  See the
documentation for <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> for more information.</p>
<dl class="function">
<dt id="c.blk_queue_enter">
int <code class="sig-name descname">blk_queue_enter</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, blk_mq_req_flags_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>try to increase q-&gt;q_usage_counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>BLK_MQ_REQ_NOWAIT and/or BLK_MQ_REQ_PREEMPT</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_attempt_plug_merge">
bool <code class="sig-name descname">blk_attempt_plug_merge</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct bio *<em> bio</em>, unsigned int<em> nr_segs</em>, struct request **<em> same_queue_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_attempt_plug_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge with <code class="docutils literal notranslate"><span class="pre">current</span></code>’s plugged list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request_queue new bio is being queued at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>new bio being queued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_segs</span></code></dt><dd><p>number of segments in <strong>bio</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">**</span> <span class="pre">same_queue_rq</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span></code> that gets filled in when
another request associated with <strong>q</strong> is found on the plug list
(optional, may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether <strong>bio</strong> being queued on <strong>q</strong> can be merged with a request
on <code class="docutils literal notranslate"><span class="pre">current</span></code>’s plugged list.  Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if merge was successful,
otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Plugging coalesces IOs from the same issuer for the same purpose without
going through <strong>q-&gt;queue_lock</strong>.  As such it’s more of an issuing mechanism
than scheduling, and the request, while may have elvpriv data, is not
added on the elevator at this point.  In addition, we don’t have
reliable access to the elevator outside queue lock.  Only check basic
merging parameters without querying the elevator.</p>
<p>Caller must ensure !blk_queue_nomerges(q) beforehand.</p>
<dl class="function">
<dt id="c.blk_cloned_rq_check_limits">
int <code class="sig-name descname">blk_cloned_rq_check_limits</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cloned_rq_check_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to check a cloned request for the new queue limits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the request being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>rq</strong> may have been made based on weaker limitations of upper-level queues
in request stacking drivers, and it may violate the limitation of <strong>q</strong>.
Since the block layer and the underlying device driver trust <strong>rq</strong>
after it is inserted to <strong>q</strong>, it should be checked against <strong>q</strong> before
the insertion using this generic function.</p>
<p>Request stacking drivers like request-based dm may change the queue
limits when retrying requests on other queues. Those requests need
to be checked against the new queue limits again during dispatch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_user_iov">
int <code class="sig-name descname">blk_rq_map_user_iov</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct request *<em> rq</em>, struct rq_map_data *<em> map_data</em>, const struct iov_iter *<em> iter</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_user_iov" title="Permalink to this definition">¶</a></dt>
<dd><p>map user data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue where request should be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to map data to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rq_map_data</span> <span class="pre">*</span> <span class="pre">map_data</span></code></dt><dd><p>pointer to the rq_map_data holding pages (if necessary)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt><dd><p>iovec iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly for zero copy I/O, if possible. Otherwise
a kernel bounce buffer is used.</p>
<p>A matching <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_rq_unmap_user()</span></code></a> must be issued at the end of I/O, while
still in process context.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The mapped bio may need to be bounced through blk_queue_bounce()</dt><dd><p>before being submitted to the device, as pages mapped may be out of
reach. It’s the callers responsibility to make sure this happens. The
original bio must be passed back in to <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_rq_unmap_user()</span></code></a> for proper
unmapping.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_unmap_user">
int <code class="sig-name descname">blk_rq_unmap_user</code><span class="sig-paren">(</span>struct bio *<em> bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unmap_user" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a request with user data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>start of bio list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unmap a rq previously mapped by blk_rq_map_user(). The caller must
supply the original rq-&gt;bio from the blk_rq_map_user() return, since
the I/O completion may have changed rq-&gt;bio.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_kern">
int <code class="sig-name descname">blk_rq_map_kern</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct request *<em> rq</em>, void *<em> kbuf</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>map kernel data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue where request should be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kbuf</span></code></dt><dd><p>the kernel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of user data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly if possible. Otherwise a bounce
buffer is used. Can be called multiple times to append multiple
buffers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__blk_release_queue">
void <code class="sig-name descname">__blk_release_queue</code><span class="sig-paren">(</span>struct work_struct *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_release_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>release a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>pointer to the release_work member of the request queue to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called when a block device is being unregistered. The
process of releasing a request queue starts with blk_cleanup_queue, which
set the appropriate flags and then calls blk_put_queue, that decrements
the reference counter of the request queue. Once the reference counter
of the request queue reaches zero, blk_release_queue is called to release
all allocated resources of the request queue.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_unregister_queue">
void <code class="sig-name descname">blk_unregister_queue</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unregister_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>counterpart of blk_register_queue()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>Disk of which the request queue should be unregistered from sysfs.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>the caller is responsible for guaranteeing that this function is called
after blk_register_queue() has finished.</p>
<dl class="function">
<dt id="c.blk_set_default_limits">
void <code class="sig-name descname">blk_set_default_limits</code><span class="sig-paren">(</span>struct queue_limits *<em> lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_default_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>reset limits to default values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt><dd><p>the queue_limits structure to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns a queue_limit struct to its default state.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_stacking_limits">
void <code class="sig-name descname">blk_set_stacking_limits</code><span class="sig-paren">(</span>struct queue_limits *<em> lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_stacking_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>set default limits for stacking devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt><dd><p>the queue_limits structure to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns a queue_limit struct to its default state. Should be used
by stacking drivers like DM that have no internal limits.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_bounce_limit">
void <code class="sig-name descname">blk_queue_bounce_limit</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, u64<em> max_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bounce_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set bounce buffer limit for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">max_addr</span></code></dt><dd><p>the maximum address the device can handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Different hardware can have different requirements as to what pages
it can do I/O directly to. A low level driver can call
blk_queue_bounce_limit to have lower memory pages allocated as bounce
buffers for doing I/O to pages residing above <strong>max_addr</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_hw_sectors">
void <code class="sig-name descname">blk_queue_max_hw_sectors</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> max_hw_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_hw_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_hw_sectors</span></code></dt><dd><p>max hardware sectors in the usual 512b unit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set a hard upper limit,
max_hw_sectors, on the size of requests.  max_hw_sectors is set by
the device driver based upon the capabilities of the I/O
controller.</p>
<p>max_dev_sectors is a hard limit imposed by the storage device for
READ/WRITE requests. It is set by the disk driver.</p>
<p>max_sectors is a soft limit imposed by the block layer for
filesystem type requests.  This value can be overridden on a
per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.
The soft limit can not exceed max_hw_sectors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_chunk_sectors">
void <code class="sig-name descname">blk_queue_chunk_sectors</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> chunk_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_chunk_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set size of the chunk for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">chunk_sectors</span></code></dt><dd><p>chunk sectors in the usual 512b unit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a driver doesn’t want IOs to cross a given chunk size, it can set
this limit and prevent merging across chunks. Note that the chunk size
must currently be a power-of-2 in sectors. Also note that the block
layer must accept a page worth of data at any offset. So if the
crossing of chunks is a hard limitation in the driver, it must still be
prepared to split single page bios.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_sectors">
void <code class="sig-name descname">blk_queue_max_discard_sectors</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> max_discard_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_discard_sectors</span></code></dt><dd><p>maximum number of sectors to discard</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_same_sectors">
void <code class="sig-name descname">blk_queue_max_write_same_sectors</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> max_write_same_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_same_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write same</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_same_sectors</span></code></dt><dd><p>maximum number of sectors to write per command</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_zeroes_sectors">
void <code class="sig-name descname">blk_queue_max_write_zeroes_sectors</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> max_write_zeroes_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_zeroes_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write zeroes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_zeroes_sectors</span></code></dt><dd><p>maximum number of sectors to write per command</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_segments">
void <code class="sig-name descname">blk_queue_max_segments</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned short<em> max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max hw segments for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt><dd><p>max number of segments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the number of
hw data segments in a request.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_segments">
void <code class="sig-name descname">blk_queue_max_discard_segments</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned short<em> max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segments for discard requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt><dd><p>max number of segments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the number of
segments in a discard request.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_segment_size">
void <code class="sig-name descname">blk_queue_max_segment_size</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segment_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segment size for blk_rq_map_sg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_size</span></code></dt><dd><p>max size of segment in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the size of a
coalesced segment</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_logical_block_size">
void <code class="sig-name descname">blk_queue_logical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_logical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set logical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the logical block size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be set to the lowest possible block size that the
storage device can address.  The default of 512 covers most
hardware.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_physical_block_size">
void <code class="sig-name descname">blk_queue_physical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_physical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the physical block size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be set to the lowest possible sector size that the
hardware can operate on without reverting to read-modify-write
operations.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_alignment_offset">
void <code class="sig-name descname">blk_queue_alignment_offset</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_alignment_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block alignment offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>alignment offset in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Some devices are naturally misaligned to compensate for things like
the legacy DOS partition table 63-sector offset.  Low-level drivers
should call this function for devices whose first sector is not
naturally aligned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_min">
void <code class="sig-name descname">blk_limits_io_min</code><span class="sig-paren">(</span>struct queue_limits *<em> limits</em>, unsigned int<em> min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt><dd><p>the queue limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Some devices have an internal block size bigger than the reported
hardware sector size.  This function can be used to signal the
smallest I/O the device can perform without incurring a performance
penalty.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_min">
void <code class="sig-name descname">blk_queue_io_min</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report a granularity or preferred minimum I/O
size which is the smallest request the device can perform without
incurring a performance penalty.  For disk drives this is often the
physical block size.  For RAID arrays it is often the stripe chunk
size.  A properly aligned multiple of minimum_io_size is the
preferred request size for workloads where a high number of I/O
operations is desired.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_opt">
void <code class="sig-name descname">blk_limits_io_opt</code><span class="sig-paren">(</span>struct queue_limits *<em> limits</em>, unsigned int<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt><dd><p>the queue limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report an optimal I/O size, which is the
device’s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_opt">
void <code class="sig-name descname">blk_queue_io_opt</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt><dd><p>optimal request size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report an optimal I/O size, which is the
device’s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_stack_limits">
void <code class="sig-name descname">blk_queue_stack_limits</code><span class="sig-paren">(</span>struct request_queue *<em> t</em>, struct request_queue *<em> b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>inherit underlying queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>the stacking driver (top)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>the underlying device (bottom)</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_stack_limits">
int <code class="sig-name descname">blk_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em> t</em>, struct queue_limits *<em> b</em>, sector_t<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue_limits for stacked devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>the stacking driver limits (top device)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">b</span></code></dt><dd><p>the underlying queue limits (bottom, component device)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt><dd><p>first data sector within component device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is used by stacking drivers like MD and DM to ensure
that all component devices have compatible block sizes and
alignments.  The stacking driver must provide a queue_limits
struct (top) and then iteratively call the stacking function for
all component (bottom) devices.  The stacking function will
attempt to combine the values and ensure proper alignment.</p>
<p>Returns 0 if the top and bottom queue_limits are compatible.  The
top device’s block sizes and alignment offsets may be adjusted to
ensure alignment with the bottom device. If no compatible sizes
and alignments exist, -1 is returned and the resulting top
queue_limits will have the misaligned flag set to indicate that
the alignment_offset is undefined.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bdev_stack_limits">
int <code class="sig-name descname">bdev_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em> t</em>, struct block_device *<em> bdev</em>, sector_t<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt><dd><p>the stacking driver limits (top device)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>the component block_device (bottom)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt><dd><p>first data sector within component device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Merges queue limits for a top device and a block_device.  Returns
0 if alignment didn’t change.  Returns -1 if adding the bottom
device caused misalignment.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disk_stack_limits">
void <code class="sig-name descname">disk_stack_limits</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, struct block_device *<em> bdev</em>, sector_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>MD/DM gendisk (top)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>the underlying block device (bottom)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt><dd><p>offset to beginning of data within component device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Merges the limits for a top level gendisk and a bottom level
block_device.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_update_dma_pad">
void <code class="sig-name descname">blk_queue_update_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>update pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>pad mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_dma_drain">
int <code class="sig-name descname">blk_queue_dma_drain</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, dma_drain_needed_fn *<em> dma_drain_needed</em>, void *<em> buf</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_drain" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up a drain buffer for excess dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_drain_needed_fn</span> <span class="pre">*</span> <span class="pre">dma_drain_needed</span></code></dt><dd><p>fn which returns non-zero if drain is necessary</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>physically contiguous buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of the buffer in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices have excess DMA problems and can’t simply discard (or
zero fill) the unwanted piece of the transfer.  They have to have a
real area of memory to transfer it into.  The use case for this is
ATAPI devices in DMA mode.  If the packet command causes a transfer
bigger than the transfer size some HBAs will lock up if there
aren’t DMA elements to contain the excess transfer.  What this API
does is adjust the queue so that the buf is always appended
silently to the scatterlist.</p>
<p><strong>Note</strong></p>
<p>This routine adjusts max_hw_segments to make room for appending
the drain buffer.  If you call <a class="reference internal" href="#c.blk_queue_max_segments" title="blk_queue_max_segments"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_queue_max_segments()</span></code></a> after calling
this routine, you must set the limit to one fewer than your device
can support otherwise there won’t be room for the drain buffer.</p>
<dl class="function">
<dt id="c.blk_queue_segment_boundary">
void <code class="sig-name descname">blk_queue_segment_boundary</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned long<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_segment_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for segment merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>the memory boundary mask</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_virt_boundary">
void <code class="sig-name descname">blk_queue_virt_boundary</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned long<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_virt_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for bio merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>the memory boundary mask</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_dma_alignment">
void <code class="sig-name descname">blk_queue_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>set dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>alignment mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>set required memory and length alignment for direct dma transactions.
this is used when building direct io requests for the queue.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_update_dma_alignment">
void <code class="sig-name descname">blk_queue_update_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>update dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>alignment mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>update required memory and length alignment for direct dma transactions.
If the requested alignment is larger than the current alignment, then
the current queue alignment is updated to the new value, otherwise it
is left alone.  The design of this is to allow multiple objects
(driver, device, transport etc) to set their respective
alignments without having them interfere.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_queue_depth">
void <code class="sig-name descname">blk_set_queue_depth</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>tell the block layer about the device queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>queue depth</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_write_cache">
void <code class="sig-name descname">blk_queue_write_cache</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, bool<em> wc</em>, bool<em> fua</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>configure queue’s write cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wc</span></code></dt><dd><p>write back cache on or off</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fua</span></code></dt><dd><p>device supports FUA writes, if true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about the write cache of <strong>q</strong>.</p>
<dl class="function">
<dt id="c.blk_queue_required_elevator_features">
void <code class="sig-name descname">blk_queue_required_elevator_features</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, unsigned int<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_required_elevator_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a queue required elevator features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">features</span></code></dt><dd><p>Required elevator features OR’ed together</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer that for the device controlled through <strong>q</strong>, only the
only elevators that can be used are those that implement at least the set of
features specified by <strong>features</strong>.</p>
<dl class="function">
<dt id="c.blk_queue_can_use_dma_map_merging">
bool <code class="sig-name descname">blk_queue_can_use_dma_map_merging</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_can_use_dma_map_merging" title="Permalink to this definition">¶</a></dt>
<dd><p>configure queue for merging segments.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device pointer for dma</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about merging the segments by dma map of <strong>q</strong>.</p>
<dl class="function">
<dt id="c.blk_execute_rq_nowait">
void <code class="sig-name descname">blk_execute_rq_nowait</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct gendisk *<em> bd_disk</em>, struct request *<em> rq</em>, int<em> at_head</em>, rq_end_io_fn *<em> done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue to insert the request in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt><dd><p>matching gendisk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">at_head</span></code></dt><dd><p>insert request at head or tail of queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rq_end_io_fn</span> <span class="pre">*</span> <span class="pre">done</span></code></dt><dd><p>I/O completion handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Insert a fully prepared request at the back of the I/O scheduler queue
for execution.  Don’t wait for completion.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function will invoke <strong>done</strong> directly if the queue is dead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_execute_rq">
void <code class="sig-name descname">blk_execute_rq</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct gendisk *<em> bd_disk</em>, struct request *<em> rq</em>, int<em> at_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue to insert the request in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt><dd><p>matching gendisk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">at_head</span></code></dt><dd><p>insert request at head or tail of queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Insert a fully prepared request at the back of the I/O scheduler queue
for execution and wait for completion.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_flush">
int <code class="sig-name descname">blkdev_issue_flush</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, gfp_t<em> gfp_mask</em>, sector_t *<em> error_sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>blockdev to issue flush for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">error_sector</span></code></dt><dd><p>error sector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue a flush for the block device in question. Caller can supply
room for storing the error offset in case of a flush error, if they
wish to.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_discard">
int <code class="sig-name descname">blkdev_issue_discard</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> sector</em>, sector_t<em> nr_sects</em>, gfp_t<em> gfp_mask</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>blockdev to issue discard for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to discard</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>BLKDEV_DISCARD_* flags to control behaviour</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue a discard request for the sectors in question.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_write_same">
int <code class="sig-name descname">blkdev_issue_write_same</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> sector</em>, sector_t<em> nr_sects</em>, gfp_t<em> gfp_mask</em>, struct page *<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_write_same" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a write same operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>target blockdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt><dd><p>page containing data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue a write same request for the sectors in question.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__blkdev_issue_zeroout">
int <code class="sig-name descname">__blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> sector</em>, sector_t<em> nr_sects</em>, gfp_t<em> gfp_mask</em>, struct bio **<em> biop</em>, unsigned<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>generate number of zero filed write bios</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>blockdev to issue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">**</span> <span class="pre">biop</span></code></dt><dd><p>pointer to anchor bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>controls detailed behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.</p>
<p>If a device is using logical block provisioning, the underlying space will
not be released if <code class="docutils literal notranslate"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOUNMAP.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOFALLBACK, the function will return
-EOPNOTSUPP if no explicit hardware offload for zeroing is provided.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_zeroout">
int <code class="sig-name descname">blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, sector_t<em> sector</em>, sector_t<em> nr_sects</em>, gfp_t<em> gfp_mask</em>, unsigned<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>zero-fill a block range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>blockdev to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>controls detailed behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.  See <a class="reference internal" href="#c.__blkdev_issue_zeroout" title="__blkdev_issue_zeroout"><code class="xref c c-func docutils literal notranslate"><span class="pre">__blkdev_issue_zeroout()</span></code></a> for the
valid values for <code class="docutils literal notranslate"><span class="pre">flags</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_count_integrity_sg">
int <code class="sig-name descname">blk_rq_count_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct bio *<em> bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_count_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of integrity scatterlist elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>bio with integrity metadata attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of elements required in a
scatterlist corresponding to the integrity metadata in a bio.</p>
<dl class="function">
<dt id="c.blk_rq_map_integrity_sg">
int <code class="sig-name descname">blk_rq_map_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct bio *<em> bio</em>, struct scatterlist *<em> sglist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Map integrity metadata into a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>request queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>bio with integrity metadata attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sglist</span></code></dt><dd><p>target scatterlist</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the integrity vectors in request into a
scatterlist.  The scatterlist must be big enough to hold all
elements.  I.e. sized using <a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="blk_rq_count_integrity_sg"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_rq_count_integrity_sg()</span></code></a>.</p>
<dl class="function">
<dt id="c.blk_integrity_compare">
int <code class="sig-name descname">blk_integrity_compare</code><span class="sig-paren">(</span>struct gendisk *<em> gd1</em>, struct gendisk *<em> gd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare integrity profile of two disks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd1</span></code></dt><dd><p>Disk to compare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd2</span></code></dt><dd><p>Disk to compare</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Meta-devices like DM and MD need to verify that all
sub-devices use the same integrity format before advertising to
upper layers that they can send/receive integrity metadata.  This
function can be used to check whether two gendisk devices have
compatible integrity formats.</p>
<dl class="function">
<dt id="c.blk_integrity_register">
void <code class="sig-name descname">blk_integrity_register</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, struct blk_integrity *<em> template</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a gendisk as being integrity-capable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>struct gendisk pointer to make integrity-aware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_integrity</span> <span class="pre">*</span> <span class="pre">template</span></code></dt><dd><p>block integrity profile to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device needs to advertise itself as being able to
send/receive integrity metadata it must use this function to register
the capability with the block layer. The template is a blk_integrity
struct with values appropriate for the underlying hardware. See
Documentation/block/data-integrity.rst.</p>
<dl class="function">
<dt id="c.blk_integrity_unregister">
void <code class="sig-name descname">blk_integrity_unregister</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister block integrity profile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk whose integrity profile to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the integrity capability from
a block device.</p>
<dl class="function">
<dt id="c.blk_trace_ioctl">
int <code class="sig-name descname">blk_trace_ioctl</code><span class="sig-paren">(</span>struct block_device *<em> bdev</em>, unsigned<em> cmd</em>, char __user *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the ioctls associated with tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>the block device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">cmd</span></code></dt><dd><p>the ioctl cmd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>the argument data, if any</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_trace_shutdown">
void <code class="sig-name descname">blk_trace_shutdown</code><span class="sig-paren">(</span>struct request_queue *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>stop and cleanup trace structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>the request queue associated with the device</p>
</dd>
</dl>
<dl class="function">
<dt id="c.blk_add_trace_rq">
void <code class="sig-name descname">blk_add_trace_rq</code><span class="sig-paren">(</span>struct request *<em> rq</em>, int<em> error</em>, unsigned int<em> nr_bytes</em>, u32<em> what</em>, u64<em> cgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the source request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>return status to log</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt><dd><p>number of completed bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">what</span></code></dt><dd><p>the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">cgid</span></code></dt><dd><p>the cgroup info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Records an action against a request. Will log the bio offset + size.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio">
void <code class="sig-name descname">blk_add_trace_bio</code><span class="sig-paren">(</span>struct request_queue *<em> q</em>, struct bio *<em> bio</em>, u32<em> what</em>, int<em> error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue the io is for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>the source bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">what</span></code></dt><dd><p>the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>error, if any</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Records an action against a bio. Will log the bio offset + size.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio_remap">
void <code class="sig-name descname">blk_add_trace_bio_remap</code><span class="sig-paren">(</span>void *<em> ignore</em>, struct request_queue *<em> q</em>, struct bio *<em> bio</em>, dev_t<em> dev</em>, sector_t<em> from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt><dd><p>trace callback data parameter (not used)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue the io is for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt><dd><p>the source bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt><dd><p>source sector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Device mapper or raid target sometimes need to split a bio because
it spans a stripe (or similar). Add a trace for that action.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_rq_remap">
void <code class="sig-name descname">blk_add_trace_rq_remap</code><span class="sig-paren">(</span>void *<em> ignore</em>, struct request_queue *<em> q</em>, struct request *<em> rq</em>, dev_t<em> dev</em>, sector_t<em> from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt><dd><p>trace callback data parameter (not used)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>queue the io is for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>the source request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt><dd><p>source sector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Device mapper remaps request to other devices.
Add a trace for that action.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disk_get_part">
struct hd_struct * <code class="sig-name descname">disk_get_part</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, int<em> partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_get_part" title="Permalink to this definition">¶</a></dt>
<dd><p>get partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to look partition from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">partno</span></code></dt><dd><p>partition number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for partition <strong>partno</strong> from <strong>disk</strong>.  If found, increment
reference count and return it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<p><strong>Return</strong></p>
<p>Pointer to the found partition on success, NULL if not found.</p>
<dl class="function">
<dt id="c.disk_map_sector_rcu">
struct hd_struct * <code class="sig-name descname">disk_map_sector_rcu</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, sector_t<em> sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_map_sector_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>map sector to partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>gendisk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>sector to map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out which partition <strong>sector</strong> maps to on <strong>disk</strong>.  This is
primarily used for stats accounting.</p>
<p><strong>Context</strong></p>
<p>RCU read locked.  The returned partition pointer is valid only
while preemption is disabled.</p>
<p><strong>Return</strong></p>
<p>Found partition on success, part0 is returned if no partition matches</p>
<dl class="function">
<dt id="c.blk_mangle_minor">
int <code class="sig-name descname">blk_mangle_minor</code><span class="sig-paren">(</span>int<em> minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_mangle_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>scatter minor numbers apart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">minor</span></code></dt><dd><p>minor number to mangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatter consecutively allocated <strong>minor</strong> number apart if MANGLE_DEVT
is enabled.  Mangling twice gives the original value.</p>
<p><strong>Return</strong></p>
<p>Mangled value.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.blk_alloc_devt">
int <code class="sig-name descname">blk_alloc_devt</code><span class="sig-paren">(</span>struct hd_struct *<em> part</em>, dev_t *<em> devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_alloc_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dev_t for a partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt><dd><p>partition to allocate dev_t for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">devt</span></code></dt><dd><p>out parameter for resulting dev_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dev_t for block device.</p>
<p><strong>Return</strong></p>
<p>0 on success, allocated dev_t is returned in <strong>*devt</strong>.  -errno on
failure.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.blk_free_devt">
void <code class="sig-name descname">blk_free_devt</code><span class="sig-paren">(</span>dev_t<em> devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>free a dev_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>dev_t to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>devt</strong> which was allocated using <a class="reference internal" href="#c.blk_alloc_devt" title="blk_alloc_devt"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_alloc_devt()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.__device_add_disk">
void <code class="sig-name descname">__device_add_disk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> parent</em>, struct gendisk *<em> disk</em>, const struct attribute_group **<em> groups</em>, bool<em> register_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__device_add_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>add disk information to kernel list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent device for the disk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>per-device partitioning information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt><dd><p>Additional per-device sysfs groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">register_queue</span></code></dt><dd><p>register the queue if set to true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the partitioning information in <strong>disk</strong>
with the kernel.</p>
<p>FIXME: error handling</p>
<dl class="function">
<dt id="c.get_gendisk">
struct gendisk * <code class="sig-name descname">get_gendisk</code><span class="sig-paren">(</span>dev_t<em> devt</em>, int *<em> partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_gendisk" title="Permalink to this definition">¶</a></dt>
<dd><p>get partitioning information for a given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>device to get partitioning information for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">partno</span></code></dt><dd><p>returned partition index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the structure containing partitioning
information for the given device <strong>devt</strong>.</p>
<dl class="function">
<dt id="c.disk_replace_part_tbl">
void <code class="sig-name descname">disk_replace_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, struct disk_part_tbl *<em> new_ptbl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_replace_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>replace disk-&gt;part_tbl in RCU-safe way</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to replace part_tbl for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">disk_part_tbl</span> <span class="pre">*</span> <span class="pre">new_ptbl</span></code></dt><dd><p>new part_tbl to install</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace disk-&gt;part_tbl with <strong>new_ptbl</strong> in RCU-safe way.  The
original ptbl is freed using RCU callback.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.</p>
<dl class="function">
<dt id="c.disk_expand_part_tbl">
int <code class="sig-name descname">disk_expand_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, int<em> partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_expand_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>expand disk-&gt;part_tbl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to expand part_tbl for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">partno</span></code></dt><dd><p>expand such that this partno can fit in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expand disk-&gt;part_tbl such that <strong>partno</strong> can fit in.  disk-&gt;part_tbl
uses RCU to allow unlocked dereferencing for stats and other stuff.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.
Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.disk_block_events">
void <code class="sig-name descname">disk_block_events</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_block_events" title="Permalink to this definition">¶</a></dt>
<dd><p>block and flush disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to block events for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return from this function, it is guaranteed that event checking
isn’t in progress and won’t happen until unblocked by
<a class="reference internal" href="#c.disk_unblock_events" title="disk_unblock_events"><code class="xref c c-func docutils literal notranslate"><span class="pre">disk_unblock_events()</span></code></a>.  Events blocking is counted and the actual
unblocking happens after the matching number of unblocks are done.</p>
<p>Note that this intentionally does not block event checking from
<a class="reference internal" href="#c.disk_clear_events" title="disk_clear_events"><code class="xref c c-func docutils literal notranslate"><span class="pre">disk_clear_events()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_unblock_events">
void <code class="sig-name descname">disk_unblock_events</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_unblock_events" title="Permalink to this definition">¶</a></dt>
<dd><p>unblock disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to unblock events for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.disk_block_events" title="disk_block_events"><code class="xref c c-func docutils literal notranslate"><span class="pre">disk_block_events()</span></code></a>.  When the block count reaches zero, it
starts events polling if configured.</p>
<p><strong>Context</strong></p>
<p>Don’t care.  Safe to call from irq context.</p>
<dl class="function">
<dt id="c.disk_flush_events">
void <code class="sig-name descname">disk_flush_events</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_flush_events" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule immediate event checking and flushing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to check and flush events for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>events to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule immediate event checking on <strong>disk</strong> if not blocked.  Events in
<strong>mask</strong> are scheduled to be cleared from the driver.  Note that this
doesn’t clear the events from <strong>disk-&gt;ev</strong>.</p>
<p><strong>Context</strong></p>
<p>If <strong>mask</strong> is non-zero must be called with bdev-&gt;bd_mutex held.</p>
<dl class="function">
<dt id="c.disk_clear_events">
unsigned int <code class="sig-name descname">disk_clear_events</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_clear_events" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously check, clear and return pending events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to fetch and clear events from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>mask of events to be fetched and cleared</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disk events are synchronously checked and pending events in <strong>mask</strong>
are cleared and returned.  This ignores the block count.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_part_iter_init">
void <code class="sig-name descname">disk_part_iter_init</code><span class="sig-paren">(</span>struct disk_part_iter *<em> piter</em>, struct gendisk *<em> disk</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize partition iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt><dd><p>iterator to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>disk to iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>DISK_PITER_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>piter</strong> so that it iterates over partitions of <strong>disk</strong>.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_next">
struct hd_struct * <code class="sig-name descname">disk_part_iter_next</code><span class="sig-paren">(</span>struct disk_part_iter *<em> piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>proceed iterator to the next partition and return it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt><dd><p>iterator of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>piter</strong> to the next partition and return it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_exit">
void <code class="sig-name descname">disk_part_iter_exit</code><span class="sig-paren">(</span>struct disk_part_iter *<em> piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish up partition iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt><dd><p>iter of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when iteration is over.  Cleans up <strong>piter</strong>.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_has_partitions">
bool <code class="sig-name descname">disk_has_partitions</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_has_partitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>gendisk of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk through the partition table and check if valid partition exists.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<p><strong>Return</strong></p>
<p>True if the gendisk has at least one valid non-zero size partition.
Otherwise false.</p>
<dl class="function">
<dt id="c.register_blkdev">
int <code class="sig-name descname">register_blkdev</code><span class="sig-paren">(</span>unsigned int<em> major</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_blkdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>the requested major device number [1..BLKDEV_MAJOR_MAX-1]. If
<strong>major</strong> = 0, try to allocate any unused major number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the name of the new block device as a zero terminated string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>name</strong> must be unique within the system.</p>
<p>The return value depends on the <strong>major</strong> input parameter:</p>
<blockquote>
<div><ul class="simple">
<li><p>if a major device number was requested in range [1..BLKDEV_MAJOR_MAX-1]
then the function returns zero on success, or a negative error code</p></li>
<li><p>if any unused major number was requested with <strong>major</strong> = 0 parameter
then the return value is the allocated major number in range
[1..BLKDEV_MAJOR_MAX-1] or a negative error code otherwise</p></li>
</ul>
</div></blockquote>
<p>See Documentation/admin-guide/devices.txt for the list of allocated
major numbers.</p>
<dl class="function">
<dt id="c.bdget_disk">
struct block_device * <code class="sig-name descname">bdget_disk</code><span class="sig-paren">(</span>struct gendisk *<em> disk</em>, int<em> partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdget_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>do bdget() by gendisk and partition number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt><dd><p>gendisk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">partno</span></code></dt><dd><p>partition number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find partition <strong>partno</strong> from <strong>disk</strong>, do bdget() on it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<p><strong>Return</strong></p>
<p>Resulting block_device on success, NULL on failure.</p>
</div>
<div class="section" id="char-devices">
<h2>Char devices<a class="headerlink" href="#char-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.register_chrdev_region">
int <code class="sig-name descname">register_chrdev_region</code><span class="sig-paren">(</span>dev_t<em> from</em>, unsigned<em> count</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt><dd><p>the first in the desired range of device numbers; must include
the major number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of consecutive device numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the name of the device or driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return value is zero on success, a negative error code on failure.</p>
<dl class="function">
<dt id="c.alloc_chrdev_region">
int <code class="sig-name descname">alloc_chrdev_region</code><span class="sig-paren">(</span>dev_t *<em> dev</em>, unsigned<em> baseminor</em>, unsigned<em> count</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of char device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>output parameter for first assigned number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the requested range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the name of the associated device or driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a range of char device numbers.  The major number will be
chosen dynamically, and returned (along with the first minor number)
in <strong>dev</strong>.  Returns zero or a negative error code.</p>
<dl class="function">
<dt id="c.__register_chrdev">
int <code class="sig-name descname">__register_chrdev</code><span class="sig-paren">(</span>unsigned int<em> major</em>, unsigned int<em> baseminor</em>, unsigned int<em> count</em>, const char *<em> name</em>, const struct file_operations *<em> fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register a cdev occupying a range of minors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major device number or 0 for dynamic allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the requested range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of this range of devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>file operations associated with this devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>major</strong> == 0 this functions will dynamically allocate a major and return
its number.</p>
<p>If <strong>major</strong> &gt; 0 this function will attempt to reserve a device with the given
major number and will return zero on success.</p>
<p>Returns a -ve errno on failure.</p>
<p>The name of this device has nothing to do with the name of the device in
/dev. It only helps to keep track of the different owners of devices. If
your module name has only one type of devices it’s ok to use e.g. the name
of the module here.</p>
<dl class="function">
<dt id="c.unregister_chrdev_region">
void <code class="sig-name descname">unregister_chrdev_region</code><span class="sig-paren">(</span>dev_t<em> from</em>, unsigned<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt><dd><p>the first in the range of numbers to unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of device numbers to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will unregister a range of <strong>count</strong> device numbers,
starting with <strong>from</strong>.  The caller should normally be the one who
allocated those numbers in the first place…</p>
<dl class="function">
<dt id="c.__unregister_chrdev">
void <code class="sig-name descname">__unregister_chrdev</code><span class="sig-paren">(</span>unsigned int<em> major</em>, unsigned int<em> baseminor</em>, unsigned int<em> count</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__unregister_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and destroy a cdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers this cdev is occupying</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of this range of devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister and destroy the cdev occupying the region described by
<strong>major</strong>, <strong>baseminor</strong> and <strong>count</strong>.  This function undoes what
<a class="reference internal" href="#c.__register_chrdev" title="__register_chrdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">__register_chrdev()</span></code></a> did.</p>
<dl class="function">
<dt id="c.cdev_add">
int <code class="sig-name descname">cdev_add</code><span class="sig-paren">(</span>struct cdev *<em> p</em>, dev_t<em> dev</em>, unsigned<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>the cdev structure for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>the first device number for which this device is responsible</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of consecutive minor numbers corresponding to this
device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_add()</span></code></a> adds the device represented by <strong>p</strong> to the system, making it
live immediately.  A negative error code is returned on failure.</p>
<dl class="function">
<dt id="c.cdev_set_parent">
void <code class="sig-name descname">cdev_set_parent</code><span class="sig-paren">(</span>struct cdev *<em> p</em>, struct kobject *<em> kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent kobject for a char device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt><dd><p>the kobject to take a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_set_parent" title="cdev_set_parent"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_set_parent()</span></code></a> sets a parent kobject which will be referenced
appropriately so the parent is not freed before the cdev. This
should be called before cdev_add.</p>
<dl class="function">
<dt id="c.cdev_device_add">
int <code class="sig-name descname">cdev_device_add</code><span class="sig-paren">(</span>struct cdev *<em> cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device and it’s corresponding struct device, linkink</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_add" title="cdev_device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_device_add()</span></code></a> adds the char device represented by <strong>cdev</strong> to the system,
just as cdev_add does. It then adds <strong>dev</strong> to the system using device_add
The dev_t for the char device will be taken from the struct device which
needs to be initialized first. This helper function correctly takes a
reference to the parent device so the parent will not get released until
all references to the cdev are released.</p>
<p>This helper uses dev-&gt;devt for the device number. If it is not set
it will not add the cdev and it will be equivalent to device_add.</p>
<p>This function should be used whenever the struct cdev and the
struct device are members of the same structure whose lifetime is
managed by the struct device.</p>
<p><strong>NOTE</strong></p>
<p>Callers must assume that userspace was able to open the cdev and
can call cdev fops callbacks at any time, even if this function fails.</p>
<dl class="function">
<dt id="c.cdev_device_del">
void <code class="sig-name descname">cdev_device_del</code><span class="sig-paren">(</span>struct cdev *<em> cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>inverse of cdev_device_add</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_del" title="cdev_device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_device_del()</span></code></a> is a helper function to call cdev_del and device_del.
It should be used whenever cdev_device_add is used.</p>
<p>If dev-&gt;devt is not set it will not remove the cdev and will be equivalent
to device_del.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that associated sysfs callbacks are not running
or runnable, however any cdevs already open will remain and their fops
will still be callable even after this function returns.</p>
<dl class="function">
<dt id="c.cdev_del">
void <code class="sig-name descname">cdev_del</code><span class="sig-paren">(</span>struct cdev *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a cdev from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>the cdev structure to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_del" title="cdev_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_del()</span></code></a> removes <strong>p</strong> from the system, possibly freeing the structure
itself.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that cdev device will no longer be able to be
opened, however any cdevs already open will remain and their fops will
still be callable even after cdev_del returns.</p>
<dl class="function">
<dt id="c.cdev_alloc">
struct cdev * <code class="sig-name descname">cdev_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a cdev structure, or NULL on failure.</p>
<dl class="function">
<dt id="c.cdev_init">
void <code class="sig-name descname">cdev_init</code><span class="sig-paren">(</span>struct cdev *<em> cdev</em>, const struct file_operations *<em> fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt><dd><p>the structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>the file_operations for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cdev</strong>, remembering <strong>fops</strong>, making it ready to add to the
system with <a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_add()</span></code></a>.</p>
</div>
<div class="section" id="clock-framework">
<h2>Clock Framework<a class="headerlink" href="#clock-framework" title="Permalink to this headline">¶</a></h2>
<p>The clock framework defines programming interfaces to support software
management of the system clock tree. This framework is widely used with
System-On-Chip (SOC) platforms to support power management and various
devices which may need custom clock rates. Note that these “clocks”
don’t relate to timekeeping or real time clocks (RTCs), each of which
have separate frameworks. These <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span></code>
instances may be used to manage for example a 96 MHz signal that is used
to shift bits into and out of peripherals or busses, or otherwise
trigger synchronous state machine transitions in system hardware.</p>
<p>Power management is supported by explicit software clock gating: unused
clocks are disabled, so the system doesn’t waste power changing the
state of transistors that aren’t in active use. On some systems this may
be backed by hardware clock gating, where clocks are gated without being
disabled in software. Sections of chips that are powered but not clocked
may be able to retain their last state. This low power state is often
called a <em>retention mode</em>. This mode still incurs leakage currents,
especially with finer circuit geometries, but for CMOS circuits power is
mostly used by clocked state changes.</p>
<p>Power-aware drivers only enable their clocks when the device they manage
is in active use. Also, system sleep states often differ according to
which clock domains are active: while a “standby” state may allow wakeup
from several active domains, a “mem” (suspend-to-RAM) state may require
a more wholesale shutdown of clocks derived from higher speed PLLs and
oscillators, limiting the number of possible wakeup event sources. A
driver’s suspend method may need to be aware of system-specific clock
constraints on the target sleep state.</p>
<p>Some platforms support programmable clock generators. These can be used
by external chips of various kinds, such as other CPUs, multimedia
codecs, and devices with strict requirements for interface clocking.</p>
<dl class="type">
<dt id="c.clk_notifier">
struct <code class="sig-name descname">clk_notifier</code><a class="headerlink" href="#c.clk_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a clk with a notifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_notifier {
  struct clk                      *clk;
  struct srcu_notifier_head       notifier_head;
  struct list_head                node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * to associate the notifier with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notifier_head</span></code></dt><dd><p>a blocking_notifier_head for this clk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>linked list pointers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A list of struct clk_notifier is maintained by the notifier code.
An entry is created whenever code registers the first notifier on a
particular <strong>clk</strong>.  Future notifiers on that <strong>clk</strong> are added to the
<strong>notifier_head</strong>.</p>
<dl class="type">
<dt id="c.clk_notifier_data">
struct <code class="sig-name descname">clk_notifier_data</code><a class="headerlink" href="#c.clk_notifier_data" title="Permalink to this definition">¶</a></dt>
<dd><p>rate data to pass to the notifier callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_notifier_data {
  struct clk              *clk;
  unsigned long           old_rate;
  unsigned long           new_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * being changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_rate</span></code></dt><dd><p>previous rate of this clk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_rate</span></code></dt><dd><p>new rate of this clk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a pre-notifier, old_rate is the clk’s rate before this rate
change, and new_rate is what the rate will be in the future.  For a
post-notifier, old_rate and new_rate are both set to the clk’s
current rate (this was done to optimize the implementation).</p>
<dl class="type">
<dt id="c.clk_bulk_data">
struct <code class="sig-name descname">clk_bulk_data</code><a class="headerlink" href="#c.clk_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk clk operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_bulk_data {
  const char              *id;
  struct clk              *clk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * to store the associated clock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The CLK APIs provide a series of clk_bulk_() API calls as
a convenience to consumers which require multiple clks.  This
structure is used to manage data for these calls.</p>
<dl class="function">
<dt id="c.clk_notifier_register">
int <code class="sig-name descname">clk_notifier_register</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock whose rate we are interested in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier block with callback function pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ProTip: debugging across notifier chains can be frustrating. Make sure that
your notifier callback function prints a nice big warning in case of
failure.</p>
<dl class="function">
<dt id="c.clk_notifier_unregister">
int <code class="sig-name descname">clk_notifier_unregister</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, struct notifier_block *<em> nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock whose rate we are no longer interested in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt><dd><p>notifier block which will be unregistered</p>
</dd>
</dl>
<dl class="function">
<dt id="c.clk_get_accuracy">
long <code class="sig-name descname">clk_get_accuracy</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the clock accuracy in ppb (parts per billion) for a clock source.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This gets the clock source accuracy expressed in ppb.
A perfect clock returns 0.</p>
<dl class="function">
<dt id="c.clk_set_phase">
int <code class="sig-name descname">clk_set_phase</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, int<em> degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">degrees</span></code></dt><dd><p>number of degrees the signal is shifted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifts the phase of a clock signal by the specified degrees. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_phase">
int <code class="sig-name descname">clk_get_phase</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>return the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock signal source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the phase shift of a clock node in degrees, otherwise returns
-EERROR.</p>
<dl class="function">
<dt id="c.clk_set_duty_cycle">
int <code class="sig-name descname">clk_set_duty_cycle</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned int<em> num</em>, unsigned int<em> den</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the duty cycle ratio of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>numerator of the duty cycle ratio to be applied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">den</span></code></dt><dd><p>denominator of the duty cycle ratio to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust the duty cycle of a clock signal by the specified ratio. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_scaled_duty_cycle">
int <code class="sig-name descname">clk_get_scaled_duty_cycle</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned int<em> scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_scaled_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>return the duty cycle ratio of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>scaling factor to be applied to represent the ratio as an integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the duty cycle ratio multiplied by the scale provided, otherwise
returns -EERROR.</p>
<dl class="function">
<dt id="c.clk_is_match">
bool <code class="sig-name descname">clk_is_match</code><span class="sig-paren">(</span>const struct clk *<em> p</em>, const struct clk *<em> q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>check if two clk’s point to the same hardware clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>clk compared against q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">q</span></code></dt><dd><p>clk compared against p</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the two struct clk pointers both point to the same hardware
clock node. Put differently, returns true if <strong>p</strong> and <strong>q</strong>
share the same <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_core</span></code> object.</p>
<p>Returns false otherwise. Note that two NULL clks are treated as matching.</p>
<dl class="function">
<dt id="c.clk_prepare">
int <code class="sig-name descname">clk_prepare</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the clock source for use.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_unprepare">
void <code class="sig-name descname">clk_unprepare</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>undo preparation of a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This undoes a previously prepared clock.  The caller must balance
the number of prepare and unprepare calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_get">
struct clk * <code class="sig-name descname">clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid IS_ERR() condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get">
int <code class="sig-name descname">clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a number of references to clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get several clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully, or valid IS_ERR() condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data.id</strong> to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data.clk</strong> field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get_all">
int <code class="sig-name descname">clk_bulk_get_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> **<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get_all" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain all available references to clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">**</span> <span class="pre">clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get all clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns a positive value for the number of clocks obtained while the
clock references are stored in the clk_bulk_data table in <strong>clks</strong> field.
Returns 0 if there’re none and a negative value if something failed.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get_optional">
int <code class="sig-name descname">clk_bulk_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a number of references to clock producer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.clk_bulk_get" title="clk_bulk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_get()</span></code></a> except where there is no clock producer.
In this case, instead of returning -ENOENT, the function returns 0 and
NULL for a clk for which a clock producer could not be determined.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get">
int <code class="sig-name descname">devm_clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get_optional">
int <code class="sig-name descname">devm_clk_bulk_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple optional consumer clocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.devm_clk_bulk_get" title="devm_clk_bulk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_bulk_get()</span></code></a> except where there is no clock
producer.  In this case, instead of returning -ENOENT, the function returns
NULL for given clk. It is assumed all clocks in clk_bulk_data are optional.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully or for any clk there was no clk provider available, otherwise
returns valid IS_ERR() condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data.id</strong> to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data.clk</strong> field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get_all">
int <code class="sig-name descname">devm_clk_bulk_get_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> **<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get_all" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">**</span> <span class="pre">clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a positive value for the number of clocks obtained while the
clock references are stored in the clk_bulk_data table in <strong>clks</strong> field.
Returns 0 if there’re none and a negative value if something failed.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
<dl class="function">
<dt id="c.devm_clk_get">
struct clk * <code class="sig-name descname">devm_clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid IS_ERR() condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>devm_clk_get should not be called from within interrupt context.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.devm_clk_get_optional">
struct clk * <code class="sig-name descname">devm_clk_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to an optional clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a> except where there is no clock producer.
In this case, instead of returning -ENOENT, the function returns NULL.</p>
<dl class="function">
<dt id="c.devm_get_clk_from_child">
struct clk * <code class="sig-name descname">devm_get_clk_from_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct device_node *<em> np</em>, const char *<em> con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_clk_from_child" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer from child node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt><dd><p>pointer to clock consumer node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function parses the clocks, and uses them to look up the
struct clk from the registered list of clock providers by using
<strong>np</strong> and <strong>con_id</strong></p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.clk_rate_exclusive_get">
int <code class="sig-name descname">clk_rate_exclusive_get</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get exclusivity over the rate control of a producer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to get exclusive control over the rate of a
provider. It prevents any other consumer to execute, even indirectly,
opereation which could alter the rate of the provider or cause glitches</p>
<p>If exlusivity is claimed more than once on clock, even by the same driver,
the rate effectively gets locked as exclusivity can’t be preempted.</p>
<p>Must not be called from within atomic context.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_rate_exclusive_put">
void <code class="sig-name descname">clk_rate_exclusive_put</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release exclusivity over the rate control of a producer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to release the exclusivity it previously got
from <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_get()</span></code></a></p>
<p>The caller must balance the number of <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_get()</span></code></a> and
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_put()</span></code></a> calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_enable">
int <code class="sig-name descname">clk_enable</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the clock can not be enabled/disabled, this should return success.</p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_bulk_enable">
int <code class="sig-name descname">clk_bulk_enable</code><span class="sig-paren">(</span>int<em> num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_disable">
void <code class="sig-name descname">clk_disable</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a clock source is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the clock source is shared between
multiple drivers, <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_bulk_disable">
void <code class="sig-name descname">clk_bulk_disable</code><span class="sig-paren">(</span>int<em> num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a set of clks is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the set of clks is shared between
multiple drivers, <a class="reference internal" href="#c.clk_bulk_enable" title="clk_bulk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_bulk_disable" title="clk_bulk_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_get_rate">
unsigned long <code class="sig-name descname">clk_get_rate</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the current clock rate (in Hz) for a clock source. This is only valid once the clock source has been enabled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<dl class="function">
<dt id="c.clk_put">
void <code class="sig-name descname">clk_put</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_put">
void <code class="sig-name descname">clk_bulk_put</code><span class="sig-paren">(</span>int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p>clk_bulk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_put_all">
void <code class="sig-name descname">clk_bulk_put_all</code><span class="sig-paren">(</span>int<em> num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em> clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put_all" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” all the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p>clk_bulk_put_all should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_put">
void <code class="sig-name descname">devm_clk_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” a managed clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device used to acquire the clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source acquired with <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a></p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_round_rate">
long <code class="sig-name descname">clk_round_rate</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_round_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust a rate to the exact rate a clock can provide</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This answers the question “if I were to pass <strong>rate</strong> to <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_set_rate()</span></code></a>,
what clock rate would I end up with?” without changing the hardware
in any way.  In other words:</p>
<blockquote>
<div><p>rate = clk_round_rate(clk, r);</p>
</div></blockquote>
<p>and:</p>
<blockquote>
<div><p>clk_set_rate(clk, r);
rate = clk_get_rate(clk);</p>
</div></blockquote>
<p>are equivalent except the former does not modify the clock hardware
in any way.</p>
<p>Returns rounded clock rate in Hz, or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate">
int <code class="sig-name descname">clk_set_rate</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updating the rate starts at the top-most affected clock and then
walks the tree down to the bottom-most clock that needs updating.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate_exclusive">
int <code class="sig-name descname">clk_set_rate_exclusive</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate and claim exclusivity over clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to atomically set the rate of a producer
and claim exclusivity over the rate control of the producer.</p>
<p>It is essentially a combination of <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_set_rate()</span></code></a> and
clk_rate_exclusite_get(). Caller must balance this call with a call to
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_put()</span></code></a></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_has_parent">
bool <code class="sig-name descname">clk_has_parent</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, struct clk *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_has_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a clock is a possible parent for another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers that need to check that a clock can be
the parent of another without actually changing the parent.</p>
<p>Returns true if <strong>parent</strong> is a possible parent for <strong>clk</strong>, false otherwise.</p>
<dl class="function">
<dt id="c.clk_set_rate_range">
int <code class="sig-name descname">clk_set_rate_range</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> min</em>, unsigned long<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>set a rate range for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>desired minimum clock rate in Hz, inclusive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>desired maximum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_min_rate">
int <code class="sig-name descname">clk_set_min_rate</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_min_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a minimum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired minimum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_max_rate">
int <code class="sig-name descname">clk_set_max_rate</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, unsigned long<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_max_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a maximum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired maximum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_parent">
int <code class="sig-name descname">clk_set_parent</code><span class="sig-paren">(</span>struct clk *<em> clk</em>, struct clk *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>parent clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_get_parent">
struct clk * <code class="sig-name descname">clk_get_parent</code><span class="sig-paren">(</span>struct clk *<em> clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct clk corresponding to parent clock source, or
valid IS_ERR() condition containing errno.</p>
<dl class="function">
<dt id="c.clk_get_sys">
struct clk * <code class="sig-name descname">clk_get_sys</code><span class="sig-paren">(</span>const char *<em> dev_id</em>, const char *<em> con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_sys" title="Permalink to this definition">¶</a></dt>
<dd><p>get a clock based upon the device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt><dd><p>device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt><dd><p>connection ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid IS_ERR() condition containing errno.  The implementation
uses <strong>dev_id</strong> and <strong>con_id</strong> to determine the clock consumer, and
thereby the clock producer. In contrast to <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_get()</span></code></a> this function
takes the device name instead of the device itself for identification.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get_sys should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_save_context">
int <code class="sig-name descname">clk_save_context</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.clk_save_context" title="Permalink to this definition">¶</a></dt>
<dd><p>save clock context for poweroff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Saves the context of the clock register for powerstates in which the
contents of the registers will be lost. Occurs deep within the suspend
code so locking is not necessary.</p>
<dl class="function">
<dt id="c.clk_restore_context">
void <code class="sig-name descname">clk_restore_context</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.clk_restore_context" title="Permalink to this definition">¶</a></dt>
<dd><p>restore clock context after poweroff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This occurs with all clocks enabled. Occurs deep within the resume code
so locking is not necessary.</p>
<dl class="function">
<dt id="c.clk_get_optional">
struct clk * <code class="sig-name descname">clk_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const char *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to an optional clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device for clock “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_get()</span></code></a> except where there is no clock producer. In
this case, instead of returning -ENOENT, the function returns NULL.</p>
</div>
<div class="section" id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="read-copy-update-rcu">
<h3>Read-Copy Update (RCU)<a class="headerlink" href="#read-copy-update-rcu" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.RCU_NONIDLE">
<code class="sig-name descname">RCU_NONIDLE</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_NONIDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate idle-loop code that needs RCU readers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>Code that RCU needs to pay attention to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>RCU read-side critical sections are forbidden in the inner idle loop,
that is, between the <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_enter()</span></code></a> and the <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_exit()</span></code></a> – RCU
will happily ignore any such read-side critical sections.  However,
things like powertop need tracepoints in the inner idle loop.</p>
<p>This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())
will tell RCU that it needs to pay attention, invoke its argument
(in this example, calling the do_something_with_RCU() function),
and then tell RCU to go back to ignoring this CPU.  It is permissible
to nest <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_NONIDLE()</span></code></a> wrappers, but not indefinitely (but the limit is
on the order of a million or so, even on 32-bit systems).  It is
not legal to block within <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_NONIDLE()</span></code></a>, nor is it permissible to
transfer control either into or out of <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_NONIDLE()</span></code></a>’s statement.</p>
<dl class="function">
<dt id="c.cond_resched_tasks_rcu_qs">
<code class="sig-name descname">cond_resched_tasks_rcu_qs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_resched_tasks_rcu_qs" title="Permalink to this definition">¶</a></dt>
<dd><p>Report potential quiescent states to RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro resembles cond_resched(), except that it is defined to
report potential quiescent states to RCU-tasks even if the cond_resched()
machinery were to be shut off, as some advocate for PREEMPTION kernels.</p>
<dl class="function">
<dt id="c.RCU_LOCKDEP_WARN">
<code class="sig-name descname">RCU_LOCKDEP_WARN</code><span class="sig-paren">(</span><em>c</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_LOCKDEP_WARN" title="Permalink to this definition">¶</a></dt>
<dd><p>emit lockdep splat if specified condition is met</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>condition to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>informative message</p>
</dd>
</dl>
<dl class="function">
<dt id="c.RCU_INITIALIZER">
<code class="sig-name descname">RCU_INITIALIZER</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU-protected global variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to statically initialize with.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rcu_assign_pointer">
<code class="sig-name descname">rcu_assign_pointer</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_assign_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>assign to RCU-protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>pointer to assign to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>value to assign (publish)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assigns the specified value to the specified RCU-protected
pointer, ensuring that any concurrent RCU readers will see
any prior initialization.</p>
<p>Inserts memory barriers on architectures that require them
(which is most of them), and also prevents the compiler from
reordering the code that initializes the structure after the pointer
assignment.  More importantly, this call documents which pointers
will be dereferenced by RCU read-side code.</p>
<p>In some special cases, you may use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> instead
of <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a>.  <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> is a bit faster due
to the fact that it does not constrain either the CPU or the compiler.
That said, using <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> when you should have used
<a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> is a very bad thing that results in
impossible-to-diagnose memory corruption.  So please be careful.
See the <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> comment header for details.</p>
<p>Note that <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> evaluates each of its arguments only
once, appearances notwithstanding.  One of the “extra” evaluations
is in typeof() and the other visible only to sparse (__CHECKER__),
neither of which actually execute the argument.  As with most cpp
macros, this execute-arguments-only-once property is important, so
please be careful when making changes to <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> and the
other macros that it invokes.</p>
<dl class="function">
<dt id="c.rcu_replace_pointer">
<code class="sig-name descname">rcu_replace_pointer</code><span class="sig-paren">(</span><em>rcu_ptr</em>, <em>ptr</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_replace_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>replace an RCU pointer, returning its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_ptr</span></code></dt><dd><p>RCU pointer, whose old value is returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>regular pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>the lockdep conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a replacement, where <strong>rcu_ptr</strong> is an RCU-annotated
pointer and <strong>c</strong> is the lockdep argument that is passed to the
<a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_protected()</span></code></a> call used to read that pointer.  The old
value of <strong>rcu_ptr</strong> is returned, and <strong>rcu_ptr</strong> is set to <strong>ptr</strong>.</p>
<dl class="function">
<dt id="c.rcu_access_pointer">
<code class="sig-name descname">rcu_access_pointer</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_access_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer with no dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit the
lockdep checks for being in an RCU read-side critical section.  This is
useful when the value of this pointer is accessed, but the pointer is
not dereferenced, for example, when testing an RCU-protected pointer
against NULL.  Although <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> may also be used in cases
where update-side locks prevent the value of the pointer from changing,
you should instead use <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_protected()</span></code></a> for this use case.</p>
<p>It is also permissible to use <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> when read-side
access to the pointer was removed at least one grace period ago, as
is the case in the context of the RCU callback that is freeing up
the data, or after a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> returns.  This can be useful
when tearing down multi-linked structures after a grace period
has elapsed.</p>
<dl class="function">
<dt id="c.rcu_dereference_check">
<code class="sig-name descname">rcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do an <a class="reference internal" href="#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>, but check that the conditions under which the
dereference will take place are correct.  Typically the conditions
indicate the various locking conditions that should be held at that
point.  The check should return true if the conditions are satisfied.
An implicit check for being in an RCU read-side critical section
(<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>) is included.</p>
<p>For example:</p>
<blockquote>
<div><p>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;lock</span></code>));</p>
</div></blockquote>
<p>could be used to indicate to lockdep that foo-&gt;bar may only be dereferenced
if either <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> is held, or that the lock required to replace
the bar struct at foo-&gt;bar is held.</p>
<p>Note that the list of conditions may also include indications of when a lock
need not be held, for example during initialisation or destruction of the
target struct:</p>
<blockquote>
<div><dl class="simple">
<dt>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;lock</span></code>) ||</dt><dd><p>atomic_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;usage</span></code>) == 0);</p>
</dd>
</dl>
</div></blockquote>
<p>Inserts memory barriers on architectures that require them
(currently only the Alpha), prevents the compiler from refetching
(and from merging fetches), and, more importantly, documents exactly
which pointers are protected by RCU and checks that the pointer is
annotated as __rcu.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh_check">
<code class="sig-name descname">rcu_dereference_bh_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_bh with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-bh counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched_check">
<code class="sig-name descname">rcu_dereference_sched_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_sched with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-sched counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_protected">
<code class="sig-name descname">rcu_dereference_protected</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_protected" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer when updates prevented</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit
the READ_ONCE().  This is useful in cases where update-side locks
prevent the value of the pointer from changing.  Please note that this
primitive does <em>not</em> prevent the compiler from repeating this reference
or combining it with other references, so it should not be used without
protection of appropriate locks.</p>
<p>This function is only for update-side use.  Using this function
when protected only by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> will result in infrequent
but very ugly failures.</p>
<dl class="function">
<dt id="c.rcu_dereference">
<code class="sig-name descname">rcu_dereference</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wrapper around <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh">
<code class="sig-name descname">rcu_dereference_bh</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch an RCU-bh-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched">
<code class="sig-name descname">rcu_dereference_sched</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-sched-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_pointer_handoff">
<code class="sig-name descname">rcu_pointer_handoff</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_pointer_handoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hand off a pointer from RCU to other mechanism</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to hand off</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is simply an identity function, but it documents where a pointer
is handed off from RCU to some other synchronization mechanism, for
example, reference counting or locking.  In C11, it would map to
kill_dependency().  It could be used as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rcu_read_lock();
p = rcu_dereference(gp);
long_lived = is_long_lived(p);
if (long_lived) {
        if (!atomic_inc_not_zero(p-&gt;refcnt))
                long_lived = false;
        else
                p = rcu_pointer_handoff(p);
}
rcu_read_unlock();
</pre></div>
</div>
<dl class="function">
<dt id="c.rcu_read_lock">
void <code class="sig-name descname">rcu_read_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU read-side critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is invoked on one CPU while other CPUs
are within RCU read-side critical sections, then the
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to block until after all the other
CPUs exit their critical sections.  Similarly, if <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> is invoked
on one CPU while other CPUs are within RCU read-side critical
sections, invocation of the corresponding RCU callback is deferred
until after the all the other CPUs exit their critical sections.</p>
<p>Note, however, that RCU callbacks are permitted to run concurrently
with new RCU read-side critical sections.  One way that this can happen
is via the following sequence of events: (1) CPU 0 enters an RCU
read-side critical section, (2) CPU 1 invokes <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> to register
an RCU callback, (3) CPU 0 exits the RCU read-side critical section,
(4) CPU 2 enters a RCU read-side critical section, (5) the RCU
callback is invoked.  This is legal, because the RCU read-side critical
section that was running concurrently with the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> (and which
therefore might be referencing something that the corresponding RCU
callback would free up) has completed before the corresponding
RCU callback is invoked.</p>
<p>RCU read-side critical sections may be nested.  Any deferred actions
will be deferred until the outermost RCU read-side critical section
completes.</p>
<p>You can avoid reading and understanding the next paragraph by
following this rule: don’t put anything in an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> RCU
read-side critical section that would block in a !PREEMPTION kernel.
But if you want the full story, read on!</p>
<p>In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),
it is illegal to block while in an RCU read-side critical section.
In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION
kernel builds, RCU read-side critical sections may be preempted,
but explicit blocking is illegal.  Finally, in preemptible RCU
implementations in real-time (with -rt patchset) kernel builds, RCU
read-side critical sections may be preempted and they may also block, but
only when acquiring spinlocks that are subject to priority inheritance.</p>
<dl class="function">
<dt id="c.rcu_read_unlock">
void <code class="sig-name descname">rcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>marks the end of an RCU read-side critical section.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In most situations, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> is immune from deadlock.
However, in kernels built with CONFIG_RCU_BOOST, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>
is responsible for deboosting, which it does via rt_mutex_unlock().
Unfortunately, this function acquires the scheduler’s runqueue and
priority-inheritance spinlocks.  This means that deadlock could result
if the caller of <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> already holds one of these locks or
any lock that is ever acquired while holding them.</p>
<p>That said, RCU readers are never priority boosted unless they were
preempted.  Therefore, one way to avoid deadlock is to make sure
that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> is called with one of
rt_mutex_unlock()’s locks held.  Such preemption can be avoided in
a number of ways, for example, by invoking preempt_disable() before
critical section’s outermost <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>Given that the set of locks acquired by rt_mutex_unlock() might change
at any time, a somewhat more future-proofed approach is to make sure
that that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> is called with irqs disabled.
This approach relies on the fact that rt_mutex_unlock() currently only
acquires irq-disabled locks.</p>
<p>The second of these two approaches is best in most situations,
however, the first approach can also be useful, at least to those
developers willing to keep abreast of the set of locks acquired by
rt_mutex_unlock().</p>
<p>See <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> for more information.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh">
void <code class="sig-name descname">rcu_read_lock_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU-bh critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, but also disables softirqs.
Note that anything else that disables softirqs can also serve as
an RCU read-side critical section.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> and the matching rcu_read_unlock_bh()
must occur in the same context, for example, it is illegal to invoke
rcu_read_unlock_bh() from one task if the matching <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a>
was invoked from some other task.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched">
void <code class="sig-name descname">rcu_read_lock_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of a RCU-sched critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, but disables preemption.
Read-side critical sections can also be introduced by anything else
that disables preemption, including local_irq_disable() and friends.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> and the matching rcu_read_unlock_sched()
must occur in the same context, for example, it is illegal to invoke
rcu_read_unlock_sched() from process context if the matching
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> was invoked from an NMI handler.</p>
<dl class="function">
<dt id="c.RCU_INIT_POINTER">
<code class="sig-name descname">RCU_INIT_POINTER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INIT_POINTER" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to be initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to initialized the pointer to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an RCU-protected pointer in special cases where readers
do not need ordering constraints on the CPU or the compiler.  These
special cases are:</p>
<ol class="arabic simple">
<li><p>This use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> is NULLing out the pointer <em>or</em></p></li>
<li><p>The caller has taken whatever steps are required to prevent
RCU readers from concurrently accessing this pointer <em>or</em></p></li>
<li><p>The referenced data structure has already been exposed to
readers either at compile time or via <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> <em>and</em></p>
<ol class="loweralpha simple">
<li><p>You have not made <em>any</em> reader-visible changes to
this structure since then <em>or</em></p></li>
<li><p>It is OK for readers accessing this structure from its
new location to see the old state of the structure.  (For
example, the changes were to statistical counters or to
other state where exact synchronization is not required.)</p></li>
</ol>
</li>
</ol>
<p>Failure to follow these rules governing use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> will
result in impossible-to-diagnose memory corruption.  As in the structures
will look OK in crash dumps, but any concurrent RCU readers might
see pre-initialized values of the referenced data structure.  So
please be very careful how you use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a>!!!</p>
<p>If you are creating an RCU-protected linked structure that is accessed
by a single external-to-structure RCU-protected pointer, then you may
use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> to initialize the internal RCU-protected
pointers, but you must use <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> to initialize the
external-to-structure pointer <em>after</em> you have completely initialized
the reader-accessible portions of the linked structure.</p>
<p>Note that unlike <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a>, <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> provides no
ordering guarantees for either the CPU or the compiler.</p>
<dl class="function">
<dt id="c.RCU_POINTER_INITIALIZER">
<code class="sig-name descname">RCU_POINTER_INITIALIZER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_POINTER_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to be initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to initialized the pointer to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GCC-style initialization for an RCU-protected pointer in a structure field.</p>
<dl class="function">
<dt id="c.kfree_rcu">
<code class="sig-name descname">kfree_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>rhf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>kfree an object after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>pointer to kfree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rhf</span></code></dt><dd><p>the name of the struct rcu_head within the type of <strong>ptr</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many rcu callbacks functions just call <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> on the base structure.
These functions are trivial, but their size adds up, and furthermore
when they are used in a kernel module, that module must invoke the
high-latency <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> function at module-unload time.</p>
<p>The <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> function handles this issue.  Rather than encoding a
function address in the embedded rcu_head structure, <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> instead
encodes the offset of the rcu_head structure within the base structure.
Because the functions are not allowed in the low-order 4096 bytes of
kernel virtual memory, offsets up to 4095 bytes can be accommodated.
If the offset is larger than 4095 bytes, a compile-time error will
be generated in __kfree_rcu().  If this error is triggered, you can
either fall back to use of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> or rearrange the structure to
position the rcu_head structure into the first 4096 bytes.</p>
<p>Note that the allowable offset might decrease in the future, for example,
to allow something like kmem_cache_free_rcu().</p>
<p>The BUILD_BUG_ON check must not involve any function calls, hence the
checks are done in macros here.</p>
<dl class="function">
<dt id="c.rcu_head_init">
void <code class="sig-name descname">rcu_head_init</code><span class="sig-paren">(</span>struct rcu_head *<em> rhp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_head_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize rcu_head for <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt><dd><p>The rcu_head structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you intend to invoke <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a> to test whether a
given rcu_head structure has already been passed to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, then
you must also invoke this <a class="reference internal" href="#c.rcu_head_init" title="rcu_head_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_init()</span></code></a> function on it just after
allocating that structure.  Calls to this function must not race with
calls to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a>, or callback invocation.</p>
<dl class="function">
<dt id="c.rcu_head_after_call_rcu">
bool <code class="sig-name descname">rcu_head_after_call_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em> rhp</em>, rcu_callback_t<em> f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_head_after_call_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Has this rcu_head been passed to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt><dd><p>The rcu_head structure to test.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">f</span></code></dt><dd><p>The function passed to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> along with <strong>rhp</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <strong>true</strong> if the <strong>rhp</strong> has been passed to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> with <strong>func</strong>,
and <strong>false</strong> otherwise.  Emits a warning in any other case, including
the case where <strong>rhp</strong> has already been invoked after a grace period.
Calls to this function must not race with callback invocation.  One way
to avoid such races is to enclose the call to <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a>
in an RCU read-side critical section that includes a read-side fetch
of the pointer to the structure containing <strong>rhp</strong>.</p>
<dl class="function">
<dt id="c.rcu_is_cpu_rrupt_from_idle">
int <code class="sig-name descname">rcu_is_cpu_rrupt_from_idle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_cpu_rrupt_from_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>see if interrupted from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the current CPU is idle and running at a first-level (not nested)
interrupt from idle, return true.  The caller must have at least
disabled preemption.</p>
<dl class="function">
<dt id="c.rcu_idle_enter">
void <code class="sig-name descname">rcu_idle_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter idle mode, in other words, -leave- the mode in which RCU
read-side critical sections can occur.  (Though RCU read-side
critical sections can occur in irq handlers in idle, a possibility
handled by irq_enter() and irq_exit().)</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_user_enter">
void <code class="sig-name descname">rcu_user_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are resuming userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter RCU idle mode right before resuming userspace.  No use of RCU
is permitted between this call and <a class="reference internal" href="#c.rcu_user_exit" title="rcu_user_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_user_exit()</span></code></a>. This way the
CPU doesn’t need to maintain the tick for RCU maintenance purposes
when the CPU runs in userspace.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_user_enter" title="rcu_user_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_user_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_nmi_exit">
void <code class="sig-name descname">rcu_nmi_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of exit from NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_nmi_exit" title="rcu_nmi_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_nmi_exit()</span></code></a>, be sure to test
with CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_irq_exit">
void <code class="sig-name descname">rcu_irq_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is exiting irq towards idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit from an interrupt handler, which might possibly result in entering
idle mode, in other words, leaving the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>This code assumes that the idle loop never does anything that might
result in unbalanced calls to irq_enter() and irq_exit().  If your
architecture’s idle loop violates this assumption, RCU will give you what
you deserve, good and hard.  But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_irq_exit" title="rcu_irq_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_irq_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_idle_exit">
void <code class="sig-name descname">rcu_idle_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is leaving idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit idle mode, in other words, -enter- the mode in which RCU
read-side critical sections can occur.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_user_exit">
void <code class="sig-name descname">rcu_user_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are exiting userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit RCU idle mode while entering the kernel because it can
run a RCU read side critical section anytime.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_user_exit" title="rcu_user_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_user_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_nmi_enter_common">
void <code class="sig-name descname">rcu_nmi_enter_common</code><span class="sig-paren">(</span>bool<em> irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_enter_common" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of entry to NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">irq</span></code></dt><dd><p>Is this call from rcu_irq_enter?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the CPU was idle from RCU’s viewpoint, update rdp-&gt;dynticks and
rdp-&gt;dynticks_nmi_nesting to let the RCU grace-period handling know
that the CPU is active.  This implementation permits nested NMIs, as
long as the nesting level does not overflow an int.  (You will probably
run out of stack space first.)</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_nmi_enter_common" title="rcu_nmi_enter_common"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_nmi_enter_common()</span></code></a>, be sure to test
with CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_nmi_enter">
void <code class="sig-name descname">rcu_nmi_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of entry to NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rcu_irq_enter">
void <code class="sig-name descname">rcu_irq_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering irq away from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an interrupt handler, which might possibly result in exiting
idle mode, in other words, entering the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>Note that the Linux kernel is fully capable of entering an interrupt
handler that it never exits, for example when doing upcalls to user mode!
This code assumes that the idle loop never does upcalls to user mode.
If your architecture’s idle loop does do upcalls to user mode (or does
anything else that results in unbalanced calls to the irq_enter() and
irq_exit() functions), RCU will give you what you deserve, good and hard.
But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_irq_enter" title="rcu_irq_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_irq_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_is_watching">
bool notrace <code class="sig-name descname">rcu_is_watching</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_watching" title="Permalink to this definition">¶</a></dt>
<dd><p>see if RCU thinks that the current CPU is not idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if RCU is watching the running CPU, which means that this
CPU can safely enter RCU read-side critical sections.  In other words,
if the current CPU is not in its idle loop or is in an interrupt or
NMI handler, return true.</p>
<dl class="function">
<dt id="c.call_rcu">
void <code class="sig-name descname">call_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em> head</em>, rcu_callback_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU callback for invocation after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> was invoked.  RCU read-side critical
sections are delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, and
may be nested.  In addition, regions of code across which interrupts,
preemption, or softirqs have been disabled also serve as RCU read-side
critical sections.  This includes hardware interrupt handlers, softirq
handlers, and NMI handlers.</p>
<p>Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when “func()” is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of “func()” must have
executed a memory barrier after the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> and CPU B invoked the
resulting RCU callback function “func()”, then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> and the invocation of “func()” – even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).</p>
<dl class="type">
<dt id="c.kfree_rcu_bulk_data">
struct <code class="sig-name descname">kfree_rcu_bulk_data</code><a class="headerlink" href="#c.kfree_rcu_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>single block to store <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> pointers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kfree_rcu_bulk_data {
  unsigned long nr_records;
  void *records[KFREE_BULK_MAX_ENTR];
  struct kfree_rcu_bulk_data *next;
  struct rcu_head *head_free_debug;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">nr_records</span></code></dt><dd><p>Number of active pointers in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">records</span></code></dt><dd><p>Array of the <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>Next bulk object in the block chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_free_debug</span></code></dt><dd><p>For debug, when CONFIG_DEBUG_OBJECTS_RCU_HEAD is set</p>
</dd>
</dl>
<dl class="type">
<dt id="c.kfree_rcu_cpu_work">
struct <code class="sig-name descname">kfree_rcu_cpu_work</code><a class="headerlink" href="#c.kfree_rcu_cpu_work" title="Permalink to this definition">¶</a></dt>
<dd><p>single batch of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> requests</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kfree_rcu_cpu_work {
  struct rcu_work rcu_work;
  struct rcu_head *head_free;
  struct kfree_rcu_bulk_data *bhead_free;
  struct kfree_rcu_cpu *krcp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_work</span></code></dt><dd><p>Let <a class="reference internal" href="../driver-api/basics.html#c.queue_rcu_work" title="queue_rcu_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_rcu_work()</span></code></a> invoke workqueue handler after grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_free</span></code></dt><dd><p>List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bhead_free</span></code></dt><dd><p>Bulk-List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">krcp</span></code></dt><dd><p>Pointer to <strong>kfree_rcu_cpu</strong> structure</p>
</dd>
</dl>
<dl class="type">
<dt id="c.kfree_rcu_cpu">
struct <code class="sig-name descname">kfree_rcu_cpu</code><a class="headerlink" href="#c.kfree_rcu_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>batch up <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> requests for RCU grace period</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kfree_rcu_cpu {
  struct rcu_head *head;
  struct kfree_rcu_bulk_data *bhead;
  struct kfree_rcu_bulk_data *bcached;
  struct kfree_rcu_cpu_work krw_arr[KFREE_N_BATCHES];
  spinlock_t lock;
  struct delayed_work monitor_work;
  bool monitor_todo;
  bool initialized;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects not yet waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bhead</span></code></dt><dd><p>Bulk-List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects not yet waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcached</span></code></dt><dd><p>Keeps at most one object for later reuse when build chain blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">krw_arr</span></code></dt><dd><p>Array of batches of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Synchronize access to this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">monitor_work</span></code></dt><dd><p>Promote <strong>head</strong> to <strong>head_free</strong> after KFREE_DRAIN_JIFFIES</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">monitor_todo</span></code></dt><dd><p>Tracks whether a <strong>monitor_work</strong> delayed work is pending</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initialized</span></code></dt><dd><p>The <strong>lock</strong> and <strong>rcu_work</strong> fields have been initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a per-CPU structure.  The reason that it is not included in
the rcu_data structure is to permit this code to be extracted from
the RCU files.  Such extraction could allow further optimization of
the interactions with the slab allocators.</p>
<dl class="function">
<dt id="c.synchronize_rcu">
void <code class="sig-name descname">synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until a grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> was waiting.  RCU read-side critical sections are
delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.
In addition, regions of code across which interrupts, preemption, or
softirqs have been disabled also serve as RCU read-side critical
sections.  This includes hardware interrupt handlers, softirq handlers,
and NMI handlers.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last RCU read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to have executed a full memory barrier
after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> – even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.get_state_synchronize_rcu">
unsigned long <code class="sig-name descname">get_state_synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="../driver-api/basics.html#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_rcu">
void <code class="sig-name descname">cond_synchronize_rcu</code><span class="sig-paren">(</span>unsigned long<em> oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt><dd><p>return value from earlier call to <a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call to
<a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.rcu_barrier">
void <code class="sig-name descname">rcu_barrier</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.</p>
<dl class="function">
<dt id="c.synchronize_rcu_expedited">
void <code class="sig-name descname">synchronize_rcu_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU grace period, but expedite it.  The basic idea is to
IPI all non-idle non-nohz online CPUs.  The IPI handler checks whether
the CPU is in an RCU critical section, and if so, it sets a flag that
causes the outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> to report the quiescent state
for RCU-preempt or asks the scheduler for help for RCU-sched.  On the
other hand, if the CPU is not in an RCU read-side critical section,
the IPI handler reports the quiescent state immediately.</p>
<p>Although this is a great improvement over previous expedited
implementations, it is still unfriendly to real-time workloads, so is
thus not recommended for any sort of common-case code.  In fact, if
you are using <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> in a loop, please restructure
your code to batch your updates, and then use a single <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
instead.</p>
<p>This has the same semantics as (but is more brutal than) <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_read_lock_held_common">
bool <code class="sig-name descname">rcu_read_lock_held_common</code><span class="sig-paren">(</span>bool *<em> ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held_common" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-sched read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">ret</span></code></dt><dd><p>Best guess answer if lockdep cannot be relied on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if lockdep must be ignored, in which case <a href="#id3"><span class="problematic" id="id4">*</span></a>ret contains
the best guess described below.  Otherwise returns false, in which
case <a href="#id5"><span class="problematic" id="id6">*</span></a>ret tells the caller nothing and the caller should instead
consult lockdep.</p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, set <a href="#id7"><span class="problematic" id="id8">*</span></a>ret to nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG_DEBUG_LOCK_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.</p>
<p>Check debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that if the CPU is in the idle loop from an RCU point of view (ie:
that we are in the section between <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_enter()</span></code></a> and <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_idle_exit()</span></code></a>)
then <a class="reference internal" href="../driver-api/basics.html#c.rcu_read_lock_held" title="rcu_read_lock_held"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_held()</span></code></a> sets <a href="#id9"><span class="problematic" id="id10">*</span></a>ret to false even if the CPU did an
<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.  The reason for this is that RCU ignores CPUs that are
in such a section, considering these as in extended quiescent state,
so such a CPU is effectively never in an RCU read-side critical section
regardless of what RCU primitives it invokes.  This state of affairs is
required — we need to keep an RCU-free window in idle where the CPU may
possibly enter into low power mode. This way we can notice an extended
quiescent state to other CPUs that started a grace period. Otherwise
we would delay any grace period as long as we run in the idle task.</p>
<p>Similarly, we avoid claiming an RCU read lock held if the current
CPU is offline.</p>
<dl class="function">
<dt id="c.rcu_expedite_gp">
void <code class="sig-name descname">rcu_expedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_expedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Expedite future RCU grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and
friends act as the corresponding <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> function
had instead been called.</p>
<dl class="function">
<dt id="c.rcu_unexpedite_gp">
void <code class="sig-name descname">rcu_unexpedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_unexpedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel prior <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a> invocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo a prior call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a>.  If all prior calls to
<a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a> are undone by a subsequent call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_unexpedite_gp" title="rcu_unexpedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_unexpedite_gp()</span></code></a>,
and if the rcu_expedited sysfs/boot parameter is not set, then all
subsequent calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and friends will return to
their normal non-expedited behavior.</p>
<dl class="function">
<dt id="c.rcu_read_lock_held">
int <code class="sig-name descname">rcu_read_lock_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.</p>
<p>Checks debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> in process context if the matching <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
was invoked from within an irq handler.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh_held">
int <code class="sig-name descname">rcu_read_lock_bh_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-bh read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for bottom half being disabled, which covers both the
CONFIG_PROVE_RCU and not cases.  Note that if someone uses
<a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a>, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.</p>
<p>Check debug_lockdep_rcu_enabled() to prevent false positives during boot.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.wakeme_after_rcu">
void <code class="sig-name descname">wakeme_after_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeme_after_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function to awaken a task after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>Pointer to rcu_head member within rcu_synchronize structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Awaken the corresponding task now that a grace period has elapsed.</p>
<dl class="function">
<dt id="c.init_rcu_head_on_stack">
void <code class="sig-name descname">init_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>pointer to rcu_head structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects of a new rcu_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.destroy_rcu_head_on_stack">
void <code class="sig-name descname">destroy_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>pointer to rcu_head structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects that an on-stack rcu_head structure
is about to go out of scope.  As with <a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this
function is not required for rcu_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
<a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this function has no effect for
!CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.call_rcu_tasks">
void <code class="sig-name descname">call_rcu_tasks</code><span class="sig-paren">(</span>struct rcu_head *<em> rhp</em>, rcu_callback_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation task-based grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks()</span></code></a> assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), cond_resched_rcu_qs(), entry into idle,
or transition to usermode execution.  As such, there are no read-side
primitives analogous to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> because
this primitive is intended to determine that all tasks have passed
through a safe state, not so much for data-strcuture synchronization.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_rcu_tasks">
void <code class="sig-name descname">synchronize_rcu_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-tasks grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to schedule(),
<a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, idle execution, userspace execution, calls
to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a>, and (in theory, anyway) cond_resched().</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a> function
is not (yet) intended for heavy use from multiple CPUs.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-tasks read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a>.  In addition, each CPU
having an RCU-tasks read-side critical section that extends beyond
the return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a> is guaranteed to have executed
a full memory barrier after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a>
and before the beginning of that RCU-tasks read-side critical section.
Note that these guarantees include CPUs that are offline, idle, or
executing in user mode, as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a> – even if CPU A and CPU B are the same CPU
(but again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.rcu_barrier_tasks">
void <code class="sig-name descname">rcu_barrier_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
<dl class="function">
<dt id="c.srcu_read_lock_held">
int <code class="sig-name descname">srcu_read_lock_held</code><span class="sig-paren">(</span>const struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in SRCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>The srcu_struct structure to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an SRCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an SRCU read-side critical section unless it can
prove otherwise.</p>
<p>Checks debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that SRCU is based on its own statemachine and it doesn’t
relies on normal RCU, it can be called from the CPU which
is in the idle loop from an RCU point of view or offline.</p>
<dl class="function">
<dt id="c.srcu_dereference_check">
<code class="sig-name descname">srcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>ssp</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>condition to check for update-side use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PROVE_RCU is enabled, invoking this outside of an RCU read-side
critical section will result in an RCU-lockdep splat, unless <strong>c</strong> evaluates
to 1.  The <strong>c</strong> argument will normally be a logical expression containing
lockdep_is_held() calls.</p>
<dl class="function">
<dt id="c.srcu_dereference">
<code class="sig-name descname">srcu_dereference</code><span class="sig-paren">(</span><em>p</em>, <em>ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.  If PROVE_RCU
is enabled, invoking this outside of an RCU read-side critical
section will result in an RCU-lockdep splat.</p>
<dl class="function">
<dt id="c.srcu_dereference_notrace">
<code class="sig-name descname">srcu_dereference_notrace</code><span class="sig-paren">(</span><em>p</em>, <em>ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>no tracing and no lockdep calls from here</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.srcu_read_lock">
int <code class="sig-name descname">srcu_read_lock</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct in which to register the new reader.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an SRCU read-side critical section.  Note that SRCU read-side
critical sections may be nested.  However, it is illegal to
call anything that waits on an SRCU grace period for the same
srcu_struct, whether directly or indirectly.  Please note that
one way to indirectly wait on an SRCU grace period is to acquire
a mutex that is held elsewhere while calling <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> in an irq handler if the matching <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>
was invoked in process context.</p>
<dl class="function">
<dt id="c.srcu_read_unlock">
void <code class="sig-name descname">srcu_read_unlock</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em>, int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct in which to unregister the old reader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section.</p>
<dl class="function">
<dt id="c.smp_mb__after_srcu_read_unlock">
void <code class="sig-name descname">smp_mb__after_srcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.smp_mb__after_srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure full ordering after srcu_read_unlock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the preceding srcu_read_unlock into a two-way memory barrier.</p>
<p>Call this after srcu_read_unlock, to guarantee that all memory operations
that occur after smp_mb__after_srcu_read_unlock will appear to happen after
the preceding srcu_read_unlock.</p>
<dl class="function">
<dt id="c.init_srcu_struct">
int <code class="sig-name descname">init_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this on a given srcu_struct before passing that srcu_struct
to any other function.  Each srcu_struct represents a separate domain
of SRCU protection.</p>
<dl class="function">
<dt id="c.srcu_readers_active">
bool <code class="sig-name descname">srcu_readers_active</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_readers_active" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if there are readers. and false otherwise</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>which srcu_struct to count active readers (holding srcu_read_lock).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this is not an atomic primitive, and can therefore suffer
severe errors when invoked on an active srcu_struct.  That said, it
can be useful as an error check at cleanup time.</p>
<dl class="function">
<dt id="c.cleanup_srcu_struct">
void <code class="sig-name descname">cleanup_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cleanup_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>deconstruct a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>structure to clean up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this after you are finished using a given srcu_struct that
was initialized via <a class="reference internal" href="#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_srcu_struct()</span></code></a>, else you leak memory.</p>
<dl class="function">
<dt id="c.call_srcu">
void <code class="sig-name descname">call_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em>, struct rcu_head *<em> rhp</em>, rcu_callback_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a callback for invocation after an SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct in queue the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt><dd><p>structure to be used for queueing the SRCU callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>function to be invoked after the SRCU grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full SRCU
grace period elapses, in other words after all pre-existing SRCU
read-side critical sections have completed.  However, the callback
function might well execute concurrently with other SRCU read-side
critical sections that started after <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> was invoked.  SRCU
read-side critical sections are delimited by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>The callback will be invoked from process context, but must nevertheless
be fast and must not block.</p>
<dl class="function">
<dt id="c.synchronize_srcu_expedited">
void <code class="sig-name descname">synchronize_srcu_expedited</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct with which to synchronize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an SRCU grace period to elapse, but be more aggressive about
spinning rather than blocking when waiting.</p>
<p>Note that <a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a> has the same deadlock and
memory-ordering properties as does <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.synchronize_srcu">
void <code class="sig-name descname">synchronize_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for prior SRCU read-side critical-section completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct with which to synchronize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for the count to drain to zero of both indexes. To avoid the
possible starvation of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, it waits for the count of
the index=((-&gt;srcu_idx &amp; 1) ^ 1) to drain to zero at first,
and then flip the srcu_idx and wait for the count of the other index.</p>
<p>Can block; must be called from process context.</p>
<p>Note that it is illegal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> from the corresponding
SRCU read-side critical section; doing so will result in deadlock.
However, it is perfectly legal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> on one
srcu_struct from some other srcu_struct’s read-side critical section,
as long as the resulting graph of srcu_structs is acyclic.</p>
<p>There are memory-ordering constraints implied by <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last corresponding SRCU read-side critical section
whose beginning preceded the call to <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.  In addition,
each CPU having an SRCU read-side critical section that extends beyond
the return from <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> is guaranteed to have executed a
full memory barrier after the beginning of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> and before
the beginning of that SRCU read-side critical section.  Note that these
guarantees include CPUs that are offline, idle, or executing in user mode,
as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.  This guarantee applies even if CPU A and CPU B
are the same CPU, but again only if the system has more than one CPU.</p>
<p>Of course, these memory-ordering guarantees apply only when
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>, and <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> are
passed the same srcu_struct structure.</p>
<p>If SRCU is likely idle, expedite the first request.  This semantic
was provided by Classic SRCU, and is relied upon by its users, so TREE
SRCU must also provide it.  Note that detecting idleness is heuristic
and subject to both false positives and negatives.</p>
<dl class="function">
<dt id="c.srcu_barrier">
void <code class="sig-name descname">srcu_barrier</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct on which to wait for in-flight callbacks.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.srcu_batches_completed">
unsigned long <code class="sig-name descname">srcu_batches_completed</code><span class="sig-paren">(</span>struct srcu_struct *<em> ssp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_batches_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>return batches completed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">ssp</span></code></dt><dd><p>srcu_struct on which to report batch completion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the number of batches, correlated with, but not necessarily
precisely the same as, the number of grace periods that have elapsed.</p>
<dl class="function">
<dt id="c.hlist_bl_del_rcu">
void <code class="sig-name descname">hlist_bl_del_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_bl_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
hlist_bl_for_each_entry().</p>
<dl class="function">
<dt id="c.hlist_bl_add_head_rcu">
void <code class="sig-name descname">hlist_bl_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em> n</em>, struct hlist_bl_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_bl,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_bl_for_each_entry_rcu">
<code class="sig-name descname">hlist_bl_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_bl_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_tail_rcu">
<code class="sig-name descname">list_tail_rcu</code><span class="sig-paren">(</span><em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the prev pointer of the head of the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This should only be used with the list header, and even then
only if <a class="reference internal" href="#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a> and similar primitives are not also used on the
list header.</p>
<dl class="function">
<dt id="c.list_add_rcu">
void <code class="sig-name descname">list_add_rcu</code><span class="sig-paren">(</span>struct list_head *<em> new</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_add_tail_rcu">
void <code class="sig-name descname">list_add_tail_rcu</code><span class="sig-paren">(</span>struct list_head *<em> new</em>, struct list_head *<em> head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>list head to add it before</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_del_rcu">
void <code class="sig-name descname">list_del_rcu</code><span class="sig-paren">(</span>struct list_head *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty()</span></code></a> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<p>Note that the caller is not permitted to immediately free
the newly deleted entry.  Instead, either <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
or <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> must be used to defer freeing until an RCU
grace period has elapsed.</p>
<dl class="function">
<dt id="c.hlist_del_init_rcu">
void <code class="sig-name descname">hlist_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>list_unhashed() on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so list_unhashed() will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_replace_rcu">
void <code class="sig-name descname">list_replace_rcu</code><span class="sig-paren">(</span>struct list_head *<em> old</em>, struct list_head *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<p><strong>Note</strong></p>
<p><strong>old</strong> should not be empty.</p>
<dl class="function">
<dt id="c.__list_splice_init_rcu">
void <code class="sig-name descname">__list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> prev</em>, struct list_head *<em> next</em>, void (<em>*sync</em>)(void)<span class="sig-paren">)</span><a class="headerlink" href="#c.__list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>join an RCU-protected list into an existing list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt><dd><p>points to the last element of the existing list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">next</span></code></dt><dd><p>points to the first element of the existing list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, …</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list pointed to by <strong>prev</strong> and <strong>next</strong> can be RCU-read traversed
concurrently with this function.</p>
<p>Note that this function blocks.</p>
<p>Important note: the caller must take whatever action is necessary to prevent
any other updates to the existing list.  In principle, it is possible to
modify the list as soon as sync() begins execution. If this sort of thing
becomes necessary, an alternative version based on <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> could be
created.  But only if -really- needed – there is no shortage of RCU API
members.</p>
<dl class="function">
<dt id="c.list_splice_init_rcu">
void <code class="sig-name descname">list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em>, void (<em>*sync</em>)(void)<span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for stacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place in the existing list to splice the first list into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, …</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail_init_rcu">
void <code class="sig-name descname">list_splice_tail_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em> list</em>, struct list_head *<em> head</em>, void (<em>*sync</em>)(void)<span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for queues.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt><dd><p>the place in the existing list to splice the first list into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, …</p>
</dd>
</dl>
<dl class="function">
<dt id="c.list_entry_rcu">
<code class="sig-name descname">list_entry_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_first_or_null_rcu">
<code class="sig-name descname">list_first_or_null_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_next_or_null_rcu">
<code class="sig-name descname">list_next_or_null_rcu</code><span class="sig-paren">(</span><em>head</em>, <em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the next element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the ptr is at the end of the list, NULL is returned.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_rcu">
<code class="sig-name descname">list_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em>, <em>cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>optional lockdep expression if called from non-RCU protection.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_entry_lockless">
<code class="sig-name descname">list_entry_lockless</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu
list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, but requires some
implicit RCU read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where lockdep
cannot be invoked.  Another example is when items are added to the list,
but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_lockless">
<code class="sig-name descname">list_for_each_entry_lockless</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_struct within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu
list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, but requires some
implicit RCU read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where lockdep
cannot be invoked.  Another example is when items are added to the list,
but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_rcu">
<code class="sig-name descname">list_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position which must have been in the list when the RCU read
lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_from_rcu" title="list_for_each_entry_from_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_from_rcu()</span></code></a> except
this starts after the given position and that one starts at the given
position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_rcu">
<code class="sig-name descname">list_for_each_entry_from_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the tail of a list starting from a given position,
which must have been in the list when the RCU read lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_continue_rcu" title="list_for_each_entry_continue_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue_rcu()</span></code></a> except
this starts from the given position and that one starts from the position
after the given position.</p>
<dl class="function">
<dt id="c.hlist_del_rcu">
void <code class="sig-name descname">hlist_del_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>list_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry" title="hlist_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_replace_rcu">
void <code class="sig-name descname">hlist_replace_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> old</em>, struct hlist_node *<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<dl class="function">
<dt id="c.hlist_add_head_rcu">
void <code class="sig-name descname">hlist_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_tail_rcu">
void <code class="sig-name descname">hlist_add_tail_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_before_rcu">
void <code class="sig-name descname">hlist_add_before_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_node *<em> next</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the new element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">next</span></code></dt><dd><p>the existing element to add the new element before.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
before the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_add_behind_rcu">
void <code class="sig-name descname">hlist_add_behind_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em> n</em>, struct hlist_node *<em> prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the new element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt><dd><p>the existing element to add the new element after.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
after the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu">
<code class="sig-name descname">hlist_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em>, <em>cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>optional lockdep expression if called from non-RCU protection.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_notrace">
<code class="sig-name descname">hlist_for_each_entry_rcu_notrace</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type (for tracing)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>This is the same as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a> except that it does
not do any RCU debugging or tracing.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_bh">
<code class="sig-name descname">hlist_for_each_entry_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu">
<code class="sig-name descname">hlist_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu_bh">
<code class="sig-name descname">hlist_for_each_entry_continue_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from_rcu">
<code class="sig-name descname">hlist_for_each_entry_from_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_nulls_del_init_rcu">
void <code class="sig-name descname">hlist_nulls_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_nulls_unhashed() on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so list_unhashed() will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_first_rcu">
<code class="sig-name descname">hlist_nulls_first_rcu</code><span class="sig-paren">(</span><em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_first_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the first element of the hash list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_nulls_next_rcu">
<code class="sig-name descname">hlist_nulls_next_rcu</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_next_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the element of the list after <strong>node</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>element of the list.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hlist_nulls_del_rcu">
void <code class="sig-name descname">hlist_nulls_del_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_nulls_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
hlist_nulls_for_each_entry().</p>
<dl class="function">
<dt id="c.hlist_nulls_add_head_rcu">
void <code class="sig-name descname">hlist_nulls_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em> n</em>, struct hlist_nulls_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_add_tail_rcu">
void <code class="sig-name descname">hlist_nulls_add_tail_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em> n</em>, struct hlist_nulls_head *<em> h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_rcu">
<code class="sig-name descname">hlist_nulls_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_nulls_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The barrier() is needed to make sure compiler doesn’t cache first element [1],
as this loop can be restarted [2]
[1] Documentation/core-api/atomic_ops.rst around line 114
[2] Documentation/RCU/rculist_nulls.txt around line 146</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_safe">
<code class="sig-name descname">hlist_nulls_for_each_entry_safe</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_nulls_node within the struct.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_is_idle">
bool <code class="sig-name descname">rcu_sync_is_idle</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_is_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>Are readers permitted to use their fastpaths?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if readers are permitted to use their fastpaths.  Must be
invoked within some flavor of RCU read-side critical section.</p>
<dl class="function">
<dt id="c.rcu_sync_init">
void <code class="sig-name descname">rcu_sync_init</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to be initialized</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_enter_start">
void <code class="sig-name descname">rcu_sync_enter_start</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slow path for multiple updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.rcu_sync_init" title="rcu_sync_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_init()</span></code></a> and before first use.</p>
<p>Ensures <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> returns false and rcu_sync_{enter,exit}()
pairs turn into NO-OPs.</p>
<dl class="function">
<dt id="c.rcu_sync_func">
void <code class="sig-name descname">rcu_sync_func</code><span class="sig-paren">(</span>struct rcu_head *<em> rhp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function managing reader access to fastpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt><dd><p>Pointer to rcu_head in rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is passed to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> function by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> and
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>, so that it is invoked after a grace period following the
that invocation of enter/exit.</p>
<p>If it is called by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> it signals that all the readers were
switched onto slow path.</p>
<p>If it is called by <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> it takes action based on events that
have taken place in the meantime, so that closely spaced <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a>
and <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> pairs need not wait for a grace period.</p>
<p>If another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> is invoked before the grace period
ended, reset state to allow the next <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> to let the
readers back onto their fastpaths (after a grace period).  If both
another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> and its matching <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> are invoked
before the grace period ended, re-invoke <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> on behalf of that
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>.  Otherwise, set all state back to idle so that readers
can again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_enter">
void <code class="sig-name descname">rcu_sync_enter</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slowpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who need readers to make use of
a slowpath during the update.  After this function returns, all
subsequent calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> will return false, which
tells readers to stay off their fastpaths.  A later call to
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> re-enables reader slowpaths.</p>
<p>When called in isolation, <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> must wait for a grace
period, however, closely spaced calls to <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> can
optimize away the grace-period wait via a state machine implemented
by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a>, <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>, and <a class="reference internal" href="#c.rcu_sync_func" title="rcu_sync_func"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_func()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_sync_exit">
void <code class="sig-name descname">rcu_sync_exit</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow readers back onto fast path after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who have completed, and can therefore
now allow readers to make use of their fastpaths after a grace period
has elapsed.  After this grace period has completed, all subsequent
calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> will return true, which tells readers that
they can once again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_dtor">
void <code class="sig-name descname">rcu_sync_dtor</code><span class="sig-paren">(</span>struct rcu_sync *<em> rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_dtor" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to be cleaned up</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="workqueue.html" class="btn btn-neutral float-right" title="Concurrency Managed Workqueue (cmwq)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Core API Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>