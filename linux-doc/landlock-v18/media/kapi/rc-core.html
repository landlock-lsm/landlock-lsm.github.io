

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. Remote Controller devices &mdash; The Linux Kernel 5.7.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4. Media Controller devices" href="mc-core.html" />
    <link rel="prev" title="2.5. Digital TV Network kABI" href="dtv-net.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">3. Remote Controller devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#remote-controller-core">3.1. Remote Controller core</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
        
      <li><span class="section-number">3. </span>Remote Controller devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/media/kapi/rc-core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="remote-controller-devices">
<h1><span class="section-number">3. </span>Remote Controller devices<a class="headerlink" href="#remote-controller-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="remote-controller-core">
<h2><span class="section-number">3.1. </span>Remote Controller core<a class="headerlink" href="#remote-controller-core" title="Permalink to this headline">¶</a></h2>
<p>The remote controller core implements infrastructure to receive and send
remote controller keyboard keystrokes and mouse events.</p>
<p>Every time a key is pressed on a remote controller, a scan code is produced.
Also, on most hardware, keeping a key pressed for more than a few dozens of
milliseconds produce a repeat key event. That’s somewhat similar to what
a normal keyboard or mouse is handled internally on Linux<a class="footnote-reference brackets" href="#f1" id="id1">1</a>. So, the
remote controller core is implemented on the top of the linux input/evdev
interface.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The main difference is that, on keyboard events, the keyboard controller
produces one event for a key press and another one for key release. On
infrared-based remote controllers, there’s no key release event. Instead,
an extra code is produced to indicate key repeats.</p>
</dd>
</dl>
<p>However, most of the remote controllers use infrared (IR) to transmit signals.
As there are several protocols used to modulate infrared signals, one
important part of the core is dedicated to adjust the driver and the core
system to support the infrared protocol used by the emitter.</p>
<p>The infrared transmission is done by blinking a infrared emitter using a
carrier. The carrier can be switched on or off by the IR transmitter
hardware. When the carrier is switched on, it is called <em>PULSE</em>.
When the carrier is switched off, it is called <em>SPACE</em>.</p>
<p>In other words, a typical IR transmission can be viewed as a sequence of
<em>PULSE</em> and <em>SPACE</em> events, each with a given duration.</p>
<p>The carrier parameters (frequency, duty cycle) and the intervals for
<em>PULSE</em> and <em>SPACE</em> events depend on the protocol.
For example, the NEC protocol uses a carrier of 38kHz, and transmissions
start with a 9ms <em>PULSE</em> and a 4.5ms SPACE. It then transmits 16 bits of
scan code, being 8 bits for address (usually it is a fixed number for a
given remote controller), followed by 8 bits of code. A bit “1” is modulated
with 560µs <em>PULSE</em> followed by 1690µs <em>SPACE</em> and a bit “0”  is modulated
with 560µs <em>PULSE</em> followed by 560µs <em>SPACE</em>.</p>
<p>At receiver, a simple low-pass filter can be used to convert the received
signal in a sequence of <em>PULSE/SPACE</em> events, filtering out the carrier
frequency. Due to that, the receiver doesn’t care about the carrier’s
actual frequency parameters: all it has to do is to measure the amount
of time it receives <em>PULSE/SPACE</em> events.
So, a simple IR receiver hardware will just provide a sequence of timings
for those events to the Kernel. The drivers for hardware with such kind of
receivers are identified by  <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code>, as defined by
<a class="reference internal" href="#c.rc_driver_type" title="rc_driver_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_driver_type</span></code></a><a class="footnote-reference brackets" href="#f2" id="id2">2</a>. Other hardware come with a
microcontroller that decode the <em>PULSE/SPACE</em> sequence and return scan
codes to the Kernel. Such kind of receivers are identified
by <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The RC core also supports devices that have just IR emitters,
without any receivers. Right now, all such devices work only in
raw TX mode. Such kind of hardware is identified as
<code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW_TX</span></code>.</p>
</dd>
</dl>
<p>When the RC core receives events produced by <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code> IR
receivers, it needs to decode the IR protocol, in order to obtain the
corresponding scan code. The protocols supported by the RC core are
defined at enum <code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code>.</p>
<p>When the RC code receives a scan code (either directly, by a driver
of the type <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code>, or via its IR decoders), it needs
to convert into a Linux input event code. This is done via a mapping
table.</p>
<p>The Kernel has support for mapping tables available on most media
devices. It also supports loading a table in runtime, via some
sysfs nodes. See the <a class="reference internal" href="../uapi/rc/rc-intro.html#remote-controllers-intro"><span class="std std-ref">RC userspace API</span></a>
for more details.</p>
<div class="section" id="remote-controller-data-structures-and-functions">
<h3><span class="section-number">3.1.1. </span>Remote controller data structures and functions<a class="headerlink" href="#remote-controller-data-structures-and-functions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.rc_driver_type">
enum <code class="sig-name descname">rc_driver_type</code><a class="headerlink" href="#c.rc_driver_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the RC driver.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code></dt><dd><p>Driver or hardware generates a scancode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code></dt><dd><p>Driver or hardware generates pulse/space sequences.
It needs a Infra-Red pulse/space decoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW_TX</span></code></dt><dd><p>Device transmitter only,
driver requires pulse/space data sequence.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_scancode_filter">
struct <code class="sig-name descname">rc_scancode_filter</code><a class="headerlink" href="#c.rc_scancode_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter scan codes.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_scancode_filter {
  u32 data;
  u32 mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Scancode data to match.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Mask of bits of scancode to compare.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_filter_type">
enum <code class="sig-name descname">rc_filter_type</code><a class="headerlink" href="#c.rc_filter_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter type constants.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_NORMAL</span></code></dt><dd><p>Filter for normal operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_WAKEUP</span></code></dt><dd><p>Filter for waking from suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_MAX</span></code></dt><dd><p>Number of filter types.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.lirc_fh">
struct <code class="sig-name descname">lirc_fh</code><a class="headerlink" href="#c.lirc_fh" title="Permalink to this definition">¶</a></dt>
<dd><p>represents an open lirc file</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct lirc_fh {
  struct list_head list;
  struct rc_dev *rc;
  int carrier_low;
  bool send_timeout_reports;
  unsigned int *rawir;
  struct lirc_scancode *scancodes;
  wait_queue_head_t wait_poll;
  u8 send_mode;
  u8 rec_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list of open file handles</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc</span></code></dt><dd><p>rcdev for this lirc chardev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_low</span></code></dt><dd><p>when setting the carrier range, first the low end must be
set with an ioctl and then the high end with another ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_timeout_reports</span></code></dt><dd><p>report timeouts in lirc raw IR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rawir</span></code></dt><dd><p>queue for incoming raw IR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancodes</span></code></dt><dd><p>queue for incoming decoded scancodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_poll</span></code></dt><dd><p>poll struct for lirc device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_mode</span></code></dt><dd><p>lirc mode for sending, either LIRC_MODE_SCANCODE or
LIRC_MODE_PULSE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rec_mode</span></code></dt><dd><p>lirc mode for receiving, either LIRC_MODE_SCANCODE or
LIRC_MODE_MODE2</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_dev">
struct <code class="sig-name descname">rc_dev</code><a class="headerlink" href="#c.rc_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a remote control device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_dev {
  struct device                   dev;
  bool managed_alloc;
  const struct attribute_group    *sysfs_groups[5];
  const char                      *device_name;
  const char                      *input_phys;
  struct input_id                 input_id;
  const char                      *driver_name;
  const char                      *map_name;
  struct rc_map                   rc_map;
  struct mutex                    lock;
  unsigned int                    minor;
  struct ir_raw_event_ctrl        *raw;
  struct input_dev                *input_dev;
  enum rc_driver_type             driver_type;
  bool idle;
  bool encode_wakeup;
  u64 allowed_protocols;
  u64 enabled_protocols;
  u64 allowed_wakeup_protocols;
  enum rc_proto                   wakeup_protocol;
  struct rc_scancode_filter       scancode_filter;
  struct rc_scancode_filter       scancode_wakeup_filter;
  u32 scancode_mask;
  u32 users;
  void *priv;
  spinlock_t keylock;
  bool keypressed;
  unsigned long                   keyup_jiffies;
  struct timer_list               timer_keyup;
  struct timer_list               timer_repeat;
  u32 last_keycode;
  enum rc_proto                   last_protocol;
  u64 last_scancode;
  u8 last_toggle;
  u32 timeout;
  u32 min_timeout;
  u32 max_timeout;
  u32 rx_resolution;
  u32 tx_resolution;
#ifdef CONFIG_LIRC;
  struct device                   lirc_dev;
  struct cdev                     lirc_cdev;
  ktime_t gap_start;
  u64 gap_duration;
  bool gap;
  spinlock_t lirc_fh_lock;
  struct list_head                lirc_fh;
#endif;
  bool registered;
  int (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
  int (*open)(struct rc_dev *dev);
  void (*close)(struct rc_dev *dev);
  int (*s_tx_mask)(struct rc_dev *dev, u32 mask);
  int (*s_tx_carrier)(struct rc_dev *dev, u32 carrier);
  int (*s_tx_duty_cycle)(struct rc_dev *dev, u32 duty_cycle);
  int (*s_rx_carrier_range)(struct rc_dev *dev, u32 min, u32 max);
  int (*tx_ir)(struct rc_dev *dev, unsigned *txbuf, unsigned n);
  void (*s_idle)(struct rc_dev *dev, bool enable);
  int (*s_learning_mode)(struct rc_dev *dev, int enable);
  int (*s_carrier_report) (struct rc_dev *dev, int enable);
  int (*s_filter)(struct rc_dev *dev, struct rc_scancode_filter *filter);
  int (*s_wakeup_filter)(struct rc_dev *dev, struct rc_scancode_filter *filter);
  int (*s_timeout)(struct rc_dev *dev, unsigned int timeout);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model’s view of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">managed_alloc</span></code></dt><dd><p>devm_rc_allocate_device was used to create rc_dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_groups</span></code></dt><dd><p>sysfs attribute groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_name</span></code></dt><dd><p>name of the rc child device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_phys</span></code></dt><dd><p>physical path to the input child device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_id</span></code></dt><dd><p>id of the input child device (struct input_id)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_name</span></code></dt><dd><p>name of the hardware driver which registered this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_name</span></code></dt><dd><p>name of the default keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_map</span></code></dt><dd><p>current scan/key table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>used to ensure we’ve filled in all protocol details before
anyone can call show_protocols or store_protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>unique minor remote control device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">raw</span></code></dt><dd><p>additional data for raw pulse/space devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_dev</span></code></dt><dd><p>the input child device used to communicate events to userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_type</span></code></dt><dd><p>specifies if protocol decoding is done in hardware or software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idle</span></code></dt><dd><p>used to keep track of RX state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encode_wakeup</span></code></dt><dd><p>wakeup filtering uses IR encode API, therefore the allowed
wakeup protocols is the set of all raw encoders</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_protocols</span></code></dt><dd><p>bitmask with the supported RC_PROTO_BIT_* protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled_protocols</span></code></dt><dd><p>bitmask with the enabled RC_PROTO_BIT_* protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_wakeup_protocols</span></code></dt><dd><p>bitmask with the supported RC_PROTO_BIT_* wakeup
protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeup_protocol</span></code></dt><dd><p>the enabled RC_PROTO_* wakeup protocol or
RC_PROTO_UNKNOWN if disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_filter</span></code></dt><dd><p>scancode filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_wakeup_filter</span></code></dt><dd><p>scancode wakeup filters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_mask</span></code></dt><dd><p>some hardware decoders are not capable of providing the full
scancode to the application. As this is a hardware limit, we can’t do
anything with it. Yet, as the same keycode table can be used with other
devices, a mask is provided to allow its usage. Drivers should generally
leave this field in blank</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>number of current users of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>driver-specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keylock</span></code></dt><dd><p>protects the remaining members of the struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keypressed</span></code></dt><dd><p>whether a key is currently pressed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keyup_jiffies</span></code></dt><dd><p>time (in jiffies) when the current keypress should be released</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_keyup</span></code></dt><dd><p>timer for releasing a keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_repeat</span></code></dt><dd><p>timer for autorepeat events. This is needed for CEC, which
has non-standard repeats.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_keycode</span></code></dt><dd><p>keycode of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_protocol</span></code></dt><dd><p>protocol of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_scancode</span></code></dt><dd><p>scancode of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_toggle</span></code></dt><dd><p>toggle value of last command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>optional time after which device stops sending data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_timeout</span></code></dt><dd><p>minimum timeout supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_timeout</span></code></dt><dd><p>maximum timeout supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_resolution</span></code></dt><dd><p>resolution (in ns) of input sampler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_resolution</span></code></dt><dd><p>resolution (in ns) of output sampler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_dev</span></code></dt><dd><p>lirc device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_cdev</span></code></dt><dd><p>lirc char cdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gap_start</span></code></dt><dd><p>time when gap starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gap_duration</span></code></dt><dd><p>duration of initial gap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gap</span></code></dt><dd><p>true if we’re in a gap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_fh_lock</span></code></dt><dd><p>protects lirc_fh list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_fh</span></code></dt><dd><p>list of open files</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">registered</span></code></dt><dd><p>set to true by <a class="reference internal" href="#c.rc_register_device" title="rc_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">rc_register_device()</span></code></a>, false by
rc_unregister_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_protocol</span></code></dt><dd><p>allow changing the protocol used on hardware decoders</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>callback to allow drivers to enable polling/irq when IR input device
is opened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p>callback to allow drivers to disable polling/irq when IR input device
is opened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_mask</span></code></dt><dd><p>set transmitter mask (for devices with multiple tx outputs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_carrier</span></code></dt><dd><p>set transmit carrier frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_duty_cycle</span></code></dt><dd><p>set transmit duty cycle (0% - 100%)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_rx_carrier_range</span></code></dt><dd><p>inform driver about carrier it is expected to handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_ir</span></code></dt><dd><p>transmit IR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_idle</span></code></dt><dd><p>enable/disable hardware idle mode, upon which,
device doesn’t interrupt host until it sees IR pulses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_learning_mode</span></code></dt><dd><p>enable wide band receiver used for learning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_carrier_report</span></code></dt><dd><p>enable carrier reports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_filter</span></code></dt><dd><p>set the scancode filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_wakeup_filter</span></code></dt><dd><p>set the wakeup scancode filter. If the mask is zero
then wakeup should be disabled. wakeup_protocol will be set to
a valid protocol if mask is nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_timeout</span></code></dt><dd><p>set hardware timeout in ns</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_allocate_device">
struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> * <code class="sig-name descname">rc_allocate_device</code><span class="sig-paren">(</span>enum<em> rc_driver_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates a RC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rc_driver_type</span></code></dt><dd><p>specifies the type of the RC output to be allocated
returns a pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_rc_allocate_device">
struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> * <code class="sig-name descname">devm_rc_allocate_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, enum<em> rc_driver_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_rc_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed RC device allocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rc_driver_type</span></code></dt><dd><p>specifies the type of the RC output to be allocated
returns a pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_free_device">
void <code class="sig-name descname">rc_free_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_free_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a RC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_register_device">
int <code class="sig-name descname">rc_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a RC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.devm_rc_register_device">
int <code class="sig-name descname">devm_rc_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em> parent</em>, struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_rc_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Manageded registering of a RC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>pointer to struct device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_unregister_device">
void <code class="sig-name descname">rc_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a RC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>pointer to struct rc_dev.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_map_table">
struct <code class="sig-name descname">rc_map_table</code><a class="headerlink" href="#c.rc_map_table" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a scancode/keycode pair</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map_table {
  u64 scancode;
  u32 keycode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scancode</span></code></dt><dd><p>scan code (u64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycode</span></code></dt><dd><p>Linux input keycode</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_map">
struct <code class="sig-name descname">rc_map</code><a class="headerlink" href="#c.rc_map" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a keycode map table</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map {
  struct rc_map_table     *scan;
  unsigned int            size;
  unsigned int            len;
  unsigned int            alloc;
  enum rc_proto           rc_proto;
  const char              *name;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scan</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.rc_map_table" title="rc_map_table"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map_table</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Max number of entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Number of entries that are in use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc</span></code></dt><dd><p>size of *scan, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_proto</span></code></dt><dd><p>type of the remote controller protocol, as defined at
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the key map table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock to protect access to this structure</p>
</dd>
</dl>
<dl class="type">
<dt id="c.rc_map_list">
struct <code class="sig-name descname">rc_map_list</code><a class="headerlink" href="#c.rc_map_list" title="Permalink to this definition">¶</a></dt>
<dd><p>list of the registered <a class="reference internal" href="#c.rc_map" title="rc_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map</span></code></a> maps</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map_list {
  struct list_head         list;
  struct rc_map map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.rc_map" title="rc_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map</span></code></a></p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_map_register">
int <code class="sig-name descname">rc_map_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_map_list" title="rc_map_list">rc_map_list</a> *<em> map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a Remote Controller scancode map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>pointer to struct rc_map_list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_map_unregister">
void <code class="sig-name descname">rc_map_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_map_list" title="rc_map_list">rc_map_list</a> *<em> map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a Remote Controller scancode map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span> <span class="pre">*</span> <span class="pre">map</span></code></dt><dd><p>pointer to struct rc_map_list</p>
</dd>
</dl>
<dl class="function">
<dt id="c.rc_map_get">
struct <a class="reference internal" href="#c.rc_map" title="rc_map">rc_map</a> * <code class="sig-name descname">rc_map_get</code><span class="sig-paren">(</span>const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_get" title="Permalink to this definition">¶</a></dt>
<dd><p>gets an RC map from its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of the RC scancode map</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mc-core.html" class="btn btn-neutral float-right" title="4. Media Controller devices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-net.html" class="btn btn-neutral float-left" title="2.5. Digital TV Network kABI" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>