

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing s390 channel device drivers &mdash; The Linux Kernel 5.6.0-rc3+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="VME Device Drivers" href="vme.html" />
    <link rel="prev" title="RapidIO subsystem Channelized Messaging character device driver (rio_cm.c)" href="rapidio/rio_cm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing s390 channel device drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-css-bus">The css bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-ccw-bus">The ccw bus</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-o-functions-for-channel-attached-devices">I/O functions for channel-attached devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccw-devices">ccw devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-channel-measurement-facility">The channel-measurement facility</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-ccwgroup-bus">The ccwgroup bus</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ccw-group-devices">ccw group devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#generic-interfaces">Generic interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adapter-interrupts">Adapter interrupts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Writing s390 channel device drivers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/s390-drivers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-s390-channel-device-drivers">
<h1>Writing s390 channel device drivers<a class="headerlink" href="#writing-s390-channel-device-drivers" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Cornelia Huck</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the interfaces available for device drivers that
drive s390 based channel attached I/O devices. This includes interfaces
for interaction with the hardware and interfaces for interacting with
the common driver core. Those interfaces are provided by the s390 common
I/O layer.</p>
<p>The document assumes a familarity with the technical terms associated
with the s390 channel I/O architecture. For a description of this
architecture, please refer to the “z/Architecture: Principles of
Operation”, IBM publication no. SA22-7832.</p>
<p>While most I/O devices on a s390 system are typically driven through the
channel I/O mechanism described here, there are various other methods
(like the diag interface). These are out of the scope of this document.</p>
<p>The s390 common I/O layer also provides access to some devices that are
not strictly considered I/O devices. They are considered here as well,
although they are not the focus of this document.</p>
<p>Some additional information can also be found in the kernel source under
Documentation/s390/driver-model.rst.</p>
</div>
<div class="section" id="the-css-bus">
<h2>The css bus<a class="headerlink" href="#the-css-bus" title="Permalink to this headline">¶</a></h2>
<p>The css bus contains the subchannels available on the system. They fall
into several categories:</p>
<ul class="simple">
<li>Standard I/O subchannels, for use by the system. They have a child
device on the ccw bus and are described below.</li>
<li>I/O subchannels bound to the vfio-ccw driver. See
Documentation/s390/vfio-ccw.rst.</li>
<li>Message subchannels. No Linux driver currently exists.</li>
<li>CHSC subchannels (at most one). The chsc subchannel driver can be used
to send asynchronous chsc commands.</li>
<li>eADM subchannels. Used for talking to storage class memory.</li>
</ul>
</div>
<div class="section" id="the-ccw-bus">
<h2>The ccw bus<a class="headerlink" href="#the-ccw-bus" title="Permalink to this headline">¶</a></h2>
<p>The ccw bus typically contains the majority of devices available to a
s390 system. Named after the channel command word (ccw), the basic
command structure used to address its devices, the ccw bus contains
so-called channel attached devices. They are addressed via I/O
subchannels, visible on the css bus. A device driver for
channel-attached devices, however, will never interact with the
subchannel directly, but only via the I/O device on the ccw bus, the ccw
device.</p>
<div class="section" id="i-o-functions-for-channel-attached-devices">
<h3>I/O functions for channel-attached devices<a class="headerlink" href="#i-o-functions-for-channel-attached-devices" title="Permalink to this headline">¶</a></h3>
<p>Some hardware structures have been translated into C structures for use
by the common I/O layer and device drivers. For more information on the
hardware structures represented here, please consult the Principles of
Operation.</p>
<dl class="type">
<dt id="c.ccw1">
struct <code class="descname">ccw1</code><a class="headerlink" href="#c.ccw1" title="Permalink to this definition">¶</a></dt>
<dd><p>channel command word</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw1 {
  __u8 cmd_code;
  __u8 flags;
  __u16 count;
  __u32 cda;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cmd_code</span></code></dt>
<dd>command code</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>flags, like IDA addressing, etc.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt>
<dd>byte count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cda</span></code></dt>
<dd>data address</dd>
</dl>
<p><strong>Description</strong></p>
<p>The ccw is the basic structure to build channel programs that perform
operations with the device or the control unit. Only Format-1 channel
command words are supported.</p>
<dl class="type">
<dt id="c.ccw0">
struct <code class="descname">ccw0</code><a class="headerlink" href="#c.ccw0" title="Permalink to this definition">¶</a></dt>
<dd><p>channel command word</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw0 {
  __u8 cmd_code;
  __u32 cda : 24;
  __u8 flags;
  __u8 reserved;
  __u16 count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cmd_code</span></code></dt>
<dd>command code</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cda</span></code></dt>
<dd>data address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>flags, like IDA addressing, etc.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt>
<dd>will be ignored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt>
<dd>byte count</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format-0 ccw structure.</p>
<dl class="type">
<dt id="c.erw">
struct <code class="descname">erw</code><a class="headerlink" href="#c.erw" title="Permalink to this definition">¶</a></dt>
<dd><p>extended report word</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct erw {
  __u32 res0  : 3;
  __u32 auth  : 1;
  __u32 pvrf  : 1;
  __u32 cpt   : 1;
  __u32 fsavf : 1;
  __u32 cons  : 1;
  __u32 scavf : 1;
  __u32 fsaf  : 1;
  __u32 scnt  : 6;
  __u32 res16 : 16;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">res0</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth</span></code></dt>
<dd>authorization check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pvrf</span></code></dt>
<dd>path-verification-required flag</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpt</span></code></dt>
<dd>channel-path timeout</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fsavf</span></code></dt>
<dd>failing storage address validity flag</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cons</span></code></dt>
<dd>concurrent sense</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scavf</span></code></dt>
<dd>secondary ccw address validity flag</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fsaf</span></code></dt>
<dd>failing storage address format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scnt</span></code></dt>
<dd>sense count, if <strong>cons</strong> == <code class="docutils literal notranslate"><span class="pre">1</span></code></dd>
<dt><code class="docutils literal notranslate"><span class="pre">res16</span></code></dt>
<dd>reserved</dd>
</dl>
<dl class="type">
<dt id="c.erw_eadm">
struct <code class="descname">erw_eadm</code><a class="headerlink" href="#c.erw_eadm" title="Permalink to this definition">¶</a></dt>
<dd><p>EADM Subchannel extended report word</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct erw_eadm {
  __u32 : 16;
  __u32 b : 1;
  __u32 r : 1;
  __u32 : 14;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt>
<dd>aob error</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code></dt>
<dd>arsb error</dd>
</dl>
<dl class="type">
<dt id="c.sublog">
struct <code class="descname">sublog</code><a class="headerlink" href="#c.sublog" title="Permalink to this definition">¶</a></dt>
<dd><p>subchannel logout area</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sublog {
  __u32 res0  : 1;
  __u32 esf   : 7;
  __u32 lpum  : 8;
  __u32 arep  : 1;
  __u32 fvf   : 5;
  __u32 sacc  : 2;
  __u32 termc : 2;
  __u32 devsc : 1;
  __u32 serr  : 1;
  __u32 ioerr : 1;
  __u32 seqc  : 3;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">res0</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">esf</span></code></dt>
<dd>extended status flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpum</span></code></dt>
<dd>last path used mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arep</span></code></dt>
<dd>ancillary report</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fvf</span></code></dt>
<dd>field-validity flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sacc</span></code></dt>
<dd>storage access code</dd>
<dt><code class="docutils literal notranslate"><span class="pre">termc</span></code></dt>
<dd>termination code</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devsc</span></code></dt>
<dd>device-status check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">serr</span></code></dt>
<dd>secondary error</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioerr</span></code></dt>
<dd>i/o-error alert</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqc</span></code></dt>
<dd>sequence code</dd>
</dl>
<dl class="type">
<dt id="c.esw0">
struct <code class="descname">esw0</code><a class="headerlink" href="#c.esw0" title="Permalink to this definition">¶</a></dt>
<dd><p>Format 0 Extended Status Word (ESW)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct esw0 {
  struct sublog sublog;
  struct erw erw;
  __u32 faddr[2];
  __u32 saddr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sublog</span></code></dt>
<dd>subchannel logout</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erw</span></code></dt>
<dd>extended report word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">faddr</span></code></dt>
<dd>failing storage address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">saddr</span></code></dt>
<dd>secondary ccw address</dd>
</dl>
<dl class="type">
<dt id="c.esw1">
struct <code class="descname">esw1</code><a class="headerlink" href="#c.esw1" title="Permalink to this definition">¶</a></dt>
<dd><p>Format 1 Extended Status Word (ESW)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct esw1 {
  __u8 zero0;
  __u8 lpum;
  __u16 zero16;
  struct erw erw;
  __u32 zeros[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">zero0</span></code></dt>
<dd>reserved zeros</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpum</span></code></dt>
<dd>last path used mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zero16</span></code></dt>
<dd>reserved zeros</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erw</span></code></dt>
<dd>extended report word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeros</span></code></dt>
<dd>three fullwords of zeros</dd>
</dl>
<dl class="type">
<dt id="c.esw2">
struct <code class="descname">esw2</code><a class="headerlink" href="#c.esw2" title="Permalink to this definition">¶</a></dt>
<dd><p>Format 2 Extended Status Word (ESW)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct esw2 {
  __u8 zero0;
  __u8 lpum;
  __u16 dcti;
  struct erw erw;
  __u32 zeros[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">zero0</span></code></dt>
<dd>reserved zeros</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpum</span></code></dt>
<dd>last path used mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dcti</span></code></dt>
<dd>device-connect-time interval</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erw</span></code></dt>
<dd>extended report word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeros</span></code></dt>
<dd>three fullwords of zeros</dd>
</dl>
<dl class="type">
<dt id="c.esw3">
struct <code class="descname">esw3</code><a class="headerlink" href="#c.esw3" title="Permalink to this definition">¶</a></dt>
<dd><p>Format 3 Extended Status Word (ESW)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct esw3 {
  __u8 zero0;
  __u8 lpum;
  __u16 res;
  struct erw erw;
  __u32 zeros[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">zero0</span></code></dt>
<dd>reserved zeros</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpum</span></code></dt>
<dd>last path used mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">res</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erw</span></code></dt>
<dd>extended report word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeros</span></code></dt>
<dd>three fullwords of zeros</dd>
</dl>
<dl class="type">
<dt id="c.esw_eadm">
struct <code class="descname">esw_eadm</code><a class="headerlink" href="#c.esw_eadm" title="Permalink to this definition">¶</a></dt>
<dd><p>EADM Subchannel Extended Status Word (ESW)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct esw_eadm {
  __u32 sublog;
  struct erw_eadm erw;
  __u32 : 32;
  __u32 : 32;
  __u32 : 32;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sublog</span></code></dt>
<dd>subchannel logout</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erw</span></code></dt>
<dd>extended report word</dd>
</dl>
<dl class="type">
<dt id="c.irb">
struct <code class="descname">irb</code><a class="headerlink" href="#c.irb" title="Permalink to this definition">¶</a></dt>
<dd><p>interruption response block</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irb {
  union scsw scsw;
  union {
    struct esw0 esw0;
    struct esw1 esw1;
    struct esw2 esw2;
    struct esw3 esw3;
    struct esw_eadm eadm;
  } esw;
  __u8 ecw[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">scsw</span></code></dt>
<dd>subchannel status word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">esw</span></code></dt>
<dd>extended status word</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecw</span></code></dt>
<dd>extended control word</dd>
</dl>
<p><strong>Description</strong></p>
<p>The irb that is handed to the device driver when an interrupt occurs. For
solicited interrupts, the common I/O layer already performs checks whether
a field is valid; a field not being valid is always passed as <code class="docutils literal notranslate"><span class="pre">0</span></code>.
If a unit check occurred, <strong>ecw</strong> may contain sense data; this is retrieved
by the common I/O layer itself if the device doesn’t support concurrent
sense (so that the device driver never needs to perform basic sense itself).
For unsolicited interrupts, the irb is passed as-is (expect for sense data,
if applicable).</p>
<dl class="type">
<dt id="c.ciw">
struct <code class="descname">ciw</code><a class="headerlink" href="#c.ciw" title="Permalink to this definition">¶</a></dt>
<dd><p>command information word (CIW) layout</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ciw {
  __u32 et       :  2;
  __u32 reserved :  2;
  __u32 ct       :  4;
  __u32 cmd      :  8;
  __u32 count    : 16;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">et</span></code></dt>
<dd>entry type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt>
<dd>reserved bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ct</span></code></dt>
<dd>command type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt>
<dd>command code</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt>
<dd>command count</dd>
</dl>
<dl class="type">
<dt id="c.ccw_dev_id">
struct <code class="descname">ccw_dev_id</code><a class="headerlink" href="#c.ccw_dev_id" title="Permalink to this definition">¶</a></dt>
<dd><p>unique identifier for ccw devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw_dev_id {
  u8 ssid;
  u16 devno;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt>
<dd>subchannel set id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devno</span></code></dt>
<dd>device number</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is not directly based on any hardware structure. The
hardware identifies a device by its device number and its subchannel,
which is in turn identified by its id. In order to get a unique identifier
for ccw devices across subchannel sets, <strong>struct</strong> ccw_dev_id has been
introduced.</p>
<dl class="function">
<dt id="c.ccw_dev_id_is_equal">
int <code class="descname">ccw_dev_id_is_equal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_dev_id" title="ccw_dev_id">ccw_dev_id</a> *<em>&nbsp;dev_id1</em>, struct <a class="reference internal" href="#c.ccw_dev_id" title="ccw_dev_id">ccw_dev_id</a> *<em>&nbsp;dev_id2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_dev_id_is_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>compare two ccw_dev_ids</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_dev_id</span> <span class="pre">*</span> <span class="pre">dev_id1</span></code></dt>
<dd>a ccw_dev_id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_dev_id</span> <span class="pre">*</span> <span class="pre">dev_id2</span></code></dt>
<dd>another ccw_dev_id</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">1</span></code> if the two structures are equal field-by-field,
<code class="docutils literal notranslate"><span class="pre">0</span></code> if not.</div></blockquote>
<p><strong>Context</strong></p>
<p>any</p>
<dl class="function">
<dt id="c.pathmask_to_pos">
u8 <code class="descname">pathmask_to_pos</code><span class="sig-paren">(</span>u8<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pathmask_to_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find the position of the left-most bit in a pathmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mask</span></code></dt>
<dd>pathmask with at least one bit set</dd>
</dl>
</div>
<div class="section" id="ccw-devices">
<h3>ccw devices<a class="headerlink" href="#ccw-devices" title="Permalink to this headline">¶</a></h3>
<p>Devices that want to initiate channel I/O need to attach to the ccw bus.
Interaction with the driver core is done via the common I/O layer, which
provides the abstractions of ccw devices and ccw device drivers.</p>
<p>The functions that initiate or terminate channel I/O all act upon a ccw
device structure. Device drivers must not bypass those functions or
strange side effects may happen.</p>
<dl class="type">
<dt id="c.ccw_device">
struct <code class="descname">ccw_device</code><a class="headerlink" href="#c.ccw_device" title="Permalink to this definition">¶</a></dt>
<dd><p>channel attached device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw_device {
  spinlock_t *ccwlock;
  struct ccw_device_id id;
  struct ccw_driver *drv;
  struct device dev;
  int online;
  void (*handler) (struct ccw_device *, unsigned long, struct irb *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ccwlock</span></code></dt>
<dd>pointer to device lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>id of this device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv</span></code></dt>
<dd>ccw driver for this device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>embedded device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">online</span></code></dt>
<dd>online status of device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt>
<dd>interrupt handler</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>handler</strong> is a member of the device rather than the driver since a driver
can have different interrupt handlers for different ccw devices
(multi-subchannel drivers).</p>
<dl class="type">
<dt id="c.ccw_driver">
struct <code class="descname">ccw_driver</code><a class="headerlink" href="#c.ccw_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>device driver for channel attached devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw_driver {
  struct ccw_device_id *ids;
  int (*probe) (struct ccw_device *);
  void (*remove) (struct ccw_device *);
  int (*set_online) (struct ccw_device *);
  int (*set_offline) (struct ccw_device *);
  int (*notify) (struct ccw_device *, int);
  void (*path_event) (struct ccw_device *, int *);
  void (*shutdown) (struct ccw_device *);
  int (*prepare) (struct ccw_device *);
  void (*complete) (struct ccw_device *);
  int (*freeze)(struct ccw_device *);
  int (*thaw) (struct ccw_device *);
  int (*restore)(struct ccw_device *);
  enum uc_todo (*uc_handler) (struct ccw_device *, struct irb *);
  struct device_driver driver;
  enum interruption_class int_class;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ids</span></code></dt>
<dd>ids supported by this driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt>
<dd>function called on probe</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt>
<dd>function called on remove</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_online</span></code></dt>
<dd>called when setting device online</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_offline</span></code></dt>
<dd>called when setting device offline</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notify</span></code></dt>
<dd>notify driver of device state changes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_event</span></code></dt>
<dd>notify driver of channel path events</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt>
<dd>called at device shutdown</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt>
<dd>prepare for pm state transition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt>
<dd>undo work done in <strong>prepare</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">freeze</span></code></dt>
<dd>callback for freezing during hibernation snapshotting</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thaw</span></code></dt>
<dd>undo work done in <strong>freeze</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">restore</span></code></dt>
<dd>callback for restoring after hibernation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc_handler</span></code></dt>
<dd>callback for unit check handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt>
<dd>embedded device driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int_class</span></code></dt>
<dd>interruption class to use for accounting interrupts</dd>
</dl>
<dl class="function">
<dt id="c.ccw_device_set_offline">
int <code class="descname">ccw_device_set_offline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_set_offline" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a ccw device for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls the driver’s set_offline() function for <strong>cdev</strong>, if
given, and then disables <strong>cdev</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and a negative error value on failure.</div></blockquote>
<p><strong>Context</strong></p>
<p>enabled, ccw device lock not held</p>
<dl class="function">
<dt id="c.ccw_device_set_online">
int <code class="descname">ccw_device_set_online</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_set_online" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a ccw device for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function first enables <strong>cdev</strong> and then calls the driver’s set_online()
function for <strong>cdev</strong>, if given. If set_online() returns an error, <strong>cdev</strong> is
disabled again.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and a negative error value on failure.</div></blockquote>
<p><strong>Context</strong></p>
<p>enabled, ccw device lock not held</p>
<dl class="function">
<dt id="c.get_ccwdev_by_dev_id">
struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> * <code class="descname">get_ccwdev_by_dev_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_dev_id" title="ccw_dev_id">ccw_dev_id</a> *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_ccwdev_by_dev_id" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain device from a ccw device id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_dev_id</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>id of the device to be searched</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function searches all devices attached to the ccw bus for a device
matching <strong>dev_id</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>If a device is found its reference count is increased and returned;
else <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</div></blockquote>
<dl class="function">
<dt id="c.get_ccwdev_by_busid">
struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> * <code class="descname">get_ccwdev_by_busid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_driver" title="ccw_driver">ccw_driver</a> *<em>&nbsp;cdrv</em>, const char *<em>&nbsp;bus_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_ccwdev_by_busid" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain device from a bus id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_driver</span> <span class="pre">*</span> <span class="pre">cdrv</span></code></dt>
<dd>driver the device is owned by</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>bus id of the device to be searched</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function searches all devices owned by <strong>cdrv</strong> for a device with a bus
id matching <strong>bus_id</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>If a match is found, its reference count of the found device is increased
and it is returned; else <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</div></blockquote>
<dl class="function">
<dt id="c.ccw_driver_register">
int <code class="descname">ccw_driver_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_driver" title="ccw_driver">ccw_driver</a> *<em>&nbsp;cdriver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a ccw driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_driver</span> <span class="pre">*</span> <span class="pre">cdriver</span></code></dt>
<dd>driver to be registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is mainly a wrapper around <a class="reference internal" href="infrastructure.html#c.driver_register" title="driver_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and a negative error value on failure.</div></blockquote>
<dl class="function">
<dt id="c.ccw_driver_unregister">
void <code class="descname">ccw_driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_driver" title="ccw_driver">ccw_driver</a> *<em>&nbsp;cdriver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a ccw driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_driver</span> <span class="pre">*</span> <span class="pre">cdriver</span></code></dt>
<dd>driver to be deregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is mainly a wrapper around <a class="reference internal" href="infrastructure.html#c.driver_unregister" title="driver_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_unregister()</span></code></a>.</p>
<dl class="function">
<dt id="c.ccw_device_siosl">
int <code class="descname">ccw_device_siosl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_siosl" title="Permalink to this definition">¶</a></dt>
<dd><p>initiate logging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to invoke model-dependent logging within the channel
subsystem.</p>
<dl class="function">
<dt id="c.ccw_device_set_options_mask">
int <code class="descname">ccw_device_set_options_mask</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_set_options_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>set some options and unset the rest</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device for which the options are to be set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>options to be set</dd>
</dl>
<p><strong>Description</strong></p>
<p>All flags specified in <strong>flags</strong> are set, all flags not specified in <strong>flags</strong>
are cleared.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> on an invalid flag combination.</div></blockquote>
<dl class="function">
<dt id="c.ccw_device_set_options">
int <code class="descname">ccw_device_set_options</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_set_options" title="Permalink to this definition">¶</a></dt>
<dd><p>set some options</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device for which the options are to be set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>options to be set</dd>
</dl>
<p><strong>Description</strong></p>
<p>All flags specified in <strong>flags</strong> are set, the remainder is left untouched.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> if an invalid flag combination would ensue.</div></blockquote>
<dl class="function">
<dt id="c.ccw_device_clear_options">
void <code class="descname">ccw_device_clear_options</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_clear_options" title="Permalink to this definition">¶</a></dt>
<dd><p>clear some options</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device for which the options are to be cleared</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>options to be cleared</dd>
</dl>
<p><strong>Description</strong></p>
<p>All flags specified in <strong>flags</strong> are cleared, the remainder is left untouched.</p>
<dl class="function">
<dt id="c.ccw_device_is_pathgroup">
int <code class="descname">ccw_device_is_pathgroup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_is_pathgroup" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if paths to this device are grouped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return non-zero if there is a path group, zero otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_is_multipath">
int <code class="descname">ccw_device_is_multipath</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_is_multipath" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if device is operating in multipath mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return non-zero if device is operating in multipath mode, zero otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_clear">
int <code class="descname">ccw_device_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, unsigned long<em>&nbsp;intparm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>terminate I/O request processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>interruption parameter to be returned upon conclusion of csch</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a> calls csch on <strong>cdev</strong>’s subchannel.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success,
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> on device not operational,
-<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> on invalid device state.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_start_timeout_key">
int <code class="descname">ccw_device_start_timeout_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.ccw1" title="ccw1">ccw1</a> *<em>&nbsp;cpa</em>, unsigned long<em>&nbsp;intparm</em>, __u8<em>&nbsp;lpm</em>, __u8<em>&nbsp;key</em>, unsigned long<em>&nbsp;flags</em>, int<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_start_timeout_key" title="Permalink to this definition">¶</a></dt>
<dd><p>start a s390 channel program with timeout and key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw1</span> <span class="pre">*</span> <span class="pre">cpa</span></code></dt>
<dd>logical start address of channel program</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user specific interruption parameter; will be presented back to
<strong>cdev</strong>’s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">lpm</span></code></dt>
<dd>defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">key</span></code></dt>
<dd>storage key to be used for the I/O</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>additional flags; defines the action to be performed for I/O
processing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">expires</span></code></dt>
<dd>timeout value in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
This function notifies the device driver if the channel program has not
completed during the time specified by <strong>expires</strong>. If a timeout occurs, the
channel program is terminated via xsch, hsch or csch, and the device’s
interrupt handler will be called with an irb containing ERR_PTR(-<code class="docutils literal notranslate"><span class="pre">ETIMEDOUT</span></code>).
The interruption handler will echo back the <strong>intparm</strong> specified here, unless
another interruption parameter is specified by a subsequent invocation of
<a class="reference internal" href="#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> or <a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code>, if the operation was successful;
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>, if the device is busy, or status pending;
-<code class="docutils literal notranslate"><span class="pre">EACCES</span></code>, if no path specified in <strong>lpm</strong> is operational;
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>, if the device is not operational.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_start_key">
int <code class="descname">ccw_device_start_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.ccw1" title="ccw1">ccw1</a> *<em>&nbsp;cpa</em>, unsigned long<em>&nbsp;intparm</em>, __u8<em>&nbsp;lpm</em>, __u8<em>&nbsp;key</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_start_key" title="Permalink to this definition">¶</a></dt>
<dd><p>start a s390 channel program with key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw1</span> <span class="pre">*</span> <span class="pre">cpa</span></code></dt>
<dd>logical start address of channel program</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user specific interruption parameter; will be presented back to
<strong>cdev</strong>’s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">lpm</span></code></dt>
<dd>defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">key</span></code></dt>
<dd>storage key to be used for the I/O</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>additional flags; defines the action to be performed for I/O
processing.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
The interruption handler will echo back the <strong>intparm</strong> specified here, unless
another interruption parameter is specified by a subsequent invocation of
<a class="reference internal" href="#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> or <a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code>, if the operation was successful;
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>, if the device is busy, or status pending;
-<code class="docutils literal notranslate"><span class="pre">EACCES</span></code>, if no path specified in <strong>lpm</strong> is operational;
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>, if the device is not operational.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_start">
int <code class="descname">ccw_device_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.ccw1" title="ccw1">ccw1</a> *<em>&nbsp;cpa</em>, unsigned long<em>&nbsp;intparm</em>, __u8<em>&nbsp;lpm</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a s390 channel program</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw1</span> <span class="pre">*</span> <span class="pre">cpa</span></code></dt>
<dd>logical start address of channel program</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user specific interruption parameter; will be presented back to
<strong>cdev</strong>’s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">lpm</span></code></dt>
<dd>defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>additional flags; defines the action to be performed for I/O
processing.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
The interruption handler will echo back the <strong>intparm</strong> specified here, unless
another interruption parameter is specified by a subsequent invocation of
<a class="reference internal" href="#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> or <a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code>, if the operation was successful;
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>, if the device is busy, or status pending;
-<code class="docutils literal notranslate"><span class="pre">EACCES</span></code>, if no path specified in <strong>lpm</strong> is operational;
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>, if the device is not operational.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_start_timeout">
int <code class="descname">ccw_device_start_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.ccw1" title="ccw1">ccw1</a> *<em>&nbsp;cpa</em>, unsigned long<em>&nbsp;intparm</em>, __u8<em>&nbsp;lpm</em>, unsigned long<em>&nbsp;flags</em>, int<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_start_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>start a s390 channel program with timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw1</span> <span class="pre">*</span> <span class="pre">cpa</span></code></dt>
<dd>logical start address of channel program</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user specific interruption parameter; will be presented back to
<strong>cdev</strong>’s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">lpm</span></code></dt>
<dd>defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>additional flags; defines the action to be performed for I/O
processing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">expires</span></code></dt>
<dd>timeout value in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
This function notifies the device driver if the channel program has not
completed during the time specified by <strong>expires</strong>. If a timeout occurs, the
channel program is terminated via xsch, hsch or csch, and the device’s
interrupt handler will be called with an irb containing ERR_PTR(-<code class="docutils literal notranslate"><span class="pre">ETIMEDOUT</span></code>).
The interruption handler will echo back the <strong>intparm</strong> specified here, unless
another interruption parameter is specified by a subsequent invocation of
<a class="reference internal" href="#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> or <a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code>, if the operation was successful;
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>, if the device is busy, or status pending;
-<code class="docutils literal notranslate"><span class="pre">EACCES</span></code>, if no path specified in <strong>lpm</strong> is operational;
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>, if the device is not operational.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_halt">
int <code class="descname">ccw_device_halt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, unsigned long<em>&nbsp;intparm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_halt" title="Permalink to this definition">¶</a></dt>
<dd><p>halt I/O request processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>interruption parameter to be returned upon conclusion of hsch</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> calls hsch on <strong>cdev</strong>’s subchannel.
The interruption handler will echo back the <strong>intparm</strong> specified here, unless
another interruption parameter is specified by a subsequent invocation of
<a class="reference internal" href="#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success,
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> on device not operational,
-<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> on invalid device state,
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on device busy or interrupt pending.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_resume">
int <code class="descname">ccw_device_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>resume channel program execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>target ccw device</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ccw_device_resume" title="ccw_device_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_resume()</span></code></a> calls rsch on <strong>cdev</strong>’s subchannel.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success,
-<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> on device not operational,
-<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> on invalid device state,
-<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on device busy or interrupt pending.</div></blockquote>
<p><strong>Context</strong></p>
<p>Interrupts disabled, ccw device lock held</p>
<dl class="function">
<dt id="c.ccw_device_get_ciw">
struct <a class="reference internal" href="#c.ciw" title="ciw">ciw</a> * <code class="descname">ccw_device_get_ciw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, __u32<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_ciw" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for CIW command in extended sense data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device to inspect</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">ct</span></code></dt>
<dd>command type to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>During SenseID, command information words (CIWs) describing special
commands available to the device may have been stored in the extended
sense data. This function searches for CIWs of a specified command
type in the extended sense data.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no extended sense data has been stored or if no CIW of the
specified command type could be found,
else a pointer to the CIW of the specified command type.</div></blockquote>
<dl class="function">
<dt id="c.ccw_device_get_path_mask">
__u8 <code class="descname">ccw_device_get_path_mask</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_path_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>get currently available paths</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device to be queried</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> if no subchannel for the device is available,
else the mask of currently available paths for the ccw device’s subchannel.</div></blockquote>
<dl class="function">
<dt id="c.ccw_device_get_chp_desc">
struct channel_path_desc_fmt0 * <code class="descname">ccw_device_get_chp_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, int<em>&nbsp;chp_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_chp_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>return newly allocated channel-path descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device to obtain the descriptor for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chp_idx</span></code></dt>
<dd>index of the channel path</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success return a newly allocated copy of the channel-path description
data associated with the given channel path. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.ccw_device_get_util_str">
u8 * <code class="descname">ccw_device_get_util_str</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, int<em>&nbsp;chp_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_util_str" title="Permalink to this definition">¶</a></dt>
<dd><p>return newly allocated utility strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device to obtain the utility strings for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chp_idx</span></code></dt>
<dd>index of the channel path</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success return a newly allocated copy of the utility strings
associated with the given channel path. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.ccw_device_get_id">
void <code class="descname">ccw_device_get_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.ccw_dev_id" title="ccw_dev_id">ccw_dev_id</a> *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a ccw device id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device to obtain the id for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_dev_id</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>where to fill in the values</dd>
</dl>
<dl class="function">
<dt id="c.ccw_device_tm_start_timeout_key">
int <code class="descname">ccw_device_tm_start_timeout_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct tcw *<em>&nbsp;tcw</em>, unsigned long<em>&nbsp;intparm</em>, u8<em>&nbsp;lpm</em>, u8<em>&nbsp;key</em>, int<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_tm_start_timeout_key" title="Permalink to this definition">¶</a></dt>
<dd><p>perform start function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device on which to perform the start function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcw</span> <span class="pre">*</span> <span class="pre">tcw</span></code></dt>
<dd>transport-command word to be started</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user defined parameter to be passed to the interrupt handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">lpm</span></code></dt>
<dd>mask of paths to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt>
<dd>storage key to use for storage access</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">expires</span></code></dt>
<dd>time span in jiffies after which to abort request</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_tm_start_key">
int <code class="descname">ccw_device_tm_start_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct tcw *<em>&nbsp;tcw</em>, unsigned long<em>&nbsp;intparm</em>, u8<em>&nbsp;lpm</em>, u8<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_tm_start_key" title="Permalink to this definition">¶</a></dt>
<dd><p>perform start function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device on which to perform the start function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcw</span> <span class="pre">*</span> <span class="pre">tcw</span></code></dt>
<dd>transport-command word to be started</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user defined parameter to be passed to the interrupt handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">lpm</span></code></dt>
<dd>mask of paths to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt>
<dd>storage key to use for storage access</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_tm_start">
int <code class="descname">ccw_device_tm_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct tcw *<em>&nbsp;tcw</em>, unsigned long<em>&nbsp;intparm</em>, u8<em>&nbsp;lpm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_tm_start" title="Permalink to this definition">¶</a></dt>
<dd><p>perform start function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device on which to perform the start function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcw</span> <span class="pre">*</span> <span class="pre">tcw</span></code></dt>
<dd>transport-command word to be started</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user defined parameter to be passed to the interrupt handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">lpm</span></code></dt>
<dd>mask of paths to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_tm_start_timeout">
int <code class="descname">ccw_device_tm_start_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct tcw *<em>&nbsp;tcw</em>, unsigned long<em>&nbsp;intparm</em>, u8<em>&nbsp;lpm</em>, int<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_tm_start_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>perform start function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device on which to perform the start function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tcw</span> <span class="pre">*</span> <span class="pre">tcw</span></code></dt>
<dd>transport-command word to be started</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">intparm</span></code></dt>
<dd>user defined parameter to be passed to the interrupt handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">lpm</span></code></dt>
<dd>mask of paths to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">expires</span></code></dt>
<dd>time span in jiffies after which to abort request</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_get_mdc">
int <code class="descname">ccw_device_get_mdc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, u8<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_mdc" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate max data count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device for which the max data count is accumulated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mask</span></code></dt>
<dd>mask of paths to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the number of 64K-bytes blocks all paths at least support
for a transport command. Return value 0 indicates failure.</p>
<dl class="function">
<dt id="c.ccw_device_tm_intrg">
int <code class="descname">ccw_device_tm_intrg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_tm_intrg" title="Permalink to this definition">¶</a></dt>
<dd><p>perform interrogate function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device on which to perform the interrogate function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform an interrogate function on the given ccw device. Return zero on
success, non-zero otherwise.</p>
<dl class="function">
<dt id="c.ccw_device_get_schid">
void <code class="descname">ccw_device_get_schid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct subchannel_id *<em>&nbsp;schid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccw_device_get_schid" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a subchannel id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>device to obtain the id for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subchannel_id</span> <span class="pre">*</span> <span class="pre">schid</span></code></dt>
<dd>where to fill in the values</dd>
</dl>
</div>
<div class="section" id="the-channel-measurement-facility">
<h3>The channel-measurement facility<a class="headerlink" href="#the-channel-measurement-facility" title="Permalink to this headline">¶</a></h3>
<p>The channel-measurement facility provides a means to collect measurement
data which is made available by the channel subsystem for each channel
attached device.</p>
<dl class="type">
<dt id="c.cmbdata">
struct <code class="descname">cmbdata</code><a class="headerlink" href="#c.cmbdata" title="Permalink to this definition">¶</a></dt>
<dd><p>channel measurement block data for user space</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cmbdata {
  __u64 size;
  __u64 elapsed_time;
  __u64 ssch_rsch_count;
  __u64 sample_count;
  __u64 device_connect_time;
  __u64 function_pending_time;
  __u64 device_disconnect_time;
  __u64 control_unit_queuing_time;
  __u64 device_active_only_time;
  __u64 device_busy_time;
  __u64 initial_command_response_time;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>size of the stored data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">elapsed_time</span></code></dt>
<dd>time since last sampling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssch_rsch_count</span></code></dt>
<dd>number of ssch and rsch</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sample_count</span></code></dt>
<dd>number of samples</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_connect_time</span></code></dt>
<dd>time of device connect</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_pending_time</span></code></dt>
<dd>time of function pending</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_disconnect_time</span></code></dt>
<dd>time of device disconnect</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_unit_queuing_time</span></code></dt>
<dd>time of control unit queuing</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_active_only_time</span></code></dt>
<dd>time of device active only</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_busy_time</span></code></dt>
<dd>time of device busy (ext. format)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_command_response_time</span></code></dt>
<dd>initial command response time (ext. format)</dd>
</dl>
<p><strong>Description</strong></p>
<p>All values are stored as 64 bit for simplicity, especially
in 32 bit emulation mode. All time values are normalized to
nanoseconds.
Currently, two formats are known, which differ by the size of
this structure, i.e. the last two members are only set when
the extended channel measurement facility (first shipped in
z990 machines) is activated.
Potentially, more fields could be added, which would result in a
new ioctl number.</p>
<dl class="function">
<dt id="c.enable_cmf">
int <code class="descname">enable_cmf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_cmf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch on the channel measurement for a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>The ccw device to be enabled</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enable channel measurements for <strong>cdev</strong>. If this is called on a device
for which channel measurement is already enabled a reset of the
measurement data is triggered.</div></blockquote>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> for success or a negative error value.</p>
<p><strong>Context</strong></p>
<p>non-atomic</p>
<dl class="function">
<dt id="c.disable_cmf">
int <code class="descname">disable_cmf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_cmf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch off the channel measurement for a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>The ccw device to be disabled</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> for success or a negative error value.</p>
<p><strong>Context</strong></p>
<p>non-atomic</p>
<dl class="function">
<dt id="c.cmf_read">
u64 <code class="descname">cmf_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cmf_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read one value from the current channel measurement block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the channel to be read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>the index of the value to be read</dd>
</dl>
<p><strong>Return</strong></p>
<p>The value read or <code class="docutils literal notranslate"><span class="pre">0</span></code> if the value cannot be read.</p>
<p><strong>Context</strong></p>
<p>any</p>
<dl class="function">
<dt id="c.cmf_readall">
int <code class="descname">cmf_readall</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.cmbdata" title="cmbdata">cmbdata</a> *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cmf_readall" title="Permalink to this definition">¶</a></dt>
<dd><p>read the current channel measurement block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the channel to be read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cmbdata</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to a data block that will be filled</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, a negative error value otherwise.</p>
<p><strong>Context</strong></p>
<p>any</p>
</div>
</div>
<div class="section" id="the-ccwgroup-bus">
<h2>The ccwgroup bus<a class="headerlink" href="#the-ccwgroup-bus" title="Permalink to this headline">¶</a></h2>
<p>The ccwgroup bus only contains artificial devices, created by the user.
Many networking devices (e.g. qeth) are in fact composed of several ccw
devices (like read, write and data channel for qeth). The ccwgroup bus
provides a mechanism to create a meta-device which contains those ccw
devices as slave devices and can be associated with the netdevice.</p>
<div class="section" id="ccw-group-devices">
<h3>ccw group devices<a class="headerlink" href="#ccw-group-devices" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.ccwgroup_device">
struct <code class="descname">ccwgroup_device</code><a class="headerlink" href="#c.ccwgroup_device" title="Permalink to this definition">¶</a></dt>
<dd><p>ccw group device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccwgroup_device {
  enum {
    CCWGROUP_OFFLINE,
    CCWGROUP_ONLINE,
  } state;
  unsigned int count;
  struct device   dev;
  struct work_struct ungroup_work;
  struct ccw_device *cdev[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>online/offline state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt>
<dd>number of attached slave devices</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>embedded device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ungroup_work</span></code></dt>
<dd>work to be done when a ccwgroup notifier has action
type <code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_UNBIND_DRIVER</span></code></dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdev</span></code></dt>
<dd>variable number of slave devices, allocated as needed</dd>
</dl>
<dl class="type">
<dt id="c.ccwgroup_driver">
struct <code class="descname">ccwgroup_driver</code><a class="headerlink" href="#c.ccwgroup_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>driver for ccw group devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccwgroup_driver {
  int (*setup) (struct ccwgroup_device *);
  void (*remove) (struct ccwgroup_device *);
  int (*set_online) (struct ccwgroup_device *);
  int (*set_offline) (struct ccwgroup_device *);
  void (*shutdown)(struct ccwgroup_device *);
  int (*prepare) (struct ccwgroup_device *);
  void (*complete) (struct ccwgroup_device *);
  int (*freeze)(struct ccwgroup_device *);
  int (*thaw) (struct ccwgroup_device *);
  int (*restore)(struct ccwgroup_device *);
  struct device_driver driver;
  struct ccw_driver *ccw_driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt>
<dd>function called during device creation to setup the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt>
<dd>function called on remove</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_online</span></code></dt>
<dd>function called when device is set online</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_offline</span></code></dt>
<dd>function called when device is set offline</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt>
<dd>function called when device is shut down</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt>
<dd>prepare for pm state transition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt>
<dd>undo work done in <strong>prepare</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">freeze</span></code></dt>
<dd>callback for freezing during hibernation snapshotting</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thaw</span></code></dt>
<dd>undo work done in <strong>freeze</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">restore</span></code></dt>
<dd>callback for restoring after hibernation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt>
<dd>embedded driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ccw_driver</span></code></dt>
<dd>supported ccw_driver (optional)</dd>
</dl>
<dl class="function">
<dt id="c.ccwgroup_set_online">
int <code class="descname">ccwgroup_set_online</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccwgroup_device" title="ccwgroup_device">ccwgroup_device</a> *<em>&nbsp;gdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_set_online" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a ccwgroup device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_device</span> <span class="pre">*</span> <span class="pre">gdev</span></code></dt>
<dd>target ccwgroup device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function attempts to put the ccwgroup device into the online state.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and a negative error value on failure.</div></blockquote>
<dl class="function">
<dt id="c.ccwgroup_set_offline">
int <code class="descname">ccwgroup_set_offline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccwgroup_device" title="ccwgroup_device">ccwgroup_device</a> *<em>&nbsp;gdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_set_offline" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a ccwgroup device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_device</span> <span class="pre">*</span> <span class="pre">gdev</span></code></dt>
<dd>target ccwgroup device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function attempts to put the ccwgroup device into the offline state.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and a negative error value on failure.</div></blockquote>
<dl class="function">
<dt id="c.ccwgroup_create_dev">
int <code class="descname">ccwgroup_create_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct <a class="reference internal" href="#c.ccwgroup_driver" title="ccwgroup_driver">ccwgroup_driver</a> *<em>&nbsp;gdrv</em>, int<em>&nbsp;num_devices</em>, const char *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_create_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register a ccw group device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the new device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_driver</span> <span class="pre">*</span> <span class="pre">gdrv</span></code></dt>
<dd>driver for the new group device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_devices</span></code></dt>
<dd>number of slave devices</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer containing comma separated bus ids of slave devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and register a new ccw group device as a child of <strong>parent</strong>. Slave
devices are obtained from the list of bus ids given in <strong>buf</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">0</span></code> on success and an error code on failure.</div></blockquote>
<p><strong>Context</strong></p>
<p>non-atomic</p>
<dl class="function">
<dt id="c.ccwgroup_driver_register">
int <code class="descname">ccwgroup_driver_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccwgroup_driver" title="ccwgroup_driver">ccwgroup_driver</a> *<em>&nbsp;cdriver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a ccw group driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_driver</span> <span class="pre">*</span> <span class="pre">cdriver</span></code></dt>
<dd>driver to be registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is mainly a wrapper around <a class="reference internal" href="infrastructure.html#c.driver_register" title="driver_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_register()</span></code></a>.</p>
<dl class="function">
<dt id="c.ccwgroup_driver_unregister">
void <code class="descname">ccwgroup_driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccwgroup_driver" title="ccwgroup_driver">ccwgroup_driver</a> *<em>&nbsp;cdriver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a ccw group driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_driver</span> <span class="pre">*</span> <span class="pre">cdriver</span></code></dt>
<dd>driver to be deregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is mainly a wrapper around <a class="reference internal" href="infrastructure.html#c.driver_unregister" title="driver_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_unregister()</span></code></a>.</p>
<dl class="function">
<dt id="c.get_ccwgroupdev_by_busid">
struct <a class="reference internal" href="#c.ccwgroup_device" title="ccwgroup_device">ccwgroup_device</a> * <code class="descname">get_ccwgroupdev_by_busid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccwgroup_driver" title="ccwgroup_driver">ccwgroup_driver</a> *<em>&nbsp;gdrv</em>, char *<em>&nbsp;bus_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_ccwgroupdev_by_busid" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain device from a bus id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccwgroup_driver</span> <span class="pre">*</span> <span class="pre">gdrv</span></code></dt>
<dd>driver the device is owned by</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>bus id of the device to be searched</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function searches all devices owned by <strong>gdrv</strong> for a device with a bus
id matching <strong>bus_id</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>If a match is found, its reference count of the found device is increased
and it is returned; else <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</div></blockquote>
<dl class="function">
<dt id="c.ccwgroup_probe_ccwdev">
int <code class="descname">ccwgroup_probe_ccwdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_probe_ccwdev" title="Permalink to this definition">¶</a></dt>
<dd><p>probe function for slave devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device to be probed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a dummy probe function for ccw devices that are slave devices in
a ccw group device.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>always <code class="docutils literal notranslate"><span class="pre">0</span></code></div></blockquote>
<dl class="function">
<dt id="c.ccwgroup_remove_ccwdev">
void <code class="descname">ccwgroup_remove_ccwdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ccw_device" title="ccw_device">ccw_device</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ccwgroup_remove_ccwdev" title="Permalink to this definition">¶</a></dt>
<dd><p>remove function for slave devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ccw_device</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>ccw device to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a remove function for ccw devices that are slave devices in a ccw
group device. It sets the ccw device offline and also deregisters the
embedding ccw group device.</p>
</div>
</div>
<div class="section" id="generic-interfaces">
<h2>Generic interfaces<a class="headerlink" href="#generic-interfaces" title="Permalink to this headline">¶</a></h2>
<p>The following section contains interfaces in use not only by drivers
dealing with ccw devices, but drivers for various other s390 hardware
as well.</p>
<div class="section" id="adapter-interrupts">
<h3>Adapter interrupts<a class="headerlink" href="#adapter-interrupts" title="Permalink to this headline">¶</a></h3>
<p>The common I/O layer provides helper functions for dealing with adapter
interrupts and interrupt vectors.</p>
<dl class="function">
<dt id="c.register_adapter_interrupt">
int <code class="descname">register_adapter_interrupt</code><span class="sig-paren">(</span>struct airq_struct *<em>&nbsp;airq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_adapter_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>register adapter interrupt handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_struct</span> <span class="pre">*</span> <span class="pre">airq</span></code></dt>
<dd>pointer to adapter interrupt descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, or -EINVAL.</p>
<dl class="function">
<dt id="c.unregister_adapter_interrupt">
void <code class="descname">unregister_adapter_interrupt</code><span class="sig-paren">(</span>struct airq_struct *<em>&nbsp;airq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_adapter_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister adapter interrupt handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_struct</span> <span class="pre">*</span> <span class="pre">airq</span></code></dt>
<dd>pointer to adapter interrupt descriptor</dd>
</dl>
<dl class="function">
<dt id="c.airq_iv_create">
struct airq_iv * <code class="descname">airq_iv_create</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;bits</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.airq_iv_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an interrupt vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in the interrupt vector</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to an interrupt vector structure</p>
<dl class="function">
<dt id="c.airq_iv_release">
void <code class="descname">airq_iv_release</code><span class="sig-paren">(</span>struct airq_iv *<em>&nbsp;iv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.airq_iv_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release an interrupt vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_iv</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>pointer to interrupt vector structure</dd>
</dl>
<dl class="function">
<dt id="c.airq_iv_alloc">
unsigned long <code class="descname">airq_iv_alloc</code><span class="sig-paren">(</span>struct airq_iv *<em>&nbsp;iv</em>, unsigned long<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.airq_iv_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate irq bits from an interrupt vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_iv</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>pointer to an interrupt vector structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt>
<dd>number of consecutive irq bits to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the bit number of the first irq in the allocated block of irqs,
or -1UL if no bit is available or the AIRQ_IV_ALLOC flag has not been
specified</p>
<dl class="function">
<dt id="c.airq_iv_free">
void <code class="descname">airq_iv_free</code><span class="sig-paren">(</span>struct airq_iv *<em>&nbsp;iv</em>, unsigned long<em>&nbsp;bit</em>, unsigned long<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.airq_iv_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free irq bits of an interrupt vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_iv</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>pointer to interrupt vector structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">bit</span></code></dt>
<dd>number of the first irq bit to free</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt>
<dd>number of consecutive irq bits to free</dd>
</dl>
<dl class="function">
<dt id="c.airq_iv_scan">
unsigned long <code class="descname">airq_iv_scan</code><span class="sig-paren">(</span>struct airq_iv *<em>&nbsp;iv</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.airq_iv_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>scan interrupt vector for non-zero bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">airq_iv</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>pointer to interrupt vector structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>bit number to start the search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>bit number to end the search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the bit number of the next non-zero interrupt bit, or
-1UL if the scan completed without finding any more any non-zero bits.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vme.html" class="btn btn-neutral float-right" title="VME Device Drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rapidio/rio_cm.html" class="btn btn-neutral float-left" title="RapidIO subsystem Channelized Messaging character device driver (rio_cm.c)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>