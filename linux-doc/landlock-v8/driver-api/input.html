

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Input Subsystem &mdash; The Linux Kernel 4.16.0-rc1+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.16.0-rc1+ documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementer’s API guide" href="index.html"/>
        <link rel="next" title="Linux USB API" href="usb/index.html"/>
        <link rel="prev" title="HW consumer" href="iio/hw-consumer.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Input Subsystem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-core">Input core</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multitouch-library">Multitouch Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polled-input-devices">Polled input devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-keyboards-keypads">Matrix keyboards/keypads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-keymap-support">Sparse keymap support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Input Subsystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/input.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="input-subsystem">
<h1>Input Subsystem<a class="headerlink" href="#input-subsystem" title="Permalink to this headline">¶</a></h1>
<div class="section" id="input-core">
<h2>Input core<a class="headerlink" href="#input-core" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.input_value">
struct <code class="descname">input_value</code><a class="headerlink" href="#c.input_value" title="Permalink to this definition">¶</a></dt>
<dd><p>input value representation</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_value {
  __u16 type;
  __u16 code;
  __s32 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of value (EV_KEY, EV_ABS, etc)</dd>
<dt><code class="docutils literal"><span class="pre">code</span></code></dt>
<dd>the value code</dd>
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>the value</dd>
</dl>
<dl class="type">
<dt id="c.input_dev">
struct <code class="descname">input_dev</code><a class="headerlink" href="#c.input_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>represents an input device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_dev {
  const char *name;
  const char *phys;
  const char *uniq;
  struct input_id id;
  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];
  unsigned int hint_events_per_packet;
  unsigned int keycodemax;
  unsigned int keycodesize;
  void *keycode;
  int (*setkeycode)(struct input_dev *dev,const struct input_keymap_entry *ke, unsigned int *old_keycode);
  int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke);
  struct ff_device *ff;
  unsigned int repeat_key;
  struct timer_list timer;
  int rep[REP_CNT];
  struct input_mt *mt;
  struct input_absinfo *absinfo;
  unsigned long key[BITS_TO_LONGS(KEY_CNT)];
  unsigned long led[BITS_TO_LONGS(LED_CNT)];
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];
  int (*open)(struct input_dev *dev);
  void (*close)(struct input_dev *dev);
  int (*flush)(struct input_dev *dev, struct file *file);
  int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
  struct input_handle __rcu *grab;
  spinlock_t event_lock;
  struct mutex mutex;
  unsigned int users;
  bool going_away;
  struct device dev;
  struct list_head        h_list;
  struct list_head        node;
  unsigned int num_vals;
  unsigned int max_vals;
  struct input_value *vals;
  bool devres_managed;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the device</dd>
<dt><code class="docutils literal"><span class="pre">phys</span></code></dt>
<dd>physical path to the device in the system hierarchy</dd>
<dt><code class="docutils literal"><span class="pre">uniq</span></code></dt>
<dd>unique identification code for the device (if device has it)</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>id of the device (struct input_id)</dd>
<dt><code class="docutils literal"><span class="pre">propbit</span></code></dt>
<dd>bitmap of device properties and quirks</dd>
<dt><code class="docutils literal"><span class="pre">evbit</span></code></dt>
<dd>bitmap of types of events supported by the device (EV_KEY,
EV_REL, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">keybit</span></code></dt>
<dd>bitmap of keys/buttons this device has</dd>
<dt><code class="docutils literal"><span class="pre">relbit</span></code></dt>
<dd>bitmap of relative axes for the device</dd>
<dt><code class="docutils literal"><span class="pre">absbit</span></code></dt>
<dd>bitmap of absolute axes for the device</dd>
<dt><code class="docutils literal"><span class="pre">mscbit</span></code></dt>
<dd>bitmap of miscellaneous events supported by the device</dd>
<dt><code class="docutils literal"><span class="pre">ledbit</span></code></dt>
<dd>bitmap of leds present on the device</dd>
<dt><code class="docutils literal"><span class="pre">sndbit</span></code></dt>
<dd>bitmap of sound effects supported by the device</dd>
<dt><code class="docutils literal"><span class="pre">ffbit</span></code></dt>
<dd>bitmap of force feedback effects supported by the device</dd>
<dt><code class="docutils literal"><span class="pre">swbit</span></code></dt>
<dd>bitmap of switches present on the device</dd>
<dt><code class="docutils literal"><span class="pre">hint_events_per_packet</span></code></dt>
<dd>average number of events generated by the
device in a packet (between EV_SYN/SYN_REPORT events). Used by
event handlers to estimate size of the buffer needed to hold
events.</dd>
<dt><code class="docutils literal"><span class="pre">keycodemax</span></code></dt>
<dd>size of keycode table</dd>
<dt><code class="docutils literal"><span class="pre">keycodesize</span></code></dt>
<dd>size of elements in keycode table</dd>
<dt><code class="docutils literal"><span class="pre">keycode</span></code></dt>
<dd>map of scancodes to keycodes for this device</dd>
<dt><code class="docutils literal"><span class="pre">setkeycode</span></code></dt>
<dd>optional method to alter current keymap, used to implement
sparse keymaps. If not supplied default mechanism will be used.
The method is being called while holding event_lock and thus must
not sleep</dd>
<dt><code class="docutils literal"><span class="pre">getkeycode</span></code></dt>
<dd>optional legacy method to retrieve current keymap.</dd>
<dt><code class="docutils literal"><span class="pre">ff</span></code></dt>
<dd>force feedback structure associated with the device if device
supports force feedback effects</dd>
<dt><code class="docutils literal"><span class="pre">repeat_key</span></code></dt>
<dd>stores key code of the last key pressed; used to implement
software autorepeat</dd>
<dt><code class="docutils literal"><span class="pre">timer</span></code></dt>
<dd>timer for software autorepeat</dd>
<dt><code class="docutils literal"><span class="pre">rep</span></code></dt>
<dd>current values for autorepeat parameters (delay, rate)</dd>
<dt><code class="docutils literal"><span class="pre">mt</span></code></dt>
<dd>pointer to multitouch state</dd>
<dt><code class="docutils literal"><span class="pre">absinfo</span></code></dt>
<dd>array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">input_absinfo</span></code> elements holding information
about absolute axes (current value, min, max, flat, fuzz,
resolution)</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>reflects current state of device’s keys/buttons</dd>
<dt><code class="docutils literal"><span class="pre">led</span></code></dt>
<dd>reflects current state of device’s LEDs</dd>
<dt><code class="docutils literal"><span class="pre">snd</span></code></dt>
<dd>reflects current state of sound effects</dd>
<dt><code class="docutils literal"><span class="pre">sw</span></code></dt>
<dd>reflects current state of device’s switches</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>this method is called when the very first user calls
<a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal"><span class="pre">input_open_device()</span></code></a>. The driver must prepare the device
to start generating events (start polling thread,
request an IRQ, submit URB, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">close</span></code></dt>
<dd>this method is called when the very last user calls
<a class="reference internal" href="#c.input_close_device" title="input_close_device"><code class="xref c c-func docutils literal"><span class="pre">input_close_device()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">flush</span></code></dt>
<dd>purges the device. Most commonly used to get rid of force
feedback effects loaded into the device when disconnecting
from it</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>event handler for events sent _to_ the device, like EV_LED
or EV_SND. The device is expected to carry out the requested
action (turn on a LED, play sound, etc.) The call is protected
by <strong>event_lock</strong> and must not sleep</dd>
<dt><code class="docutils literal"><span class="pre">grab</span></code></dt>
<dd>input handle that currently has the device grabbed (via
EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
recipient for all input events coming from the device</dd>
<dt><code class="docutils literal"><span class="pre">event_lock</span></code></dt>
<dd>this spinlock is taken when input core receives
and processes a new event for the device (in <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal"><span class="pre">input_event()</span></code></a>).
Code that accesses and/or modifies parameters of a device
(such as keymap or absmin, absmax, absfuzz, etc.) after device
has been registered with input core must take this lock.</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>serializes calls to <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a>, <a class="reference internal" href="../media/uapi/dvb/video-fclose.html#c.close" title="close"><code class="xref c c-func docutils literal"><span class="pre">close()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">flush()</span></code> methods</dd>
<dt><code class="docutils literal"><span class="pre">users</span></code></dt>
<dd>stores number of users (input handlers) that opened this
device. It is used by <a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal"><span class="pre">input_open_device()</span></code></a> and <a class="reference internal" href="#c.input_close_device" title="input_close_device"><code class="xref c c-func docutils literal"><span class="pre">input_close_device()</span></code></a>
to make sure that dev-&gt;:c:func:<cite>open()</cite> is only called when the first
user opens device and dev-&gt;:c:func:<cite>close()</cite> is called when the very
last user closes the device</dd>
<dt><code class="docutils literal"><span class="pre">going_away</span></code></dt>
<dd>marks devices that are in a middle of unregistering and
causes input_open_device*() fail with -ENODEV.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>driver model’s view of this device</dd>
<dt><code class="docutils literal"><span class="pre">h_list</span></code></dt>
<dd>list of input handles associated with the device. When
accessing the list dev-&gt;mutex must be held</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>used to place the device onto input_dev_list</dd>
<dt><code class="docutils literal"><span class="pre">num_vals</span></code></dt>
<dd>number of values queued in the current frame</dd>
<dt><code class="docutils literal"><span class="pre">max_vals</span></code></dt>
<dd>maximum number of values queued in a frame</dd>
<dt><code class="docutils literal"><span class="pre">vals</span></code></dt>
<dd>array of values queued in the current frame</dd>
<dt><code class="docutils literal"><span class="pre">devres_managed</span></code></dt>
<dd>indicates that devices is managed with devres framework
and needs not be explicitly unregistered or freed.</dd>
</dl>
<dl class="type">
<dt id="c.input_handler">
struct <code class="descname">input_handler</code><a class="headerlink" href="#c.input_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>implements one of interfaces for input devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_handler {
  void *private;
  void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
  void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count);
  bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
  bool (*match)(struct input_handler *handler, struct input_dev *dev);
  int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
  void (*disconnect)(struct input_handle *handle);
  void (*start)(struct input_handle *handle);
  bool legacy_minors;
  int minor;
  const char *name;
  const struct input_device_id *id_table;
  struct list_head        h_list;
  struct list_head        node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>driver-specific data</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>event handler. This method is being called by input core with
interrupts disabled and dev-&gt;event_lock spinlock held and so
it may not sleep</dd>
<dt><code class="docutils literal"><span class="pre">events</span></code></dt>
<dd>event sequence handler. This method is being called by
input core with interrupts disabled and dev-&gt;event_lock
spinlock held and so it may not sleep</dd>
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>similar to <strong>event</strong>; separates normal event handlers from
“filters”.</dd>
<dt><code class="docutils literal"><span class="pre">match</span></code></dt>
<dd>called after comparing device’s id with handler’s id_table
to perform fine-grained matching between device and handler</dd>
<dt><code class="docutils literal"><span class="pre">connect</span></code></dt>
<dd>called when attaching a handler to an input device</dd>
<dt><code class="docutils literal"><span class="pre">disconnect</span></code></dt>
<dd>disconnects a handler from input device</dd>
<dt><code class="docutils literal"><span class="pre">start</span></code></dt>
<dd>starts handler for given handle. This function is called by
input core right after <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> method and also when a process
that “grabbed” a device releases it</dd>
<dt><code class="docutils literal"><span class="pre">legacy_minors</span></code></dt>
<dd>set to <code class="docutils literal"><span class="pre">true</span></code> by drivers using legacy minor ranges</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd>beginning of range of 32 legacy minors for devices this driver
can provide</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the handler, to be shown in /proc/bus/input/handlers</dd>
<dt><code class="docutils literal"><span class="pre">id_table</span></code></dt>
<dd>pointer to a table of input_device_ids this driver can
handle</dd>
<dt><code class="docutils literal"><span class="pre">h_list</span></code></dt>
<dd>list of input handles associated with the handler</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>for placing the driver onto input_handler_list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input handlers attach to input devices and create input handles. There
are likely several handlers attached to any given input device at the
same time. All of them will get their copy of input event generated by
the device.</p>
<p>The very same structure is used to implement input filters. Input core
allows filters to run first and will not pass event to regular handlers
if any of the filters indicate that the event should be filtered (by
returning <code class="docutils literal"><span class="pre">true</span></code> from their <code class="xref c c-func docutils literal"><span class="pre">filter()</span></code> method).</p>
<p>Note that input core serializes calls to <code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">disconnect()</span></code>
methods.</p>
<dl class="type">
<dt id="c.input_handle">
struct <code class="descname">input_handle</code><a class="headerlink" href="#c.input_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>links input device with an input handler</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_handle {
  void *private;
  int open;
  const char *name;
  struct input_dev *dev;
  struct input_handler *handler;
  struct list_head        d_node;
  struct list_head        h_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>handler-specific data</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>counter showing whether the handle is ‘open’, i.e. should deliver
events from its device</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name given to the handle by handler that created it</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>input device the handle is attached to</dd>
<dt><code class="docutils literal"><span class="pre">handler</span></code></dt>
<dd>handler that works with the device through this handle</dd>
<dt><code class="docutils literal"><span class="pre">d_node</span></code></dt>
<dd>used to put the handle on device’s list of attached handles</dd>
<dt><code class="docutils literal"><span class="pre">h_node</span></code></dt>
<dd>used to put the handle on handler’s list of handles from which
it gets events</dd>
</dl>
<dl class="function">
<dt id="c.input_set_events_per_packet">
void <code class="descname">input_set_events_per_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int<em>&nbsp;n_events</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_events_per_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>tell handlers about the driver event rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the input device used by the driver</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">n_events</span></code></dt>
<dd>the average number of events between calls to <code class="xref c c-func docutils literal"><span class="pre">input_sync()</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>If the event rate sent from a device is unusually large, use this
function to set the expected event rate. This will allow handlers
to set up an appropriate buffer size for the event stream, in order
to minimize information loss.</p>
<dl class="type">
<dt id="c.ff_device">
struct <code class="descname">ff_device</code><a class="headerlink" href="#c.ff_device" title="Permalink to this definition">¶</a></dt>
<dd><p>force-feedback part of an input device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ff_device {
  int (*upload)(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old);
  int (*erase)(struct input_dev *dev, int effect_id);
  int (*playback)(struct input_dev *dev, int effect_id, int value);
  void (*set_gain)(struct input_dev *dev, u16 gain);
  void (*set_autocenter)(struct input_dev *dev, u16 magnitude);
  void (*destroy)(struct ff_device *);
  void *private;
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  struct mutex mutex;
  int max_effects;
  struct ff_effect *effects;
  struct file *effect_owners[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">upload</span></code></dt>
<dd>Called to upload an new effect into device</dd>
<dt><code class="docutils literal"><span class="pre">erase</span></code></dt>
<dd>Called to erase an effect from device</dd>
<dt><code class="docutils literal"><span class="pre">playback</span></code></dt>
<dd>Called to request device to start playing specified effect</dd>
<dt><code class="docutils literal"><span class="pre">set_gain</span></code></dt>
<dd>Called to set specified gain</dd>
<dt><code class="docutils literal"><span class="pre">set_autocenter</span></code></dt>
<dd>Called to auto-center device</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>called by input core when parent input device is being
destroyed</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>driver-specific data, will be freed automatically</dd>
<dt><code class="docutils literal"><span class="pre">ffbit</span></code></dt>
<dd>bitmap of force feedback capabilities truly supported by
device (not emulated like ones in input_dev-&gt;ffbit)</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>mutex for serializing access to the device</dd>
<dt><code class="docutils literal"><span class="pre">max_effects</span></code></dt>
<dd>maximum number of effects supported by device</dd>
<dt><code class="docutils literal"><span class="pre">effects</span></code></dt>
<dd>pointer to an array of effects currently loaded into device</dd>
<dt><code class="docutils literal"><span class="pre">effect_owners</span></code></dt>
<dd>array of effect owners; when file handle owning
an effect gets closed the effect is automatically erased</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every force-feedback device must implement <code class="xref c c-func docutils literal"><span class="pre">upload()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">playback()</span></code>
methods; <code class="xref c c-func docutils literal"><span class="pre">erase()</span></code> is optional. <code class="xref c c-func docutils literal"><span class="pre">set_gain()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">set_autocenter()</span></code> need
only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER
bits.</p>
<p>Note that <code class="xref c c-func docutils literal"><span class="pre">playback()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">set_gain()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">set_autocenter()</span></code> are called with
dev-&gt;event_lock spinlock held and interrupts off and thus may not
sleep.</p>
<dl class="function">
<dt id="c.input_event">
void <code class="descname">input_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;code</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_event" title="Permalink to this definition">¶</a></dt>
<dd><p>report new input event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that generated the event</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>type of the event</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>event code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value of the event</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be used by drivers implementing various input
devices to report input events. See also <a class="reference internal" href="#c.input_inject_event" title="input_inject_event"><code class="xref c c-func docutils literal"><span class="pre">input_inject_event()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal"><span class="pre">input_event()</span></code></a> may be safely used right after input device was
allocated with <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal"><span class="pre">input_allocate_device()</span></code></a>, even before it is registered
with <a class="reference internal" href="#c.input_register_device" title="input_register_device"><code class="xref c c-func docutils literal"><span class="pre">input_register_device()</span></code></a>, but the event will not reach any of the
input handlers. Such early invocation of <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal"><span class="pre">input_event()</span></code></a> may be used
to ‘seed’ initial state of a switch or initial position of absolute
axis, etc.</p>
<dl class="function">
<dt id="c.input_inject_event">
void <code class="descname">input_inject_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;code</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_inject_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send input event from input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>input handle to send event through</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>type of the event</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>event code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value of the event</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal"><span class="pre">input_event()</span></code></a> but will ignore event if device is
“grabbed” and handle injecting event is not the one that owns
the device.</p>
<dl class="function">
<dt id="c.input_alloc_absinfo">
void <code class="descname">input_alloc_absinfo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_alloc_absinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates array of input_absinfo structs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the input device emitting absolute events</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the absinfo struct the caller asked for is already allocated, this
functions will not do anything.</p>
<dl class="function">
<dt id="c.input_grab_device">
int <code class="descname">input_grab_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_grab_device" title="Permalink to this definition">¶</a></dt>
<dd><p>grabs device for exclusive use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>input handle that wants to own the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device is grabbed by an input handle all events generated by
the device are delivered only to this handle. Also events injected
by other input handles are ignored while device is grabbed.</p>
<dl class="function">
<dt id="c.input_release_device">
void <code class="descname">input_release_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_release_device" title="Permalink to this definition">¶</a></dt>
<dd><p>release previously grabbed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>input handle that owns the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases previously grabbed device so that other input handles can
start receiving input events. Upon release all handlers attached
to the device have their <code class="xref c c-func docutils literal"><span class="pre">start()</span></code> method called so they have a change
to synchronize device state with the rest of the system.</p>
<dl class="function">
<dt id="c.input_open_device">
int <code class="descname">input_open_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_open_device" title="Permalink to this definition">¶</a></dt>
<dd><p>open input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle through which device is being accessed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by input handlers when they
want to start receive events from given input device.</p>
<dl class="function">
<dt id="c.input_close_device">
void <code class="descname">input_close_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_close_device" title="Permalink to this definition">¶</a></dt>
<dd><p>close input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle through which device is being accessed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by input handlers when they
want to stop receive events from given input device.</p>
<dl class="function">
<dt id="c.input_scancode_to_scalar">
int <code class="descname">input_scancode_to_scalar</code><span class="sig-paren">(</span>const struct input_keymap_entry *<em>&nbsp;ke</em>, unsigned int *<em>&nbsp;scancode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_scancode_to_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>converts scancode in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">input_keymap_entry</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*</span> <span class="pre">ke</span></code></dt>
<dd>keymap entry containing scancode to be converted.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">scancode</span></code></dt>
<dd>pointer to the location where converted scancode should
be stored.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to convert scancode stored in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">keymap_entry</span></code>
into scalar form understood by legacy keymap handling methods. These
methods expect scancodes to be represented as ‘unsigned int’.</p>
<dl class="function">
<dt id="c.input_get_keycode">
int <code class="descname">input_get_keycode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, struct input_keymap_entry *<em>&nbsp;ke</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_get_keycode" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve keycode currently mapped to a given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device which keymap is being queried</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*</span> <span class="pre">ke</span></code></dt>
<dd>keymap entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by anyone interested in retrieving current
keymap. Presently evdev handlers use it.</p>
<dl class="function">
<dt id="c.input_set_keycode">
int <code class="descname">input_set_keycode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, const struct input_keymap_entry *<em>&nbsp;ke</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_keycode" title="Permalink to this definition">¶</a></dt>
<dd><p>attribute a keycode to a given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device which keymap is being updated</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*</span> <span class="pre">ke</span></code></dt>
<dd>new keymap entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by anyone needing to update current
keymap. Presently keyboard and evdev handlers use it.</p>
<dl class="function">
<dt id="c.input_reset_device">
void <code class="descname">input_reset_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_reset_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reset/restore the state of input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device whose state needs to be reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to reset the state of an opened input device and
bring internal state and state if the hardware in sync with each other.
We mark all keys as released, restore LED state, repeat rate, etc.</p>
<dl class="function">
<dt id="c.input_allocate_device">
struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> * <code class="descname">input_allocate_device</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.input_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for new input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns prepared struct input_dev or <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal"><span class="pre">input_free_device()</span></code></a> to free devices that have not been
registered; <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">input_unregister_device()</span></code></a> should be used for already
registered devices.</p>
<dl class="function">
<dt id="c.devm_input_allocate_device">
struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> * <code class="descname">devm_input_allocate_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_input_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate managed input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device owning the input device being created</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns prepared struct input_dev or <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p>Managed input devices do not need to be explicitly unregistered or
freed as it will be done automatically when owner device unbinds from
its driver (or binding fails). Once managed input device is allocated,
it is ready to be set up and registered in the same fashion as regular
input device. There are no special devm_input_device_[un]:c:func:<cite>register()</cite>
variants, regular ones work with both managed and unmanaged devices,
should you need them. In most cases however, managed input device need
not be explicitly unregistered or freed.</p>
<p><strong>NOTE</strong></p>
<p>the owner device is set up as parent of input device and users
should not override it.</p>
<dl class="function">
<dt id="c.input_free_device">
void <code class="descname">input_free_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_free_device" title="Permalink to this definition">¶</a></dt>
<dd><p>free memory occupied by input_dev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should only be used if <a class="reference internal" href="#c.input_register_device" title="input_register_device"><code class="xref c c-func docutils literal"><span class="pre">input_register_device()</span></code></a>
was not called yet or if it failed. Once device was registered
use <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">input_unregister_device()</span></code></a> and memory will be freed once last
reference to the device is dropped.</p>
<p>Device should be allocated by <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal"><span class="pre">input_allocate_device()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>If there are references to the input device then memory
will not be freed until last reference is dropped.</p>
<dl class="function">
<dt id="c.input_set_capability">
void <code class="descname">input_set_capability</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as capable of a certain event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that is capable of emitting or accepting event</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>type of the event (EV_KEY, EV_REL, etc…)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>event code</dd>
</dl>
<p><strong>Description</strong></p>
<p>In addition to setting up corresponding bit in appropriate capability
bitmap the function also adjusts dev-&gt;evbit.</p>
<dl class="function">
<dt id="c.input_enable_softrepeat">
void <code class="descname">input_enable_softrepeat</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int<em>&nbsp;delay</em>, int<em>&nbsp;period</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_enable_softrepeat" title="Permalink to this definition">¶</a></dt>
<dd><p>enable software autorepeat</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">delay</span></code></dt>
<dd>repeat delay</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">period</span></code></dt>
<dd>repeat period</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable software autorepeat on the input device.</p>
<dl class="function">
<dt id="c.input_register_device">
int <code class="descname">input_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register device with input core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to be registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers device with input core. The device must be
allocated with <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal"><span class="pre">input_allocate_device()</span></code></a> and all it’s capabilities
set up before registering.
If function fails the device must be freed with <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal"><span class="pre">input_free_device()</span></code></a>.
Once device has been successfully registered it can be unregistered
with <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">input_unregister_device()</span></code></a>; <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal"><span class="pre">input_free_device()</span></code></a> should not be
called in this case.</p>
<p>Note that this function is also used to register managed input devices
(ones allocated with <a class="reference internal" href="#c.devm_input_allocate_device" title="devm_input_allocate_device"><code class="xref c c-func docutils literal"><span class="pre">devm_input_allocate_device()</span></code></a>). Such managed input
devices need not be explicitly unregistered or freed, their tear down
is controlled by the devres infrastructure. It is also worth noting
that tear down of managed input devices is internally a 2-step process:
registered managed input device is first unregistered, but stays in
memory and can still handle <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal"><span class="pre">input_event()</span></code></a> calls (although events will
not be delivered anywhere). The freeing of managed input device will
happen later, when devres stack is unwound to the point where device
allocation was made.</p>
<dl class="function">
<dt id="c.input_unregister_device">
void <code class="descname">input_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister previously registered device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters an input device. Once device is unregistered
the caller should not try to access it as it may get freed at any moment.</p>
<dl class="function">
<dt id="c.input_register_handler">
int <code class="descname">input_register_handler</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>&nbsp;handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>handler to be registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a new input handler (interface) for input
devices in the system and attaches it to all input devices that
are compatible with the handler.</p>
<dl class="function">
<dt id="c.input_unregister_handler">
void <code class="descname">input_unregister_handler</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>&nbsp;handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>unregisters an input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>handler to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disconnects a handler from its input devices and
removes it from lists of known handlers.</p>
<dl class="function">
<dt id="c.input_handler_for_each_handle">
int <code class="descname">input_handler_for_each_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>&nbsp;handler</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_handler_for_each_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>handle iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>input handler to iterate</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">input_handle</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>’s list of devices, and call <strong>fn</strong> for each, passing
it <strong>data</strong> and stop when <strong>fn</strong> returns a non-zero value. The function is
using RCU to traverse the list and therefore may be using in atomic
contexts. The <strong>fn</strong> callback is invoked from RCU critical section and
thus must not sleep.</p>
<dl class="function">
<dt id="c.input_register_handle">
int <code class="descname">input_register_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new input handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function puts a new input handle onto device’s
and handler’s lists so that events can flow through
it once it is opened using <a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal"><span class="pre">input_open_device()</span></code></a>.</p>
<p>This function is supposed to be called from handler’s
<code class="xref c c-func docutils literal"><span class="pre">connect()</span></code> method.</p>
<dl class="function">
<dt id="c.input_unregister_handle">
void <code class="descname">input_unregister_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an input handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes input handle from device’s
and handler’s lists.</p>
<p>This function is supposed to be called from handler’s
<code class="xref c c-func docutils literal"><span class="pre">disconnect()</span></code> method.</p>
<dl class="function">
<dt id="c.input_get_new_minor">
int <code class="descname">input_get_new_minor</code><span class="sig-paren">(</span>int<em>&nbsp;legacy_base</em>, unsigned int<em>&nbsp;legacy_num</em>, bool<em>&nbsp;allow_dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_get_new_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates a new input minor number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">legacy_base</span></code></dt>
<dd>beginning or the legacy range to be searched</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">legacy_num</span></code></dt>
<dd>size of legacy range</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">allow_dynamic</span></code></dt>
<dd>whether we can also take ID from the dynamic range</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a new device minor for from input major namespace.
Caller can request legacy minor by specifying <strong>legacy_base</strong> and <strong>legacy_num</strong>
parameters and whether ID can be allocated from dynamic range if there are
no free IDs in legacy range.</p>
<dl class="function">
<dt id="c.input_free_minor">
void <code class="descname">input_free_minor</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_free_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>release previously allocated minor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minor</span></code></dt>
<dd>minor to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases previously allocated input minor so that it can be
reused later.</p>
<dl class="function">
<dt id="c.input_ff_upload">
int <code class="descname">input_ff_upload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, struct ff_effect *<em>&nbsp;effect</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_upload" title="Permalink to this definition">¶</a></dt>
<dd><p>upload effect into force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ff_effect</span> <span class="pre">*</span> <span class="pre">effect</span></code></dt>
<dd>effect to be uploaded</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>owner of the effect</dd>
</dl>
<dl class="function">
<dt id="c.input_ff_erase">
int <code class="descname">input_ff_erase</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int<em>&nbsp;effect_id</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>erase a force-feedback effect from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device to erase effect from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">effect_id</span></code></dt>
<dd>id of the effect to be erased</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>purported owner of the request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function erases a force-feedback effect from specified device.
The effect will only be erased if it was uploaded through the same
file handle that is requesting erase.</p>
<dl class="function">
<dt id="c.input_ff_event">
int <code class="descname">input_ff_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;code</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_event" title="Permalink to this definition">¶</a></dt>
<dd><p>generic handler for force-feedback events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device to send the effect to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>event type (anything but EV_FF is ignored)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>event code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>event value</dd>
</dl>
<dl class="function">
<dt id="c.input_ff_create">
int <code class="descname">input_ff_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;max_effects</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device supporting force-feedback</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_effects</span></code></dt>
<dd>maximum number of effects supported by the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates all necessary memory for a force feedback
portion of an input device and installs all default handlers.
<strong>dev</strong>-&gt;ffbit should be already set up before calling this function.
Once ff device is created you need to setup its upload, erase,
playback and other handlers before registering input device</p>
<dl class="function">
<dt id="c.input_ff_destroy">
void <code class="descname">input_ff_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>frees force feedback portion of input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device supporting force feedback</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is only needed in error path as input core will
automatically free force feedback structures when device is
destroyed.</p>
<dl class="function">
<dt id="c.input_ff_create_memless">
int <code class="descname">input_ff_create_memless</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, int (*play_effect) (struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a><em>&nbsp;*</em>, void<em>&nbsp;*</em>, struct ff_effect<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_create_memless" title="Permalink to this definition">¶</a></dt>
<dd><p>create memoryless force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device supporting force-feedback</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver-specific data to be passed into <strong>play_effect</strong></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">input_dev</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">ff_effect</span> <span class="pre">*)</span> <span class="pre">play_effect</span></code></dt>
<dd>driver-specific method for playing FF effect</dd>
</dl>
</div>
<div class="section" id="multitouch-library">
<h2>Multitouch Library<a class="headerlink" href="#multitouch-library" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.input_mt_slot">
struct <code class="descname">input_mt_slot</code><a class="headerlink" href="#c.input_mt_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>represents the state of an input MT slot</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_mt_slot {
  int abs[ABS_MT_LAST - ABS_MT_FIRST + 1];
  unsigned int frame;
  unsigned int key;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">abs</span></code></dt>
<dd>holds current values of ABS_MT axes for this slot</dd>
<dt><code class="docutils literal"><span class="pre">frame</span></code></dt>
<dd>last frame at which <a class="reference internal" href="#c.input_mt_report_slot_state" title="input_mt_report_slot_state"><code class="xref c c-func docutils literal"><span class="pre">input_mt_report_slot_state()</span></code></a> was called</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>optional driver designation of this slot</dd>
</dl>
<dl class="type">
<dt id="c.input_mt">
struct <code class="descname">input_mt</code><a class="headerlink" href="#c.input_mt" title="Permalink to this definition">¶</a></dt>
<dd><p>state of tracked contacts</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_mt {
  int trkid;
  int num_slots;
  int slot;
  unsigned int flags;
  unsigned int frame;
  int *red;
  struct input_mt_slot slots[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">trkid</span></code></dt>
<dd>stores MT tracking ID for the next contact</dd>
<dt><code class="docutils literal"><span class="pre">num_slots</span></code></dt>
<dd>number of MT slots the device uses</dd>
<dt><code class="docutils literal"><span class="pre">slot</span></code></dt>
<dd>MT slot currently being transmitted</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>input_mt operation flags</dd>
<dt><code class="docutils literal"><span class="pre">frame</span></code></dt>
<dd>increases every time <a class="reference internal" href="#c.input_mt_sync_frame" title="input_mt_sync_frame"><code class="xref c c-func docutils literal"><span class="pre">input_mt_sync_frame()</span></code></a> is called</dd>
<dt><code class="docutils literal"><span class="pre">red</span></code></dt>
<dd>reduced cost matrix for in-kernel tracking</dd>
<dt><code class="docutils literal"><span class="pre">slots</span></code></dt>
<dd>array of slots holding current values of tracked contacts</dd>
</dl>
<dl class="type">
<dt id="c.input_mt_pos">
struct <code class="descname">input_mt_pos</code><a class="headerlink" href="#c.input_mt_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>contact position</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_mt_pos {
  s16 x, y;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>horizontal coordinate</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>vertical coordinate</dd>
</dl>
<dl class="function">
<dt id="c.input_mt_init_slots">
int <code class="descname">input_mt_init_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num_slots</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_init_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize MT input slots</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device supporting MT events and finger tracking</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_slots</span></code></dt>
<dd>number of slots used by the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>mt tasks to handle in core</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates all necessary memory for MT slot handling
in the input device, prepares the ABS_MT_SLOT and
ABS_MT_TRACKING_ID events for use and sets up appropriate buffers.
Depending on the flags set, it also performs pointer emulation and
frame synchronization.</p>
<p>May be called repeatedly. Returns -EINVAL if attempting to
reinitialize with a different number of slots.</p>
<dl class="function">
<dt id="c.input_mt_destroy_slots">
void <code class="descname">input_mt_destroy_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_destroy_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>frees the MT slots of the input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is only needed in error path as the input core will
automatically free the MT slots when the device is destroyed.</p>
<dl class="function">
<dt id="c.input_mt_report_slot_state">
void <code class="descname">input_mt_report_slot_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;tool_type</em>, bool<em>&nbsp;active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_slot_state" title="Permalink to this definition">¶</a></dt>
<dd><p>report contact state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tool_type</span></code></dt>
<dd>the tool type to use in this slot</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">active</span></code></dt>
<dd>true if contact is active, false otherwise</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports a contact via ABS_MT_TRACKING_ID, and optionally
ABS_MT_TOOL_TYPE. If active is true and the slot is currently
inactive, or if the tool type is changed, a new tracking id is
assigned to the slot. The tool type is only reported if the
corresponding absbit field is set.</p>
<dl class="function">
<dt id="c.input_mt_report_finger_count">
void <code class="descname">input_mt_report_finger_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_finger_count" title="Permalink to this definition">¶</a></dt>
<dd><p>report contact count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of contacts</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,
BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP.</p>
<p>The input core ensures only the KEY events already setup for
this device will produce output.</p>
<dl class="function">
<dt id="c.input_mt_report_pointer_emulation">
void <code class="descname">input_mt_report_pointer_emulation</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, bool<em>&nbsp;use_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_pointer_emulation" title="Permalink to this definition">¶</a></dt>
<dd><p>common pointer emulation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">use_count</span></code></dt>
<dd>report number of active contacts as finger count</dd>
</dl>
<p><strong>Description</strong></p>
<p>Performs legacy pointer emulation via BTN_TOUCH, ABS_X, ABS_Y and
ABS_PRESSURE. Touchpad finger count is emulated if use_count is true.</p>
<p>The input core ensures only the KEY and ABS axes already setup for
this device will produce output.</p>
<dl class="function">
<dt id="c.input_mt_drop_unused">
void <code class="descname">input_mt_drop_unused</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_drop_unused" title="Permalink to this definition">¶</a></dt>
<dd><p>Inactivate slots not seen in this frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lift all slots not seen since the last call to this function.</p>
<dl class="function">
<dt id="c.input_mt_sync_frame">
void <code class="descname">input_mt_sync_frame</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_sync_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronize mt frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the frame and prepare the internal state for a new one.
Depending on the flags, marks unused slots as inactive and performs
pointer emulation.</p>
<dl class="function">
<dt id="c.input_mt_assign_slots">
int <code class="descname">input_mt_assign_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int *<em>&nbsp;slots</em>, const struct <a class="reference internal" href="#c.input_mt_pos" title="input_mt_pos">input_mt_pos</a> *<em>&nbsp;pos</em>, int<em>&nbsp;num_pos</em>, int<em>&nbsp;dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_assign_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a best-match assignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">slots</span></code></dt>
<dd>the slot assignment to be filled</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_mt_pos</span> <span class="pre">*</span> <span class="pre">pos</span></code></dt>
<dd>the position array to match</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_pos</span></code></dt>
<dd>number of positions</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dmax</span></code></dt>
<dd>maximum ABS_MT_POSITION displacement (zero for infinite)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Performs a best match against the current contacts and returns
the slot assignment list. New contacts are assigned to unused
slots.</p>
<p>The assignments are balanced so that all coordinate displacements are
below the euclidian distance dmax. If no such assignment can be found,
some contacts are assigned to unused slots.</p>
<p>Returns zero on success, or negative error in case of failure.</p>
<dl class="function">
<dt id="c.input_mt_get_slot_by_key">
int <code class="descname">input_mt_get_slot_by_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, int<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_get_slot_by_key" title="Permalink to this definition">¶</a></dt>
<dd><p>return slot matching key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>input device with allocated MT slots</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">key</span></code></dt>
<dd>the key of the sought slot</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the slot of the given key, if it exists, otherwise
set the key on the first unused slot and return.</p>
<p>If no available slot can be found, -1 is returned.
Note that for this function to work properly, <a class="reference internal" href="#c.input_mt_sync_frame" title="input_mt_sync_frame"><code class="xref c c-func docutils literal"><span class="pre">input_mt_sync_frame()</span></code></a> has
to be called at each frame.</p>
</div>
<div class="section" id="polled-input-devices">
<h2>Polled input devices<a class="headerlink" href="#polled-input-devices" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.input_polled_dev">
struct <code class="descname">input_polled_dev</code><a class="headerlink" href="#c.input_polled_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>simple polled input device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct input_polled_dev {
  void *private;
  void (*open)(struct input_polled_dev *dev);
  void (*close)(struct input_polled_dev *dev);
  void (*poll)(struct input_polled_dev *dev);
  unsigned int poll_interval;
  unsigned int poll_interval_max;
  unsigned int poll_interval_min;
  struct input_dev *input;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>private driver data.</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>driver-supplied method that prepares device for polling
(enabled the device and maybe flushes device state).</dd>
<dt><code class="docutils literal"><span class="pre">close</span></code></dt>
<dd>driver-supplied method that is called when device is no
longer being polled. Used to put device into low power mode.</dd>
<dt><code class="docutils literal"><span class="pre">poll</span></code></dt>
<dd>driver-supplied method that polls the device and posts
input events (mandatory).</dd>
<dt><code class="docutils literal"><span class="pre">poll_interval</span></code></dt>
<dd>specifies how often the <code class="xref c c-func docutils literal"><span class="pre">poll()</span></code> method should be called.
Defaults to 500 msec unless overridden when registering the device.</dd>
<dt><code class="docutils literal"><span class="pre">poll_interval_max</span></code></dt>
<dd>specifies upper bound for the poll interval.
Defaults to the initial value of <strong>poll_interval</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">poll_interval_min</span></code></dt>
<dd>specifies lower bound for the poll interval.
Defaults to 0.</dd>
<dt><code class="docutils literal"><span class="pre">input</span></code></dt>
<dd>input device structure associated with the polled device.
Must be properly initialized by the driver (id, name, phys, bits).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Polled input device provides a skeleton for supporting simple input
devices that do not raise interrupts but have to be periodically
scanned or polled to detect changes in their state.</p>
<dl class="function">
<dt id="c.input_allocate_polled_device">
struct <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev">input_polled_dev</a> * <code class="descname">input_allocate_polled_device</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.input_allocate_polled_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for polled device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function allocates memory for a polled device and also
for an input device associated with this polled device.</p>
<dl class="function">
<dt id="c.devm_input_allocate_polled_device">
struct <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev">input_polled_dev</a> * <code class="descname">devm_input_allocate_polled_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_input_allocate_polled_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate managed polled device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device owning the polled device being created</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns prepared <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">input_polled_dev</span></code></a> or <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p>Managed polled input devices do not need to be explicitly unregistered
or freed as it will be done automatically when owner device unbinds
from * its driver (or binding fails). Once such managed polled device
is allocated, it is ready to be set up and registered in the same
fashion as regular polled input devices (using
<a class="reference internal" href="#c.input_register_polled_device" title="input_register_polled_device"><code class="xref c c-func docutils literal"><span class="pre">input_register_polled_device()</span></code></a> function).</p>
<p>If you want to manually unregister and free such managed polled devices,
it can be still done by calling <a class="reference internal" href="#c.input_unregister_polled_device" title="input_unregister_polled_device"><code class="xref c c-func docutils literal"><span class="pre">input_unregister_polled_device()</span></code></a> and
<a class="reference internal" href="#c.input_free_polled_device" title="input_free_polled_device"><code class="xref c c-func docutils literal"><span class="pre">input_free_polled_device()</span></code></a>, although it is rarely needed.</p>
<p><strong>NOTE</strong></p>
<p>the owner device is set up as parent of input device and users
should not override it.</p>
<dl class="function">
<dt id="c.input_free_polled_device">
void <code class="descname">input_free_polled_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev">input_polled_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_free_polled_device" title="Permalink to this definition">¶</a></dt>
<dd><p>free memory allocated for polled device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_polled_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function frees memory allocated for polling device and drops
reference to the associated input device.</p>
<dl class="function">
<dt id="c.input_register_polled_device">
int <code class="descname">input_register_polled_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev">input_polled_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_polled_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register polled device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_polled_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function registers previously initialized polled input device
with input layer. The device should be allocated with call to
<a class="reference internal" href="#c.input_allocate_polled_device" title="input_allocate_polled_device"><code class="xref c c-func docutils literal"><span class="pre">input_allocate_polled_device()</span></code></a>. Callers should also set up <code class="xref c c-func docutils literal"><span class="pre">poll()</span></code>
method and set up capabilities (id, name, phys, bits) of the
corresponding input_dev structure.</p>
<dl class="function">
<dt id="c.input_unregister_polled_device">
void <code class="descname">input_unregister_polled_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_polled_dev" title="input_polled_dev">input_polled_dev</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_polled_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister polled device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_polled_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function unregisters previously registered polled input
device from input layer. Polling is stopped and device is
ready to be freed with call to <a class="reference internal" href="#c.input_free_polled_device" title="input_free_polled_device"><code class="xref c c-func docutils literal"><span class="pre">input_free_polled_device()</span></code></a>.</p>
</div>
<div class="section" id="matrix-keyboards-keypads">
<h2>Matrix keyboards/keypads<a class="headerlink" href="#matrix-keyboards-keypads" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.matrix_keymap_data">
struct <code class="descname">matrix_keymap_data</code><a class="headerlink" href="#c.matrix_keymap_data" title="Permalink to this definition">¶</a></dt>
<dd><p>keymap for matrix keyboards</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct matrix_keymap_data {
  const uint32_t *keymap;
  unsigned int    keymap_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">keymap</span></code></dt>
<dd>pointer to array of uint32 values encoded with <code class="xref c c-func docutils literal"><span class="pre">KEY()</span></code> macro
representing keymap</dd>
<dt><code class="docutils literal"><span class="pre">keymap_size</span></code></dt>
<dd>number of entries (initialized) in this keymap</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is supposed to be used by platform code to supply
keymaps to drivers that implement matrix-like keypads/keyboards.</p>
<dl class="type">
<dt id="c.matrix_keypad_platform_data">
struct <code class="descname">matrix_keypad_platform_data</code><a class="headerlink" href="#c.matrix_keypad_platform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>platform-dependent keypad data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct matrix_keypad_platform_data {
  const struct matrix_keymap_data *keymap_data;
  const unsigned int *row_gpios;
  const unsigned int *col_gpios;
  unsigned int    num_row_gpios;
  unsigned int    num_col_gpios;
  unsigned int    col_scan_delay_us;
  unsigned int    debounce_ms;
  unsigned int    clustered_irq;
  unsigned int    clustered_irq_flags;
  bool active_low;
  bool wakeup;
  bool no_autorepeat;
  bool drive_inactive_cols;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">keymap_data</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.matrix_keymap_data" title="matrix_keymap_data"><code class="xref c c-type docutils literal"><span class="pre">matrix_keymap_data</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">row_gpios</span></code></dt>
<dd>pointer to array of gpio numbers representing rows</dd>
<dt><code class="docutils literal"><span class="pre">col_gpios</span></code></dt>
<dd>pointer to array of gpio numbers reporesenting colums</dd>
<dt><code class="docutils literal"><span class="pre">num_row_gpios</span></code></dt>
<dd>actual number of row gpios used by device</dd>
<dt><code class="docutils literal"><span class="pre">num_col_gpios</span></code></dt>
<dd>actual number of col gpios used by device</dd>
<dt><code class="docutils literal"><span class="pre">col_scan_delay_us</span></code></dt>
<dd>delay, measured in microseconds, that is
needed before we can keypad after activating column gpio</dd>
<dt><code class="docutils literal"><span class="pre">debounce_ms</span></code></dt>
<dd>debounce interval in milliseconds</dd>
<dt><code class="docutils literal"><span class="pre">clustered_irq</span></code></dt>
<dd>may be specified if interrupts of all row/column GPIOs
are bundled to one single irq</dd>
<dt><code class="docutils literal"><span class="pre">clustered_irq_flags</span></code></dt>
<dd>flags that are needed for the clustered irq</dd>
<dt><code class="docutils literal"><span class="pre">active_low</span></code></dt>
<dd>gpio polarity</dd>
<dt><code class="docutils literal"><span class="pre">wakeup</span></code></dt>
<dd>controls whether the device should be set up as wakeup
source</dd>
<dt><code class="docutils literal"><span class="pre">no_autorepeat</span></code></dt>
<dd>disable key autorepeat</dd>
<dt><code class="docutils literal"><span class="pre">drive_inactive_cols</span></code></dt>
<dd>drive inactive columns during scan, rather than
making them inputs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents platform-specific data that use used by
matrix_keypad driver to perform proper initialization.</p>
</div>
<div class="section" id="sparse-keymap-support">
<h2>Sparse keymap support<a class="headerlink" href="#sparse-keymap-support" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.key_entry">
struct <code class="descname">key_entry</code><a class="headerlink" href="#c.key_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>keymap entry for use in sparse keymap</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct key_entry {
  int type;
  u32 code;
  union {
    u16 keycode;
    struct {
      u8 code;
      u8 value;
    } sw;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of the key entry (KE_KEY, KE_SW, KE_VSW, KE_END);
drivers are allowed to extend the list with their own
private definitions.</dd>
<dt><code class="docutils literal"><span class="pre">code</span></code></dt>
<dd>Device-specific data identifying the button/switch</dd>
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">keycode</span></code></dt>
<dd>KEY_* code assigned to a key/button</dd>
<dt><code class="docutils literal"><span class="pre">sw.code</span></code></dt>
<dd>SW_* code assigned to a switch</dd>
<dt><code class="docutils literal"><span class="pre">sw.value</span></code></dt>
<dd>Value that should be sent in an input even when KE_SW
switch is toggled. KE_VSW switches ignore this field and
expect driver to supply value for the event.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines an entry in a sparse keymap used by some
input devices for which traditional table-based approach is not
suitable.</p>
<dl class="function">
<dt id="c.sparse_keymap_entry_from_scancode">
struct <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> * <code class="descname">sparse_keymap_entry_from_scancode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_entry_from_scancode" title="Permalink to this definition">¶</a></dt>
<dd><p>perform sparse keymap lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Input device using sparse keymap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>Scan code</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a> lookup in an
input device using sparse keymap.</p>
<dl class="function">
<dt id="c.sparse_keymap_entry_from_keycode">
struct <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> * <code class="descname">sparse_keymap_entry_from_keycode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;keycode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_entry_from_keycode" title="Permalink to this definition">¶</a></dt>
<dd><p>perform sparse keymap lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Input device using sparse keymap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keycode</span></code></dt>
<dd>Key code</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a> lookup in an
input device using sparse keymap.</p>
<dl class="function">
<dt id="c.sparse_keymap_setup">
int <code class="descname">sparse_keymap_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<em>&nbsp;keymap</em>, int (*setup) (struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a><em>&nbsp;*</em>, struct <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a><em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>set up sparse keymap for an input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Input device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*</span> <span class="pre">keymap</span></code></dt>
<dd>Keymap in form of array of <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal"><span class="pre">key_entry</span></code></a> structures ending
with <code class="docutils literal"><span class="pre">KE_END</span></code> type entry</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">input_dev</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*)</span> <span class="pre">setup</span></code></dt>
<dd>Function that can be used to adjust keymap entries
depending on device’s needs, may be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>The function calculates size and allocates copy of the original
keymap after which sets up input device event bits appropriately.
The allocated copy of the keymap is automatically freed when it
is no longer needed.</p>
<dl class="function">
<dt id="c.sparse_keymap_report_entry">
void <code class="descname">sparse_keymap_report_entry</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<em>&nbsp;ke</em>, unsigned int<em>&nbsp;value</em>, bool<em>&nbsp;autorelease</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_report_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>report event corresponding to given key entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Input device for which event should be reported</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*</span> <span class="pre">ke</span></code></dt>
<dd>key entry describing event</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>Value that should be reported (ignored by <code class="docutils literal"><span class="pre">KE_SW</span></code> entries)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">autorelease</span></code></dt>
<dd>Signals whether release event should be emitted for <code class="docutils literal"><span class="pre">KE_KEY</span></code>
entries right after reporting press event, ignored by all other
entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to report input event described by given
<a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a>.</p>
<dl class="function">
<dt id="c.sparse_keymap_report_event">
bool <code class="descname">sparse_keymap_report_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;code</em>, unsigned int<em>&nbsp;value</em>, bool<em>&nbsp;autorelease</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_report_event" title="Permalink to this definition">¶</a></dt>
<dd><p>report event corresponding to given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Input device using sparse keymap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>Scan code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>Value that should be reported (ignored by <code class="docutils literal"><span class="pre">KE_SW</span></code> entries)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">autorelease</span></code></dt>
<dd>Signals whether release event should be emitted for <code class="docutils literal"><span class="pre">KE_KEY</span></code>
entries right after reporting press event, ignored by all other
entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform lookup in an input device using sparse
keymap and report corresponding event. Returns <code class="docutils literal"><span class="pre">true</span></code> if lookup was
successful and <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="usb/index.html" class="btn btn-neutral float-right" title="Linux USB API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="iio/hw-consumer.html" class="btn btn-neutral" title="HW consumer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.16.0-rc1+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>