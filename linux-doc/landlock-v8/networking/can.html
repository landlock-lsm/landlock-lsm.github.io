

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SocketCAN - Controller Area Network &mdash; The Linux Kernel 4.16.0-rc1+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.16.0-rc1+ documentation" href="../index.html"/>
        <link rel="up" title="Linux Networking Documentation" href="index.html"/>
        <link rel="next" title="Linux Networking and Network Devices APIs" href="kapi.html"/>
        <link rel="prev" title="batman-adv" href="batman-adv.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SocketCAN - Controller Area Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview-what-is-socketcan">Overview / What is SocketCAN</a></li>
<li class="toctree-l3"><a class="reference internal" href="#motivation-why-using-the-socket-api">Motivation / Why Using the Socket API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#socketcan-concept">SocketCAN Concept</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#receive-lists">Receive Lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-loopback-of-sent-frames">Local Loopback of Sent Frames</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network-problem-notifications">Network Problem Notifications</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-use-socketcan">How to use SocketCAN</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#raw-protocol-sockets-with-can-filters-sock-raw">RAW Protocol Sockets with can_filters (SOCK_RAW)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#broadcast-manager-protocol-sockets-sock-dgram">Broadcast Manager Protocol Sockets (SOCK_DGRAM)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connected-transport-protocols-sock-seqpacket">Connected Transport Protocols (SOCK_SEQPACKET)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unconnected-transport-protocols-sock-dgram">Unconnected Transport Protocols (SOCK_DGRAM)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#socketcan-core-module">SocketCAN Core Module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#can-ko-module-params">can.ko Module Params</a></li>
<li class="toctree-l4"><a class="reference internal" href="#procfs-content">procfs content</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-own-can-protocol-modules">Writing Own CAN Protocol Modules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#can-network-drivers">CAN Network Drivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#general-settings">General Settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#socketcan-local-loopback2">Local Loopback of Sent Frames</a></li>
<li class="toctree-l4"><a class="reference internal" href="#can-controller-hardware-filters">CAN Controller Hardware Filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-virtual-can-driver-vcan">The Virtual CAN Driver (vcan)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-can-network-device-driver-interface">The CAN Network Device Driver Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#can-fd-flexible-data-rate-driver-support">CAN FD (Flexible Data Rate) Driver Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-can-hardware">Supported CAN Hardware</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#socketcan-resources">SocketCAN Resources</a></li>
<li class="toctree-l3"><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="z8530book.html">Z8530 Programming Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>SocketCAN - Controller Area Network</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/can.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="socketcan-controller-area-network">
<h1>SocketCAN - Controller Area Network<a class="headerlink" href="#socketcan-controller-area-network" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview-what-is-socketcan">
<h2>Overview / What is SocketCAN<a class="headerlink" href="#overview-what-is-socketcan" title="Permalink to this headline">¶</a></h2>
<p>The socketcan package is an implementation of CAN protocols
(Controller Area Network) for Linux.  CAN is a networking technology
which has widespread use in automation, embedded devices, and
automotive fields.  While there have been other CAN implementations
for Linux based on character devices, SocketCAN uses the Berkeley
socket API, the Linux network stack and implements the CAN device
drivers as network interfaces.  The CAN socket API has been designed
as similar as possible to the TCP/IP protocols to allow programmers,
familiar with network programming, to easily learn how to use CAN
sockets.</p>
</div>
<div class="section" id="motivation-why-using-the-socket-api">
<span id="socketcan-motivation"></span><h2>Motivation / Why Using the Socket API<a class="headerlink" href="#motivation-why-using-the-socket-api" title="Permalink to this headline">¶</a></h2>
<p>There have been CAN implementations for Linux before SocketCAN so the
question arises, why we have started another project.  Most existing
implementations come as a device driver for some CAN hardware, they
are based on character devices and provide comparatively little
functionality.  Usually, there is only a hardware-specific device
driver which provides a character device interface to send and
receive raw CAN frames, directly to/from the controller hardware.
Queueing of frames and higher-level transport protocols like ISO-TP
have to be implemented in user space applications.  Also, most
character-device implementations support only one single process to
open the device at a time, similar to a serial interface.  Exchanging
the CAN controller requires employment of another device driver and
often the need for adaption of large parts of the application to the
new driver’s API.</p>
<p>SocketCAN was designed to overcome all of these limitations.  A new
protocol family has been implemented which provides a socket interface
to user space applications and which builds upon the Linux network
layer, enabling use all of the provided queueing functionality.  A device
driver for CAN controller hardware registers itself with the Linux
network layer as a network device, so that CAN frames from the
controller can be passed up to the network layer and on to the CAN
protocol family module and also vice-versa.  Also, the protocol family
module provides an API for transport protocol modules to register, so
that any number of transport protocols can be loaded or unloaded
dynamically.  In fact, the can core module alone does not provide any
protocol and cannot be used without loading at least one additional
protocol module.  Multiple sockets can be opened at the same time,
on different or the same protocol module and they can listen/send
frames on different or the same CAN IDs.  Several sockets listening on
the same interface for frames with the same CAN ID are all passed the
same received matching CAN frames.  An application wishing to
communicate using a specific transport protocol, e.g. ISO-TP, just
selects that protocol when opening the socket, and then can read and
write application data byte streams, without having to deal with
CAN-IDs, frames, etc.</p>
<p>Similar functionality visible from user-space could be provided by a
character device, too, but this would lead to a technically inelegant
solution for a couple of reasons:</p>
<ul>
<li><p class="first"><strong>Intricate usage:</strong>  Instead of passing a protocol argument to
socket(2) and using bind(2) to select a CAN interface and CAN ID, an
application would have to do all these operations using ioctl(2)s.</p>
</li>
<li><p class="first"><strong>Code duplication:</strong>  A character device cannot make use of the Linux
network queueing code, so all that code would have to be duplicated
for CAN networking.</p>
</li>
<li><p class="first"><strong>Abstraction:</strong>  In most existing character-device implementations, the
hardware-specific device driver for a CAN controller directly
provides the character device for the application to work with.
This is at least very unusual in Unix systems for both, char and
block devices.  For example you don’t have a character device for a
certain UART of a serial interface, a certain sound chip in your
computer, a SCSI or IDE controller providing access to your hard
disk or tape streamer device.  Instead, you have abstraction layers
which provide a unified character or block device interface to the
application on the one hand, and a interface for hardware-specific
device drivers on the other hand.  These abstractions are provided
by subsystems like the tty layer, the audio subsystem or the SCSI
and IDE subsystems for the devices mentioned above.</p>
<p>The easiest way to implement a CAN device driver is as a character
device without such a (complete) abstraction layer, as is done by most
existing drivers.  The right way, however, would be to add such a
layer with all the functionality like registering for certain CAN
IDs, supporting several open file descriptors and (de)multiplexing
CAN frames between them, (sophisticated) queueing of CAN frames, and
providing an API for device drivers to register with.  However, then
it would be no more difficult, or may be even easier, to use the
networking framework provided by the Linux kernel, and this is what
SocketCAN does.</p>
</li>
</ul>
<p>The use of the networking framework of the Linux kernel is just the
natural and most appropriate way to implement CAN for Linux.</p>
</div>
<div class="section" id="socketcan-concept">
<span id="id1"></span><h2>SocketCAN Concept<a class="headerlink" href="#socketcan-concept" title="Permalink to this headline">¶</a></h2>
<p>As described in <a class="reference internal" href="#socketcan-motivation"><span class="std std-ref">Motivation / Why Using the Socket API</span></a> the main goal of SocketCAN is to
provide a socket interface to user space applications which builds
upon the Linux network layer. In contrast to the commonly known
TCP/IP and ethernet networking, the CAN bus is a broadcast-only(!)
medium that has no MAC-layer addressing like ethernet. The CAN-identifier
(can_id) is used for arbitration on the CAN-bus. Therefore the CAN-IDs
have to be chosen uniquely on the bus. When designing a CAN-ECU
network the CAN-IDs are mapped to be sent by a specific ECU.
For this reason a CAN-ID can be treated best as a kind of source address.</p>
<div class="section" id="receive-lists">
<span id="socketcan-receive-lists"></span><h3>Receive Lists<a class="headerlink" href="#receive-lists" title="Permalink to this headline">¶</a></h3>
<p>The network transparent access of multiple applications leads to the
problem that different applications may be interested in the same
CAN-IDs from the same CAN network interface. The SocketCAN core
module - which implements the protocol family CAN - provides several
high efficient receive lists for this reason. If e.g. a user space
application opens a CAN RAW socket, the raw protocol module itself
requests the (range of) CAN-IDs from the SocketCAN core that are
requested by the user. The subscription and unsubscription of
CAN-IDs can be done for specific CAN interfaces or for all(!) known
CAN interfaces with the can_rx_(un)register() functions provided to
CAN protocol modules by the SocketCAN core (see <a class="reference internal" href="#socketcan-core-module"><span class="std std-ref">SocketCAN Core Module</span></a>).
To optimize the CPU usage at runtime the receive lists are split up
into several specific lists per device that match the requested
filter complexity for a given use-case.</p>
</div>
<div class="section" id="local-loopback-of-sent-frames">
<span id="socketcan-local-loopback1"></span><h3>Local Loopback of Sent Frames<a class="headerlink" href="#local-loopback-of-sent-frames" title="Permalink to this headline">¶</a></h3>
<p>As known from other networking concepts the data exchanging
applications may run on the same or different nodes without any
change (except for the according addressing information):</p>
<div class="code highlight-none"><div class="highlight"><pre><span></span> ___   ___   ___                   _______   ___
| _ | | _ | | _ |                 | _   _ | | _ |
||A|| ||B|| ||C||                 ||A| |B|| ||C||
|___| |___| |___|                 |_______| |___|
  |     |     |                       |       |
-----------------(1)- CAN bus -(2)---------------
</pre></div>
</div>
<p>To ensure that application A receives the same information in the
example (2) as it would receive in example (1) there is need for
some kind of local loopback of the sent CAN frames on the appropriate
node.</p>
<p>The Linux network devices (by default) just can handle the
transmission and reception of media dependent frames. Due to the
arbitration on the CAN bus the transmission of a low prio CAN-ID
may be delayed by the reception of a high prio CAN frame. To
reflect the correct <a class="footnote-reference" href="#id3" id="id2">[*]</a> traffic on the node the loopback of the sent
data has to be performed right after a successful transmission. If
the CAN network interface is not capable of performing the loopback for
some reason the SocketCAN core can do this task as a fallback solution.
See <a class="reference internal" href="#socketcan-local-loopback1"><span class="std std-ref">Local Loopback of Sent Frames</span></a> for details (recommended).</p>
<p>The loopback functionality is enabled by default to reflect standard
networking behaviour for CAN applications. Due to some requests from
the RT-SocketCAN group the loopback optionally may be disabled for each
separate socket. See sockopts from the CAN RAW sockets in <a class="reference internal" href="#socketcan-raw-sockets"><span class="std std-ref">RAW Protocol Sockets with can_filters (SOCK_RAW)</span></a>.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[*]</a></td><td>you really like to have this when you’re running analyser
tools like ‘candump’ or ‘cansniffer’ on the (same) node.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="network-problem-notifications">
<span id="socketcan-network-problem-notifications"></span><h3>Network Problem Notifications<a class="headerlink" href="#network-problem-notifications" title="Permalink to this headline">¶</a></h3>
<p>The use of the CAN bus may lead to several problems on the physical
and media access control layer. Detecting and logging of these lower
layer problems is a vital requirement for CAN users to identify
hardware issues on the physical transceiver layer as well as
arbitration problems and error frames caused by the different
ECUs. The occurrence of detected errors are important for diagnosis
and have to be logged together with the exact timestamp. For this
reason the CAN interface driver can generate so called Error Message
Frames that can optionally be passed to the user application in the
same way as other CAN frames. Whenever an error on the physical layer
or the MAC layer is detected (e.g. by the CAN controller) the driver
creates an appropriate error message frame. Error messages frames can
be requested by the user application using the common CAN filter
mechanisms. Inside this filter definition the (interested) type of
errors may be selected. The reception of error messages is disabled
by default. The format of the CAN error message frame is briefly
described in the Linux header file “include/uapi/linux/can/error.h”.</p>
</div>
</div>
<div class="section" id="how-to-use-socketcan">
<h2>How to use SocketCAN<a class="headerlink" href="#how-to-use-socketcan" title="Permalink to this headline">¶</a></h2>
<p>Like TCP/IP, you first need to open a socket for communicating over a
CAN network. Since SocketCAN implements a new protocol family, you
need to pass PF_CAN as the first argument to the socket(2) system
call. Currently, there are two CAN protocols to choose from, the raw
socket protocol and the broadcast manager (BCM). So to open a socket,
you would write:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
</pre></div>
</div>
<p>and:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>s = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);
</pre></div>
</div>
<p>respectively.  After the successful creation of the socket, you would
normally use the bind(2) system call to bind the socket to a CAN
interface (which is different from TCP/IP due to different addressing
- see <a class="reference internal" href="#socketcan-concept"><span class="std std-ref">SocketCAN Concept</span></a>). After binding (CAN_RAW) or connecting (CAN_BCM)
the socket, you can read(2) and write(2) from/to the socket or use
send(2), sendto(2), sendmsg(2) and the recv* counterpart operations
on the socket as usual. There are also CAN specific socket options
described below.</p>
<p>The basic CAN frame structure and the sockaddr structure are defined
in include/linux/can.h:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">can_frame</span> <span class="p">{</span>
        <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">;</span>  <span class="cm">/* 32 bit CAN_ID + EFF/RTR/ERR flags */</span>
        <span class="n">__u8</span>    <span class="n">can_dlc</span><span class="p">;</span> <span class="cm">/* frame payload length in byte (0 .. 8) */</span>
        <span class="n">__u8</span>    <span class="n">__pad</span><span class="p">;</span>   <span class="cm">/* padding */</span>
        <span class="n">__u8</span>    <span class="n">__res0</span><span class="p">;</span>  <span class="cm">/* reserved / padding */</span>
        <span class="n">__u8</span>    <span class="n">__res1</span><span class="p">;</span>  <span class="cm">/* reserved / padding */</span>
        <span class="n">__u8</span>    <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The alignment of the (linear) payload data[] to a 64bit boundary
allows the user to define their own structs and unions to easily access
the CAN payload. There is no given byteorder on the CAN bus by
default. A read(2) system call on a CAN_RAW socket transfers a
struct can_frame to the user space.</p>
<p>The sockaddr_can structure has an interface index like the
PF_PACKET socket, that also binds to a specific interface:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="p">{</span>
        <span class="n">sa_family_t</span> <span class="n">can_family</span><span class="p">;</span>
        <span class="kt">int</span>         <span class="n">can_ifindex</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="cm">/* transport protocol class address info (e.g. ISOTP) */</span>
                <span class="k">struct</span> <span class="p">{</span> <span class="n">canid_t</span> <span class="n">rx_id</span><span class="p">,</span> <span class="n">tx_id</span><span class="p">;</span> <span class="p">}</span> <span class="n">tp</span><span class="p">;</span>

                <span class="cm">/* reserved for future CAN protocols address information */</span>
        <span class="p">}</span> <span class="n">can_addr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To determine the interface index an appropriate ioctl() has to
be used (example for CAN_RAW sockets without error checking):</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="n">addr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_CAN</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">CAN_RAW</span><span class="p">);</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="s">&quot;can0&quot;</span> <span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCGIFINDEX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>

<span class="n">addr</span><span class="p">.</span><span class="n">can_family</span> <span class="o">=</span> <span class="n">AF_CAN</span><span class="p">;</span>
<span class="n">addr</span><span class="p">.</span><span class="n">can_ifindex</span> <span class="o">=</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span><span class="p">;</span>

<span class="n">bind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="p">(..)</span>
</pre></div>
</div>
<p>To bind a socket to all(!) CAN interfaces the interface index must
be 0 (zero). In this case the socket receives CAN frames from every
enabled CAN interface. To determine the originating CAN interface
the system call recvfrom(2) may be used instead of read(2). To send
on a socket that is bound to ‘any’ interface sendto(2) is needed to
specify the outgoing interface.</p>
<p>Reading CAN frames from a bound CAN_RAW socket (see above) consists
of reading a struct can_frame:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">can_frame</span> <span class="n">frame</span><span class="p">;</span>

<span class="n">nbytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">));</span>

<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;can raw socket read&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* paranoid check ... */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;read: incomplete CAN frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* do something with the received CAN frame */</span>
</pre></div>
</div>
<p>Writing CAN frames can be done similarly, with the write(2) system call:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>nbytes = write(s, &amp;frame, sizeof(struct can_frame));
</pre></div>
</div>
<p>When the CAN interface is bound to ‘any’ existing CAN interface
(addr.can_ifindex = 0) it is recommended to use recvfrom(2) if the
information about the originating CAN interface is needed:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="n">addr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
<span class="kt">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">can_frame</span> <span class="n">frame</span><span class="p">;</span>

<span class="n">nbytes</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">),</span>
                  <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

<span class="cm">/* get interface name of the received CAN frame */</span>
<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span> <span class="o">=</span> <span class="n">addr</span><span class="p">.</span><span class="n">can_ifindex</span><span class="p">;</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCGIFNAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received a CAN frame from interface %s&quot;</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
</pre></div>
</div>
<p>To write CAN frames on sockets bound to ‘any’ CAN interface the
outgoing interface has to be defined certainly:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="s">&quot;can0&quot;</span><span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCGIFINDEX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
<span class="n">addr</span><span class="p">.</span><span class="n">can_ifindex</span> <span class="o">=</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span><span class="p">;</span>
<span class="n">addr</span><span class="p">.</span><span class="n">can_family</span>  <span class="o">=</span> <span class="n">AF_CAN</span><span class="p">;</span>

<span class="n">nbytes</span> <span class="o">=</span> <span class="n">sendto</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
</pre></div>
</div>
<p>An accurate timestamp can be obtained with an ioctl(2) call after reading
a message from the socket:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCGSTAMP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
</pre></div>
</div>
<p>The timestamp has a resolution of one microsecond and is set automatically
at the reception of a CAN frame.</p>
<p>Remark about CAN FD (flexible data rate) support:</p>
<p>Generally the handling of CAN FD is very similar to the formerly described
examples. The new CAN FD capable CAN controllers support two different
bitrates for the arbitration phase and the payload phase of the CAN FD frame
and up to 64 bytes of payload. This extended payload length breaks all the
kernel interfaces (ABI) which heavily rely on the CAN frame with fixed eight
bytes of payload (struct can_frame) like the CAN_RAW socket. Therefore e.g.
the CAN_RAW socket supports a new socket option CAN_RAW_FD_FRAMES that
switches the socket into a mode that allows the handling of CAN FD frames
and (legacy) CAN frames simultaneously (see <a class="reference internal" href="#socketcan-rawfd"><span class="std std-ref">RAW Socket Option CAN_RAW_FD_FRAMES</span></a>).</p>
<p>The struct canfd_frame is defined in include/linux/can.h:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">canfd_frame</span> <span class="p">{</span>
        <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">;</span>  <span class="cm">/* 32 bit CAN_ID + EFF/RTR/ERR flags */</span>
        <span class="n">__u8</span>    <span class="n">len</span><span class="p">;</span>     <span class="cm">/* frame payload length in byte (0 .. 64) */</span>
        <span class="n">__u8</span>    <span class="n">flags</span><span class="p">;</span>   <span class="cm">/* additional flags for CAN FD */</span>
        <span class="n">__u8</span>    <span class="n">__res0</span><span class="p">;</span>  <span class="cm">/* reserved / padding */</span>
        <span class="n">__u8</span>    <span class="n">__res1</span><span class="p">;</span>  <span class="cm">/* reserved / padding */</span>
        <span class="n">__u8</span>    <span class="n">data</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The struct canfd_frame and the existing struct can_frame have the can_id,
the payload length and the payload data at the same offset inside their
structures. This allows to handle the different structures very similar.
When the content of a struct can_frame is copied into a struct canfd_frame
all structure elements can be used as-is - only the data[] becomes extended.</p>
<p>When introducing the struct canfd_frame it turned out that the data length
code (DLC) of the struct can_frame was used as a length information as the
length and the DLC has a 1:1 mapping in the range of 0 .. 8. To preserve
the easy handling of the length information the canfd_frame.len element
contains a plain length value from 0 .. 64. So both canfd_frame.len and
can_frame.can_dlc are equal and contain a length information and no DLC.
For details about the distinction of CAN and CAN FD capable devices and
the mapping to the bus-relevant data length code (DLC), see <a class="reference internal" href="#socketcan-can-fd-driver"><span class="std std-ref">CAN FD (Flexible Data Rate) Driver Support</span></a>.</p>
<p>The length of the two CAN(FD) frame structures define the maximum transfer
unit (MTU) of the CAN(FD) network interface and skbuff data length. Two
definitions are specified for CAN specific MTUs in include/linux/can.h:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="cp">#define CAN_MTU   (sizeof(struct can_frame))   == 16  =&gt; &#39;legacy&#39; CAN frame</span>
<span class="cp">#define CANFD_MTU (sizeof(struct canfd_frame)) == 72  =&gt; CAN FD frame</span>
</pre></div>
</div>
<div class="section" id="raw-protocol-sockets-with-can-filters-sock-raw">
<span id="socketcan-raw-sockets"></span><h3>RAW Protocol Sockets with can_filters (SOCK_RAW)<a class="headerlink" href="#raw-protocol-sockets-with-can-filters-sock-raw" title="Permalink to this headline">¶</a></h3>
<p>Using CAN_RAW sockets is extensively comparable to the commonly
known access to CAN character devices. To meet the new possibilities
provided by the multi user SocketCAN approach, some reasonable
defaults are set at RAW socket binding time:</p>
<ul class="simple">
<li>The filters are set to exactly one filter receiving everything</li>
<li>The socket only receives valid data frames (=&gt; no error message frames)</li>
<li>The loopback of sent CAN frames is enabled (see <a class="reference internal" href="#socketcan-local-loopback2"><span class="std std-ref">Local Loopback of Sent Frames</span></a>)</li>
<li>The socket does not receive its own sent frames (in loopback mode)</li>
</ul>
<p>These default settings may be changed before or after binding the socket.
To use the referenced definitions of the socket options for CAN_RAW
sockets, include &lt;linux/can/raw.h&gt;.</p>
<div class="section" id="raw-socket-option-can-raw-filter">
<span id="socketcan-rawfilter"></span><h4>RAW socket option CAN_RAW_FILTER<a class="headerlink" href="#raw-socket-option-can-raw-filter" title="Permalink to this headline">¶</a></h4>
<p>The reception of CAN frames using CAN_RAW sockets can be controlled
by defining 0 .. n filters with the CAN_RAW_FILTER socket option.</p>
<p>The CAN filter structure is defined in include/linux/can.h:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">can_filter</span> <span class="p">{</span>
        <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">;</span>
        <span class="n">canid_t</span> <span class="n">can_mask</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A filter matches, when:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">received_can_id</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">==</span> <span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">mask</span>
</pre></div>
</div>
<p>which is analogous to known CAN controllers hardware filter semantics.
The filter can be inverted in this semantic, when the CAN_INV_FILTER
bit is set in can_id element of the can_filter structure. In
contrast to CAN controller hardware filters the user may set 0 .. n
receive filters for each open socket separately:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">can_filter</span> <span class="n">rfilter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_id</span>   <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_mask</span> <span class="o">=</span> <span class="n">CAN_SFF_MASK</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">can_id</span>   <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">can_mask</span> <span class="o">=</span> <span class="mh">0x700</span><span class="p">;</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_FILTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfilter</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rfilter</span><span class="p">));</span>
</pre></div>
</div>
<p>To disable the reception of CAN frames on the selected CAN_RAW socket:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_FILTER</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>To set the filters to zero filters is quite obsolete as to not read
data causes the raw socket to discard the received CAN frames. But
having this ‘send only’ use-case we may remove the receive list in the
Kernel to save a little (really a very little!) CPU usage.</p>
<div class="section" id="can-filter-usage-optimisation">
<h5>CAN Filter Usage Optimisation<a class="headerlink" href="#can-filter-usage-optimisation" title="Permalink to this headline">¶</a></h5>
<p>The CAN filters are processed in per-device filter lists at CAN frame
reception time. To reduce the number of checks that need to be performed
while walking through the filter lists the CAN core provides an optimized
filter handling when the filter subscription focusses on a single CAN ID.</p>
<p>For the possible 2048 SFF CAN identifiers the identifier is used as an index
to access the corresponding subscription list without any further checks.
For the 2^29 possible EFF CAN identifiers a 10 bit XOR folding is used as
hash function to retrieve the EFF table index.</p>
<p>To benefit from the optimized filters for single CAN identifiers the
CAN_SFF_MASK or CAN_EFF_MASK have to be set into can_filter.mask together
with set CAN_EFF_FLAG and CAN_RTR_FLAG bits. A set CAN_EFF_FLAG bit in the
can_filter.mask makes clear that it matters whether a SFF or EFF CAN ID is
subscribed. E.g. in the example from above:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_id</span>   <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_mask</span> <span class="o">=</span> <span class="n">CAN_SFF_MASK</span><span class="p">;</span>
</pre></div>
</div>
<p>both SFF frames with CAN ID 0x123 and EFF frames with 0xXXXXX123 can pass.</p>
<p>To filter for only 0x123 (SFF) and 0x12345678 (EFF) CAN identifiers the
filter has to be defined in this way to benefit from the optimized filters:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">can_filter</span> <span class="n">rfilter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_id</span>   <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">can_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">CAN_EFF_FLAG</span> <span class="o">|</span> <span class="n">CAN_RTR_FLAG</span> <span class="o">|</span> <span class="n">CAN_SFF_MASK</span><span class="p">);</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">can_id</span>   <span class="o">=</span> <span class="mh">0x12345678</span> <span class="o">|</span> <span class="n">CAN_EFF_FLAG</span><span class="p">;</span>
<span class="n">rfilter</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">can_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">CAN_EFF_FLAG</span> <span class="o">|</span> <span class="n">CAN_RTR_FLAG</span> <span class="o">|</span> <span class="n">CAN_EFF_MASK</span><span class="p">);</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_FILTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfilter</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rfilter</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="raw-socket-option-can-raw-err-filter">
<h4>RAW Socket Option CAN_RAW_ERR_FILTER<a class="headerlink" href="#raw-socket-option-can-raw-err-filter" title="Permalink to this headline">¶</a></h4>
<p>As described in <a class="reference internal" href="#socketcan-network-problem-notifications"><span class="std std-ref">Network Problem Notifications</span></a> the CAN interface driver can generate so
called Error Message Frames that can optionally be passed to the user
application in the same way as other CAN frames. The possible
errors are divided into different error classes that may be filtered
using the appropriate error mask. To register for every possible
error condition CAN_ERR_MASK can be used as value for the error mask.
The values for the error mask are defined in linux/can/error.h:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">can_err_mask_t</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="n">CAN_ERR_TX_TIMEOUT</span> <span class="o">|</span> <span class="n">CAN_ERR_BUSOFF</span> <span class="p">);</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_ERR_FILTER</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">err_mask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">err_mask</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="raw-socket-option-can-raw-loopback">
<h4>RAW Socket Option CAN_RAW_LOOPBACK<a class="headerlink" href="#raw-socket-option-can-raw-loopback" title="Permalink to this headline">¶</a></h4>
<p>To meet multi user needs the local loopback is enabled by default
(see <a class="reference internal" href="#socketcan-local-loopback1"><span class="std std-ref">Local Loopback of Sent Frames</span></a> for details). But in some embedded use-cases
(e.g. when only one application uses the CAN bus) this loopback
functionality can be disabled (separately for each socket):</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">loopback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 0 = disabled, 1 = enabled (default) */</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_LOOPBACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loopback</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loopback</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="raw-socket-option-can-raw-recv-own-msgs">
<h4>RAW socket option CAN_RAW_RECV_OWN_MSGS<a class="headerlink" href="#raw-socket-option-can-raw-recv-own-msgs" title="Permalink to this headline">¶</a></h4>
<p>When the local loopback is enabled, all the sent CAN frames are
looped back to the open CAN sockets that registered for the CAN
frames’ CAN-ID on this given interface to meet the multi user
needs. The reception of the CAN frames on the same socket that was
sending the CAN frame is assumed to be unwanted and therefore
disabled by default. This default behaviour may be changed on
demand:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">recv_own_msgs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 0 = disabled (default), 1 = enabled */</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SOL_CAN_RAW</span><span class="p">,</span> <span class="n">CAN_RAW_RECV_OWN_MSGS</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">recv_own_msgs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recv_own_msgs</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="raw-socket-option-can-raw-fd-frames">
<span id="socketcan-rawfd"></span><h4>RAW Socket Option CAN_RAW_FD_FRAMES<a class="headerlink" href="#raw-socket-option-can-raw-fd-frames" title="Permalink to this headline">¶</a></h4>
<p>CAN FD support in CAN_RAW sockets can be enabled with a new socket option
CAN_RAW_FD_FRAMES which is off by default. When the new socket option is
not supported by the CAN_RAW socket (e.g. on older kernels), switching the
CAN_RAW_FD_FRAMES option returns the error -ENOPROTOOPT.</p>
<p>Once CAN_RAW_FD_FRAMES is enabled the application can send both CAN frames
and CAN FD frames. OTOH the application has to handle CAN and CAN FD frames
when reading from the socket:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">CAN_RAW_FD_FRAMES</span> <span class="nl">enabled</span><span class="p">:</span>  <span class="n">CAN_MTU</span> <span class="n">and</span> <span class="n">CANFD_MTU</span> <span class="n">are</span> <span class="n">allowed</span>
<span class="n">CAN_RAW_FD_FRAMES</span> <span class="nl">disabled</span><span class="p">:</span> <span class="n">only</span> <span class="n">CAN_MTU</span> <span class="n">is</span> <span class="n">allowed</span> <span class="p">(</span><span class="k">default</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="nl">remember</span><span class="p">:</span> <span class="n">CANFD_MTU</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">canfd_frame</span><span class="p">)</span> <span class="p">]</span>

<span class="k">struct</span> <span class="n">canfd_frame</span> <span class="n">cfd</span><span class="p">;</span>

<span class="n">nbytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfd</span><span class="p">,</span> <span class="n">CANFD_MTU</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">==</span> <span class="n">CANFD_MTU</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;got CAN FD frame with length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfd</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
        <span class="cm">/* cfd.flags contains valid data */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">==</span> <span class="n">CAN_MTU</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;got legacy CAN frame with length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfd</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
        <span class="cm">/* cfd.flags is undefined */</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;read: invalid CAN(FD) frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the content can be handled independently from the received MTU size */</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;can_id: %X data length: %d data: &quot;</span><span class="p">,</span> <span class="n">cfd</span><span class="p">.</span><span class="n">can_id</span><span class="p">,</span> <span class="n">cfd</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cfd</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%02X &quot;</span><span class="p">,</span> <span class="n">cfd</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</pre></div>
</div>
<p>When reading with size CANFD_MTU only returns CAN_MTU bytes that have
been received from the socket a legacy CAN frame has been read into the
provided CAN FD structure. Note that the canfd_frame.flags data field is
not specified in the struct can_frame and therefore it is only valid in
CANFD_MTU sized CAN FD frames.</p>
<p>Implementation hint for new CAN applications:</p>
<p>To build a CAN FD aware application use struct canfd_frame as basic CAN
data structure for CAN_RAW based applications. When the application is
executed on an older Linux kernel and switching the CAN_RAW_FD_FRAMES
socket option returns an error: No problem. You’ll get legacy CAN frames
or CAN FD frames and can process them the same way.</p>
<p>When sending to CAN devices make sure that the device is capable to handle
CAN FD frames by checking if the device maximum transfer unit is CANFD_MTU.
The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.</p>
</div>
<div class="section" id="raw-socket-option-can-raw-join-filters">
<h4>RAW socket option CAN_RAW_JOIN_FILTERS<a class="headerlink" href="#raw-socket-option-can-raw-join-filters" title="Permalink to this headline">¶</a></h4>
<p>The CAN_RAW socket can set multiple CAN identifier specific filters that
lead to multiple filters in the af_can.c filter processing. These filters
are indenpendent from each other which leads to logical OR’ed filters when
applied (see <a class="reference internal" href="#socketcan-rawfilter"><span class="std std-ref">RAW socket option CAN_RAW_FILTER</span></a>).</p>
<p>This socket option joines the given CAN filters in the way that only CAN
frames are passed to user space that matched <em>all</em> given CAN filters. The
semantic for the applied filters is therefore changed to a logical AND.</p>
<p>This is useful especially when the filterset is a combination of filters
where the CAN_INV_FILTER flag is set in order to notch single CAN IDs or
CAN ID ranges from the incoming traffic.</p>
</div>
<div class="section" id="raw-socket-returned-message-flags">
<h4>RAW Socket Returned Message Flags<a class="headerlink" href="#raw-socket-returned-message-flags" title="Permalink to this headline">¶</a></h4>
<p>When using recvmsg() call, the msg-&gt;msg_flags may contain following flags:</p>
<dl class="docutils">
<dt>MSG_DONTROUTE:</dt>
<dd>set when the received frame was created on the local host.</dd>
<dt>MSG_CONFIRM:</dt>
<dd>set when the frame was sent via the socket it is received on.
This flag can be interpreted as a ‘transmission confirmation’ when the
CAN driver supports the echo of frames on driver level, see
<a class="reference internal" href="#socketcan-local-loopback1"><span class="std std-ref">Local Loopback of Sent Frames</span></a> and <a class="reference internal" href="#socketcan-local-loopback2"><span class="std std-ref">Local Loopback of Sent Frames</span></a>.
In order to receive such messages, CAN_RAW_RECV_OWN_MSGS must be set.</dd>
</dl>
</div>
</div>
<div class="section" id="broadcast-manager-protocol-sockets-sock-dgram">
<h3>Broadcast Manager Protocol Sockets (SOCK_DGRAM)<a class="headerlink" href="#broadcast-manager-protocol-sockets-sock-dgram" title="Permalink to this headline">¶</a></h3>
<p>The Broadcast Manager protocol provides a command based configuration
interface to filter and send (e.g. cyclic) CAN messages in kernel space.</p>
<p>Receive filters can be used to down sample frequent messages; detect events
such as message contents changes, packet length changes, and do time-out
monitoring of received messages.</p>
<p>Periodic transmission tasks of CAN frames or a sequence of CAN frames can be
created and modified at runtime; both the message content and the two
possible transmit intervals can be altered.</p>
<p>A BCM socket is not intended for sending individual CAN frames using the
struct can_frame as known from the CAN_RAW socket. Instead a special BCM
configuration message is defined. The basic BCM configuration message used
to communicate with the broadcast manager and the available operations are
defined in the linux/can/bcm.h include. The BCM message consists of a
message header with a command (‘opcode’) followed by zero or more CAN frames.
The broadcast manager sends responses to user space in the same form:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">opcode</span><span class="p">;</span>                   <span class="cm">/* command */</span>
        <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>                    <span class="cm">/* special flags */</span>
        <span class="n">__u32</span> <span class="n">count</span><span class="p">;</span>                    <span class="cm">/* run &#39;count&#39; times with ival1 */</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">ival1</span><span class="p">,</span> <span class="n">ival2</span><span class="p">;</span>    <span class="cm">/* count and subsequent interval */</span>
        <span class="n">canid_t</span> <span class="n">can_id</span><span class="p">;</span>                 <span class="cm">/* unique can_id for task */</span>
        <span class="n">__u32</span> <span class="n">nframes</span><span class="p">;</span>                  <span class="cm">/* number of can_frames following */</span>
        <span class="k">struct</span> <span class="n">can_frame</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The aligned payload ‘frames’ uses the same basic CAN frame structure defined
at the beginning of <a class="reference internal" href="#socketcan-rawfd"><span class="std std-ref">RAW Socket Option CAN_RAW_FD_FRAMES</span></a> and in the include/linux/can.h include. All
messages to the broadcast manager from user space have this structure.</p>
<p>Note a CAN_BCM socket must be connected instead of bound after socket
creation (example without error checking):</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sockaddr_can</span> <span class="n">addr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_CAN</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">CAN_BCM</span><span class="p">);</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="s">&quot;can0&quot;</span><span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCGIFINDEX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>

<span class="n">addr</span><span class="p">.</span><span class="n">can_family</span> <span class="o">=</span> <span class="n">AF_CAN</span><span class="p">;</span>
<span class="n">addr</span><span class="p">.</span><span class="n">can_ifindex</span> <span class="o">=</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span><span class="p">;</span>

<span class="n">connect</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="p">(..)</span>
</pre></div>
</div>
<p>The broadcast manager socket is able to handle any number of in flight
transmissions or receive filters concurrently. The different RX/TX jobs are
distinguished by the unique can_id in each BCM message. However additional
CAN_BCM sockets are recommended to communicate on multiple CAN interfaces.
When the broadcast manager socket is bound to ‘any’ CAN interface (=&gt; the
interface index is set to zero) the configured receive filters apply to any
CAN interface unless the sendto() syscall is used to overrule the ‘any’ CAN
interface index. When using recvfrom() instead of read() to retrieve BCM
socket messages the originating CAN interface is provided in can_ifindex.</p>
<div class="section" id="broadcast-manager-operations">
<h4>Broadcast Manager Operations<a class="headerlink" href="#broadcast-manager-operations" title="Permalink to this headline">¶</a></h4>
<p>The opcode defines the operation for the broadcast manager to carry out,
or details the broadcast managers response to several events, including
user requests.</p>
<p>Transmit Operations (user space to broadcast manager):</p>
<dl class="docutils">
<dt>TX_SETUP:</dt>
<dd>Create (cyclic) transmission task.</dd>
<dt>TX_DELETE:</dt>
<dd>Remove (cyclic) transmission task, requires only can_id.</dd>
<dt>TX_READ:</dt>
<dd>Read properties of (cyclic) transmission task for can_id.</dd>
<dt>TX_SEND:</dt>
<dd>Send one CAN frame.</dd>
</dl>
<p>Transmit Responses (broadcast manager to user space):</p>
<dl class="docutils">
<dt>TX_STATUS:</dt>
<dd>Reply to TX_READ request (transmission task configuration).</dd>
<dt>TX_EXPIRED:</dt>
<dd>Notification when counter finishes sending at initial interval
‘ival1’. Requires the TX_COUNTEVT flag to be set at TX_SETUP.</dd>
</dl>
<p>Receive Operations (user space to broadcast manager):</p>
<dl class="docutils">
<dt>RX_SETUP:</dt>
<dd>Create RX content filter subscription.</dd>
<dt>RX_DELETE:</dt>
<dd>Remove RX content filter subscription, requires only can_id.</dd>
<dt>RX_READ:</dt>
<dd>Read properties of RX content filter subscription for can_id.</dd>
</dl>
<p>Receive Responses (broadcast manager to user space):</p>
<dl class="docutils">
<dt>RX_STATUS:</dt>
<dd>Reply to RX_READ request (filter task configuration).</dd>
<dt>RX_TIMEOUT:</dt>
<dd>Cyclic message is detected to be absent (timer ival1 expired).</dd>
<dt>RX_CHANGED:</dt>
<dd>BCM message with updated CAN frame (detected content change).
Sent on first message received or on receipt of revised CAN messages.</dd>
</dl>
</div>
<div class="section" id="broadcast-manager-message-flags">
<h4>Broadcast Manager Message Flags<a class="headerlink" href="#broadcast-manager-message-flags" title="Permalink to this headline">¶</a></h4>
<p>When sending a message to the broadcast manager the ‘flags’ element may
contain the following flag definitions which influence the behaviour:</p>
<dl class="docutils">
<dt>SETTIMER:</dt>
<dd>Set the values of ival1, ival2 and count</dd>
<dt>STARTTIMER:</dt>
<dd>Start the timer with the actual values of ival1, ival2
and count. Starting the timer leads simultaneously to emit a CAN frame.</dd>
<dt>TX_COUNTEVT:</dt>
<dd>Create the message TX_EXPIRED when count expires</dd>
<dt>TX_ANNOUNCE:</dt>
<dd>A change of data by the process is emitted immediately.</dd>
<dt>TX_CP_CAN_ID:</dt>
<dd>Copies the can_id from the message header to each
subsequent frame in frames. This is intended as usage simplification. For
TX tasks the unique can_id from the message header may differ from the
can_id(s) stored for transmission in the subsequent struct can_frame(s).</dd>
<dt>RX_FILTER_ID:</dt>
<dd>Filter by can_id alone, no frames required (nframes=0).</dd>
<dt>RX_CHECK_DLC:</dt>
<dd>A change of the DLC leads to an RX_CHANGED.</dd>
<dt>RX_NO_AUTOTIMER:</dt>
<dd>Prevent automatically starting the timeout monitor.</dd>
<dt>RX_ANNOUNCE_RESUME:</dt>
<dd>If passed at RX_SETUP and a receive timeout occurred, a
RX_CHANGED message will be generated when the (cyclic) receive restarts.</dd>
<dt>TX_RESET_MULTI_IDX:</dt>
<dd>Reset the index for the multiple frame transmission.</dd>
<dt>RX_RTR_FRAME:</dt>
<dd>Send reply for RTR-request (placed in op-&gt;frames[0]).</dd>
</dl>
</div>
<div class="section" id="broadcast-manager-transmission-timers">
<h4>Broadcast Manager Transmission Timers<a class="headerlink" href="#broadcast-manager-transmission-timers" title="Permalink to this headline">¶</a></h4>
<p>Periodic transmission configurations may use up to two interval timers.
In this case the BCM sends a number of messages (‘count’) at an interval
‘ival1’, then continuing to send at another given interval ‘ival2’. When
only one timer is needed ‘count’ is set to zero and only ‘ival2’ is used.
When SET_TIMER and START_TIMER flag were set the timers are activated.
The timer values can be altered at runtime when only SET_TIMER is set.</p>
</div>
<div class="section" id="broadcast-manager-message-sequence-transmission">
<h4>Broadcast Manager message sequence transmission<a class="headerlink" href="#broadcast-manager-message-sequence-transmission" title="Permalink to this headline">¶</a></h4>
<p>Up to 256 CAN frames can be transmitted in a sequence in the case of a cyclic
TX task configuration. The number of CAN frames is provided in the ‘nframes’
element of the BCM message head. The defined number of CAN frames are added
as array to the TX_SETUP BCM configuration message:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="cm">/* create a struct to set up a sequence of four CAN frames */</span>
<span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">can_frame</span> <span class="n">frame</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">mytxmsg</span><span class="p">;</span>

<span class="p">(..)</span>
<span class="n">mytxmsg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">(..)</span>

<span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mytxmsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mytxmsg</span><span class="p">));</span>
</pre></div>
</div>
<p>With every transmission the index in the array of CAN frames is increased
and set to zero at index overflow.</p>
</div>
<div class="section" id="broadcast-manager-receive-filter-timers">
<h4>Broadcast Manager Receive Filter Timers<a class="headerlink" href="#broadcast-manager-receive-filter-timers" title="Permalink to this headline">¶</a></h4>
<p>The timer values ival1 or ival2 may be set to non-zero values at RX_SETUP.
When the SET_TIMER flag is set the timers are enabled:</p>
<dl class="docutils">
<dt>ival1:</dt>
<dd>Send RX_TIMEOUT when a received message is not received again within
the given time. When START_TIMER is set at RX_SETUP the timeout detection
is activated directly - even without a former CAN frame reception.</dd>
<dt>ival2:</dt>
<dd>Throttle the received message rate down to the value of ival2. This
is useful to reduce messages for the application when the signal inside the
CAN frame is stateless as state changes within the ival2 periode may get
lost.</dd>
</dl>
</div>
<div class="section" id="broadcast-manager-multiplex-message-receive-filter">
<h4>Broadcast Manager Multiplex Message Receive Filter<a class="headerlink" href="#broadcast-manager-multiplex-message-receive-filter" title="Permalink to this headline">¶</a></h4>
<p>To filter for content changes in multiplex message sequences an array of more
than one CAN frames can be passed in a RX_SETUP configuration message. The
data bytes of the first CAN frame contain the mask of relevant bits that
have to match in the subsequent CAN frames with the received CAN frame.
If one of the subsequent CAN frames is matching the bits in that frame data
mark the relevant content to be compared with the previous received content.
Up to 257 CAN frames (multiplex filter bit mask CAN frame plus 256 CAN
filters) can be added as array to the TX_SETUP BCM configuration message:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="cm">/* usually used to clear CAN frame data[] - beware of endian problems! */</span>
<span class="cp">#define U64_DATA(p) (*(unsigned long long*)(p)-&gt;data)</span>

<span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">can_frame</span> <span class="n">frame</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">msg</span><span class="p">;</span>

<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">RX_SETUP</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span>  <span class="o">=</span> <span class="mh">0x42</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">U64_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0xFF00000000000000ULL</span><span class="p">;</span> <span class="cm">/* MUX mask */</span>
<span class="n">U64_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0x01000000000000FFULL</span><span class="p">;</span> <span class="cm">/* data mask (MUX 0x01) */</span>
<span class="n">U64_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0x0200FFFF000000FFULL</span><span class="p">;</span> <span class="cm">/* data mask (MUX 0x02) */</span>
<span class="n">U64_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0x330000FFFFFF0003ULL</span><span class="p">;</span> <span class="cm">/* data mask (MUX 0x33) */</span>
<span class="n">U64_DATA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0x4F07FC0FF0000000ULL</span><span class="p">;</span> <span class="cm">/* data mask (MUX 0x4F) */</span>

<span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="broadcast-manager-can-fd-support">
<h4>Broadcast Manager CAN FD Support<a class="headerlink" href="#broadcast-manager-can-fd-support" title="Permalink to this headline">¶</a></h4>
<p>The programming API of the CAN_BCM depends on struct can_frame which is
given as array directly behind the bcm_msg_head structure. To follow this
schema for the CAN FD frames a new flag ‘CAN_FD_FRAME’ in the bcm_msg_head
flags indicates that the concatenated CAN frame structures behind the
bcm_msg_head are defined as struct canfd_frame:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">bcm_msg_head</span> <span class="n">msg_head</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">canfd_frame</span> <span class="n">frame</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span> <span class="n">msg</span><span class="p">;</span>

<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">opcode</span>  <span class="o">=</span> <span class="n">RX_SETUP</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">can_id</span>  <span class="o">=</span> <span class="mh">0x42</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">CAN_FD_FRAME</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">msg_head</span><span class="p">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">(..)</span>
</pre></div>
</div>
<p>When using CAN FD frames for multiplex filtering the MUX mask is still
expected in the first 64 bit of the struct canfd_frame data section.</p>
</div>
</div>
<div class="section" id="connected-transport-protocols-sock-seqpacket">
<h3>Connected Transport Protocols (SOCK_SEQPACKET)<a class="headerlink" href="#connected-transport-protocols-sock-seqpacket" title="Permalink to this headline">¶</a></h3>
<p>(to be written)</p>
</div>
<div class="section" id="unconnected-transport-protocols-sock-dgram">
<h3>Unconnected Transport Protocols (SOCK_DGRAM)<a class="headerlink" href="#unconnected-transport-protocols-sock-dgram" title="Permalink to this headline">¶</a></h3>
<p>(to be written)</p>
</div>
</div>
<div class="section" id="socketcan-core-module">
<span id="id4"></span><h2>SocketCAN Core Module<a class="headerlink" href="#socketcan-core-module" title="Permalink to this headline">¶</a></h2>
<p>The SocketCAN core module implements the protocol family
PF_CAN. CAN protocol modules are loaded by the core module at
runtime. The core module provides an interface for CAN protocol
modules to subscribe needed CAN IDs (see <a class="reference internal" href="#socketcan-receive-lists"><span class="std std-ref">Receive Lists</span></a>).</p>
<div class="section" id="can-ko-module-params">
<h3>can.ko Module Params<a class="headerlink" href="#can-ko-module-params" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><strong>stats_timer</strong>:
To calculate the SocketCAN core statistics
(e.g. current/maximum frames per second) this 1 second timer is
invoked at can.ko module start time by default. This timer can be
disabled by using stattimer=0 on the module commandline.</li>
<li><strong>debug</strong>:
(removed since SocketCAN SVN r546)</li>
</ul>
</div>
<div class="section" id="procfs-content">
<h3>procfs content<a class="headerlink" href="#procfs-content" title="Permalink to this headline">¶</a></h3>
<p>As described in <a class="reference internal" href="#socketcan-receive-lists"><span class="std std-ref">Receive Lists</span></a> the SocketCAN core uses several filter
lists to deliver received CAN frames to CAN protocol modules. These
receive lists, their filters and the count of filter matches can be
checked in the appropriate receive list. All entries contain the
device and a protocol module identifier:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>foo@bar:~$ cat /proc/net/can/rcvlist_all

receive list &#39;rx_all&#39;:
  (vcan3: no entry)
  (vcan2: no entry)
  (vcan1: no entry)
  device   can_id   can_mask  function  userdata   matches  ident
   vcan0     000    00000000  f88e6370  f6c6f400         0  raw
  (any: no entry)
</pre></div>
</div>
<p>In this example an application requests any CAN traffic from vcan0:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>rcvlist_all - list for unfiltered entries (no filter operations)
rcvlist_eff - list for single extended frame (EFF) entries
rcvlist_err - list for error message frames masks
rcvlist_fil - list for mask/value filters
rcvlist_inv - list for mask/value filters (inverse semantic)
rcvlist_sff - list for single standard frame (SFF) entries
</pre></div>
</div>
<p>Additional procfs files in /proc/net/can:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>stats       - SocketCAN core statistics (rx/tx frames, match ratios, ...)
reset_stats - manual statistic reset
version     - prints the SocketCAN core version and the ABI version
</pre></div>
</div>
</div>
<div class="section" id="writing-own-can-protocol-modules">
<h3>Writing Own CAN Protocol Modules<a class="headerlink" href="#writing-own-can-protocol-modules" title="Permalink to this headline">¶</a></h3>
<p>To implement a new protocol in the protocol family PF_CAN a new
protocol has to be defined in include/linux/can.h .
The prototypes and definitions to use the SocketCAN core can be
accessed by including include/linux/can/core.h .
In addition to functions that register the CAN protocol and the
CAN device notifier chain there are functions to subscribe CAN
frames received by CAN interfaces and to send CAN frames:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>can_rx_register   - subscribe CAN frames from a specific interface
can_rx_unregister - unsubscribe CAN frames from a specific interface
can_send          - transmit a CAN frame (optional with local loopback)
</pre></div>
</div>
<p>For details see the kerneldoc documentation in net/can/af_can.c or
the source code of net/can/raw.c or net/can/bcm.c .</p>
</div>
</div>
<div class="section" id="can-network-drivers">
<h2>CAN Network Drivers<a class="headerlink" href="#can-network-drivers" title="Permalink to this headline">¶</a></h2>
<p>Writing a CAN network device driver is much easier than writing a
CAN character device driver. Similar to other known network device
drivers you mainly have to deal with:</p>
<ul class="simple">
<li>TX: Put the CAN frame from the socket buffer to the CAN controller.</li>
<li>RX: Put the CAN frame from the CAN controller to the socket buffer.</li>
</ul>
<p>See e.g. at Documentation/networking/netdevices.txt . The differences
for writing CAN network device driver are described below:</p>
<div class="section" id="general-settings">
<h3>General Settings<a class="headerlink" href="#general-settings" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span>  <span class="o">=</span> <span class="n">ARPHRD_CAN</span><span class="p">;</span> <span class="cm">/* the netdevice hardware type */</span>
<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IFF_NOARP</span><span class="p">;</span>  <span class="cm">/* CAN has no arp */</span>

<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">CAN_MTU</span><span class="p">;</span> <span class="cm">/* sizeof(struct can_frame) -&gt; legacy CAN interface */</span>

<span class="n">or</span> <span class="n">alternative</span><span class="p">,</span> <span class="n">when</span> <span class="n">the</span> <span class="n">controller</span> <span class="n">supports</span> <span class="n">CAN</span> <span class="n">with</span> <span class="n">flexible</span> <span class="n">data</span> <span class="nl">rate</span><span class="p">:</span>
<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">CANFD_MTU</span><span class="p">;</span> <span class="cm">/* sizeof(struct canfd_frame) -&gt; CAN FD interface */</span>
</pre></div>
</div>
<p>The struct can_frame or struct canfd_frame is the payload of each socket
buffer (skbuff) in the protocol family PF_CAN.</p>
</div>
<div class="section" id="socketcan-local-loopback2">
<span id="id5"></span><h3>Local Loopback of Sent Frames<a class="headerlink" href="#socketcan-local-loopback2" title="Permalink to this headline">¶</a></h3>
<p>As described in <a class="reference internal" href="#socketcan-local-loopback1"><span class="std std-ref">Local Loopback of Sent Frames</span></a> the CAN network device driver should
support a local loopback functionality similar to the local echo
e.g. of tty devices. In this case the driver flag IFF_ECHO has to be
set to prevent the PF_CAN core from locally echoing sent frames
(aka loopback) as fallback solution:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>dev-&gt;flags = (IFF_NOARP | IFF_ECHO);
</pre></div>
</div>
</div>
<div class="section" id="can-controller-hardware-filters">
<h3>CAN Controller Hardware Filters<a class="headerlink" href="#can-controller-hardware-filters" title="Permalink to this headline">¶</a></h3>
<p>To reduce the interrupt load on deep embedded systems some CAN
controllers support the filtering of CAN IDs or ranges of CAN IDs.
These hardware filter capabilities vary from controller to
controller and have to be identified as not feasible in a multi-user
networking approach. The use of the very controller specific
hardware filters could make sense in a very dedicated use-case, as a
filter on driver level would affect all users in the multi-user
system. The high efficient filter sets inside the PF_CAN core allow
to set different multiple filters for each socket separately.
Therefore the use of hardware filters goes to the category ‘handmade
tuning on deep embedded systems’. The author is running a MPC603e
&#64;133MHz with four SJA1000 CAN controllers from 2002 under heavy bus
load without any problems …</p>
</div>
<div class="section" id="the-virtual-can-driver-vcan">
<h3>The Virtual CAN Driver (vcan)<a class="headerlink" href="#the-virtual-can-driver-vcan" title="Permalink to this headline">¶</a></h3>
<p>Similar to the network loopback devices, vcan offers a virtual local
CAN interface. A full qualified address on CAN consists of</p>
<ul class="simple">
<li>a unique CAN Identifier (CAN ID)</li>
<li>the CAN bus this CAN ID is transmitted on (e.g. can0)</li>
</ul>
<p>so in common use cases more than one virtual CAN interface is needed.</p>
<p>The virtual CAN interfaces allow the transmission and reception of CAN
frames without real CAN controller hardware. Virtual CAN network
devices are usually named ‘vcanX’, like vcan0 vcan1 vcan2 …
When compiled as a module the virtual CAN driver module is called vcan.ko</p>
<p>Since Linux Kernel version 2.6.24 the vcan driver supports the Kernel
netlink interface to create vcan network devices. The creation and
removal of vcan network devices can be managed with the ip(8) tool:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>- Create a virtual CAN network interface:
     $ ip link add type vcan

- Create a virtual CAN network interface with a specific name &#39;vcan42&#39;:
     $ ip link add dev vcan42 type vcan

- Remove a (virtual CAN) network interface &#39;vcan42&#39;:
     $ ip link del vcan42
</pre></div>
</div>
</div>
<div class="section" id="the-can-network-device-driver-interface">
<h3>The CAN Network Device Driver Interface<a class="headerlink" href="#the-can-network-device-driver-interface" title="Permalink to this headline">¶</a></h3>
<p>The CAN network device driver interface provides a generic interface
to setup, configure and monitor CAN network devices. The user can then
configure the CAN device, like setting the bit-timing parameters, via
the netlink interface using the program “ip” from the “IPROUTE2”
utility suite. The following chapter describes briefly how to use it.
Furthermore, the interface uses a common data structure and exports a
set of common functions, which all real CAN network device drivers
should use. Please have a look to the SJA1000 or MSCAN driver to
understand how to use them. The name of the module is can-dev.ko.</p>
<div class="section" id="netlink-interface-to-set-get-devices-properties">
<h4>Netlink interface to set/get devices properties<a class="headerlink" href="#netlink-interface-to-set-get-devices-properties" title="Permalink to this headline">¶</a></h4>
<p>The CAN device must be configured via netlink interface. The supported
netlink message types are defined and briefly described in
“include/linux/can/netlink.h”. CAN link support for the program “ip”
of the IPROUTE2 utility suite is available and it can be used as shown
below:</p>
<p>Setting CAN device properties:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set can0 type can help
Usage: ip link set DEVICE type can
    [ bitrate BITRATE [ sample-point SAMPLE-POINT] ] |
    [ tq TQ prop-seg PROP_SEG phase-seg1 PHASE-SEG1
      phase-seg2 PHASE-SEG2 [ sjw SJW ] ]

    [ dbitrate BITRATE [ dsample-point SAMPLE-POINT] ] |
    [ dtq TQ dprop-seg PROP_SEG dphase-seg1 PHASE-SEG1
      dphase-seg2 PHASE-SEG2 [ dsjw SJW ] ]

    [ loopback { on | off } ]
    [ listen-only { on | off } ]
    [ triple-sampling { on | off } ]
    [ one-shot { on | off } ]
    [ berr-reporting { on | off } ]
    [ fd { on | off } ]
    [ fd-non-iso { on | off } ]
    [ presume-ack { on | off } ]

    [ restart-ms TIME-MS ]
    [ restart ]

    Where: BITRATE       := { 1..1000000 }
           SAMPLE-POINT  := { 0.000..0.999 }
           TQ            := { NUMBER }
           PROP-SEG      := { 1..8 }
           PHASE-SEG1    := { 1..8 }
           PHASE-SEG2    := { 1..8 }
           SJW           := { 1..4 }
           RESTART-MS    := { 0 | NUMBER }
</pre></div>
</div>
<p>Display CAN device details and statistics:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip -details -statistics link show can0
2: can0: &lt;NOARP,UP,LOWER_UP,ECHO&gt; mtu 16 qdisc pfifo_fast state UP qlen 10
  link/can
  can &lt;TRIPLE-SAMPLING&gt; state ERROR-ACTIVE restart-ms 100
  bitrate 125000 sample_point 0.875
  tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1
  sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1
  clock 8000000
  re-started bus-errors arbit-lost error-warn error-pass bus-off
  41         17457      0          41         42         41
  RX: bytes  packets  errors  dropped overrun mcast
  140859     17608    17457   0       0       0
  TX: bytes  packets  errors  dropped carrier collsns
  861        112      0       41      0       0
</pre></div>
</div>
<p>More info to the above output:</p>
<dl class="docutils">
<dt>“&lt;TRIPLE-SAMPLING&gt;”</dt>
<dd>Shows the list of selected CAN controller modes: LOOPBACK,
LISTEN-ONLY, or TRIPLE-SAMPLING.</dd>
<dt>“state ERROR-ACTIVE”</dt>
<dd>The current state of the CAN controller: “ERROR-ACTIVE”,
“ERROR-WARNING”, “ERROR-PASSIVE”, “BUS-OFF” or “STOPPED”</dd>
<dt>“restart-ms 100”</dt>
<dd>Automatic restart delay time. If set to a non-zero value, a
restart of the CAN controller will be triggered automatically
in case of a bus-off condition after the specified delay time
in milliseconds. By default it’s off.</dd>
<dt>“bitrate 125000 sample-point 0.875”</dt>
<dd>Shows the real bit-rate in bits/sec and the sample-point in the
range 0.000..0.999. If the calculation of bit-timing parameters
is enabled in the kernel (CONFIG_CAN_CALC_BITTIMING=y), the
bit-timing can be defined by setting the “bitrate” argument.
Optionally the “sample-point” can be specified. By default it’s
0.000 assuming CIA-recommended sample-points.</dd>
<dt>“tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1”</dt>
<dd>Shows the time quanta in ns, propagation segment, phase buffer
segment 1 and 2 and the synchronisation jump width in units of
tq. They allow to define the CAN bit-timing in a hardware
independent format as proposed by the Bosch CAN 2.0 spec (see
chapter 8 of <a class="reference external" href="http://www.semiconductors.bosch.de/pdf/can2spec.pdf">http://www.semiconductors.bosch.de/pdf/can2spec.pdf</a>).</dd>
<dt>“sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1 clock 8000000”</dt>
<dd>Shows the bit-timing constants of the CAN controller, here the
“sja1000”. The minimum and maximum values of the time segment 1
and 2, the synchronisation jump width in units of tq, the
bitrate pre-scaler and the CAN system clock frequency in Hz.
These constants could be used for user-defined (non-standard)
bit-timing calculation algorithms in user-space.</dd>
<dt>“re-started bus-errors arbit-lost error-warn error-pass bus-off”</dt>
<dd>Shows the number of restarts, bus and arbitration lost errors,
and the state changes to the error-warning, error-passive and
bus-off state. RX overrun errors are listed in the “overrun”
field of the standard network statistics.</dd>
</dl>
</div>
<div class="section" id="setting-the-can-bit-timing">
<h4>Setting the CAN Bit-Timing<a class="headerlink" href="#setting-the-can-bit-timing" title="Permalink to this headline">¶</a></h4>
<p>The CAN bit-timing parameters can always be defined in a hardware
independent format as proposed in the Bosch CAN 2.0 specification
specifying the arguments “tq”, “prop_seg”, “phase_seg1”, “phase_seg2”
and “sjw”:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set canX type can tq 125 prop-seg 6 \
                            phase-seg1 7 phase-seg2 2 sjw 1
</pre></div>
</div>
<p>If the kernel option CONFIG_CAN_CALC_BITTIMING is enabled, CIA
recommended CAN bit-timing parameters will be calculated if the bit-
rate is specified with the argument “bitrate”:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set canX type can bitrate 125000
</pre></div>
</div>
<p>Note that this works fine for the most common CAN controllers with
standard bit-rates but may <em>fail</em> for exotic bit-rates or CAN system
clock frequencies. Disabling CONFIG_CAN_CALC_BITTIMING saves some
space and allows user-space tools to solely determine and set the
bit-timing parameters. The CAN controller specific bit-timing
constants can be used for that purpose. They are listed by the
following command:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip -details link show can0
...
  sja1000: clock 8000000 tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1
</pre></div>
</div>
</div>
<div class="section" id="starting-and-stopping-the-can-network-device">
<h4>Starting and Stopping the CAN Network Device<a class="headerlink" href="#starting-and-stopping-the-can-network-device" title="Permalink to this headline">¶</a></h4>
<p>A CAN network device is started or stopped as usual with the command
“ifconfig canX up/down” or “ip link set canX up/down”. Be aware that
you <em>must</em> define proper bit-timing parameters for real CAN devices
before you can start it to avoid error-prone default settings:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set canX up type can bitrate 125000
</pre></div>
</div>
<p>A device may enter the “bus-off” state if too many errors occurred on
the CAN bus. Then no more messages are received or sent. An automatic
bus-off recovery can be enabled by setting the “restart-ms” to a
non-zero value, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set canX type can restart-ms 100
</pre></div>
</div>
<p>Alternatively, the application may realize the “bus-off” condition
by monitoring CAN error message frames and do a restart when
appropriate with the command:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set canX type can restart
</pre></div>
</div>
<p>Note that a restart will also create a CAN error message frame (see
also <a class="reference internal" href="#socketcan-network-problem-notifications"><span class="std std-ref">Network Problem Notifications</span></a>).</p>
</div>
</div>
<div class="section" id="can-fd-flexible-data-rate-driver-support">
<span id="socketcan-can-fd-driver"></span><h3>CAN FD (Flexible Data Rate) Driver Support<a class="headerlink" href="#can-fd-flexible-data-rate-driver-support" title="Permalink to this headline">¶</a></h3>
<p>CAN FD capable CAN controllers support two different bitrates for the
arbitration phase and the payload phase of the CAN FD frame. Therefore a
second bit timing has to be specified in order to enable the CAN FD bitrate.</p>
<p>Additionally CAN FD capable CAN controllers support up to 64 bytes of
payload. The representation of this length in can_frame.can_dlc and
canfd_frame.len for userspace applications and inside the Linux network
layer is a plain value from 0 .. 64 instead of the CAN ‘data length code’.
The data length code was a 1:1 mapping to the payload length in the legacy
CAN frames anyway. The payload length to the bus-relevant DLC mapping is
only performed inside the CAN drivers, preferably with the helper
functions can_dlc2len() and can_len2dlc().</p>
<p>The CAN netdevice driver capabilities can be distinguished by the network
devices maximum transfer unit (MTU):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>MTU = 16 (CAN_MTU)   =&gt; sizeof(struct can_frame)   =&gt; &#39;legacy&#39; CAN device
MTU = 72 (CANFD_MTU) =&gt; sizeof(struct canfd_frame) =&gt; CAN FD capable device
</pre></div>
</div>
<p>The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.
N.B. CAN FD capable devices can also handle and send legacy CAN frames.</p>
<p>When configuring CAN FD capable CAN controllers an additional ‘data’ bitrate
has to be set. This bitrate for the data phase of the CAN FD frame has to be
at least the bitrate which was configured for the arbitration phase. This
second bitrate is specified analogue to the first bitrate but the bitrate
setting keywords for the ‘data’ bitrate start with ‘d’ e.g. dbitrate,
dsample-point, dsjw or dtq and similar settings. When a data bitrate is set
within the configuration process the controller option “fd on” can be
specified to enable the CAN FD mode in the CAN controller. This controller
option also switches the device MTU to 72 (CANFD_MTU).</p>
<p>The first CAN FD specification presented as whitepaper at the International
CAN Conference 2012 needed to be improved for data integrity reasons.
Therefore two CAN FD implementations have to be distinguished today:</p>
<ul class="simple">
<li>ISO compliant:     The ISO 11898-1:2015 CAN FD implementation (default)</li>
<li>non-ISO compliant: The CAN FD implementation following the 2012 whitepaper</li>
</ul>
<p>Finally there are three types of CAN FD controllers:</p>
<ol class="arabic simple">
<li>ISO compliant (fixed)</li>
<li>non-ISO compliant (fixed, like the M_CAN IP core v3.0.1 in m_can.c)</li>
<li>ISO/non-ISO CAN FD controllers (switchable, like the PEAK PCAN-USB FD)</li>
</ol>
<p>The current ISO/non-ISO mode is announced by the CAN controller driver via
netlink and displayed by the ‘ip’ tool (controller option FD-NON-ISO).
The ISO/non-ISO-mode can be altered by setting ‘fd-non-iso {on|off}’ for
switchable CAN FD controllers only.</p>
<p>Example configuring 500 kbit/s arbitration bitrate and 4 Mbit/s data bitrate:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ip link set can0 up type can bitrate 500000 sample-point 0.75 \
                               dbitrate 4000000 dsample-point 0.8 fd on
$ ip -details link show can0
5: can0: &lt;NOARP,UP,LOWER_UP,ECHO&gt; mtu 72 qdisc pfifo_fast state UNKNOWN \
         mode DEFAULT group default qlen 10
link/can  promiscuity 0
can &lt;FD&gt; state ERROR-ACTIVE (berr-counter tx 0 rx 0) restart-ms 0
      bitrate 500000 sample-point 0.750
      tq 50 prop-seg 14 phase-seg1 15 phase-seg2 10 sjw 1
      pcan_usb_pro_fd: tseg1 1..64 tseg2 1..16 sjw 1..16 brp 1..1024 \
      brp-inc 1
      dbitrate 4000000 dsample-point 0.800
      dtq 12 dprop-seg 7 dphase-seg1 8 dphase-seg2 4 dsjw 1
      pcan_usb_pro_fd: dtseg1 1..16 dtseg2 1..8 dsjw 1..4 dbrp 1..1024 \
      dbrp-inc 1
      clock 80000000
</pre></div>
</div>
<p>Example when ‘fd-non-iso on’ is added on this switchable CAN FD adapter:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>can &lt;FD,FD-NON-ISO&gt; state ERROR-ACTIVE (berr-counter tx 0 rx 0) restart-ms 0
</pre></div>
</div>
</div>
<div class="section" id="supported-can-hardware">
<h3>Supported CAN Hardware<a class="headerlink" href="#supported-can-hardware" title="Permalink to this headline">¶</a></h3>
<p>Please check the “Kconfig” file in “drivers/net/can” to get an actual
list of the support CAN hardware. On the SocketCAN project website
(see <a class="reference internal" href="#socketcan-resources"><span class="std std-ref">SocketCAN Resources</span></a>) there might be further drivers available, also for
older kernel versions.</p>
</div>
</div>
<div class="section" id="socketcan-resources">
<span id="id6"></span><h2>SocketCAN Resources<a class="headerlink" href="#socketcan-resources" title="Permalink to this headline">¶</a></h2>
<p>The Linux CAN / SocketCAN project resources (project site / mailing list)
are referenced in the MAINTAINERS file in the Linux source tree.
Search for CAN NETWORK [LAYERS|DRIVERS].</p>
</div>
<div class="section" id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Oliver Hartkopp (PF_CAN core, filters, drivers, bcm, SJA1000 driver)</li>
<li>Urs Thuermann (PF_CAN core, kernel integration, socket interfaces, raw, vcan)</li>
<li>Jan Kizka (RT-SocketCAN core, Socket-API reconciliation)</li>
<li>Wolfgang Grandegger (RT-SocketCAN core &amp; drivers, Raw Socket-API reviews, CAN device driver interface, MSCAN driver)</li>
<li>Robert Schwebel (design reviews, PTXdist integration)</li>
<li>Marc Kleine-Budde (design reviews, Kernel 2.6 cleanups, drivers)</li>
<li>Benedikt Spranger (reviews)</li>
<li>Thomas Gleixner (LKML reviews, coding style, posting hints)</li>
<li>Andrey Volkov (kernel subtree structure, ioctls, MSCAN driver)</li>
<li>Matthias Brukner (first SJA1000 CAN netdevice implementation Q2/2003)</li>
<li>Klaus Hitschler (PEAK driver integration)</li>
<li>Uwe Koppe (CAN netdevices with PF_PACKET approach)</li>
<li>Michael Schulze (driver layer loopback requirement, RT CAN drivers review)</li>
<li>Pavel Pisa (Bit-timing calculation)</li>
<li>Sascha Hauer (SJA1000 platform driver)</li>
<li>Sebastian Haas (SJA1000 EMS PCI driver)</li>
<li>Markus Plessing (SJA1000 EMS PCI driver)</li>
<li>Per Dalen (SJA1000 Kvaser PCI driver)</li>
<li>Sam Ravnborg (reviews, coding style, kbuild help)</li>
</ul>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="kapi.html" class="btn btn-neutral float-right" title="Linux Networking and Network Devices APIs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="batman-adv.html" class="btn btn-neutral" title="batman-adv" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.16.0-rc1+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>