

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.1. Digital TV Common functions &mdash; The Linux Kernel 4.16.0-rc1+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="The Linux Kernel 4.16.0-rc1+ documentation" href="../../index.html"/>
        <link rel="up" title="2. Digital TV (DVB) devices" href="dtv-core.html"/>
        <link rel="next" title="2.2. Digital TV Frontend kABI" href="dtv-frontend.html"/>
        <link rel="prev" title="2. Digital TV (DVB) devices" href="dtv-core.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">2.1. Digital TV Common functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-frontend.html">2.2. Digital TV Frontend kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-demux.html">2.3. Digital TV Demux kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-ca.html">2.4. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-net.html">2.5. Digital TV Network kABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
        
          <li><a href="dtv-core.html">2. Digital TV (DVB) devices</a> &raquo;</li>
        
      <li>2.1. Digital TV Common functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/media/kapi/dtv-common.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="digital-tv-common-functions">
<h1>2.1. Digital TV Common functions<a class="headerlink" href="#digital-tv-common-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="math-functions">
<h2>2.1.1. Math functions<a class="headerlink" href="#math-functions" title="Permalink to this headline">¶</a></h2>
<p>Provide some commonly-used math functions, usually required in order to
estimate signal strength and signal to noise measurements in dB.</p>
<dl class="function">
<dt id="c.intlog2">
unsigned int <code class="descname">intlog2</code><span class="sig-paren">(</span>u32<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog2" title="Permalink to this definition">¶</a></dt>
<dd><p>computes log2 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">value</span></code></dt>
<dd>The value (must be != 0)</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div>intlog2(value) = intlog2(value * 2^x) - x * 2^24</div></blockquote>
<p>Some usecase examples:</p>
<blockquote>
<div><p>intlog2(8) will give 3 &lt;&lt; 24 = 3 * 2^24</p>
<p>intlog2(9) will give 3 &lt;&lt; 24 + … = 3.16… * 2^24</p>
<p>intlog2(1.5) = intlog2(3) - 2^24 = 0.584… * 2^24</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>log2(value) * 2^24</p>
<dl class="function">
<dt id="c.intlog10">
unsigned int <code class="descname">intlog10</code><span class="sig-paren">(</span>u32<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog10" title="Permalink to this definition">¶</a></dt>
<dd><p>computes log10 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">value</span></code></dt>
<dd>The value (must be != 0)</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div>intlog10(value) = intlog10(value * 10^x) - x * 2^24</div></blockquote>
<p>An usecase example:</p>
<blockquote>
<div><blockquote>
<div>intlog10(1000) will give 3 &lt;&lt; 24 = 3 * 2^24</div></blockquote>
<p>due to the implementation intlog10(1000) might be not exactly 3 * 2^24</p>
</div></blockquote>
<p>look at intlog2 for similar examples</p>
<p><strong>Return</strong></p>
<p>log10(value) * 2^24</p>
</div>
<div class="section" id="dvb-devices">
<h2>2.1.2. DVB devices<a class="headerlink" href="#dvb-devices" title="Permalink to this headline">¶</a></h2>
<p>Those functions are responsible for handling the DVB device nodes.</p>
<dl class="type">
<dt id="c.dvb_device_type">
enum <code class="descname">dvb_device_type</code><a class="headerlink" href="#c.dvb_device_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the Digital TV device</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_SEC</span></code></dt>
<dd>Digital TV standalone Common Interface (CI)</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_FRONTEND</span></code></dt>
<dd>Digital TV frontend.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_DEMUX</span></code></dt>
<dd>Digital TV demux.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_DVR</span></code></dt>
<dd>Digital TV digital video record (DVR).</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_CA</span></code></dt>
<dd>Digital TV Conditional Access (CA).</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_NET</span></code></dt>
<dd>Digital TV network.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_VIDEO</span></code></dt>
<dd>Digital TV video decoder.
Deprecated. Used only on av7110-av.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_AUDIO</span></code></dt>
<dd>Digital TV audio decoder.
Deprecated. Used only on av7110-av.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_DEVICE_OSD</span></code></dt>
<dd>Digital TV On Screen Display (OSD).
Deprecated. Used only on av7110.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_adapter">
struct <code class="descname">dvb_adapter</code><a class="headerlink" href="#c.dvb_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a Digital TV adapter using Linux DVB API</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_adapter {
  int num;
  struct list_head list_head;
  struct list_head device_list;
  const char *name;
  u8 proposed_mac [6];
  void* priv;
  struct device *device;
  struct module *module;
  int mfe_shared;
  struct dvb_device *mfe_dvbdev;
  struct mutex mfe_lock;
#if defined(CONFIG_MEDIA_CONTROLLER_DVB);
  struct media_device *mdev;
  struct media_entity *conn;
  struct media_pad *conn_pads;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">num</span></code></dt>
<dd>Number of the adapter</dd>
<dt><code class="docutils literal"><span class="pre">list_head</span></code></dt>
<dd>List with the DVB adapters</dd>
<dt><code class="docutils literal"><span class="pre">device_list</span></code></dt>
<dd>List with the DVB devices</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the adapter</dd>
<dt><code class="docutils literal"><span class="pre">proposed_mac</span></code></dt>
<dd>proposed MAC address for the adapter</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data</dd>
<dt><code class="docutils literal"><span class="pre">device</span></code></dt>
<dd>pointer to struct device</dd>
<dt><code class="docutils literal"><span class="pre">module</span></code></dt>
<dd>pointer to struct module</dd>
<dt><code class="docutils literal"><span class="pre">mfe_shared</span></code></dt>
<dd>mfe shared: indicates mutually exclusive frontends
Thie usage of this flag is currently deprecated</dd>
<dt><code class="docutils literal"><span class="pre">mfe_dvbdev</span></code></dt>
<dd>Frontend device in use, in the case of MFE</dd>
<dt><code class="docutils literal"><span class="pre">mfe_lock</span></code></dt>
<dd>Lock to prevent using the other frontends when MFE is
used.</dd>
<dt><code class="docutils literal"><span class="pre">mdev</span></code></dt>
<dd>pointer to struct media_device, used when the media
controller is used.</dd>
<dt><code class="docutils literal"><span class="pre">conn</span></code></dt>
<dd>RF connector. Used only if the device has no separate
tuner.</dd>
<dt><code class="docutils literal"><span class="pre">conn_pads</span></code></dt>
<dd>pointer to struct media_pad associated with <strong>conn</strong>;</dd>
</dl>
<dl class="type">
<dt id="c.dvb_device">
struct <code class="descname">dvb_device</code><a class="headerlink" href="#c.dvb_device" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a DVB device node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_device {
  struct list_head list_head;
  const struct file_operations *fops;
  struct dvb_adapter *adapter;
  enum dvb_device_type type;
  int minor;
  u32 id;
  int readers;
  int writers;
  int users;
  wait_queue_head_t wait_queue;
  int (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);
#if defined(CONFIG_MEDIA_CONTROLLER_DVB);
  const char *name;
  struct media_intf_devnode *intf_devnode;
  unsigned tsout_num_entities;
  struct media_entity *entity, *tsout_entity;
  struct media_pad *pads, *tsout_pads;
#endif;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">list_head</span></code></dt>
<dd>List head with all DVB devices</dd>
<dt><code class="docutils literal"><span class="pre">fops</span></code></dt>
<dd>pointer to struct file_operations</dd>
<dt><code class="docutils literal"><span class="pre">adapter</span></code></dt>
<dd>pointer to the adapter that holds this device node</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the device, as defined by <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_device_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd>devnode minor number. Major number is always DVB_MAJOR.</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>device ID number, inside the adapter</dd>
<dt><code class="docutils literal"><span class="pre">readers</span></code></dt>
<dd>Initialized by the caller. Each call to <a class="reference internal" href="../uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> in Read Only mode
decreases this counter by one.</dd>
<dt><code class="docutils literal"><span class="pre">writers</span></code></dt>
<dd>Initialized by the caller. Each call to <a class="reference internal" href="../uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> in Read/Write
mode decreases this counter by one.</dd>
<dt><code class="docutils literal"><span class="pre">users</span></code></dt>
<dd>Initialized by the caller. Each call to <a class="reference internal" href="../uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> in any mode
decreases this counter by one.</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue</span></code></dt>
<dd>wait queue, used to wait for certain events inside one of
the DVB API callers</dd>
<dt><code class="docutils literal"><span class="pre">kernel_ioctl</span></code></dt>
<dd>callback function used to handle ioctl calls from userspace.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name to be used for the device at the Media Controller</dd>
<dt><code class="docutils literal"><span class="pre">intf_devnode</span></code></dt>
<dd>Pointer to media_intf_devnode. Used by the dvbdev core to
store the MC device node interface</dd>
<dt><code class="docutils literal"><span class="pre">tsout_num_entities</span></code></dt>
<dd>Number of Transport Stream output entities</dd>
<dt><code class="docutils literal"><span class="pre">entity</span></code></dt>
<dd>pointer to struct media_entity associated with the device node</dd>
<dt><code class="docutils literal"><span class="pre">tsout_entity</span></code></dt>
<dd>array with MC entities associated to each TS output node</dd>
<dt><code class="docutils literal"><span class="pre">pads</span></code></dt>
<dd>pointer to struct media_pad associated with <strong>entity</strong>;</dd>
<dt><code class="docutils literal"><span class="pre">tsout_pads</span></code></dt>
<dd>array with the source pads for each <strong>tsout_entity</strong></dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used by the DVB core (frontend, CA, net, demux) in
order to create the device nodes. Usually, driver should not initialize
this struct diretly.</p>
<dl class="function">
<dt id="c.dvb_register_adapter">
int <code class="descname">dvb_register_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em>, const char *<em>&nbsp;name</em>, struct module *<em>&nbsp;module</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, short *<em>&nbsp;adapter_nums</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to struct dvb_adapter</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Adapter’s name</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>initialized with THIS_MODULE at the caller</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>pointer to struct device that corresponds to the device driver</dd>
<dt><code class="docutils literal"><span class="pre">short</span> <span class="pre">*</span> <span class="pre">adapter_nums</span></code></dt>
<dd>Array with a list of the numbers for <strong>dvb_register_adapter</strong>;
to select among them. Typically, initialized with:
DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nums)</dd>
</dl>
<dl class="function">
<dt id="c.dvb_unregister_adapter">
int <code class="descname">dvb_unregister_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to struct dvb_adapter</dd>
</dl>
<dl class="function">
<dt id="c.dvb_register_device">
int <code class="descname">dvb_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em>, struct <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> **<em>&nbsp;pdvbdev</em>, const struct <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>&nbsp;template</em>, void *<em>&nbsp;priv</em>, enum <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type">dvb_device_type</a><em>&nbsp;type</em>, int<em>&nbsp;demux_sink_pads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to struct dvb_adapter</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">**</span> <span class="pre">pdvbdev</span></code></dt>
<dd>pointer to the place where the new struct dvb_device will be
stored</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*</span> <span class="pre">template</span></code></dt>
<dd>Template used to create <code class="xref c c-type docutils literal"><span class="pre">pdvbdev</span></code>;</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>private data</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dvb_device_type</span> <span class="pre">type</span></code></dt>
<dd>type of the device, as defined by <a class="reference internal" href="#c.dvb_device_type" title="dvb_device_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_device_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">demux_sink_pads</span></code></dt>
<dd>Number of demux outputs, to be used to create the TS
outputs via the Media Controller.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_remove_device">
void <code class="descname">dvb_remove_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>&nbsp;dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_remove_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a registered DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*</span> <span class="pre">dvbdev</span></code></dt>
<dd>pointer to struct dvb_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This does not free memory.  To do that, call <a class="reference internal" href="#c.dvb_free_device" title="dvb_free_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_free_device()</span></code></a>.</p>
<dl class="function">
<dt id="c.dvb_free_device">
void <code class="descname">dvb_free_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>&nbsp;dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_free_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Free memory occupied by a DVB device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*</span> <span class="pre">dvbdev</span></code></dt>
<dd>pointer to struct dvb_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.dvb_unregister_device" title="dvb_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_unregister_device()</span></code></a> before calling this function.</p>
<dl class="function">
<dt id="c.dvb_unregister_device">
void <code class="descname">dvb_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_device" title="dvb_device">dvb_device</a> *<em>&nbsp;dvbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a DVB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span> <span class="pre">*</span> <span class="pre">dvbdev</span></code></dt>
<dd>pointer to struct dvb_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a combination of <a class="reference internal" href="#c.dvb_remove_device" title="dvb_remove_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_remove_device()</span></code></a> and <a class="reference internal" href="#c.dvb_free_device" title="dvb_free_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_free_device()</span></code></a>.
Using this function is usually a mistake, and is often an indicator
for a use-after-free bug (when a userspace process keeps a file
handle to a detached device).</p>
<dl class="function">
<dt id="c.dvb_create_media_graph">
int <code class="descname">dvb_create_media_graph</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em>, bool<em>&nbsp;create_rf_connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_create_media_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates media graph for the Digital TV part of the device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">create_rf_connector</span></code></dt>
<dd>if true, it creates the RF connector too</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks all DVB-related functions at the media controller
entities and creates the needed links for the media graph. It is
capable of working with multiple tuners or multiple frontends, but it
won’t create links if the device has multiple tuners and multiple frontends
or if the device has multiple muxes. In such case, the caller driver should
manually create the remaining links.</p>
<dl class="function">
<dt id="c.dvb_register_media_controller">
void <code class="descname">dvb_register_media_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em>, struct <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_media_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>registers a media controller at DVB adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to <a class="reference internal" href="mc-core.html#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.dvb_get_media_controller">
struct <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a> * <code class="descname">dvb_get_media_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_get_media_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the associated media controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.dvb_generic_open">
int <code class="descname">dvb_generic_open</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Digital TV open function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode is still valid, and if the permissions are
OK and increment negative use count.</p>
<dl class="function">
<dt id="c.dvb_generic_release">
int <code class="descname">dvb_generic_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Digital TV close function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode is still valid, and if the permissions are
OK and decrement negative use count.</p>
<dl class="function">
<dt id="c.dvb_generic_ioctl">
long <code class="descname">dvb_generic_ioctl</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_generic_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Digital TV close function, used by DVB devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>Ioctl name.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>Ioctl argument.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if a DVB devnode and struct dvbdev.kernel_ioctl is still valid.
If so, calls <a class="reference internal" href="#c.dvb_usercopy" title="dvb_usercopy"><code class="xref c c-func docutils literal"><span class="pre">dvb_usercopy()</span></code></a>.</p>
<dl class="function">
<dt id="c.dvb_usercopy">
int <code class="descname">dvb_usercopy</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em>, int (*func) (struct file<em>&nbsp;*file</em>, unsigned int<em>&nbsp;cmd</em>, void<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_usercopy" title="Permalink to this definition">¶</a></dt>
<dd><p>copies data from/to userspace memory when an ioctl is issued.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>Pointer to struct <code class="xref c c-type docutils literal"><span class="pre">file</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>Ioctl name.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>Ioctl argument.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">file</span> <span class="pre">*file,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span> <span class="pre">void</span> <span class="pre">*arg)</span> <span class="pre">func</span></code></dt>
<dd>function that will actually handle the ioctl</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ancillary function that uses ioctl direction and size to copy from
userspace. Then, it calls <strong>func</strong>, and, if needed, data is copied back
to userspace.</p>
<dl class="function">
<dt id="c.dvb_attach">
<code class="descname">dvb_attach</code><span class="sig-paren">(</span><em>FUNCTION</em>, <em>ARGS…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attaches a DVB frontend into the DVB core.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">FUNCTION</span></code></dt>
<dd>function on a frontend module to be called.</dd>
<dt><code class="docutils literal"><span class="pre">ARGS...</span></code></dt>
<dd><strong>FUNCTION</strong> arguments.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This ancillary function loads a frontend module in runtime and runs
the <strong>FUNCTION</strong> function there, with <strong>ARGS</strong>.
As it increments symbol usage cont, at unregister, <a class="reference internal" href="#c.dvb_detach" title="dvb_detach"><code class="xref c c-func docutils literal"><span class="pre">dvb_detach()</span></code></a>
should be called.</p>
<dl class="function">
<dt id="c.dvb_detach">
<code class="descname">dvb_detach</code><span class="sig-paren">(</span><em>FUNC</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detaches a DVB frontend loaded via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal"><span class="pre">dvb_attach()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">FUNC</span></code></dt>
<dd>attach function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements usage count for a function previously called via <a class="reference internal" href="#c.dvb_attach" title="dvb_attach"><code class="xref c c-func docutils literal"><span class="pre">dvb_attach()</span></code></a>.</p>
</div>
<div class="section" id="digital-tv-ring-buffer">
<h2>2.1.3. Digital TV Ring buffer<a class="headerlink" href="#digital-tv-ring-buffer" title="Permalink to this headline">¶</a></h2>
<p>Those routines implement ring buffers used to handle digital TV data and
copy it from/to userspace.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="arabic simple">
<li>For performance reasons read and write routines don’t check buffer sizes
and/or number of bytes free/available. This has to be done before these
routines are called. For example:</li>
</ol>
<blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* write @buflen: bytes */</span>
<span class="n">free</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_free</span><span class="p">(</span><span class="n">rbuf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">buflen</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_write</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="k">else</span>
        <span class="cm">/* do something */</span>

<span class="cm">/* read min. 1000, max. @bufsize: bytes */</span>
<span class="n">avail</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_avail</span><span class="p">(</span><span class="n">rbuf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">dvb_ringbuffer_read</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">));</span>
<span class="k">else</span>
        <span class="cm">/* do something */</span>
</pre></div>
</div>
</div></blockquote>
<ol class="last arabic simple" start="2">
<li>If there is exactly one reader and one writer, there is no need
to lock read or write operations.
Two or more readers must be locked against each other.
Flushing the buffer counts as a read operation.
Resetting the buffer counts as a read and write operation.
Two or more writers must be locked against each other.</li>
</ol>
</div>
<dl class="type">
<dt id="c.dvb_ringbuffer">
struct <code class="descname">dvb_ringbuffer</code><a class="headerlink" href="#c.dvb_ringbuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a ring buffer used at DVB framework</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_ringbuffer {
  u8 *data;
  ssize_t size;
  ssize_t pread;
  ssize_t pwrite;
  int error;
  wait_queue_head_t queue;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Area were the ringbuffer data is written</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of the ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">pread</span></code></dt>
<dd>next position to read</dd>
<dt><code class="docutils literal"><span class="pre">pwrite</span></code></dt>
<dd>next position to write</dd>
<dt><code class="docutils literal"><span class="pre">error</span></code></dt>
<dd>used by ringbuffer clients to indicate that an error happened.</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>Wait queue used by ringbuffer clients to indicate when buffer
was filled</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>Spinlock used to protect the ringbuffer</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_init">
void <code class="descname">dvb_ringbuffer_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize ring buffer, lock and queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to the buffer where the data will be stored</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>bytes from ring buffer into <strong>buf</strong></dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_empty">
int <code class="descname">dvb_ringbuffer_empty</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_free">
ssize_t <code class="descname">dvb_ringbuffer_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_free" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of free bytes in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of free bytes in the buffer</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_avail">
ssize_t <code class="descname">dvb_ringbuffer_avail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of bytes waiting in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of bytes waiting in the buffer</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_reset">
void <code class="descname">dvb_ringbuffer_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets the ringbuffer to initial state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the read and write pointers to zero and flush the buffer.</p>
<p>This counts as a read and write operation</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_flush">
void <code class="descname">dvb_ringbuffer_flush</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>flush buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_flush_spinlock_wakeup">
void <code class="descname">dvb_ringbuffer_flush_spinlock_wakeup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_flush_spinlock_wakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>flush buffer protected by spinlock and wake-up waiting task(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
</dl>
<dl class="function">
<dt id="c.DVB_RINGBUFFER_PEEK">
<code class="descname">DVB_RINGBUFFER_PEEK</code><span class="sig-paren">(</span><em>rbuf</em>, <em>offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DVB_RINGBUFFER_PEEK" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at byte <strong>offs</strong> in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">offs</span></code></dt>
<dd>offset inside the ringbuffer</dd>
</dl>
<dl class="function">
<dt id="c.DVB_RINGBUFFER_SKIP">
<code class="descname">DVB_RINGBUFFER_SKIP</code><span class="sig-paren">(</span><em>rbuf</em>, <em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DVB_RINGBUFFER_SKIP" title="Permalink to this definition">¶</a></dt>
<dd><p>advance read ptr by <strong>num</strong> bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">num</span></code></dt>
<dd>number of bytes to advance</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_read_user">
ssize_t <code class="descname">dvb_ringbuffer_read_user</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, u8 __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_read_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a buffer into a user pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the buffer where the data will be stored</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>bytes from ring buffer into <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the userspace. So,
it will internally call <code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code>.</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_read">
void <code class="descname">dvb_ringbuffer_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a buffer into a pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the buffer where the data will be stored</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>bytes from ring buffer into <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the Kernel space</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="function">
<dt id="c.DVB_RINGBUFFER_WRITE_BYTE">
<code class="descname">DVB_RINGBUFFER_WRITE_BYTE</code><span class="sig-paren">(</span><em>rbuf</em>, <em>byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DVB_RINGBUFFER_WRITE_BYTE" title="Permalink to this definition">¶</a></dt>
<dd><p>write single byte to ring buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">byte</span></code></dt>
<dd>byte to write</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_write">
ssize_t <code class="descname">dvb_ringbuffer_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a buffer into the ringbuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the buffer where the data will be read</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>bytes from ring buffer into <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the Kernel space</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_write_user">
ssize_t <code class="descname">dvb_ringbuffer_write_user</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, const u8 __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_write_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a buffer received via a user pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>pointer to struct dvb_ringbuffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the buffer where the data will be read</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>bytes from ring buffer into <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant assumes that the buffer is a memory at the userspace. So,
it will internally call <code class="xref c c-func docutils literal"><span class="pre">copy_from_user()</span></code>.</p>
<p><strong>Return</strong></p>
<p>number of bytes transferred or -EFAULT</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_pkt_write">
ssize_t <code class="descname">dvb_ringbuffer_pkt_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a packet into the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>Ringbuffer to write to.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to write.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Length of buffer (currently limited to 65535 bytes max).</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of bytes written, or -EFAULT, -ENOMEM, -EVINAL.</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_pkt_read_user">
ssize_t <code class="descname">dvb_ringbuffer_pkt_read_user</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, size_t<em>&nbsp;idx</em>, int<em>&nbsp;offset</em>, u8 __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_read_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from a packet in the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>Ringbuffer concerned.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt>
<dd>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>Offset into packet to read from.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Destination buffer for data.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Size of destination buffer.</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of bytes read, or -EFAULT.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">unlike <a class="reference internal" href="#c.dvb_ringbuffer_read" title="dvb_ringbuffer_read"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_read()</span></code></a>, this does <strong>NOT</strong> update the read pointer
in the ringbuffer. You must use <a class="reference internal" href="#c.dvb_ringbuffer_pkt_dispose" title="dvb_ringbuffer_pkt_dispose"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_pkt_dispose()</span></code></a> to mark a
packet as no longer required.</p>
</div>
<dl class="function">
<dt id="c.dvb_ringbuffer_pkt_read">
ssize_t <code class="descname">dvb_ringbuffer_pkt_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, size_t<em>&nbsp;idx</em>, int<em>&nbsp;offset</em>, u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from a packet in the ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>Ringbuffer concerned.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt>
<dd>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>Offset into packet to read from.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Destination buffer for data.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Size of destination buffer.</dd>
</dl>
<p><strong>Note</strong></p>
<p>unlike <a class="reference internal" href="#c.dvb_ringbuffer_read_user" title="dvb_ringbuffer_read_user"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_read_user()</span></code></a>, this DOES update the read pointer
in the ringbuffer.</p>
<p><strong>Return</strong></p>
<p>Number of bytes read, or -EFAULT.</p>
<dl class="function">
<dt id="c.dvb_ringbuffer_pkt_dispose">
void <code class="descname">dvb_ringbuffer_pkt_dispose</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, size_t<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_dispose" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispose of a packet in the ring buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>Ring buffer concerned.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt>
<dd>Packet index as returned by <a class="reference internal" href="#c.dvb_ringbuffer_pkt_next" title="dvb_ringbuffer_pkt_next"><code class="xref c c-func docutils literal"><span class="pre">dvb_ringbuffer_pkt_next()</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_ringbuffer_pkt_next">
ssize_t <code class="descname">dvb_ringbuffer_pkt_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_ringbuffer" title="dvb_ringbuffer">dvb_ringbuffer</a> *<em>&nbsp;rbuf</em>, size_t<em>&nbsp;idx</em>, size_t *<em>&nbsp;pktlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_ringbuffer_pkt_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the index of the next packet in a ringbuffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt>
<dd>Ringbuffer concerned.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">idx</span></code></dt>
<dd>Previous packet index, or -1 to return the first packet index.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">pktlen</span></code></dt>
<dd>On success, will be updated to contain the length of the packet
in bytes.
returns Packet index (if &gt;=0), or -1 if no packets available.</dd>
</dl>
</div>
<div class="section" id="digital-tv-vb2-handler">
<h2>2.1.4. Digital TV VB2 handler<a class="headerlink" href="#digital-tv-vb2-handler" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.dvb_buf_type">
enum <code class="descname">dvb_buf_type</code><a class="headerlink" href="#c.dvb_buf_type" title="Permalink to this definition">¶</a></dt>
<dd><p>types of Digital TV memory-mapped buffers</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DVB_BUF_TYPE_CAPTURE</span></code></dt>
<dd>buffer is filled by the Kernel,
with a received Digital TV stream</dd>
</dl>
<dl class="type">
<dt id="c.dvb_vb2_states">
enum <code class="descname">dvb_vb2_states</code><a class="headerlink" href="#c.dvb_vb2_states" title="Permalink to this definition">¶</a></dt>
<dd><p>states to control VB2 state machine</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DVB_VB2_STATE_NONE</span></code></dt>
<dd>VB2 engine not initialized yet, init failed or VB2 was released.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_VB2_STATE_INIT</span></code></dt>
<dd>VB2 engine initialized.</dd>
<dt><code class="docutils literal"><span class="pre">DVB_VB2_STATE_REQBUFS</span></code></dt>
<dd>Buffers were requested</dd>
<dt><code class="docutils literal"><span class="pre">DVB_VB2_STATE_STREAMON</span></code></dt>
<dd>VB2 is streaming. Callers should not check it directly. Instead,
they should use <a class="reference internal" href="#c.dvb_vb2_is_streaming" title="dvb_vb2_is_streaming"><code class="xref c c-func docutils literal"><span class="pre">dvb_vb2_is_streaming()</span></code></a>.</dd>
</dl>
<p><strong>Note</strong></p>
<p>Callers should not touch at the state machine directly. This
is handled inside dvb_vb2.c.</p>
<dl class="type">
<dt id="c.dvb_buffer">
struct <code class="descname">dvb_buffer</code><a class="headerlink" href="#c.dvb_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>video buffer information for v4l2.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_buffer {
  struct vb2_buffer       vb;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb</span></code></dt>
<dd>embedded struct <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>list of <a class="reference internal" href="#c.dvb_buffer" title="dvb_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_buffer</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_vb2_ctx">
struct <code class="descname">dvb_vb2_ctx</code><a class="headerlink" href="#c.dvb_vb2_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>control struct for VB2 handler</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_vb2_ctx {
  struct vb2_queue        vb_q;
  struct mutex            mutex;
  spinlock_t slock;
  struct list_head        dvb_q;
  struct dvb_buffer       *buf;
  int offset;
  int remain;
  int state;
  int buf_siz;
  int buf_cnt;
  int nonblocking;
  char name[DVB_VB2_NAME_MAX + 1];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb_q</span></code></dt>
<dd>pointer to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>mutex to serialize vb2 operations. Used by
vb2 core <code class="docutils literal"><span class="pre">wait_prepare</span></code> and <code class="docutils literal"><span class="pre">wait_finish</span></code> operations.</dd>
<dt><code class="docutils literal"><span class="pre">slock</span></code></dt>
<dd>spin lock used to protect buffer filling at dvb_vb2.c.</dd>
<dt><code class="docutils literal"><span class="pre">dvb_q</span></code></dt>
<dd>List of buffers that are not filled yet.</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>Pointer to the buffer that are currently being filled.</dd>
<dt><code class="docutils literal"><span class="pre">offset</span></code></dt>
<dd>index to the next position at the <strong>buf</strong> to be filled.</dd>
<dt><code class="docutils literal"><span class="pre">remain</span></code></dt>
<dd>How many bytes are left to be filled at <strong>buf</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>bitmask of buffer states as defined by <a class="reference internal" href="#c.dvb_vb2_states" title="dvb_vb2_states"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_vb2_states</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">buf_siz</span></code></dt>
<dd>size of each VB2 buffer.</dd>
<dt><code class="docutils literal"><span class="pre">buf_cnt</span></code></dt>
<dd>number of VB2 buffers.</dd>
<dt><code class="docutils literal"><span class="pre">nonblocking</span></code></dt>
<dd>If different than zero, device is operating on non-blocking
mode.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the device type. Currently, it can either be
“dvr” or “demux_filter”.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_vb2_init">
int <code class="descname">dvb_vb2_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;non_blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes VB2 handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name for the VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">non_blocking</span></code></dt>
<dd>if not zero, it means that the device is at non-blocking mode</dd>
</dl>
<dl class="function">
<dt id="c.dvb_vb2_release">
int <code class="descname">dvb_vb2_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the VB2 handler allocated resources and put <strong>ctx</strong> at DVB_VB2_STATE_NONE state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
</dl>
<dl class="function">
<dt id="c.dvb_vb2_is_streaming">
int <code class="descname">dvb_vb2_is_streaming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_is_streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>checks if the VB2 handler is streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if not streaming, 1 otherwise.</p>
<dl class="function">
<dt id="c.dvb_vb2_fill_buffer">
int <code class="descname">dvb_vb2_fill_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, const unsigned char *<em>&nbsp;src</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_fill_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>fills a VB2 buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>place where the data is stored</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to be copied from <strong>src</strong></dd>
</dl>
<dl class="function">
<dt id="c.dvb_vb2_poll">
__poll_t <code class="descname">dvb_vb2_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct file *<em>&nbsp;file</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamon" title="vb2_core_streamon"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_streamon()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> argument passed to the poll
file operation handler.</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">poll_table</span></code> wait argument passed to the poll
file operation handler.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements poll <code class="xref c c-func docutils literal"><span class="pre">syscall()</span></code> logic.</p>
<dl class="function">
<dt id="c.dvb_vb2_stream_on">
int <code class="descname">dvb_vb2_stream_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_stream_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamon" title="vb2_core_streamon"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_streamon()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts dvb streaming</p>
<dl class="function">
<dt id="c.dvb_vb2_stream_off">
int <code class="descname">dvb_vb2_stream_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_stream_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_streamoff" title="vb2_core_streamoff"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_streamoff()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops dvb streaming</p>
<dl class="function">
<dt id="c.dvb_vb2_reqbufs">
int <code class="descname">dvb_vb2_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_requestbuffers" title="dmx_requestbuffers">dmx_requestbuffers</a> *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_reqbufs()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_requestbuffers</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd><a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_requestbuffers" title="dmx_requestbuffers"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_requestbuffers</span></code></a> passed from userspace in
order to handle <a class="reference internal" href="../uapi/dvb/dmx-reqbufs.html#c.DMX_REQBUFS" title="DMX_REQBUFS"><code class="xref c c-type docutils literal"><span class="pre">DMX_REQBUFS</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate streaming by requesting a number of buffers. Also used to
free previously requested buffers, is <code class="docutils literal"><span class="pre">req-&gt;count</span></code> is zero.</p>
<dl class="function">
<dt id="c.dvb_vb2_querybuf">
int <code class="descname">dvb_vb2_querybuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_querybuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_querybuf" title="vb2_core_querybuf"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_querybuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd><a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <a class="reference internal" href="../uapi/dvb/dmx-querybuf.html#c.DMX_QUERYBUF" title="DMX_QUERYBUF"><code class="xref c c-type docutils literal"><span class="pre">DMX_QUERYBUF</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_vb2_expbuf">
int <code class="descname">dvb_vb2_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_exportbuffer" title="dmx_exportbuffer">dmx_exportbuffer</a> *<em>&nbsp;exp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_expbuf" title="vb2_core_expbuf"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_expbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_exportbuffer</span> <span class="pre">*</span> <span class="pre">exp</span></code></dt>
<dd><a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_exportbuffer" title="dmx_exportbuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_exportbuffer</span></code></a> passed from userspace in
order to handle <a class="reference internal" href="../uapi/dvb/dmx-expbuf.html#c.DMX_EXPBUF" title="DMX_EXPBUF"><code class="xref c c-type docutils literal"><span class="pre">DMX_EXPBUF</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Export a buffer as a file descriptor.</p>
<dl class="function">
<dt id="c.dvb_vb2_qbuf">
int <code class="descname">dvb_vb2_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_qbuf" title="vb2_core_qbuf"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_qbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd><a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <a class="reference internal" href="../uapi/dvb/dmx-qbuf.html#c.DMX_QBUF" title="DMX_QBUF"><code class="xref c c-type docutils literal"><span class="pre">DMX_QBUF</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue a Digital TV buffer as requested by userspace</p>
<dl class="function">
<dt id="c.dvb_vb2_dqbuf">
int <code class="descname">dvb_vb2_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer">dmx_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_core_dqbuf" title="vb2_core_dqbuf"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_dqbuf()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd><a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer" title="dmx_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_buffer</span></code></a> passed from userspace in
order to handle <a class="reference internal" href="../uapi/dvb/dmx-qbuf.html#c.DMX_DQBUF" title="DMX_DQBUF"><code class="xref c c-type docutils literal"><span class="pre">DMX_DQBUF</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dequeue a Digital TV buffer to the userspace</p>
<dl class="function">
<dt id="c.dvb_vb2_mmap">
int <code class="descname">dvb_vb2_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_vb2_ctx" title="dvb_vb2_ctx">dvb_vb2_ctx</a> *<em>&nbsp;ctx</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_vb2_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_mmap" title="vb2_mmap"><code class="xref c c-func docutils literal"><span class="pre">vb2_mmap()</span></code></a> for Digital TV buffer handling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_vb2_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> with the vma passed
to the mmap file operation handler in the driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>map Digital TV video buffers into application address space.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dtv-frontend.html" class="btn btn-neutral float-right" title="2.2. Digital TV Frontend kABI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-core.html" class="btn btn-neutral" title="2. Digital TV (DVB) devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.16.0-rc1+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>