

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Parallel Port Devices &mdash; The Linux Kernel 5.4.0-rc3+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Intel(R) Management Engine Interface (Intel(R) MEI)" href="mei/index.html" />
    <link rel="prev" title="MTD NAND Driver Programming Interface" href="mtdnand.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.4.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ioctl/index.html">IOCTLs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">GENERIC SYSTEM INTERCONNECT SUBSYSTEM</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="dell_rbu.html">Usage of the new open sourced rbu (Remote BIOS Update) driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Parallel Port Devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/miscellaneous.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="parallel-port-devices">
<h1>Parallel Port Devices<a class="headerlink" href="#parallel-port-devices" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.parport_yield">
int <code class="descname">parport_yield</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield" title="Permalink to this definition">¶</a></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>a device on the parallel port</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>.  If it fails, the port is left unclaimed and it is
the driver’s responsibility to reclaim the port.</p>
<p>The <a class="reference internal" href="#c.parport_yield" title="parport_yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield()</span></code></a> and <a class="reference internal" href="#c.parport_yield_blocking" title="parport_yield_blocking"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield_blocking()</span></code></a> functions are for
marking points in the driver at which other drivers may claim the
port and use their devices.  Yielding the port is similar to
releasing it and reclaiming it, but is more efficient because no
action is taken if there are no other devices needing the port.  In
fact, nothing is done even if there are other devices waiting but
the current device is still within its “timeslice”.  The default
timeslice is half a second, but it can be adjusted via the /proc
interface.</p>
<dl class="function">
<dt id="c.parport_yield_blocking">
int <code class="descname">parport_yield_blocking</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>a device on the parallel port</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>.</p>
<dl class="function">
<dt id="c.parport_wait_event">
int <code class="descname">parport_wait_event</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, signed long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_event" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for an event on a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to wait on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>time to wait (in jiffies)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for up to <strong>timeout</strong> jiffies for an
interrupt to occur on a parallel port.  If the port timeout is
set to zero, it returns immediately.</p>
<p>If an interrupt occurs before the timeout period elapses, this
function returns zero immediately.  If it times out, it returns
one.  An error code less than zero indicates an error (most
likely a pending signal), and the calling code should finish
what it’s doing as soon as it can.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_wait_peripheral">
int <code class="descname">parport_wait_peripheral</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, unsigned char<em>&nbsp;mask</em>, unsigned char<em>&nbsp;result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for status lines to change in 35ms</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to watch</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">mask</span></code></dt>
<dd>status lines to watch</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">result</span></code></dt>
<dd>desired values of chosen status lines</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits until the masked status lines have the
desired values, or until 35ms have elapsed (see IEEE 1284-1994
page 24 to 25 for why this value in particular is hardcoded).
The <strong>mask</strong> and <strong>result</strong> parameters are bitmasks, with the bits
defined by the constants in parport.h: <code class="docutils literal notranslate"><span class="pre">PARPORT_STATUS_BUSY</span></code>,
and so on.</p>
<p>The port is polled quickly to start off with, in anticipation
of a fast response from the peripheral.  This fast polling
time is configurable (using /proc), and defaults to 500usec.
If the timeout for this port (see <a class="reference internal" href="#c.parport_set_timeout" title="parport_set_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_set_timeout()</span></code></a>) is
zero, the fast polling time is 35ms, and this function does
not call schedule().</p>
<p>If the timeout for this port is non-zero, after the fast
polling fails it uses <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> to wait for up to
10ms, waking up if an interrupt occurs.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_negotiate">
int <code class="descname">parport_negotiate</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, int<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_negotiate" title="Permalink to this definition">¶</a></dt>
<dd><p>negotiate an IEEE 1284 mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>mode to negotiate to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Use this to negotiate to a particular IEEE 1284 transfer mode.
The <strong>mode</strong> parameter should be one of the constants in
parport.h starting <code class="docutils literal notranslate"><span class="pre">IEEE1284_MODE_xxx</span></code>.</p>
<p>The return value is 0 if the peripheral has accepted the
negotiation to the mode specified, -1 if the peripheral is not
IEEE 1284 compliant (or not present), or 1 if the peripheral
has rejected the negotiation.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_write">
ssize_t <code class="descname">parport_write</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, const void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a block of data to a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to write to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data buffer (in kernel space)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes of data to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This will write up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports forward transfers (host to peripheral).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are valid.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_read">
ssize_t <code class="descname">parport_read</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a block of data from a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data buffer (in kernel space)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes of data to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This will read up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports reverse transfers (peripheral to host).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are available to write to.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_set_timeout">
long <code class="descname">parport_set_timeout</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em>, long<em>&nbsp;inactivity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_set_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>set the inactivity timeout for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device on a port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">inactivity</span></code></dt>
<dd>inactivity timeout (in jiffies)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This sets the inactivity timeout for a particular device on a
port.  This affects functions like <a class="reference internal" href="#c.parport_wait_peripheral" title="parport_wait_peripheral"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_peripheral()</span></code></a>.
The special value 0 means not to call schedule() while dealing
with this device.</p>
<p>The return value is the previous inactivity timeout.</p>
<p>Any callers of <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> for this device are woken
up.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__parport_register_driver">
int <code class="descname">__parport_register_driver</code><span class="sig-paren">(</span>struct parport_driver *<em>&nbsp;drv</em>, struct module *<em>&nbsp;owner</em>, const char *<em>&nbsp;mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__parport_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a parallel port device driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>structure describing the driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of drv</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mod_name</span></code></dt>
<dd>module name string</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.</p>
<p>If devmodel is true then the new device model is used
for registration.</p>
<p>The <strong>drv</strong> structure is allocated by the caller and must not be
deallocated until after calling <a class="reference internal" href="#c.parport_unregister_driver" title="parport_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_driver()</span></code></a>.</p>
<p>If using the non device model:
The driver’s attach() function may block.  The port that
attach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.  Calling
<a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a> on that port will do this for you.</p>
<p>The driver’s detach() function may block.  The port that
detach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.</p>
<p>Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_unregister_driver">
void <code class="descname">parport_unregister_driver</code><span class="sig-paren">(</span>struct parport_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a parallel port device driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>structure describing the driver that was given to
parport_register_driver()</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be called by a parallel port device driver that
has registered itself using parport_register_driver() when it
is about to be unloaded.</p>
<p>When it returns, the driver’s attach() routine will no longer
be called, and for each port that attach() was called for, the
detach() routine will have been called.</p>
<p>All the driver’s attach() and detach() calls are guaranteed to have
finished by the time this function returns.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_get_port">
struct parport * <code class="descname">parport_get_port</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a port’s reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>the port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This ensures that a struct parport pointer remains valid
until the matching <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a> call.</div></blockquote>
<dl class="function">
<dt id="c.parport_put_port">
void <code class="descname">parport_put_port</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_put_port" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a port’s reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>the port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be called once for each call to <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a>,
once the port is no longer needed. When the reference count reaches
zero (port is no longer used), free_port is called.</div></blockquote>
<dl class="function">
<dt id="c.parport_register_port">
struct parport * <code class="descname">parport_register_port</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;base</em>, int<em>&nbsp;irq</em>, int<em>&nbsp;dma</em>, struct parport_operations *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_port" title="Permalink to this definition">¶</a></dt>
<dd><p>register a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt>
<dd>base I/O address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>IRQ line</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt>
<dd>DMA channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_operations</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>pointer to the port driver’s port operations structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>When a parallel port (lowlevel) driver finds a port that
should be made available to parallel port device drivers, it
should call <a class="reference internal" href="#c.parport_register_port" title="parport_register_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_port()</span></code></a>.  The <strong>base</strong>, <strong>irq</strong>, and
<strong>dma</strong> parameters are for the convenience of port drivers, and
for ports where they aren’t meaningful needn’t be set to
anything special.  They can be altered afterwards by adjusting
the relevant members of the parport structure that is returned
and represents the port.  They should not be tampered with
after calling parport_announce_port, however.</p>
<p>If there are parallel port device drivers in the system that
have registered themselves using parport_register_driver(),
they are not told about the port at this time; that is done by
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a>.</p>
<p>The <strong>ops</strong> structure is allocated by the caller, and must not be
deallocated before calling <a class="reference internal" href="#c.parport_remove_port" title="parport_remove_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_remove_port()</span></code></a>.</p>
<p>If there is no memory to allocate a new parport structure,
this function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_announce_port">
void <code class="descname">parport_announce_port</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_announce_port" title="Permalink to this definition">¶</a></dt>
<dd><p>tell device drivers about a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>parallel port to announce</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>After a port driver has registered a parallel port with
parport_register_port, and performed any necessary
initialisation or adjustments, it should call
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a> in order to notify all device drivers
that have called parport_register_driver().  Their attach()
functions will be called, with <strong>port</strong> as the parameter.</div></blockquote>
<dl class="function">
<dt id="c.parport_remove_port">
void <code class="descname">parport_remove_port</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_remove_port" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>parallel port to deregister</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>When a parallel port driver is forcibly unloaded, or a
parallel port becomes inaccessible, the port driver must call
this function in order to deal with device drivers that still
want to use it.</p>
<p>The parport structure associated with the port has its
operations structure replaced with one containing ‘null’
operations that return errors or just don’t do anything.</p>
<p>Any drivers that have registered themselves using
parport_register_driver() are notified that the port is no
longer accessible by having their detach() routines called
with <strong>port</strong> as the parameter.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_register_device">
struct pardevice * <code class="descname">parport_register_device</code><span class="sig-paren">(</span>struct parport *<em>&nbsp;port</em>, const char *<em>&nbsp;name</em>, int (*pf) (void<em>&nbsp;*</em>, void (*kf) (void<em>&nbsp;*</em>, void (*irq_func) (void<em>&nbsp;*</em>, int<em>&nbsp;flags</em>, void *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a device on a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to which the device is attached</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a name to refer to the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">pf</span></code></dt>
<dd>preemption callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">kf</span></code></dt>
<dd>kick callback (wake-up)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">irq_func</span></code></dt>
<dd>interrupt handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>registration flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>data for callback functions</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function, called by parallel port device drivers,
declares that a device is connected to a port, and tells the
system all it needs to know.</p>
<p>The <strong>name</strong> is allocated by the caller and must not be
deallocated until the caller calls <strong>parport_unregister_device</strong>
for that device.</p>
<p>The preemption callback function, <strong>pf</strong>, is called when this
device driver has claimed access to the port but another
device driver wants to use it.  It is given <strong>handle</strong> as its
parameter, and should return zero if it is willing for the
system to release the port to another driver on its behalf.
If it wants to keep control of the port it should return
non-zero, and no action will be taken.  It is good manners for
the driver to try to release the port at the earliest
opportunity after its preemption callback rejects a preemption
attempt.  Note that if a preemption callback is happy for
preemption to go ahead, there is no need to release the port;
it is done automatically.  This function may not block, as it
may be called from interrupt context.  If the device driver
does not support preemption, <strong>pf</strong> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The wake-up (“kick”) callback function, <strong>kf</strong>, is called when
the port is available to be claimed for exclusive access; that
is, <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> is guaranteed to succeed when called from
inside the wake-up callback function.  If the driver wants to
claim the port it should do so; otherwise, it need not take
any action.  This function may not block, as it may be called
from interrupt context.  If the device driver does not want to
be explicitly invited to claim the port in this way, <strong>kf</strong> can
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The interrupt handler, <strong>irq_func</strong>, is called when an interrupt
arrives from the parallel port.  Note that if a device driver
wants to use interrupts it should use parport_enable_irq(),
and can also check the irq member of the parport structure
representing the port.</p>
<p>The parallel port (lowlevel) driver is the one that has called
request_irq() and whose interrupt handler is called first.
This handler does whatever needs to be done to the hardware to
acknowledge the interrupt (for PC-style ports there is nothing
special to be done).  It then tells the IEEE 1284 code about
the interrupt, which may involve reacting to an IEEE 1284
event depending on the current IEEE 1284 phase.  After this,
it calls <strong>irq_func</strong>.  Needless to say, <strong>irq_func</strong> will be called
from interrupt context, and may not block.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PARPORT_DEV_EXCL</span></code> flag is for preventing port sharing, and
so should only be used when sharing the port with other device
drivers is impossible and would lead to incorrect behaviour.
Use it sparingly!  Normally, <strong>flags</strong> will be zero.</p>
<p>This function returns a pointer to a structure that represents
the device on the port, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is not enough memory
to allocate space for that structure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_unregister_device">
void <code class="descname">parport_unregister_device</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a device on a parallel port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to structure representing device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This undoes the effect of <a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.parport_find_number">
struct parport * <code class="descname">parport_find_number</code><span class="sig-paren">(</span>int<em>&nbsp;number</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_number" title="Permalink to this definition">¶</a></dt>
<dd><p>find a parallel port by number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt>
<dd>parallel port number</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This returns the parallel port with the specified number, or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_number" title="parport_find_number"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_number()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_find_base">
struct parport * <code class="descname">parport_find_base</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_base" title="Permalink to this definition">¶</a></dt>
<dd><p>find a parallel port by base address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt>
<dd>base I/O address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This returns the parallel port with the specified base
address, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_base" title="parport_find_base"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_base()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_claim">
int <code class="descname">parport_claim</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim" title="Permalink to this definition">¶</a></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to structure representing a device on the port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will not block and so can be used from interrupt
context.  If <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> succeeds in claiming access to
the port it returns zero and the port is available to use.  It
may fail (returning non-zero) if the port is in use by another
driver and that driver is not willing to relinquish control of
the port.</div></blockquote>
<dl class="function">
<dt id="c.parport_claim_or_block">
int <code class="descname">parport_claim_or_block</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim_or_block" title="Permalink to this definition">¶</a></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to structure representing a device on the port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This behaves like <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, but will block if necessary
to wait for the port to be free.  A return value of 1
indicates that it slept; 0 means that it succeeded without
needing to sleep.  A negative error code indicates failure.</div></blockquote>
<dl class="function">
<dt id="c.parport_release">
void <code class="descname">parport_release</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_release" title="Permalink to this definition">¶</a></dt>
<dd><p>give up access to a parallel port device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to structure representing parallel port device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function cannot fail, but it should not be called without
the port claimed.  Similarly, if the port is already claimed
you should not try claiming it again.</div></blockquote>
<dl class="function">
<dt id="c.parport_open">
struct pardevice * <code class="descname">parport_open</code><span class="sig-paren">(</span>int<em>&nbsp;devnum</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_open" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by canonical device number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnum</span></code></dt>
<dd>canonical device number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to associate with the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is similar to <a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a>, except
that it locates a device by its number rather than by the port
it is attached to.</p>
<p>All parameters except for <strong>devnum</strong> are the same as for
<a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a>.  The return value is the same as
for <a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.parport_close">
void <code class="descname">parport_close</code><span class="sig-paren">(</span>struct pardevice *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close a device opened with <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to close</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is to <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a> as <a class="reference internal" href="#c.parport_unregister_device" title="parport_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_device()</span></code></a> is to
<a class="reference internal" href="#c.parport_register_device" title="parport_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_device()</span></code></a>.</div></blockquote>
</div>
<div class="section" id="x50-uart-driver">
<h1>16x50 UART Driver<a class="headerlink" href="#x50-uart-driver" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.uart_update_timeout">
void <code class="descname">uart_update_timeout</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, unsigned int<em>&nbsp;cflag</em>, unsigned int<em>&nbsp;baud</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_update_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>update per-port FIFO timeout.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>uart_port structure describing the port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cflag</span></code></dt>
<dd>termios cflag value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baud</span></code></dt>
<dd>speed of the port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set the port FIFO timeout value.  The <strong>cflag</strong> value should
reflect the actual hardware settings.</div></blockquote>
<dl class="function">
<dt id="c.uart_get_baud_rate">
unsigned int <code class="descname">uart_get_baud_rate</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, struct ktermios *<em>&nbsp;termios</em>, struct ktermios *<em>&nbsp;old</em>, unsigned int<em>&nbsp;min</em>, unsigned int<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_baud_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>return baud rate for a particular port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>uart_port structure describing the port in question.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*</span> <span class="pre">termios</span></code></dt>
<dd>desired termios settings.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>old termios (or NULL)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>minimum acceptable baud rate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>maximum acceptable baud rate</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Decode the termios structure into a numeric baud rate,
taking account of the magic 38400 baud rate (with spd_*
flags), and mapping the <code class="docutils literal notranslate"><span class="pre">B0</span></code> rate to 9600 baud.</p>
<p>If the new baud rate is invalid, try the old termios setting.
If it’s still invalid, we try 9600 baud.</p>
<p>Update the <strong>termios</strong> structure to reflect the baud rate
we’re actually going to be using. Don’t do this for the case
where B0 is requested (“hang up”).</p>
</div></blockquote>
<dl class="function">
<dt id="c.uart_get_divisor">
unsigned int <code class="descname">uart_get_divisor</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, unsigned int<em>&nbsp;baud</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_divisor" title="Permalink to this definition">¶</a></dt>
<dd><p>return uart clock divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>uart_port structure describing the port.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baud</span></code></dt>
<dd>desired baud rate</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Calculate the uart clock divisor for the port.</div></blockquote>
<dl class="function">
<dt id="c.uart_console_write">
void <code class="descname">uart_console_write</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;count</em>, void (*putchar) (struct uart_port<em>&nbsp;*</em>, int<span class="sig-paren">)</span><a class="headerlink" href="#c.uart_console_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a console message to a serial port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>the port to write the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>array of characters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of characters in string to write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">uart_port</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">putchar</span></code></dt>
<dd>function to write character to port</dd>
</dl>
<dl class="function">
<dt id="c.uart_parse_earlycon">
int <code class="descname">uart_parse_earlycon</code><span class="sig-paren">(</span>char *<em>&nbsp;p</em>, unsigned char *<em>&nbsp;iotype</em>, resource_size_t *<em>&nbsp;addr</em>, char **<em>&nbsp;options</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_parse_earlycon" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse earlycon options</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>ptr to 2nd field (ie., just beyond ‘&lt;name&gt;,’)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">iotype</span></code></dt>
<dd>ptr for decoded iotype (out)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>ptr for decoded mapbase/iobase (out)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">options</span></code></dt>
<dd>ptr for &lt;options&gt; field; NULL if not present (out)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><dl class="docutils">
<dt>Decodes earlycon kernel command line parameters of the form</dt>
<dd>earlycon=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;
console=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;</dd>
</dl>
<p>The optional form</p>
<blockquote>
<div>earlycon=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;
console=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</div></blockquote>
<p>is also accepted; the returned <strong>iotype</strong> will be UPIO_MEM.</p>
<p>Returns 0 on success or -EINVAL on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.uart_parse_options">
void <code class="descname">uart_parse_options</code><span class="sig-paren">(</span>const char *<em>&nbsp;options</em>, int *<em>&nbsp;baud</em>, int *<em>&nbsp;parity</em>, int *<em>&nbsp;bits</em>, int *<em>&nbsp;flow</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_parse_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse serial port baud/parity/bits/flow control.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">options</span></code></dt>
<dd>pointer to option string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">baud</span></code></dt>
<dd>pointer to an ‘int’ variable for the baud rate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">parity</span></code></dt>
<dd>pointer to an ‘int’ variable for the parity.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">bits</span></code></dt>
<dd>pointer to an ‘int’ variable for the number of data bits.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">flow</span></code></dt>
<dd>pointer to an ‘int’ variable for the flow control character.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>uart_parse_options decodes a string containing the serial console
options.  The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,
eg: 115200n8r</div></blockquote>
<dl class="function">
<dt id="c.uart_set_options">
int <code class="descname">uart_set_options</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, struct console *<em>&nbsp;co</em>, int<em>&nbsp;baud</em>, int<em>&nbsp;parity</em>, int<em>&nbsp;bits</em>, int<em>&nbsp;flow</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_set_options" title="Permalink to this definition">¶</a></dt>
<dd><p>setup the serial console parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>pointer to the serial ports uart_port structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">console</span> <span class="pre">*</span> <span class="pre">co</span></code></dt>
<dd>console pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">baud</span></code></dt>
<dd>baud rate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">parity</span></code></dt>
<dd>parity character - ‘n’ (none), ‘o’ (odd), ‘e’ (even)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of data bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flow</span></code></dt>
<dd>flow control character - ‘r’ (rts)</dd>
</dl>
<dl class="function">
<dt id="c.uart_register_driver">
int <code class="descname">uart_register_driver</code><span class="sig-paren">(</span>struct uart_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver with the uart core layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>low level driver structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Register a uart driver with the core driver.  We in turn register
with the tty layer, and initialise the core driver per-port state.</p>
<p>We have a proc file in /proc/tty/driver which is named after the
normal driver.</p>
<p>drv-&gt;port should be NULL, and the per-port structures should be
registered using uart_add_one_port after this call has succeeded.</p>
</div></blockquote>
<dl class="function">
<dt id="c.uart_unregister_driver">
void <code class="descname">uart_unregister_driver</code><span class="sig-paren">(</span>struct uart_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a driver from the uart core layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>low level driver structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove all references to a driver from the core driver.  The low
level driver must have removed all its ports via the
<a class="reference internal" href="#c.uart_remove_one_port" title="uart_remove_one_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_remove_one_port()</span></code></a> if it registered them with <a class="reference internal" href="#c.uart_add_one_port" title="uart_add_one_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_add_one_port()</span></code></a>.
(ie, drv-&gt;port == NULL)</div></blockquote>
<dl class="function">
<dt id="c.uart_add_one_port">
int <code class="descname">uart_add_one_port</code><span class="sig-paren">(</span>struct uart_driver *<em>&nbsp;drv</em>, struct uart_port *<em>&nbsp;uport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_add_one_port" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a driver-defined port structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the uart low level driver structure for this port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">uport</span></code></dt>
<dd>uart port structure to use for this port.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This allows the driver to register its own uart_port structure
with the core driver.  The main purpose is to allow the low
level uart drivers to expand uart_port, rather than having yet
more levels of structures.</div></blockquote>
<dl class="function">
<dt id="c.uart_remove_one_port">
int <code class="descname">uart_remove_one_port</code><span class="sig-paren">(</span>struct uart_driver *<em>&nbsp;drv</em>, struct uart_port *<em>&nbsp;uport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_remove_one_port" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a driver defined port structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the uart low level driver structure for this port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">uport</span></code></dt>
<dd>uart port structure for this port</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This unhooks (and hangs up) the specified port structure from the
core driver.  No further calls will be made to the low-level code
for this port.</div></blockquote>
<dl class="function">
<dt id="c.uart_handle_dcd_change">
void <code class="descname">uart_handle_dcd_change</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;uport</em>, unsigned int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_handle_dcd_change" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a change of carrier detect state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">uport</span></code></dt>
<dd>uart_port structure for the open port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>new carrier detect status, nonzero if active</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Caller must hold uport-&gt;lock</div></blockquote>
<dl class="function">
<dt id="c.uart_handle_cts_change">
void <code class="descname">uart_handle_cts_change</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;uport</em>, unsigned int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_handle_cts_change" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a change of clear-to-send state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">uport</span></code></dt>
<dd>uart_port structure for the open port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>new clear to send status, nonzero if active</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Caller must hold uport-&gt;lock</div></blockquote>
<dl class="function">
<dt id="c.uart_insert_char">
void <code class="descname">uart_insert_char</code><span class="sig-paren">(</span>struct uart_port *<em>&nbsp;port</em>, unsigned int<em>&nbsp;status</em>, unsigned int<em>&nbsp;overrun</em>, unsigned int<em>&nbsp;ch</em>, unsigned int<em>&nbsp;flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_insert_char" title="Permalink to this definition">¶</a></dt>
<dd><p>push a char to the uart layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>corresponding port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>state of the serial port RX buffer (LSR for 8250)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">overrun</span></code></dt>
<dd>mask of overrun bits in <strong>status</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ch</span></code></dt>
<dd>character to push</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>flag for the character (see TTY_NORMAL and friends)</dd>
</dl>
<p><strong>Description</strong></p>
<p>User is responsible to call tty_flip_buffer_push when they are done with
insertion.</p>
<dl class="function">
<dt id="c.uart_get_rs485_mode">
void <code class="descname">uart_get_rs485_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct serial_rs485 *<em>&nbsp;rs485conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_rs485_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve rs485 properties for given uart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>uart device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span> <span class="pre">*</span> <span class="pre">rs485conf</span></code></dt>
<dd>output parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the device tree binding described in
Documentation/devicetree/bindings/serial/rs485.txt.</p>
<dl class="function">
<dt id="c.serial8250_get_port">
struct uart_8250_port * <code class="descname">serial8250_get_port</code><span class="sig-paren">(</span>int<em>&nbsp;line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve struct uart_8250_port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd>serial line number</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves struct uart_8250_port for the specific line.
This struct <em>must</em> <em>not</em> be used to perform a 8250 or serial core operation
which is not accessible otherwise. Its only purpose is to make the struct
accessible to the runtime-pm callbacks for context suspend/restore.
The lock assumption made here is none because runtime-pm suspend/resume
callbacks should not be invoked if there is any operation performed on the
port.</p>
<dl class="function">
<dt id="c.serial8250_suspend_port">
void <code class="descname">serial8250_suspend_port</code><span class="sig-paren">(</span>int<em>&nbsp;line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_suspend_port" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend one serial port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd>serial line number</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Suspend one serial port.</div></blockquote>
<dl class="function">
<dt id="c.serial8250_resume_port">
void <code class="descname">serial8250_resume_port</code><span class="sig-paren">(</span>int<em>&nbsp;line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_resume_port" title="Permalink to this definition">¶</a></dt>
<dd><p>resume one serial port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd>serial line number</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Resume one serial port.</div></blockquote>
<dl class="function">
<dt id="c.serial8250_register_8250_port">
int <code class="descname">serial8250_register_8250_port</code><span class="sig-paren">(</span>struct uart_8250_port *<em>&nbsp;up</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_register_8250_port" title="Permalink to this definition">¶</a></dt>
<dd><p>register a serial port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_8250_port</span> <span class="pre">*</span> <span class="pre">up</span></code></dt>
<dd>serial port template</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Configure the serial port specified by the request. If the
port exists and is in use, it is hung up and unregistered
first.</p>
<p>The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.</p>
<p>On success the port is ready to use and the line number is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.serial8250_unregister_port">
void <code class="descname">serial8250_unregister_port</code><span class="sig-paren">(</span>int<em>&nbsp;line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_unregister_port" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a 16x50 serial port at runtime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd>serial line number</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.</div></blockquote>
</div>
<div class="section" id="pulse-width-modulation-pwm">
<h1>Pulse-Width Modulation (PWM)<a class="headerlink" href="#pulse-width-modulation-pwm" title="Permalink to this headline">¶</a></h1>
<p>Pulse-width modulation is a modulation technique primarily used to
control power supplied to electrical devices.</p>
<p>The PWM framework provides an abstraction for providers and consumers of
PWM signals. A controller that provides one or more PWM signals is
registered as <a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span></code></a>. Providers
are expected to embed this structure in a driver-specific structure.
This structure contains fields that describe a particular chip.</p>
<p>A chip exposes one or more PWM signal sources, each of which exposed as
a <a class="reference internal" href="#c.pwm_device" title="pwm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span></code></a>. Operations can be
performed on PWM devices to control the period, duty cycle, polarity and
active state of the signal.</p>
<p>Note that PWM devices are exclusive resources: they can always only be
used by one consumer at a time.</p>
<dl class="type">
<dt id="c.pwm_polarity">
enum <code class="descname">pwm_polarity</code><a class="headerlink" href="#c.pwm_polarity" title="Permalink to this definition">¶</a></dt>
<dd><p>polarity of a PWM signal</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_NORMAL</span></code></dt>
<dd>a high signal for the duration of the duty-
cycle, followed by a low signal for the remainder of the pulse
period</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_INVERSED</span></code></dt>
<dd>a low signal for the duration of the duty-
cycle, followed by a high signal for the remainder of the pulse
period</dd>
</dl>
<dl class="type">
<dt id="c.pwm_args">
struct <code class="descname">pwm_args</code><a class="headerlink" href="#c.pwm_args" title="Permalink to this definition">¶</a></dt>
<dd><p>board-dependent PWM arguments</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_args {
  unsigned int period;
  enum pwm_polarity polarity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt>
<dd>reference period</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polarity</span></code></dt>
<dd>reference polarity</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes board-dependent arguments attached to a PWM
device. These arguments are usually retrieved from the PWM lookup table or
device tree.</p>
<p>Do not confuse this with the PWM state: PWM arguments represent the initial
configuration that users want to use on this PWM device rather than the
current PWM hardware state.</p>
<dl class="type">
<dt id="c.pwm_device">
struct <code class="descname">pwm_device</code><a class="headerlink" href="#c.pwm_device" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM channel object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_device {
  const char *label;
  unsigned long flags;
  unsigned int hwpwm;
  unsigned int pwm;
  struct pwm_chip *chip;
  void *chip_data;
  struct pwm_args args;
  struct pwm_state state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt>
<dd>name of the PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>flags associated with the PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpwm</span></code></dt>
<dd>per-chip relative index of the PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwm</span></code></dt>
<dd>global index of the PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt>
<dd>PWM chip providing this PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_data</span></code></dt>
<dd>chip-private data associated with the PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args</span></code></dt>
<dd>PWM arguments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>curent PWM channel state</dd>
</dl>
<dl class="function">
<dt id="c.pwm_get_state">
void <code class="descname">pwm_get_state</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, struct pwm_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the current PWM state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>state to fill with the current PWM state</dd>
</dl>
<dl class="function">
<dt id="c.pwm_init_state">
void <code class="descname">pwm_init_state</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, struct pwm_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_init_state" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a new state to be applied with <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>state to fill with the prepared PWM state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions prepares a state that can later be tweaked and applied
to the PWM device with <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a>. This is a convenient function
that first retrieves the current PWM state and the replaces the period
and polarity fields with the reference values defined in pwm-&gt;args.
Once the function returns, you can adjust the -&gt;enabled and -&gt;duty_cycle
fields according to your needs before calling <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a>.</p>
<p>-&gt;duty_cycle is initially set to zero to avoid cases where the current
-&gt;duty_cycle value exceed the pwm_args-&gt;period one, which would trigger
an error if the user calls <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a> without adjusting -&gt;duty_cycle
first.</p>
<dl class="function">
<dt id="c.pwm_get_relative_duty_cycle">
unsigned int <code class="descname">pwm_get_relative_duty_cycle</code><span class="sig-paren">(</span>const struct pwm_state *<em>&nbsp;state</em>, unsigned int<em>&nbsp;scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_relative_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a relative duty cycle value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>PWM state to extract the duty cycle from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt>
<dd>target scale of the relative duty cycle</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts the absolute duty cycle stored in <strong>state</strong> (expressed
in nanosecond) into a value relative to the period.</p>
<p>For example if you want to get the duty_cycle expressed in percent, call:</p>
<p>pwm_get_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
duty = pwm_get_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 100);</p>
<dl class="function">
<dt id="c.pwm_set_relative_duty_cycle">
int <code class="descname">pwm_set_relative_duty_cycle</code><span class="sig-paren">(</span>struct pwm_state *<em>&nbsp;state</em>, unsigned int<em>&nbsp;duty_cycle</em>, unsigned int<em>&nbsp;scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_relative_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a relative duty cycle value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>PWM state to fill</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duty_cycle</span></code></dt>
<dd>relative duty cycle value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt>
<dd>scale in which <strong>duty_cycle</strong> is expressed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts a relative into an absolute duty cycle (expressed
in nanoseconds), and puts the result in state-&gt;duty_cycle.</p>
<p>For example if you want to configure a 50% duty cycle, call:</p>
<p>pwm_init_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
pwm_set_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 50, 100);
pwm_apply_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);</p>
<p>This functions returns -EINVAL if <strong>duty_cycle</strong> and/or <strong>scale</strong> are
inconsistent (<strong>scale</strong> == 0 or <strong>duty_cycle</strong> &gt; <strong>scale</strong>).</p>
<dl class="type">
<dt id="c.pwm_ops">
struct <code class="descname">pwm_ops</code><a class="headerlink" href="#c.pwm_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM controller operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_ops {
  int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
  void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
  int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_capture *result, unsigned long timeout);
  int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm, const struct pwm_state *state);
  void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state);
  struct module *owner;
  int (*config)(struct pwm_chip *chip, struct pwm_device *pwm, int duty_ns, int period_ns);
  int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm, enum pwm_polarity polarity);
  int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
  void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt>
<dd>optional hook for requesting a PWM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt>
<dd>optional hook for freeing a PWM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capture</span></code></dt>
<dd>capture and report PWM signal</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply</span></code></dt>
<dd>atomically apply a new PWM config. The state argument
should be adjusted with the real hardware config (if the
approximate the period or duty_cycle value, state should
reflect it)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_state</span></code></dt>
<dd>get the current PWM state. This function is only
called once per PWM device when the PWM chip is
registered.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt>
<dd>helps prevent removal of modules exporting active PWMs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt>
<dd>configure duty cycles and period length for this PWM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_polarity</span></code></dt>
<dd>configure the polarity of this PWM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt>
<dd>enable PWM output toggling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt>
<dd>disable PWM output toggling</dd>
</dl>
<dl class="type">
<dt id="c.pwm_chip">
struct <code class="descname">pwm_chip</code><a class="headerlink" href="#c.pwm_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract a PWM controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_chip {
  struct device *dev;
  const struct pwm_ops *ops;
  int base;
  unsigned int npwm;
  struct pwm_device * (*of_xlate)(struct pwm_chip *pc, const struct of_phandle_args *args);
  unsigned int of_pwm_n_cells;
  struct list_head list;
  struct pwm_device *pwms;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>device providing the PWMs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>callbacks for this PWM controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd>number of first PWM controlled by this chip</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npwm</span></code></dt>
<dd>number of PWMs controlled by this chip</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_xlate</span></code></dt>
<dd>request a PWM device given a device tree PWM specifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_pwm_n_cells</span></code></dt>
<dd>number of cells expected in the device tree PWM specifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>list node for internal use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwms</span></code></dt>
<dd>array of PWM devices allocated by the framework</dd>
</dl>
<dl class="type">
<dt id="c.pwm_capture">
struct <code class="descname">pwm_capture</code><a class="headerlink" href="#c.pwm_capture" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM capture data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_capture {
  unsigned int period;
  unsigned int duty_cycle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt>
<dd>period of the PWM signal (in nanoseconds)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_cycle</span></code></dt>
<dd>duty cycle of the PWM signal (in nanoseconds)</dd>
</dl>
<dl class="function">
<dt id="c.pwm_config">
int <code class="descname">pwm_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, int<em>&nbsp;duty_ns</em>, int<em>&nbsp;period_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_config" title="Permalink to this definition">¶</a></dt>
<dd><p>change a PWM device configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duty_ns</span></code></dt>
<dd>“on” time (in nanoseconds)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">period_ns</span></code></dt>
<dd>duration (in nanoseconds) of one cycle</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwm_enable">
int <code class="descname">pwm_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>start a PWM output toggling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwm_disable">
void <code class="descname">pwm_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a PWM output toggling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<dl class="function">
<dt id="c.pwm_set_chip_data">
int <code class="descname">pwm_set_chip_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_chip_data" title="Permalink to this definition">¶</a></dt>
<dd><p>set private chip data for a PWM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to chip-specific data</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwm_get_chip_data">
void * <code class="descname">pwm_get_chip_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_chip_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get private chip data for a PWM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the chip-private data for the PWM device.</p>
<dl class="function">
<dt id="c.pwmchip_add_with_polarity">
int <code class="descname">pwmchip_add_with_polarity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a> *<em>&nbsp;chip</em>, enum <a class="reference internal" href="#c.pwm_polarity" title="pwm_polarity">pwm_polarity</a><em>&nbsp;polarity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_add_with_polarity" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new PWM chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the PWM chip to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pwm_polarity</span> <span class="pre">polarity</span></code></dt>
<dd>initial polarity of PWM channels</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new PWM chip. If chip-&gt;base &lt; 0 then a dynamically assigned base
will be used. The initial polarity for all channels is specified by the
<strong>polarity</strong> parameter.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwmchip_add">
int <code class="descname">pwmchip_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_add" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new PWM chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the PWM chip to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new PWM chip. If chip-&gt;base &lt; 0 then a dynamically assigned base
will be used. The initial polarity for all channels is normal.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwmchip_remove">
int <code class="descname">pwmchip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a PWM chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the PWM chip to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a PWM chip. This function may return busy if the PWM chip provides
a PWM device that is still requested.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwm_request">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">pwm_request</code><span class="sig-paren">(</span>int<em>&nbsp;pwm</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request a PWM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pwm</span></code></dt>
<dd>global PWM device index</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>PWM device label</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated, use <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>A pointer to a PWM device or an ERR_PTR()-encoded error code on
failure.</p>
<dl class="function">
<dt id="c.pwm_request_from_chip">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">pwm_request_from_chip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a> *<em>&nbsp;chip</em>, unsigned int<em>&nbsp;index</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_request_from_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>request a PWM device relative to a PWM chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>PWM chip</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>per-chip index of the PWM to request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>a literal description string of this PWM</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the PWM device at the given index of the given PWM
chip. A negative error code is returned if the index is not valid for the
specified PWM chip or if the PWM device cannot be requested.</p>
<dl class="function">
<dt id="c.pwm_free">
void <code class="descname">pwm_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a PWM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated, use <a class="reference internal" href="#c.pwm_put" title="pwm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_put()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.pwm_apply_state">
int <code class="descname">pwm_apply_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, const struct pwm_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_apply_state" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically apply a new state to a PWM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>new state to apply</dd>
</dl>
<dl class="function">
<dt>
int <code class="descname">pwm_capture</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em>, struct <a class="reference internal" href="#c.pwm_capture" title="pwm_capture">pwm_capture</a> *<em>&nbsp;result</em>, unsigned long<em>&nbsp;timeout</em><span class="sig-paren">)</span></dt>
<dd><p>capture and report a PWM signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_capture</span> <span class="pre">*</span> <span class="pre">result</span></code></dt>
<dd>structure to fill with capture result</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>time to wait, in milliseconds, before giving up on capture</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.pwm_adjust_config">
int <code class="descname">pwm_adjust_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_adjust_config" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the current PWM config to the PWM arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will adjust the PWM config to the PWM arguments provided
by the DT or PWM lookup table. This is particularly useful to adapt
the bootloader config to the Linux one.</p>
<dl class="function">
<dt id="c.of_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">of_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;np</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>request a PWM via the PWM framework</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device node to get the PWM from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>consumer name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the PWM device parsed from the phandle and index specified in the
“pwms” property of a device tree node or a negative error-code on failure.
Values parsed from the device tree are stored in the returned PWM device
object.</p>
<p>If con_id is NULL, the first PWM device listed in the “pwms” property will
be requested. Otherwise the “pwm-names” property is used to do a reverse
lookup of the PWM index. This also means that the “pwm-names” property
becomes mandatory for devices that look up the PWM device via the con_id
parameter.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
<dl class="function">
<dt id="c.pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>look up and request a PWM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>consumer name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup is first attempted using DT. If the device was not instantiated from
a device tree, a PWM chip and a relative index is looked up via a table
supplied by board setup code (see pwm_add_table()).</p>
<p>Once a PWM chip has been found the specified PWM device will be requested
and is ready to be used.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
<dl class="function">
<dt id="c.pwm_put">
void <code class="descname">pwm_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a PWM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<dl class="function">
<dt id="c.devm_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">devm_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>consumer name</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs like <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a> but the acquired PWM device will
automatically be released on driver detach.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
<dl class="function">
<dt id="c.devm_of_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">devm_of_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;np</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_of_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed <a class="reference internal" href="#c.of_pwm_get" title="of_pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_pwm_get()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device node to get the PWM from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>consumer name</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs like <a class="reference internal" href="#c.of_pwm_get" title="of_pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_pwm_get()</span></code></a> but the acquired PWM device will
automatically be released on driver detach.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
<dl class="function">
<dt id="c.devm_fwnode_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="descname">devm_fwnode_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct fwnode_handle *<em>&nbsp;fwnode</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>request a resource managed PWM from firmware node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>firmware node to get the PWM from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>consumer name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the PWM device parsed from the firmware node. See <a class="reference internal" href="#c.of_pwm_get" title="of_pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_pwm_get()</span></code></a> and
acpi_pwm_get() for a detailed description.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
<dl class="function">
<dt id="c.devm_pwm_put">
void <code class="descname">devm_pwm_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> *<em>&nbsp;pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pwm_put" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed <a class="reference internal" href="#c.pwm_put" title="pwm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_put()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for PWM consumer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*</span> <span class="pre">pwm</span></code></dt>
<dd>PWM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a PWM previously allocated using <a class="reference internal" href="#c.devm_pwm_get" title="devm_pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_pwm_get()</span></code></a>. Calling this
function is usually not needed because devm-allocated resources are
automatically released on driver detach.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mei/index.html" class="btn btn-neutral float-right" title="Intel(R) Management Engine Interface (Intel(R) MEI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mtdnand.html" class="btn btn-neutral float-left" title="MTD NAND Driver Programming Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>