

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Serial Peripheral Interface (SPI) &mdash; The Linux Kernel 5.4.0-rc3+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="I2C and SMBus Subsystem" href="i2c.html" />
    <link rel="prev" title="PCI Peer-to-Peer DMA Support" href="pci/p2pdma.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.4.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ioctl/index.html">IOCTLs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">GENERIC SYSTEM INTERCONNECT SUBSYSTEM</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="dell_rbu.html">Usage of the new open sourced rbu (Remote BIOS Update) driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Serial Peripheral Interface (SPI)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/spi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="serial-peripheral-interface-spi">
<h1>Serial Peripheral Interface (SPI)<a class="headerlink" href="#serial-peripheral-interface-spi" title="Permalink to this headline">¶</a></h1>
<p>SPI is the “Serial Peripheral Interface”, widely used with embedded
systems because it is a simple and efficient interface: basically a
multiplexed shift register. Its three signal wires hold a clock (SCK,
often in the range of 1-20 MHz), a “Master Out, Slave In” (MOSI) data
line, and a “Master In, Slave Out” (MISO) data line. SPI is a full
duplex protocol; for each bit shifted out the MOSI line (one per clock)
another is shifted in on the MISO line. Those bits are assembled into
words of various sizes on the way to and from system memory. An
additional chipselect line is usually active-low (nCS); four signals are
normally used for each peripheral, plus sometimes an interrupt.</p>
<p>The SPI bus facilities listed here provide a generalized interface to
declare SPI busses and devices, manage them according to the standard
Linux driver model, and perform input/output operations. At this time,
only “master” side interfaces are supported, where Linux talks to SPI
peripherals and does not implement such a peripheral itself. (Interfaces
to support implementing SPI slaves would necessarily look different.)</p>
<p>The programming interface is structured around two kinds of driver, and
two kinds of device. A “Controller Driver” abstracts the controller
hardware, which may be as simple as a set of GPIO pins or as complex as
a pair of FIFOs connected to dual DMA engines on the other side of the
SPI shift register (maximizing throughput). Such drivers bridge between
whatever bus they sit on (often the platform bus) and SPI, and expose
the SPI side of their device as a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_master</span></code>. SPI devices are children of that master,
represented as a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span></code></a> and
manufactured from <a class="reference internal" href="#c.spi_board_info" title="spi_board_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span></code></a> descriptors which are usually provided by
board-specific initialization code. A <a class="reference internal" href="#c.spi_driver" title="spi_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span></code></a> is called a “Protocol Driver”, and is bound to a
spi_device using normal driver model calls.</p>
<p>The I/O model is a set of queued messages. Protocol drivers submit one
or more <a class="reference internal" href="#c.spi_message" title="spi_message"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span></code></a> objects,
which are processed and completed asynchronously. (There are synchronous
wrappers, however.) Messages are built from one or more
<a class="reference internal" href="#c.spi_transfer" title="spi_transfer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span></code></a> objects, each of
which wraps a full duplex SPI transfer. A variety of protocol tweaking
options are needed, because different chips adopt very different
policies for how they use the bits transferred with SPI.</p>
<dl class="type">
<dt id="c.spi_statistics">
struct <code class="descname">spi_statistics</code><a class="headerlink" href="#c.spi_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics for spi transfers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_statistics {
  spinlock_t lock;
  unsigned long           messages;
  unsigned long           transfers;
  unsigned long           errors;
  unsigned long           timedout;
  unsigned long           spi_sync;
  unsigned long           spi_sync_immediate;
  unsigned long           spi_async;
  unsigned long long      bytes;
  unsigned long long      bytes_rx;
  unsigned long long      bytes_tx;
#define SPI_STATISTICS_HISTO_SIZE 17;
  unsigned long transfer_bytes_histo[SPI_STATISTICS_HISTO_SIZE];
  unsigned long transfers_split_maxsize;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>lock protecting this structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">messages</span></code></dt>
<dd>number of spi-messages handled</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfers</span></code></dt>
<dd>number of spi_transfers handled</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errors</span></code></dt>
<dd>number of errors during spi_transfer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timedout</span></code></dt>
<dd>number of timeouts during spi_transfer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_sync</span></code></dt>
<dd>number of times spi_sync is used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_sync_immediate</span></code></dt>
<dd>number of times spi_sync is executed immediately
in calling context without queuing and scheduling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_async</span></code></dt>
<dd>number of times spi_async is used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt>
<dd>number of bytes transferred to/from device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes_rx</span></code></dt>
<dd>number of bytes received from device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes_tx</span></code></dt>
<dd>number of bytes sent to device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_bytes_histo</span></code></dt>
<dd>transfer bytes histogramm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfers_split_maxsize</span></code></dt>
<dd>number of transfers that have been split because of
maxsize limit</dd>
</dl>
<dl class="type">
<dt id="c.spi_device">
struct <code class="descname">spi_device</code><a class="headerlink" href="#c.spi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller side proxy for an SPI slave device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_device {
  struct device           dev;
  struct spi_controller   *controller;
  struct spi_controller   *master;
  u32 max_speed_hz;
  u8 chip_select;
  u8 bits_per_word;
  bool rt;
  u32 mode;
#define SPI_CPHA        0x01                    ;
#define SPI_CPOL        0x02                    ;
#define SPI_MODE_0      (0|0)                   ;
#define SPI_MODE_1      (0|SPI_CPHA);
#define SPI_MODE_2      (SPI_CPOL|0);
#define SPI_MODE_3      (SPI_CPOL|SPI_CPHA);
#define SPI_CS_HIGH     0x04                    ;
#define SPI_LSB_FIRST   0x08                    ;
#define SPI_3WIRE       0x10                    ;
#define SPI_LOOP        0x20                    ;
#define SPI_NO_CS       0x40                    ;
#define SPI_READY       0x80                    ;
#define SPI_TX_DUAL     0x100                   ;
#define SPI_TX_QUAD     0x200                   ;
#define SPI_RX_DUAL     0x400                   ;
#define SPI_RX_QUAD     0x800                   ;
#define SPI_CS_WORD     0x1000                  ;
#define SPI_TX_OCTAL    0x2000                  ;
#define SPI_RX_OCTAL    0x4000                  ;
#define SPI_3WIRE_HIZ   0x8000                  ;
  int irq;
  void *controller_state;
  void *controller_data;
  char modalias[SPI_NAME_SIZE];
  const char              *driver_override;
  int cs_gpio;
  struct gpio_desc        *cs_gpiod;
  uint8_t word_delay_usecs;
  struct spi_statistics   statistics;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>Driver model representation of the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller</span></code></dt>
<dd>SPI controller used with the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master</span></code></dt>
<dd>Copy of controller, for backwards compatibility.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt>
<dd>Maximum clock rate to be used with this chip
(on this board); may be changed by the device’s driver.
The spi_transfer.speed_hz can override this for each transfer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_select</span></code></dt>
<dd>Chipselect, distinguishing chips handled by <strong>controller</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word</span></code></dt>
<dd>Data transfers involve one or more words; word sizes
like eight or 12 bits are common.  In-memory wordsizes are
powers of two bytes (e.g. 20 bit samples use 32 bits).
This may be changed by the device’s driver, or left at the
default (0) indicating protocol words are eight bit bytes.
The spi_transfer.bits_per_word can override this for each transfer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt</span></code></dt>
<dd>Make the pump thread real time priority.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt>
<dd>The spi mode defines how data is clocked out and in.
This may be changed by the device’s driver.
The “active low” default for chipselect mode can be overridden
(by specifying SPI_CS_HIGH) as can the “MSB first” default for
each word in a transfer (by specifying SPI_LSB_FIRST).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt>
<dd>Negative, or the number passed to request_irq() to receive
interrupts from this device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_state</span></code></dt>
<dd>Controller’s runtime state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_data</span></code></dt>
<dd>Board-specific definitions for controller, such as
FIFO initialization parameters; from board_info.controller_data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modalias</span></code></dt>
<dd>Name of the driver to use with this device, or an alias
for that name.  This appears in the sysfs “modalias” attribute
for driver coldplugging, and in uevents used for hotplugging</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpio</span></code></dt>
<dd>LEGACY: gpio number of the chipselect line (optional, -ENOENT when
not using a GPIO line) use cs_gpiod in new drivers by opting in on
the spi_master.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpiod</span></code></dt>
<dd>gpio descriptor of the chipselect line (optional, NULL when
not using a GPIO line)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word_delay_usecs</span></code></dt>
<dd>microsecond delay to be inserted between consecutive
words of a transfer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">statistics</span></code></dt>
<dd>statistics for the spi_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>A <strong>spi_device</strong> is used to interchange data between an SPI slave
(usually a discrete chip) and CPU memory.</p>
<p>In <strong>dev</strong>, the platform_data is used to hold information about this
device that’s meaningful to the device’s protocol driver, but not
to its controller.  One example might be an identifier for a chip
variant with slightly different functionality; another might be
information about how this particular board wires the chip’s pins.</p>
<dl class="type">
<dt id="c.spi_driver">
struct <code class="descname">spi_driver</code><a class="headerlink" href="#c.spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Host side “protocol” driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_driver {
  const struct spi_device_id *id_table;
  int (*probe)(struct spi_device *spi);
  int (*remove)(struct spi_device *spi);
  void (*shutdown)(struct spi_device *spi);
  struct device_driver    driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt>
<dd>List of SPI devices supported by this driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt>
<dd>Binds this driver to the spi device.  Drivers can verify
that the device is actually present, and may need to configure
characteristics (such as bits_per_word) which weren’t needed for
the initial configuration done during system setup.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt>
<dd>Unbinds this driver from the spi device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt>
<dd>Standard shutdown callback used during system state
transitions such as powerdown/halt and kexec</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt>
<dd>SPI device drivers should initialize the name and owner
field of this structure.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents the kind of device driver that uses SPI messages to
interact with the hardware at the other end of a SPI link.  It’s called
a “protocol” driver because it works through messages rather than talking
directly to SPI hardware (which is what the underlying SPI controller
driver does to pass those messages).  These protocols are defined in the
specification for the device(s) supported by the driver.</p>
<p>As a rule, those device protocols represent the lowest level interface
supported by a driver, and it will support upper level interfaces too.
Examples of such upper levels include frameworks like MTD, networking,
MMC, RTC, filesystem character device nodes, and hardware monitoring.</p>
<dl class="function">
<dt id="c.spi_unregister_driver">
void <code class="descname">spi_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a> *<em>&nbsp;sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of spi_register_driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*</span> <span class="pre">sdrv</span></code></dt>
<dd>the driver to unregister</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<dl class="function">
<dt id="c.module_spi_driver">
<code class="descname">module_spi_driver</code><span class="sig-paren">(</span><em>__spi_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a SPI driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">__spi_driver</span></code></dt>
<dd>spi_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for SPI drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
<dl class="type">
<dt id="c.spi_controller">
struct <code class="descname">spi_controller</code><a class="headerlink" href="#c.spi_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>interface to SPI master or slave controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_controller {
  struct device   dev;
  struct list_head list;
  s16 bus_num;
  u16 num_chipselect;
  u16 dma_alignment;
  u32 mode_bits;
  u32 bits_per_word_mask;
#define SPI_BPW_MASK(bits) BIT((bits) - 1);
#define SPI_BPW_RANGE_MASK(min, max) GENMASK((max) - 1, (min) - 1);
  u32 min_speed_hz;
  u32 max_speed_hz;
  u16 flags;
#define SPI_CONTROLLER_HALF_DUPLEX      BIT(0)  ;
#define SPI_CONTROLLER_NO_RX            BIT(1)  ;
#define SPI_CONTROLLER_NO_TX            BIT(2)  ;
#define SPI_CONTROLLER_MUST_RX          BIT(3)  ;
#define SPI_CONTROLLER_MUST_TX          BIT(4)  ;
#define SPI_MASTER_GPIO_SS              BIT(5)  ;
  bool slave;
  size_t (*max_transfer_size)(struct spi_device *spi);
  size_t (*max_message_size)(struct spi_device *spi);
  struct mutex            io_mutex;
  spinlock_t bus_lock_spinlock;
  struct mutex            bus_lock_mutex;
  bool bus_lock_flag;
  int (*setup)(struct spi_device *spi);
  void (*set_cs_timing)(struct spi_device *spi, u8 setup_clk_cycles, u8 hold_clk_cycles, u8 inactive_clk_cycles);
  int (*transfer)(struct spi_device *spi, struct spi_message *mesg);
  void (*cleanup)(struct spi_device *spi);
  bool (*can_dma)(struct spi_controller *ctlr,struct spi_device *spi, struct spi_transfer *xfer);
  bool queued;
  struct kthread_worker           kworker;
  struct task_struct              *kworker_task;
  struct kthread_work             pump_messages;
  spinlock_t queue_lock;
  struct list_head                queue;
  struct spi_message              *cur_msg;
  bool idling;
  bool busy;
  bool running;
  bool rt;
  bool auto_runtime_pm;
  bool cur_msg_prepared;
  bool cur_msg_mapped;
  struct completion               xfer_completion;
  size_t max_dma_len;
  int (*prepare_transfer_hardware)(struct spi_controller *ctlr);
  int (*transfer_one_message)(struct spi_controller *ctlr, struct spi_message *mesg);
  int (*unprepare_transfer_hardware)(struct spi_controller *ctlr);
  int (*prepare_message)(struct spi_controller *ctlr, struct spi_message *message);
  int (*unprepare_message)(struct spi_controller *ctlr, struct spi_message *message);
  int (*slave_abort)(struct spi_controller *ctlr);
  void (*set_cs)(struct spi_device *spi, bool enable);
  int (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi, struct spi_transfer *transfer);
  void (*handle_err)(struct spi_controller *ctlr, struct spi_message *message);
  const struct spi_controller_mem_ops *mem_ops;
  int *cs_gpios;
  struct gpio_desc        **cs_gpiods;
  bool use_gpio_descriptors;
  struct spi_statistics   statistics;
  struct dma_chan         *dma_tx;
  struct dma_chan         *dma_rx;
  void *dummy_rx;
  void *dummy_tx;
  int (*fw_translate_cs)(struct spi_controller *ctlr, unsigned cs);
  bool ptp_sts_supported;
  unsigned long           irq_flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>device interface to this driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>link with the global spi_controller list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_num</span></code></dt>
<dd>board-specific (and often SOC-specific) identifier for a
given SPI controller.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_chipselect</span></code></dt>
<dd>chipselects are used to distinguish individual
SPI slaves, and are numbered from zero to num_chipselects.
each slave has a chipselect signal, but it’s common that not
every chipselect is connected to a slave.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_alignment</span></code></dt>
<dd>SPI controller constraint on DMA buffers alignment.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_bits</span></code></dt>
<dd>flags understood by this controller driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word_mask</span></code></dt>
<dd>A mask indicating which values of bits_per_word are
supported by the driver. Bit n indicates that a bits_per_word n+1 is
supported. If set, the SPI core will reject any transfer with an
unsupported bits_per_word. If not set, this value is simply ignored,
and it’s up to the individual driver to perform any validation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_speed_hz</span></code></dt>
<dd>Lowest supported transfer speed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt>
<dd>Highest supported transfer speed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>other constraints relevant to this driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave</span></code></dt>
<dd>indicates that this is an SPI slave controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_transfer_size</span></code></dt>
<dd>function that returns the max transfer size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, so the default <code class="docutils literal notranslate"><span class="pre">SIZE_MAX</span></code> will be used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_message_size</span></code></dt>
<dd>function that returns the max message size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, so the default <code class="docutils literal notranslate"><span class="pre">SIZE_MAX</span></code> will be used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">io_mutex</span></code></dt>
<dd>mutex for physical bus access</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_spinlock</span></code></dt>
<dd>spinlock for SPI bus locking</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_mutex</span></code></dt>
<dd>mutex for exclusion of multiple callers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_flag</span></code></dt>
<dd>indicates that the SPI bus is locked for exclusive use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt>
<dd>updates the device mode and clocking records used by a
device’s SPI controller; protocol code may call this.  This
must fail if an unrecognized or unsupported mode is requested.
It’s always safe to call this unless transfers are pending on
the device whose settings are being modified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cs_timing</span></code></dt>
<dd>optional hook for SPI devices to request SPI master
controller for configuring specific CS setup time, hold time and inactive
delay interms of clock counts</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt>
<dd>adds a message to the controller’s transfer queue.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt>
<dd>frees controller-specific state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_dma</span></code></dt>
<dd>determine whether this controller supports DMA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queued</span></code></dt>
<dd>whether this controller is providing an internal message queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kworker</span></code></dt>
<dd>thread struct for message pump</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kworker_task</span></code></dt>
<dd>pointer to task for message pump kworker thread</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pump_messages</span></code></dt>
<dd>work struct for scheduling work to the message pump</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_lock</span></code></dt>
<dd>spinlock to syncronise access to message queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt>
<dd>message queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg</span></code></dt>
<dd>the currently in-flight message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idling</span></code></dt>
<dd>the device is entering idle state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">busy</span></code></dt>
<dd>message pump is busy</dd>
<dt><code class="docutils literal notranslate"><span class="pre">running</span></code></dt>
<dd>message pump is running</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt</span></code></dt>
<dd>whether this queue is set to run as a realtime task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto_runtime_pm</span></code></dt>
<dd>the core should ensure a runtime PM reference is held
while the hardware is prepared, using the parent
device for the spidev</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_prepared</span></code></dt>
<dd>spi_prepare_message was called for the currently
in-flight message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_mapped</span></code></dt>
<dd>message has been mapped for DMA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfer_completion</span></code></dt>
<dd>used by core transfer_one_message()</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_dma_len</span></code></dt>
<dd>Maximum length of a DMA transfer for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_transfer_hardware</span></code></dt>
<dd>a message will soon arrive from the queue
so the subsystem requests the driver to prepare the transfer hardware
by issuing this call</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_one_message</span></code></dt>
<dd>the subsystem calls the driver to transfer a single
message while queuing transfers that arrive in the meantime. When the
driver is finished with this message, it must call
<a class="reference internal" href="#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_message()</span></code></a> so the subsystem can issue the next
message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_transfer_hardware</span></code></dt>
<dd>there are currently no more messages on the
queue so the subsystem notifies the driver that it may relax the
hardware by issuing this call</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_message</span></code></dt>
<dd>set up the controller to transfer a single message,
for example doing DMA mapping.  Called from threaded
context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_message</span></code></dt>
<dd>undo any work done by prepare_message().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave_abort</span></code></dt>
<dd>abort the ongoing transfer request on an SPI slave controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cs</span></code></dt>
<dd>set the logic level of the chip select line.  May be called
from interrupt context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_one</span></code></dt>
<dd><p class="first">transfer a single spi_transfer.
- return 0 if the transfer is finished,
- return 1 if the transfer is still in progress. When</p>
<blockquote class="last">
<div>the driver is finished with this transfer it must
call <a class="reference internal" href="#c.spi_finalize_current_transfer" title="spi_finalize_current_transfer"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_transfer()</span></code></a> so the subsystem
can issue the next transfer. Note: transfer_one and
transfer_one_message are mutually exclusive; when both
are set, the generic subsystem does not call your
transfer_one callback.</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle_err</span></code></dt>
<dd>the subsystem calls the driver to handle an error that occurs
in the generic implementation of transfer_one_message().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_ops</span></code></dt>
<dd>optimized/dedicated operations for interactions with SPI memory.
This field is optional and should only be implemented if the
controller has native support for memory like operations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpios</span></code></dt>
<dd>LEGACY: array of GPIO descs to use as chip select lines; one per
CS number. Any individual value may be -ENOENT for CS lines that
are not GPIOs (driven by the SPI controller itself). Use the cs_gpiods
in new drivers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpiods</span></code></dt>
<dd>Array of GPIO descs to use as chip select lines; one per CS
number. Any individual value may be NULL for CS lines that
are not GPIOs (driven by the SPI controller itself).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_gpio_descriptors</span></code></dt>
<dd>Turns on the code in the SPI core to parse and grab
GPIO descriptors rather than using global GPIO numbers grabbed by the
driver. This will fill in <strong>cs_gpiods</strong> and <strong>cs_gpios</strong> should not be used,
and SPI devices will have the cs_gpiod assigned rather than cs_gpio.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">statistics</span></code></dt>
<dd>statistics for the spi_controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_tx</span></code></dt>
<dd>DMA transmit channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_rx</span></code></dt>
<dd>DMA receive channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_rx</span></code></dt>
<dd>dummy receive buffer for full-duplex devices</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_tx</span></code></dt>
<dd>dummy transmit buffer for full-duplex devices</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_translate_cs</span></code></dt>
<dd>If the boot firmware uses different numbering scheme
what Linux expects, this optional hook can be used to translate
between the two.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_supported</span></code></dt>
<dd>If the driver sets this to true, it must provide a
time snapshot in <strong>spi_transfer-&gt;ptp_sts</strong> as close as possible to the
moment in time when <strong>spi_transfer-&gt;ptp_sts_word_pre</strong> and
<strong>spi_transfer-&gt;ptp_sts_word_post</strong> were transmitted.
If the driver does not set this, the SPI core takes the snapshot as
close to the driver hand-over as possible.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each SPI controller can communicate with one or more <strong>spi_device</strong>
children.  These make a small bus, sharing MOSI, MISO and SCK signals
but not chip select signals.  Each device may be configured to use a
different clock rate, since those shared signals are ignored unless
the chip is selected.</p>
<p>The driver for an SPI controller manages access to those devices through
a queue of spi_message transactions, copying data between CPU memory and
an SPI slave device.  For each such message it queues, it calls the
message’s completion function when the transaction completes.</p>
<dl class="type">
<dt id="c.spi_res">
struct <code class="descname">spi_res</code><a class="headerlink" href="#c.spi_res" title="Permalink to this definition">¶</a></dt>
<dd><p>spi resource management structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_res {
  struct list_head        entry;
  spi_res_release_t release;
  unsigned long long      data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>list entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt>
<dd>release code called prior to freeing this resource</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd>extra data allocated for the specific use-case</dd>
</dl>
<p><strong>Description</strong></p>
<p>this is based on ideas from devres, but focused on life-cycle
management during spi_message processing</p>
<dl class="type">
<dt id="c.spi_transfer">
struct <code class="descname">spi_transfer</code><a class="headerlink" href="#c.spi_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>a read/write buffer pair</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_transfer {
  const void      *tx_buf;
  void *rx_buf;
  unsigned len;
  dma_addr_t tx_dma;
  dma_addr_t rx_dma;
  struct sg_table tx_sg;
  struct sg_table rx_sg;
  unsigned cs_change:1;
  unsigned tx_nbits:3;
  unsigned rx_nbits:3;
#define SPI_NBITS_SINGLE        0x01 ;
#define SPI_NBITS_DUAL          0x02 ;
#define SPI_NBITS_QUAD          0x04 ;
  u8 bits_per_word;
  u8 word_delay_usecs;
  u16 delay_usecs;
  u16 cs_change_delay;
  u8 cs_change_delay_unit;
#define SPI_DELAY_UNIT_USECS    0;
#define SPI_DELAY_UNIT_NSECS    1;
#define SPI_DELAY_UNIT_SCK      2;
  u32 speed_hz;
  u16 word_delay;
  u32 effective_speed_hz;
  unsigned int    ptp_sts_word_pre;
  unsigned int    ptp_sts_word_post;
  struct ptp_system_timestamp *ptp_sts;
  bool timestamped_pre;
  bool timestamped_post;
  struct list_head transfer_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt>
<dd>data to be written (dma-safe memory), or NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_buf</span></code></dt>
<dd>data to be read (dma-safe memory), or NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>size of rx and tx buffers (in bytes)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_dma</span></code></dt>
<dd>DMA address of tx_buf, if <strong>spi_message.is_dma_mapped</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_dma</span></code></dt>
<dd>DMA address of rx_buf, if <strong>spi_message.is_dma_mapped</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_sg</span></code></dt>
<dd>Scatterlist for transmit, currently not for client use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_sg</span></code></dt>
<dd>Scatterlist for receive, currently not for client use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_change</span></code></dt>
<dd>affects chipselect after this transfer completes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_nbits</span></code></dt>
<dd>number of bits used for writing. If 0 the default
(SPI_NBITS_SINGLE) is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_nbits</span></code></dt>
<dd>number of bits used for reading. If 0 the default
(SPI_NBITS_SINGLE) is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word</span></code></dt>
<dd>select a bits_per_word other than the device default
for this transfer. If 0 the default (from <strong>spi_device</strong>) is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word_delay_usecs</span></code></dt>
<dd>microseconds to inter word delay after each word size
(set by bits_per_word) transmission.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delay_usecs</span></code></dt>
<dd>microseconds to delay after this transfer before
(optionally) changing the chipselect status, then starting
the next transfer or completing this <strong>spi_message</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_change_delay</span></code></dt>
<dd>delay between cs deassert and assert when
<strong>cs_change</strong> is set and <strong>spi_transfer</strong> is not the last in <strong>spi_message</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_change_delay_unit</span></code></dt>
<dd>unit of cs_change_delay</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed_hz</span></code></dt>
<dd>Select a speed other than the device default for this
transfer. If 0 the default (from <strong>spi_device</strong>) is used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word_delay</span></code></dt>
<dd>clock cycles to inter word delay after each word size
(set by bits_per_word) transmission.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">effective_speed_hz</span></code></dt>
<dd>the effective SCK-speed that was used to
transfer this transfer. Set to 0 if the spi bus driver does
not support it.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_word_pre</span></code></dt>
<dd>The word (subject to bits_per_word semantics) offset
within <strong>tx_buf</strong> for which the SPI device is requesting that the time
snapshot for this transfer begins. Upon completing the SPI transfer,
this value may have changed compared to what was requested, depending
on the available snapshotting resolution (DMA transfer,
<strong>ptp_sts_supported</strong> is false, etc).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_word_post</span></code></dt>
<dd>See <strong>ptp_sts_word_post</strong>. The two can be equal (meaning
that a single byte should be snapshotted).
If the core takes care of the timestamp (if <strong>ptp_sts_supported</strong> is false
for this controller), it will set <strong>ptp_sts_word_pre</strong> to 0, and
<strong>ptp_sts_word_post</strong> to the length of the transfer. This is done
purposefully (instead of setting to spi_transfer-&gt;len - 1) to denote
that a transfer-level snapshot taken from within the driver may still
be of higher quality.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts</span></code></dt>
<dd>Pointer to a memory location held by the SPI slave device where a
PTP system timestamp structure may lie. If drivers use PIO or their
hardware has some sort of assist for retrieving exact transfer timing,
they can (and should) assert <strong>ptp_sts_supported</strong> and populate this
structure using the ptp_read_system_*ts helper functions.
The timestamp must represent the time at which the SPI slave device has
processed the word, i.e. the “pre” timestamp should be taken before
transmitting the “pre” word, and the “post” timestamp after receiving
transmit confirmation from the controller for the “post” word.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamped_pre</span></code></dt>
<dd>Set by the SPI controller driver to denote it has acted
upon the <strong>ptp_sts</strong> request. Not set when the SPI core has taken care of
the task. SPI device drivers are free to print a warning if this comes
back unset and they need the better resolution.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamped_post</span></code></dt>
<dd>See above. The reason why both exist is that these
booleans are also used to keep state in the core SPI logic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_list</span></code></dt>
<dd>transfers are sequenced through <strong>spi_message.transfers</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>SPI transfers always write the same number of bytes as they read.
Protocol drivers should always provide <strong>rx_buf</strong> and/or <strong>tx_buf</strong>.
In some cases, they may also want to provide DMA addresses for
the data being transferred; that may reduce overhead, when the
underlying driver uses dma.</p>
<p>If the transmit buffer is null, zeroes will be shifted out
while filling <strong>rx_buf</strong>.  If the receive buffer is null, the data
shifted in will be discarded.  Only “len” bytes shift out (or in).
It’s an error to try to shift out a partial word.  (For example, by
shifting out three bytes with word size of sixteen or twenty bits;
the former uses two bytes per word, the latter uses four bytes.)</p>
<p>In-memory data values are always in native CPU byte order, translated
from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
for example when bits_per_word is sixteen, buffers are 2N bytes long
(<strong>len</strong> = 2N) and hold N sixteen bit words in CPU byte order.</p>
<p>When the word size of the SPI transfer is not a power-of-two multiple
of eight bits, those in-memory words include extra bits.  In-memory
words are always seen by protocol drivers as right-justified, so the
undefined (rx) or unused (tx) bits are always the most significant bits.</p>
<p>All SPI transfers start with the relevant chipselect active.  Normally
it stays selected until after the last transfer in a message.  Drivers
can affect the chipselect signal using cs_change.</p>
<p>(i) If the transfer isn’t the last one in the message, this flag is
used to make the chipselect briefly go inactive in the middle of the
message.  Toggling chipselect in this way may be needed to terminate
a chip command, letting a single spi_message perform all of group of
chip transactions together.</p>
<p>(ii) When the transfer is the last one in the message, the chip may
stay selected until the next transfer.  On multi-device SPI busses
with nothing blocking messages going to other devices, this is just
a performance hint; starting a message to another device deselects
this one.  But in other cases, this can be used to ensure correctness.
Some devices need protocol transactions to be built from a series of
spi_message submissions, where the content of one message is determined
by the results of previous messages and where the whole transaction
ends when the chipselect goes intactive.</p>
<p>When SPI can transfer in 1x,2x or 4x. It can get this transfer information
from device through <strong>tx_nbits</strong> and <strong>rx_nbits</strong>. In Bi-direction, these
two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x)
SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="type">
<dt id="c.spi_message">
struct <code class="descname">spi_message</code><a class="headerlink" href="#c.spi_message" title="Permalink to this definition">¶</a></dt>
<dd><p>one multi-segment SPI transaction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_message {
  struct list_head        transfers;
  struct spi_device       *spi;
  unsigned is_dma_mapped:1;
  void (*complete)(void *context);
  void *context;
  unsigned frame_length;
  unsigned actual_length;
  int status;
  struct list_head        queue;
  void *state;
  struct list_head        resources;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">transfers</span></code></dt>
<dd>list of transfer segments in this transaction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi</span></code></dt>
<dd>SPI device to which the transaction is queued</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_dma_mapped</span></code></dt>
<dd>if true, the caller provided both dma and cpu virtual
addresses for each transfer buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt>
<dd>called to report transaction completions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt>
<dd>the argument to complete() when it’s called</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame_length</span></code></dt>
<dd>the total number of bytes in the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actual_length</span></code></dt>
<dd>the total number of bytes that were transferred in all
successful segments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt>
<dd>zero for success, else negative errno</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt>
<dd>for use by whichever driver currently owns the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>for use by whichever driver currently owns the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resources</span></code></dt>
<dd>for resource management when the spi message is processed</dd>
</dl>
<p><strong>Description</strong></p>
<p>A <strong>spi_message</strong> is used to execute an atomic sequence of data transfers,
each represented by a struct spi_transfer.  The sequence is “atomic”
in the sense that no other spi_message may use that SPI bus until that
sequence completes.  On some systems, many such sequences can execute as
as single programmed DMA transfer.  On all systems, these messages are
queued, and might complete after transactions to other devices.  Messages
sent to a given spi_device are always executed in FIFO order.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="function">
<dt id="c.spi_message_init_with_transfers">
void <code class="descname">spi_message_init_with_transfers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;m</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfers</em>, unsigned int<em>&nbsp;num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_message_init_with_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize spi_message and append transfers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>spi_message to be initialized</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfers</span></code></dt>
<dd>An array of spi transfers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt>
<dd>Number of items in the xfer array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the given spi_message and adds each spi_transfer in
the given array to the message.</p>
<dl class="function">
<dt id="c.spi_is_bpw_supported">
bool <code class="descname">spi_is_bpw_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u32<em>&nbsp;bpw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_is_bpw_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if bits per word is supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>SPI device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">bpw</span></code></dt>
<dd>Bits per word</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks to see if the SPI controller supports <strong>bpw</strong>.</p>
<p><strong>Return</strong></p>
<p>True if <strong>bpw</strong> is supported, false otherwise.</p>
<dl class="type">
<dt id="c.spi_replaced_transfers">
struct <code class="descname">spi_replaced_transfers</code><a class="headerlink" href="#c.spi_replaced_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>structure describing the spi_transfer replacements that have occurred so that they can get reverted</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_replaced_transfers {
  spi_replaced_release_t release;
  void *extradata;
  struct list_head replaced_transfers;
  struct list_head *replaced_after;
  size_t inserted;
  struct spi_transfer inserted_transfers[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt>
<dd>some extra release code to get executed prior to
relasing this structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extradata</span></code></dt>
<dd>pointer to some extra data if requested or NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">replaced_transfers</span></code></dt>
<dd>transfers that have been replaced and which need
to get restored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">replaced_after</span></code></dt>
<dd>the transfer after which the <strong>replaced_transfers</strong>
are to get re-inserted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inserted</span></code></dt>
<dd>number of transfers inserted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inserted_transfers</span></code></dt>
<dd>array of spi_transfers of array-size <strong>inserted</strong>,
that have been replacing replaced_transfers</dd>
</dl>
<p><strong>note</strong></p>
<p>that <strong>extradata</strong> will point to <strong>inserted_transfers**[**inserted</strong>]
if some extra allocation is requested, so alignment will be the same
as for spi_transfers</p>
<dl class="function">
<dt id="c.spi_sync_transfer">
int <code class="descname">spi_sync_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfers</em>, unsigned int<em>&nbsp;num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronous SPI data transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfers</span></code></dt>
<dd>An array of spi_transfers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt>
<dd>Number of items in the xfer array</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Does a synchronous SPI data transfer of the given spi_transfer array.</p>
<p>For more specific semantics see <a class="reference internal" href="#c.spi_sync" title="spi_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_sync()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Return: zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_write">
int <code class="descname">spi_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, const void *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device to which data will be written</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>data buffer size</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function writes the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_read">
int <code class="descname">spi_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device from which data will be read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>data buffer size</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function reads the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r8">
ssize_t <code class="descname">spi_w8r8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r8" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 8 bit read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) eight bit number returned by the
device, or else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r16">
ssize_t <code class="descname">spi_w8r16</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>The number is returned in wire-order, which is at least sometimes
big-endian.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the
device, or else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r16be">
ssize_t <code class="descname">spi_w8r16be</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16be" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit big-endian read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function is similar to spi_w8r16, with the exception that it will
convert the read 16 bit data word from big-endian to native endianness.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the device in cpu
endianness, or else a negative error code.</p>
<dl class="type">
<dt id="c.spi_board_info">
struct <code class="descname">spi_board_info</code><a class="headerlink" href="#c.spi_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>board-specific template for a SPI device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_board_info {
  char modalias[SPI_NAME_SIZE];
  const void      *platform_data;
  const struct property_entry *properties;
  void *controller_data;
  int irq;
  u32 max_speed_hz;
  u16 bus_num;
  u16 chip_select;
  u32 mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">modalias</span></code></dt>
<dd>Initializes spi_device.modalias; identifies the driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt>
<dd>Initializes spi_device.platform_data; the particular
data stored there is driver-specific.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt>
<dd>Additional device properties for the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_data</span></code></dt>
<dd>Initializes spi_device.controller_data; some
controllers need hints about hardware setup, e.g. for DMA.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt>
<dd>Initializes spi_device.irq; depends on how the board is wired.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt>
<dd>Initializes spi_device.max_speed_hz; based on limits
from the chip datasheet and board-specific signal quality issues.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_num</span></code></dt>
<dd>Identifies which spi_controller parents the spi_device; unused
by <a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_new_device()</span></code></a>, and otherwise depends on board wiring.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_select</span></code></dt>
<dd>Initializes spi_device.chip_select; depends on how
the board is wired.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt>
<dd>Initializes spi_device.mode; based on the chip datasheet, board
wiring (some devices support both 3WIRE and standard modes), and
possibly presence of an inverter in the chipselect path.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When adding new SPI devices to the device tree, these structures serve
as a partial device template.  They hold information which can’t always
be determined by drivers.  Information that probe() can establish (such
as the default transfer wordsize) is not included here.</p>
<p>These structures are used in two places.  Their primary role is to
be stored in tables of board-specific device descriptors, which are
declared early in board initialization and then used (much later) to
populate a controller’s device tree after the that controller’s driver
initializes.  A secondary (and atypical) role is as a parameter to
<a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_new_device()</span></code></a> call, which happens after those controller drivers
are active in some dynamic board configuration models.</p>
<dl class="function">
<dt id="c.spi_register_board_info">
int <code class="descname">spi_register_board_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a> const *<em>&nbsp;info</em>, unsigned<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI devices for a given board</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>array of chip descriptors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n</span></code></dt>
<dd>how many descriptors are provided</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Board-specific early init code calls this (probably during arch_initcall)
with segments of the SPI device table.  Any device nodes are created later,
after the relevant parent SPI controller (bus_num) is defined.  We keep
this table of devices forever, so that reloading a controller driver will
not make Linux forget about these hard-wired devices.</p>
<p>Other code can also call this, e.g. a particular add-on board might provide
SPI devices through its expansion connector, so code initializing that board
would naturally declare its SPI devices.</p>
<p>The board info passed can safely be __initdata … but be careful of
any embedded pointers (platform_data, etc), they’re copied as-is.
Device properties are deep-copied though.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.__spi_register_driver">
int <code class="descname">__spi_register_driver</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a> *<em>&nbsp;sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a SPI driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of the driver to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*</span> <span class="pre">sdrv</span></code></dt>
<dd>the driver to register</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_alloc_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="descname">spi_alloc_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_alloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Controller to which device is connected</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Allows a driver to allocate and initialize a spi_device without
registering it immediately.  This allows a driver to directly
fill the spi_device with device parameters before calling
<a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_add_device()</span></code></a> on it.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_add_device()</span></code></a> on the returned
spi_device structure to add it to the SPI controller.  If the caller
needs to discard the spi_device without adding it, then it should
call spi_dev_put() on it.</p>
<p><strong>Return</strong></p>
<p>a pointer to the new device, or NULL.</p>
<dl class="function">
<dt id="c.spi_add_device">
int <code class="descname">spi_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Add spi_device allocated with spi_alloc_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>spi_device to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Companion function to spi_alloc_device.  Devices allocated with
spi_alloc_device can be added onto the spi bus with this function.</p>
<p><strong>Return</strong></p>
<p>0 on success; negative errno on failure</p>
<dl class="function">
<dt id="c.spi_new_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="descname">spi_new_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_new_device" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate one new SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Controller to which device is connected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>Describes the SPI device</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>On typical mainboards, this is purely internal; and it’s not needed
after board init creates the hard-wired devices.  Some development
platforms may not be able to use spi_register_board_info though, and
this is exported so that for example a USB or parport based adapter
driver could add devices (which it would learn about out-of-band).</p>
<p><strong>Return</strong></p>
<p>the new device, or NULL.</p>
<dl class="function">
<dt id="c.spi_unregister_device">
void <code class="descname">spi_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a single SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>spi_device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start making the passed SPI device vanish. Normally this would be handled
by <a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
<dl class="function">
<dt id="c.spi_finalize_current_transfer">
void <code class="descname">spi_finalize_current_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>report completion of a transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller reporting completion</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by SPI drivers using the core transfer_one_message()
implementation to notify it that the current interrupt driven
transfer has finished and the next one may be scheduled.</p>
<dl class="function">
<dt id="c.spi_take_timestamp_pre">
void <code class="descname">spi_take_timestamp_pre</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfer</em>, const void *<em>&nbsp;tx</em>, bool<em>&nbsp;irqs_off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_take_timestamp_pre" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for drivers to collect the beginning of the TX timestamp for the requested byte from the SPI transfer. The frequency with which this function must be called (once per word, once for the whole transfer, once per batch of words etc) is arbitrary as long as the <strong>tx</strong> buffer offset is greater than or equal to the requested byte at the time of the call. The timestamp is only taken once, at the first such call. It is assumed that the driver advances its <strong>tx</strong> buffer pointer monotonically.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Pointer to the spi_controller structure of the driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfer</span></code></dt>
<dd>Pointer to the transfer being timestamped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">tx</span></code></dt>
<dd>Pointer to the current word within the xfer-&gt;tx_buf that the driver is
preparing to transmit right now.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">irqs_off</span></code></dt>
<dd>If true, will disable IRQs and preemption for the duration of the
transfer, for less jitter in time measurement. Only compatible
with PIO drivers. If true, must follow up with
spi_take_timestamp_post or otherwise system will crash.
WARNING: for fully predictable results, the CPU frequency must
also be under control (governor).</dd>
</dl>
<dl class="function">
<dt id="c.spi_take_timestamp_post">
void <code class="descname">spi_take_timestamp_post</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfer</em>, const void *<em>&nbsp;tx</em>, bool<em>&nbsp;irqs_off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_take_timestamp_post" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for drivers to collect the end of the TX timestamp for the requested byte from the SPI transfer. Can be called with an arbitrary frequency: only the first call where <strong>tx</strong> exceeds or is equal to the requested word will be timestamped.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Pointer to the spi_controller structure of the driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfer</span></code></dt>
<dd>Pointer to the transfer being timestamped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">tx</span></code></dt>
<dd>Pointer to the current word within the xfer-&gt;tx_buf that the driver has
just transmitted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">irqs_off</span></code></dt>
<dd>If true, will re-enable IRQs and preemption for the local CPU.</dd>
</dl>
<dl class="function">
<dt id="c.spi_get_next_queued_message">
struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> * <code class="descname">spi_get_next_queued_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_get_next_queued_message" title="Permalink to this definition">¶</a></dt>
<dd><p>called by driver to check for queued messages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller to check for queued messages</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there are more messages in the queue, the next message is returned from
this call.</p>
<p><strong>Return</strong></p>
<p>the next message in the queue, else NULL if the queue is empty.</p>
<dl class="function">
<dt id="c.spi_finalize_current_message">
void <code class="descname">spi_finalize_current_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_message" title="Permalink to this definition">¶</a></dt>
<dd><p>the current message is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller to return the message to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the driver to notify the core that the message in the front of the
queue is complete and can be removed from the queue.</p>
<dl class="function">
<dt id="c.spi_slave_abort">
int <code class="descname">spi_slave_abort</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_slave_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>abort the ongoing transfer request on an SPI slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device used for the current transfer</dd>
</dl>
<dl class="function">
<dt id="c.__spi_alloc_controller">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="descname">__spi_alloc_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;size</em>, bool<em>&nbsp;slave</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_alloc_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the controller, possibly using the platform_bus</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>how much zeroed driver-private data to allocate; the pointer to this
memory is in the driver_data field of the returned device, accessible
with spi_controller_get_devdata(); the memory is cacheline aligned;
drivers granting DMA access to portions of their private data need to
round up <strong>size</strong> using ALIGN(size, dma_get_cache_alignment()).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">slave</span></code></dt>
<dd>flag indicating whether to allocate an SPI master (false) or SPI
slave (true) controller</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.  It’s how they allocate
an spi_controller structure, prior to calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a>.</p>
<p>This must be called from context that can sleep.</p>
<p>The caller is responsible for assigning the bus number and initializing the
controller’s methods before calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a>; and (after
errors adding the device) calling spi_controller_put() to prevent a memory
leak.</p>
<p><strong>Return</strong></p>
<p>the SPI controller structure on success, else NULL.</p>
<dl class="function">
<dt id="c.spi_register_controller">
int <code class="descname">spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>initialized master, originally from spi_alloc_master() or
spi_alloc_slave()</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>SPI controllers connect to their drivers using some non-SPI bus,
such as the platform bus.  The final stage of probe() in that code
includes calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> to hook up to this SPI bus glue.</p>
<p>SPI controllers use board specific (often SOC specific) bus numbers,
and board-specific addressing for SPI devices combines those numbers
with chip select numbers.  Since SPI does not directly support dynamic
device identification, boards need configuration tables telling which
chip is at which address.</p>
<p>This must be called from context that can sleep.  It returns zero on
success, else a negative error code (dropping the controller’s refcount).
After a successful return, the caller is responsible for calling
<a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.devm_spi_register_controller">
int <code class="descname">devm_spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register managed SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device managing SPI controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>initialized controller, originally from spi_alloc_master() or
spi_alloc_slave()</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Register a SPI device as with <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> which will
automatically be unregistered and freed.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_unregister_controller">
void <code class="descname">spi_unregister_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller being unregistered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.</p>
<p>This must be called from context that can sleep.</p>
<p>Note that this function also drops a reference to the controller.</p>
<dl class="function">
<dt id="c.spi_busnum_to_master">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="descname">spi_busnum_to_master</code><span class="sig-paren">(</span>u16<em>&nbsp;bus_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_busnum_to_master" title="Permalink to this definition">¶</a></dt>
<dd><p>look up master associated with bus_num</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">bus_num</span></code></dt>
<dd>the master’s bus number</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may be used with devices that are registered after
arch init time.  It returns a refcounted pointer to the relevant
spi_controller (which the caller must release), or NULL if there is
no such master registered.</p>
<p><strong>Return</strong></p>
<p>the SPI master structure on success, else NULL.</p>
<dl class="function">
<dt id="c.spi_res_alloc">
void * <code class="descname">spi_res_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, spi_res_release_t<em>&nbsp;release</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a spi resource that is life-cycle managed during the processing of a spi_message while using spi_transfer_one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>the spi device for which we allocate memory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_res_release_t</span> <span class="pre">release</span></code></dt>
<dd>the release code to execute for this resource</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size to alloc and return</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP allocation flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>the pointer to the allocated data</p>
<p>This may get enhanced in the future to allocate from a memory pool
of the <strong>spi_device</strong> or <strong>spi_controller</strong> to avoid repeated allocations.</p>
<dl class="function">
<dt id="c.spi_res_free">
void <code class="descname">spi_res_free</code><span class="sig-paren">(</span>void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free an spi resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>pointer to the custom data of a resource</dd>
</dl>
<dl class="function">
<dt id="c.spi_res_add">
void <code class="descname">spi_res_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em>, void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a spi_res to the spi_message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>the spi message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>the spi_resource</dd>
</dl>
<dl class="function">
<dt id="c.spi_res_release">
void <code class="descname">spi_res_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release all spi resources for this message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the <strong>spi_controller</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>the <strong>spi_message</strong></dd>
</dl>
<dl class="function">
<dt id="c.spi_replace_transfers">
struct <a class="reference internal" href="#c.spi_replaced_transfers" title="spi_replaced_transfers">spi_replaced_transfers</a> * <code class="descname">spi_replace_transfers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;msg</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfer_first</em>, size_t<em>&nbsp;remove</em>, size_t<em>&nbsp;insert</em>, spi_replaced_release_t<em>&nbsp;release</em>, size_t<em>&nbsp;extradatasize</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_replace_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>replace transfers with several transfers and register change with spi_message.resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>the spi_message we work upon</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfer_first</span></code></dt>
<dd>the first spi_transfer we want to replace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">remove</span></code></dt>
<dd>number of transfers to remove</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">insert</span></code></dt>
<dd>the number of transfers we want to insert instead</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_replaced_release_t</span> <span class="pre">release</span></code></dt>
<dd>extra release code necessary in some circumstances</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">extradatasize</span></code></dt>
<dd>extra data to allocate (with alignment guarantees
of struct <strong>spi_transfer</strong>)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>gfp flags</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>pointer to <strong>spi_replaced_transfers</strong>,</dt>
<dd>PTR_ERR(…) in case of errors.</dd>
</dl>
<dl class="function">
<dt id="c.spi_split_transfers_maxsize">
int <code class="descname">spi_split_transfers_maxsize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;msg</em>, size_t<em>&nbsp;maxsize</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_split_transfers_maxsize" title="Permalink to this definition">¶</a></dt>
<dd><p>split spi transfers into multiple transfers when an individual transfer exceeds a certain size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the <strong>spi_controller</strong> for this transfer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>the <strong>spi_message</strong> to transform</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxsize</span></code></dt>
<dd>the maximum when to apply this</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP allocation flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>status of transformation</p>
<dl class="function">
<dt id="c.spi_setup">
int <code class="descname">spi_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup SPI mode and clock rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>the device whose settings are being modified</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep, and no requests are queued to the device</p>
<p><strong>Description</strong></p>
<p>SPI protocol drivers may need to update the transfer mode if the
device doesn’t work with its default.  They may likewise need
to update clock rates or word sizes from initial values.  This function
changes those settings, and must be called from a context that can sleep.
Except for SPI_CS_HIGH, which takes effect immediately, the changes take
effect the next time the device is selected and data is transferred to
or from it.  When this function returns, the spi device is deselected.</p>
<p>Note that this call will fail if the protocol driver specifies an option
that the underlying controller or its driver does not support.  For
example, not all hardware supports wire transfers using nine bit words,
LSB-first wire encoding, or active-high chipselects.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_set_cs_timing">
void <code class="descname">spi_set_cs_timing</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;setup</em>, u8<em>&nbsp;hold</em>, u8<em>&nbsp;inactive_dly</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_set_cs_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>configure CS setup, hold, and inactive delays</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>the device that requires specific CS timing configuration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">setup</span></code></dt>
<dd>CS setup time in terms of clock count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">hold</span></code></dt>
<dd>CS hold time in terms of clock count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">inactive_dly</span></code></dt>
<dd>CS inactive delay between transfers in terms of clock count</dd>
</dl>
<dl class="function">
<dt id="c.spi_async">
int <code class="descname">spi_async</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous SPI transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers, including completion callback</dd>
</dl>
<p><strong>Context</strong></p>
<p>any (irqs may be blocked, etc)</p>
<p><strong>Description</strong></p>
<p>This call may be used in_irq and other contexts which can’t sleep,
as well as from task contexts which can sleep.</p>
<p>The completion callback is invoked in a context which can’t sleep.
Before that invocation, the value of message-&gt;status is undefined.
When the callback is issued, message-&gt;status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it’s no longer in use by any SPI
core or controller driver code.</p>
<p>Note that although all messages to a spi_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various “hard” access
time requirements, for example.</p>
<p>On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_async_locked">
int <code class="descname">spi_async_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_async_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>version of spi_async with exclusive bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers, including completion callback</dd>
</dl>
<p><strong>Context</strong></p>
<p>any (irqs may be blocked, etc)</p>
<p><strong>Description</strong></p>
<p>This call may be used in_irq and other contexts which can’t sleep,
as well as from task contexts which can sleep.</p>
<p>The completion callback is invoked in a context which can’t sleep.
Before that invocation, the value of message-&gt;status is undefined.
When the callback is issued, message-&gt;status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it’s no longer in use by any SPI
core or controller driver code.</p>
<p>Note that although all messages to a spi_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various “hard” access
time requirements, for example.</p>
<p>On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_sync">
int <code class="descname">spi_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>blocking/synchronous SPI data transfers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>Note that the SPI device’s chip select is active during the message,
and then is normally disabled between messages.  Drivers for some
frequently-used devices may want to minimize costs of selecting a chip,
by leaving it selected in anticipation that the next message will go
to the same chip.  (That may increase power usage.)</p>
<p>Also, the caller is guaranteeing that the memory associated with the
message will not be freed before this call returns.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_sync_locked">
int <code class="descname">spi_sync_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>version of spi_sync with exclusive bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
be released by a spi_bus_unlock call when the exclusive access is over.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_bus_lock">
int <code class="descname">spi_bus_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a lock for exclusive SPI bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>SPI bus master that should be locked for exclusive bus access</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. The SPI bus must be released by a spi_bus_unlock call when the
exclusive access is over. Data transfer must be done by spi_sync_locked
and spi_async_locked calls when the SPI bus lock is held.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
<dl class="function">
<dt id="c.spi_bus_unlock">
int <code class="descname">spi_bus_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the lock for exclusive SPI bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>SPI bus master that was locked for exclusive bus access</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call releases an SPI bus lock previously obtained by an spi_bus_lock
call.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
<dl class="function">
<dt id="c.spi_write_then_read">
int <code class="descname">spi_write_then_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, const void *<em>&nbsp;txbuf</em>, unsigned<em>&nbsp;n_tx</em>, void *<em>&nbsp;rxbuf</em>, unsigned<em>&nbsp;n_rx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write_then_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write followed by read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">txbuf</span></code></dt>
<dd>data to be written (need not be dma-safe)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n_tx</span></code></dt>
<dd>size of txbuf, in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">rxbuf</span></code></dt>
<dd>buffer into which data will be read (need not be dma-safe)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n_rx</span></code></dt>
<dd>size of rxbuf, in bytes</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This performs a half duplex MicroWire style transaction with the
device, sending txbuf and then reading rxbuf.  The return value
is zero for success, else a negative errno status code.
This call may only be used from a context that may sleep.</p>
<p>Parameters to this routine are always copied using a small buffer;
portable code should never use this for more than 32 bytes.
Performance-sensitive or bulk transfer code should instead use
spi_{async,sync}() calls with dma-safe buffers.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i2c.html" class="btn btn-neutral float-right" title="I2C and SMBus Subsystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pci/p2pdma.html" class="btn btn-neutral float-left" title="PCI Peer-to-Peer DMA Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>