

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Summary of HDIO_ ioctl calls &mdash; The Linux Kernel 5.4.0-rc3+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Working with the kernel development community" href="../process/index.html" />
    <link rel="prev" title="Summary of CDROM ioctl calls" href="cdrom.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.4.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">IOCTLs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ioctl-number.html">Ioctl Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="botching-up-ioctls.html">(How to avoid) Botching up ioctls</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl-decoding.html">Decoding an IOCTL Magic Number</a></li>
<li class="toctree-l2"><a class="reference internal" href="cdrom.html">Summary of CDROM ioctl calls</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Summary of <cite>HDIO_</cite> ioctl calls</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">IOCTLs</a> &raquo;</li>
        
      <li>Summary of <cite>HDIO_</cite> ioctl calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/ioctl/hdio.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="summary-of-hdio-ioctl-calls">
<h1>Summary of <cite>HDIO_</cite> ioctl calls<a class="headerlink" href="#summary-of-hdio-ioctl-calls" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>Edward A. Falk &lt;<a class="reference external" href="mailto:efalk&#37;&#52;&#48;google&#46;com">efalk<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</li>
</ul>
<p>November, 2004</p>
<p>This document attempts to describe the ioctl(2) calls supported by
the HD/IDE layer.  These are by-and-large implemented (as of Linux 2.6)
in drivers/ide/ide.c and drivers/block/scsi_ioctl.c</p>
<p>ioctl values are listed in &lt;linux/hdreg.h&gt;.  As of this writing, they
are as follows:</p>
<blockquote>
<div><p>ioctls that pass argument pointers to user space:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>HDIO_GETGEO</td>
<td>get device geometry</td>
</tr>
<tr class="row-even"><td>HDIO_GET_UNMASKINTR</td>
<td>get current unmask setting</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_MULTCOUNT</td>
<td>get current IDE blockmode setting</td>
</tr>
<tr class="row-even"><td>HDIO_GET_QDMA</td>
<td>get use-qdma flag</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_XFER</td>
<td>set transfer rate via proc</td>
</tr>
<tr class="row-even"><td>HDIO_OBSOLETE_IDENTITY</td>
<td>OBSOLETE, DO NOT USE</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_KEEPSETTINGS</td>
<td>get keep-settings-on-reset flag</td>
</tr>
<tr class="row-even"><td>HDIO_GET_32BIT</td>
<td>get current io_32bit setting</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_NOWERR</td>
<td>get ignore-write-error flag</td>
</tr>
<tr class="row-even"><td>HDIO_GET_DMA</td>
<td>get use-dma flag</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_NICE</td>
<td>get nice flags</td>
</tr>
<tr class="row-even"><td>HDIO_GET_IDENTITY</td>
<td>get IDE identification info</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_WCACHE</td>
<td>get write cache mode on|off</td>
</tr>
<tr class="row-even"><td>HDIO_GET_ACOUSTIC</td>
<td>get acoustic value</td>
</tr>
<tr class="row-odd"><td>HDIO_GET_ADDRESS</td>
<td>get sector addressing mode</td>
</tr>
<tr class="row-even"><td>HDIO_GET_BUSSTATE</td>
<td>get the bus state of the hwif</td>
</tr>
<tr class="row-odd"><td>HDIO_TRISTATE_HWIF</td>
<td>execute a channel tristate</td>
</tr>
<tr class="row-even"><td>HDIO_DRIVE_RESET</td>
<td>execute a device reset</td>
</tr>
<tr class="row-odd"><td>HDIO_DRIVE_TASKFILE</td>
<td>execute raw taskfile</td>
</tr>
<tr class="row-even"><td>HDIO_DRIVE_TASK</td>
<td>execute task and special drive command</td>
</tr>
<tr class="row-odd"><td>HDIO_DRIVE_CMD</td>
<td>execute a special drive command</td>
</tr>
<tr class="row-even"><td>HDIO_DRIVE_CMD_AEB</td>
<td>HDIO_DRIVE_TASK</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>ioctls that pass non-pointer values:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>HDIO_SET_MULTCOUNT</td>
<td>change IDE blockmode</td>
</tr>
<tr class="row-even"><td>HDIO_SET_UNMASKINTR</td>
<td>permit other irqs during I/O</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_KEEPSETTINGS</td>
<td>keep ioctl settings on reset</td>
</tr>
<tr class="row-even"><td>HDIO_SET_32BIT</td>
<td>change io_32bit flags</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_NOWERR</td>
<td>change ignore-write-error flag</td>
</tr>
<tr class="row-even"><td>HDIO_SET_DMA</td>
<td>change use-dma flag</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_PIO_MODE</td>
<td>reconfig interface to new speed</td>
</tr>
<tr class="row-even"><td>HDIO_SCAN_HWIF</td>
<td>register and (re)scan interface</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_NICE</td>
<td>set nice flags</td>
</tr>
<tr class="row-even"><td>HDIO_UNREGISTER_HWIF</td>
<td>unregister interface</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_WCACHE</td>
<td>change write cache enable-disable</td>
</tr>
<tr class="row-even"><td>HDIO_SET_ACOUSTIC</td>
<td>change acoustic behavior</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_BUSSTATE</td>
<td>set the bus state of the hwif</td>
</tr>
<tr class="row-even"><td>HDIO_SET_QDMA</td>
<td>change use-qdma flag</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_ADDRESS</td>
<td>change lba addressing modes</td>
</tr>
<tr class="row-even"><td>HDIO_SET_IDE_SCSI</td>
<td>Set scsi emulation mode on/off</td>
</tr>
<tr class="row-odd"><td>HDIO_SET_SCSI_IDE</td>
<td>not implemented yet</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p>The information that follows was determined from reading kernel source
code.  It is likely that some corrections will be made over time.</p>
<hr class="docutils" />
<p>General:</p>
<blockquote>
<div><p>Unless otherwise specified, all ioctl calls return 0 on success
and -1 with errno set to an appropriate value on error.</p>
<p>Unless otherwise specified, all ioctl calls return -1 and set
errno to EFAULT on a failed attempt to copy data to or from user
address space.</p>
<p>Unless otherwise specified, all data structures and constants
are defined in &lt;linux/hdreg.h&gt;</p>
</div></blockquote>
<hr class="docutils" />
<dl class="docutils">
<dt>HDIO_GETGEO</dt>
<dd><p class="first">get device geometry</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hd_geometry geom;

ioctl(fd, HDIO_GETGEO, &amp;geom);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>hd_geometry structure containing:</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>heads</td>
<td>number of heads</td>
</tr>
<tr class="row-even"><td>sectors</td>
<td>number of sectors/track</td>
</tr>
<tr class="row-odd"><td>cylinders</td>
<td>number of cylinders, mod 65536</td>
</tr>
<tr class="row-even"><td>start</td>
<td>starting sector of this partition.</td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last">
<li><p class="first">EINVAL</p>
<blockquote>
<div><p>if the device is not a disk drive or floppy drive,
or if the user passes a null pointer</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">Not particularly useful with modern disk drives, whose geometry
is a polite fiction anyway.  Modern drives are addressed
purely by sector number nowadays (lba addressing), and the
drive geometry is an abstraction which is actually subject
to change.  Currently (as of Nov 2004), the geometry values
are the “bios” values – presumably the values the drive had
when Linux first booted.</p>
<p>In addition, the cylinders field of the hd_geometry is an
unsigned short, meaning that on most architectures, this
ioctl will not return a meaningful value on drives with more
than 65535 tracks.</p>
<p class="last">The start field is unsigned long, meaning that it will not
contain a meaningful value for disks over 219 Gb in size.</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_UNMASKINTR</dt>
<dd><p class="first">get current unmask setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_UNMASKINTR, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the drive’s current unmask setting</dd>
</dl>
</dd>
<dt>HDIO_SET_UNMASKINTR</dt>
<dd><p class="first">permit other irqs during I/O</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long val;

ioctl(fd, HDIO_SET_UNMASKINTR, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for unmask flag</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_GET_MULTCOUNT</dt>
<dd><p class="first">get current IDE blockmode setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_MULTCOUNT, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current IDE block mode setting.  This
controls how many sectors the drive will transfer per
interrupt.</dd>
</dl>
</dd>
<dt>HDIO_SET_MULTCOUNT</dt>
<dd><p class="first">change IDE blockmode</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_MULTCOUNT, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for IDE block mode setting.  This controls how many
sectors the drive will transfer per interrupt.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range supported by disk.</li>
<li>EBUSY       Controller busy or blockmode already set.</li>
<li>EIO         Drive did not accept new block mode.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">Source code comments read:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is tightly woven into the driver-&gt;do_special cannot
touch.  DON&#39;T do it again until a total personality rewrite
is committed.
</pre></div>
</div>
<p class="last">If blockmode has already been set, this ioctl will fail with
-EBUSY</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_QDMA</dt>
<dd><p class="first">get use-qdma flag</p>
<p class="last">Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_XFER</dt>
<dd><p class="first">set transfer rate via proc</p>
<p class="last">Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_OBSOLETE_IDENTITY</dt>
<dd><p class="first">OBSOLETE, DO NOT USE</p>
<p class="last">Same as HDIO_GET_IDENTITY (see below), except that it only
returns the first 142 bytes of drive identity information.</p>
</dd>
<dt>HDIO_GET_IDENTITY</dt>
<dd><p class="first">get IDE identification info</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char identity[512];

ioctl(fd, HDIO_GET_IDENTITY, identity);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>ATA drive identity information.  For full description, see
the IDENTIFY DEVICE and IDENTIFY PACKET DEVICE commands in
the ATA specification.</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>ENOMSG      IDENTIFY DEVICE information not available</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">Returns information that was obtained when the drive was
probed.  Some of this information is subject to change, and
this ioctl does not re-probe the drive to update the
information.</p>
<p class="last">This information is also available from /proc/ide/hdX/identify</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_KEEPSETTINGS</dt>
<dd><p class="first">get keep-settings-on-reset flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_KEEPSETTINGS, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current “keep settings” flag</dd>
<dt>notes:</dt>
<dd>When set, indicates that kernel should restore settings
after a drive reset.</dd>
</dl>
</dd>
<dt>HDIO_SET_KEEPSETTINGS</dt>
<dd><p class="first">keep ioctl settings on reset</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_KEEPSETTINGS, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for keep_settings flag</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY               Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_GET_32BIT</dt>
<dd><p class="first">get current io_32bit setting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_32BIT, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current io_32bit setting</dd>
<dt>notes:</dt>
<dd>0=16-bit, 1=32-bit, 2,3 = 32bit+sync</dd>
</dl>
</dd>
<dt>HDIO_GET_NOWERR</dt>
<dd><p class="first">get ignore-write-error flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_NOWERR, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current ignore-write-error flag</dd>
</dl>
</dd>
<dt>HDIO_GET_DMA</dt>
<dd><p class="first">get use-dma flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_DMA, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current use-dma flag</dd>
</dl>
</dd>
<dt>HDIO_GET_NICE</dt>
<dd><p class="first">get nice flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long nice;

ioctl(fd, HDIO_GET_NICE, &amp;nice);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The drive’s “nice” values.</dd>
<dt>notes:</dt>
<dd><p class="first">Per-drive flags which determine when the system will give more
bandwidth to other devices sharing the same IDE bus.</p>
<p class="last">See &lt;linux/hdreg.h&gt;, near symbol IDE_NICE_DSC_OVERLAP.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_NICE</dt>
<dd><p class="first">set nice flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long nice;

...
ioctl(fd, HDIO_SET_NICE, nice);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>bitmask of nice flags.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EPERM       Flags other than DSC_OVERLAP and NICE_1 set.</li>
<li>EPERM       DSC_OVERLAP specified but not supported by drive</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">This ioctl sets the DSC_OVERLAP and NICE_1 flags from values
provided by the user.</p>
<p class="last">Nice flags are listed in &lt;linux/hdreg.h&gt;, starting with
IDE_NICE_DSC_OVERLAP.  These values represent shifts.</p>
</dd>
</dl>
</dd>
<dt>HDIO_GET_WCACHE</dt>
<dd><p class="first">get write cache mode on|off</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_WCACHE, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current write cache mode</dd>
</dl>
</dd>
<dt>HDIO_GET_ACOUSTIC</dt>
<dd><p class="first">get acoustic value</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_ACOUSTIC, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current acoustic settings</dd>
<dt>notes:</dt>
<dd>See HDIO_SET_ACOUSTIC</dd>
</dl>
</dd>
<dt>HDIO_GET_ADDRESS</dt>
<dd><p class="first">usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_GET_ADDRESS, &amp;val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>The value of the current addressing mode:</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>28-bit</td>
</tr>
<tr class="row-even"><td>1</td>
<td>48-bit</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>48-bit doing 28-bit</td>
</tr>
<tr class="row-even"><td>3</td>
<td>64-bit</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
<dt>HDIO_GET_BUSSTATE</dt>
<dd><p class="first">get the bus state of the hwif</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long state;

ioctl(fd, HDIO_SCAN_HWIF, &amp;state);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>Current power state of the IDE bus.  One of BUSSTATE_OFF,
BUSSTATE_ON, or BUSSTATE_TRISTATE</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_BUSSTATE</dt>
<dd><p class="first">set the bus state of the hwif</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int state;

...
ioctl(fd, HDIO_SCAN_HWIF, state);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Desired IDE power state.  One of BUSSTATE_OFF, BUSSTATE_ON,
or BUSSTATE_TRISTATE</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_RAWIO</li>
<li>EOPNOTSUPP  Hardware interface does not support bus power control</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_TRISTATE_HWIF</dt>
<dd><p class="first">execute a channel tristate</p>
<p class="last">Not implemented, as of 2.6.8.1.  See HDIO_SET_BUSSTATE</p>
</dd>
<dt>HDIO_DRIVE_RESET</dt>
<dd><p class="first">execute a device reset</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int args[3]

...
ioctl(fd, HDIO_DRIVE_RESET, args);
</pre></div>
</div>
<dl class="docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>ENXIO       No such device: phy dead or ctl_addr == 0</li>
<li>EIO         I/O error:      reset timed out or hardware error</li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote class="last">
<div><ul class="simple">
<li>Execute a reset on the device as soon as the current IO
operation has completed.</li>
<li>Executes an ATAPI soft reset if applicable, otherwise
executes an ATA soft reset on the controller.</li>
</ul>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_TASKFILE</dt>
<dd><p class="first">execute raw taskfile</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</dd>
</dl>
<ul class="simple">
<li>Execute an ATA disk command directly by writing the “taskfile”
registers of the drive.  Requires ADMIN and RAWIO access
privileges.</li>
</ul>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {

  ide_task_request_t req_task;
  u8 outbuf[OUTPUT_SIZE];
  u8 inbuf[INPUT_SIZE];
} task;
memset(&amp;task.req_task, 0, sizeof(task.req_task));
task.req_task.out_size = sizeof(task.outbuf);
task.req_task.in_size = sizeof(task.inbuf);
...
ioctl(fd, HDIO_DRIVE_TASKFILE, &amp;task);
...
</pre></div>
</div>
<p>inputs:</p>
<blockquote>
<div><p>(See below for details on memory area passed to ioctl.)</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>io_ports[8]</td>
<td>values to be written to taskfile registers</td>
</tr>
<tr class="row-even"><td>hob_ports[8]</td>
<td>high-order bytes, for extended commands.</td>
</tr>
<tr class="row-odd"><td>out_flags</td>
<td>flags indicating which registers are valid</td>
</tr>
<tr class="row-even"><td>in_flags</td>
<td>flags indicating which registers should be returned</td>
</tr>
<tr class="row-odd"><td>data_phase</td>
<td>see below</td>
</tr>
<tr class="row-even"><td>req_cmd</td>
<td>command type to be executed</td>
</tr>
<tr class="row-odd"><td>out_size</td>
<td>size of output buffer</td>
</tr>
<tr class="row-even"><td>outbuf</td>
<td>buffer of data to be transmitted to disk</td>
</tr>
<tr class="row-odd"><td>inbuf</td>
<td>buffer of data to be received from disk (see [1])</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>outputs:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>io_ports[]</td>
<td>values returned in the taskfile registers</td>
</tr>
<tr class="row-even"><td>hob_ports[]</td>
<td>high-order bytes, for extended commands.</td>
</tr>
<tr class="row-odd"><td>out_flags</td>
<td>flags indicating which registers are valid (see [2])</td>
</tr>
<tr class="row-even"><td>in_flags</td>
<td>flags indicating which registers should be returned</td>
</tr>
<tr class="row-odd"><td>outbuf</td>
<td>buffer of data to be transmitted to disk (see [1])</td>
</tr>
<tr class="row-even"><td>inbuf</td>
<td>buffer of data to be received from disk</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="docutils">
<dt>error returns:</dt>
<dd><ul class="first last">
<li><p class="first">EACCES      CAP_SYS_ADMIN or CAP_SYS_RAWIO privilege not set.</p>
</li>
<li><p class="first">ENOMSG      Device is not a disk drive.</p>
</li>
<li><p class="first">ENOMEM      Unable to allocate memory for task</p>
</li>
<li><p class="first">EFAULT      req_cmd == TASKFILE_IN_OUT (not implemented as of 2.6.8)</p>
</li>
<li><p class="first">EPERM</p>
<blockquote>
<div><p>req_cmd == TASKFILE_MULTI_OUT and drive
multi-count not yet set.</p>
</div></blockquote>
</li>
<li><p class="first">EIO         Drive failed the command.</p>
</li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote class="last">
<div><p>[1] READ THE FOLLOWING NOTES <em>CAREFULLY</em>.  THIS IOCTL IS
FULL OF GOTCHAS.  Extreme caution should be used with using
this ioctl.  A mistake can easily corrupt data or hang the
system.</p>
<p>[2] Both the input and output buffers are copied from the
user and written back to the user, even when not used.</p>
<p>[3] If one or more bits are set in out_flags and in_flags is
zero, the following values are used for in_flags.all and
written back into in_flags on completion.</p>
<blockquote>
<div><ul class="simple">
<li>IDE_TASKFILE_STD_IN_FLAGS | (IDE_HOB_STD_IN_FLAGS &lt;&lt; 8)
if LBA48 addressing is enabled for the drive</li>
<li>IDE_TASKFILE_STD_IN_FLAGS
if CHS/LBA28</li>
</ul>
</div></blockquote>
<p>The association between in_flags.all and each enable
bitfield flips depending on endianness; fortunately, TASKFILE
only uses inflags.b.data bit and ignores all other bits.
The end result is that, on any endian machines, it has no
effect other than modifying in_flags on completion.</p>
<p>[4] The default value of SELECT is (0xa0|DEV_bit|LBA_bit)
except for four drives per port chipsets.  For four drives
per port chipsets, it’s (0xa0|DEV_bit|LBA_bit) for the first
pair and (0x80|DEV_bit|LBA_bit) for the second pair.</p>
<p>[5] The argument to the ioctl is a pointer to a region of
memory containing a ide_task_request_t structure, followed
by an optional buffer of data to be transmitted to the
drive, followed by an optional buffer to receive data from
the drive.</p>
<p>Command is passed to the disk drive via the ide_task_request_t
structure, which contains these fields:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>io_ports[8]</td>
<td>values for the taskfile registers</td>
</tr>
<tr class="row-even"><td>hob_ports[8]</td>
<td>high-order bytes, for extended commands</td>
</tr>
<tr class="row-odd"><td>out_flags</td>
<td>flags indicating which entries in the
io_ports[] and hob_ports[] arrays
contain valid values.  Type ide_reg_valid_t.</td>
</tr>
<tr class="row-even"><td>in_flags</td>
<td>flags indicating which entries in the
io_ports[] and hob_ports[] arrays
are expected to contain valid values
on return.</td>
</tr>
<tr class="row-odd"><td>data_phase</td>
<td>See below</td>
</tr>
<tr class="row-even"><td>req_cmd</td>
<td>Command type, see below</td>
</tr>
<tr class="row-odd"><td>out_size</td>
<td>output (user-&gt;drive) buffer size, bytes</td>
</tr>
<tr class="row-even"><td>in_size</td>
<td>input (drive-&gt;user) buffer size, bytes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When out_flags is zero, the following registers are loaded.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>HOB_FEATURE</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>HOB_NSECTOR</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-odd"><td>HOB_SECTOR</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>HOB_LCYL</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-odd"><td>HOB_HCYL</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>FEATURE</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>NSECTOR</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SECTOR</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>LCYL</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>HCYL</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SELECT</td>
<td>First, masked with 0xE0 if LBA48, 0xEF
otherwise; then, or’ed with the default
value of SELECT.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If any bit in out_flags is set, the following registers are loaded.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>HOB_DATA</td>
<td>If out_flags.b.data is set.  HOB_DATA will
travel on DD8-DD15 on little endian machines
and on DD0-DD7 on big endian machines.</td>
</tr>
<tr class="row-even"><td>DATA</td>
<td>If out_flags.b.data is set.  DATA will
travel on DD0-DD7 on little endian machines
and on DD8-DD15 on big endian machines.</td>
</tr>
<tr class="row-odd"><td>HOB_NSECTOR</td>
<td>If out_flags.b.nsector_hob is set</td>
</tr>
<tr class="row-even"><td>HOB_SECTOR</td>
<td>If out_flags.b.sector_hob is set</td>
</tr>
<tr class="row-odd"><td>HOB_LCYL</td>
<td>If out_flags.b.lcyl_hob is set</td>
</tr>
<tr class="row-even"><td>HOB_HCYL</td>
<td>If out_flags.b.hcyl_hob is set</td>
</tr>
<tr class="row-odd"><td>FEATURE</td>
<td>If out_flags.b.feature is set</td>
</tr>
<tr class="row-even"><td>NSECTOR</td>
<td>If out_flags.b.nsector is set</td>
</tr>
<tr class="row-odd"><td>SECTOR</td>
<td>If out_flags.b.sector is set</td>
</tr>
<tr class="row-even"><td>LCYL</td>
<td>If out_flags.b.lcyl is set</td>
</tr>
<tr class="row-odd"><td>HCYL</td>
<td>If out_flags.b.hcyl is set</td>
</tr>
<tr class="row-even"><td>SELECT</td>
<td>Or’ed with the default value of SELECT and
loaded regardless of out_flags.b.select.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Taskfile registers are read back from the drive into
{io|hob}_ports[] after the command completes iff one of the
following conditions is met; otherwise, the original values
will be written back, unchanged.</p>
<blockquote>
<div><ol class="arabic simple">
<li>The drive fails the command (EIO).</li>
<li>One or more than one bits are set in out_flags.</li>
<li>The requested data_phase is TASKFILE_NO_DATA.</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>HOB_DATA</td>
<td>If in_flags.b.data is set.  It will contain
DD8-DD15 on little endian machines and
DD0-DD7 on big endian machines.</td>
</tr>
<tr class="row-even"><td>DATA</td>
<td>If in_flags.b.data is set.  It will contain
DD0-DD7 on little endian machines and
DD8-DD15 on big endian machines.</td>
</tr>
<tr class="row-odd"><td>HOB_FEATURE</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>HOB_NSECTOR</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-odd"><td>HOB_SECTOR</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>HOB_LCYL</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-odd"><td>HOB_HCYL</td>
<td>If the drive supports LBA48</td>
</tr>
<tr class="row-even"><td>NSECTOR</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SECTOR</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>LCYL</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>HCYL</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The data_phase field describes the data transfer to be
performed.  Value is one of:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>TASKFILE_IN</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>TASKFILE_MULTI_IN</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>TASKFILE_OUT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>TASKFILE_MULTI_OUT</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>TASKFILE_IN_OUT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>TASKFILE_IN_DMA</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>TASKFILE_IN_DMAQ</td>
<td>== IN_DMA (queueing not supported)</td>
</tr>
<tr class="row-even"><td>TASKFILE_OUT_DMA</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>TASKFILE_OUT_DMAQ</td>
<td>== OUT_DMA (queueing not supported)</td>
</tr>
<tr class="row-even"><td>TASKFILE_P_IN</td>
<td>unimplemented</td>
</tr>
<tr class="row-odd"><td>TASKFILE_P_IN_DMA</td>
<td>unimplemented</td>
</tr>
<tr class="row-even"><td>TASKFILE_P_IN_DMAQ</td>
<td>unimplemented</td>
</tr>
<tr class="row-odd"><td>TASKFILE_P_OUT</td>
<td>unimplemented</td>
</tr>
<tr class="row-even"><td>TASKFILE_P_OUT_DMA</td>
<td>unimplemented</td>
</tr>
<tr class="row-odd"><td>TASKFILE_P_OUT_DMAQ</td>
<td>unimplemented</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The req_cmd field classifies the command type.  It may be
one of:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>IDE_DRIVE_TASK_NO_DATA</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>IDE_DRIVE_TASK_SET_XFER</td>
<td>unimplemented</td>
</tr>
<tr class="row-odd"><td>IDE_DRIVE_TASK_IN</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>IDE_DRIVE_TASK_OUT</td>
<td>unimplemented</td>
</tr>
<tr class="row-odd"><td>IDE_DRIVE_TASK_RAW_WRITE</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>[6] Do not access {in|out}_flags-&gt;all except for resetting
all the bits.  Always access individual bit fields.  -&gt;all
value will flip depending on endianness.  For the same
reason, do not use IDE_{TASKFILE|HOB}_STD_{OUT|IN}_FLAGS
constants defined in hdreg.h.</p>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_CMD</dt>
<dd><p class="first">execute a special drive command</p>
<p>Note:  If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 args[4+XFER_SIZE];

...
ioctl(fd, HDIO_DRIVE_CMD, args);
</pre></div>
</div>
<dl class="docutils">
<dt>inputs:</dt>
<dd><p class="first">Commands other than WIN_SMART:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>COMMAND</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>NSECTOR</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>FEATURE</td>
</tr>
<tr class="row-even"><td>args[3]</td>
<td>NSECTOR</td>
</tr>
</tbody>
</table>
<p>WIN_SMART:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>COMMAND</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>SECTOR</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>FEATURE</td>
</tr>
<tr class="row-even"><td>args[3]</td>
<td>NSECTOR</td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>args[] buffer is filled with register values followed by any</div></blockquote>
<p>data returned by the disk.</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>status</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>error</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>NSECTOR</td>
</tr>
<tr class="row-even"><td>args[3]</td>
<td>undefined</td>
</tr>
<tr class="row-odd"><td>args[4+]</td>
<td>NSECTOR * 512 bytes of data returned by the command.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_RAWIO</li>
<li>ENOMEM      Unable to allocate memory for task</li>
<li>EIO         Drive reports error</li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote class="last">
<div><p>[1] For commands other than WIN_SMART, args[1] should equal
args[3].  SECTOR, LCYL and HCYL are undefined.  For
WIN_SMART, 0x4f and 0xc2 are loaded into LCYL and HCYL
respectively.  In both cases SELECT will contain the default
value for the drive.  Please refer to HDIO_DRIVE_TASKFILE
notes for the default value of SELECT.</p>
<p>[2] If NSECTOR value is greater than zero and the drive sets
DRQ when interrupting for the command, NSECTOR * 512 bytes
are read from the device into the area following NSECTOR.
In the above example, the area would be
args[4..4+XFER_SIZE].  16bit PIO is used regardless of
HDIO_SET_32BIT setting.</p>
<p>[3] If COMMAND == WIN_SETFEATURES &amp;&amp; FEATURE == SETFEATURES_XFER
&amp;&amp; NSECTOR &gt;= XFER_SW_DMA_0 &amp;&amp; the drive supports any DMA
mode, IDE driver will try to tune the transfer mode of the
drive accordingly.</p>
</div></blockquote>
</dd>
<dt>HDIO_DRIVE_TASK</dt>
<dd><p class="first">execute task and special drive command</p>
<p>Note:  If you don’t have a copy of the ANSI ATA specification
handy, you should probably ignore this ioctl.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 args[7];

...
ioctl(fd, HDIO_DRIVE_TASK, args);
</pre></div>
</div>
<dl class="docutils">
<dt>inputs:</dt>
<dd><p class="first">Taskfile register values:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>COMMAND</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>FEATURE</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>NSECTOR</td>
</tr>
<tr class="row-even"><td>args[3]</td>
<td>SECTOR</td>
</tr>
<tr class="row-odd"><td>args[4]</td>
<td>LCYL</td>
</tr>
<tr class="row-even"><td>args[5]</td>
<td>HCYL</td>
</tr>
<tr class="row-odd"><td>args[6]</td>
<td>SELECT</td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt>
<dd><p class="first">Taskfile register values:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>status</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>error</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>NSECTOR</td>
</tr>
<tr class="row-even"><td>args[3]</td>
<td>SECTOR</td>
</tr>
<tr class="row-odd"><td>args[4]</td>
<td>LCYL</td>
</tr>
<tr class="row-even"><td>args[5]</td>
<td>HCYL</td>
</tr>
<tr class="row-odd"><td>args[6]</td>
<td>SELECT</td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_RAWIO</li>
<li>ENOMEM      Unable to allocate memory for task</li>
<li>ENOMSG      Device is not a disk drive.</li>
<li>EIO         Drive failed the command.</li>
</ul>
</dd>
</dl>
<p>notes:</p>
<blockquote class="last">
<div>[1] DEV bit (0x10) of SELECT register is ignored and the
appropriate value for the drive is used.  All other bits
are used unaltered.</div></blockquote>
</dd>
<dt>HDIO_DRIVE_CMD_AEB</dt>
<dd><p class="first">HDIO_DRIVE_TASK</p>
<p class="last">Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_32BIT</dt>
<dd><p class="first">change io_32bit flags</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_32BIT, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for io_32bit flag</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 3]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_NOWERR</dt>
<dd><p class="first">change ignore-write-error flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_NOWERR, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><blockquote class="first">
<div>New value for ignore-write-error flag.  Used for ignoring</div></blockquote>
<p class="last">WRERR_STAT</p>
</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY               Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_DMA</dt>
<dd><p class="first">change use-dma flag</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_DMA, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for use-dma flag</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_PIO_MODE</dt>
<dd><p class="first">reconfig interface to new speed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_PIO_MODE, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New interface speed.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 255]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SCAN_HWIF</dt>
<dd><p class="first">register and (re)scan interface</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int args[3]

...
ioctl(fd, HDIO_SCAN_HWIF, args);
</pre></div>
</div>
<p>inputs:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>args[0]</td>
<td>io address to probe</td>
</tr>
<tr class="row-even"><td>args[1]</td>
<td>control address to probe</td>
</tr>
<tr class="row-odd"><td>args[2]</td>
<td>irq number</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_RAWIO</li>
<li>EIO         Probe failed.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd>This ioctl initializes the addresses and irq for a disk
controller, probes for drives, and creates /proc/ide
interfaces as appropriate.</dd>
</dl>
</dd>
<dt>HDIO_UNREGISTER_HWIF</dt>
<dd><p class="first">unregister interface</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int index;

ioctl(fd, HDIO_UNREGISTER_HWIF, index);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>index           index of hardware interface to unregister</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_RAWIO</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">This ioctl removes a hardware interface from the kernel.</p>
<p class="last">Currently (2.6.8) this ioctl silently fails if any drive on
the interface is busy.</p>
</dd>
</dl>
</dd>
<dt>HDIO_SET_WCACHE</dt>
<dd><p class="first">change write cache enable-disable</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_WCACHE, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for write cache enable</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_ACOUSTIC</dt>
<dd><p class="first">change acoustic behavior</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_ACOUSTIC, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for drive acoustic settings</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 254]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_QDMA</dt>
<dd><p class="first">change use-qdma flag</p>
<p class="last">Not implemented, as of 2.6.8.1</p>
</dd>
<dt>HDIO_SET_ADDRESS</dt>
<dd><p class="first">change lba addressing modes</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, HDIO_SET_ADDRESS, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><blockquote class="first">
<div>New value for addressing mode</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>28-bit</td>
</tr>
<tr class="row-even"><td>1</td>
<td>48-bit</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>48-bit doing 28-bit</td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 2]</li>
<li>EBUSY               Controller busy</li>
<li>EIO         Drive does not support lba48 mode.</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_IDE_SCSI</dt>
<dd><p class="first">usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long val;

ioctl(fd, HDIO_SET_IDE_SCSI, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New value for scsi emulation mode (?)</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      (bdev != bdev-&gt;bd_contains) (not sure what this means)</li>
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>EINVAL      value out of range [0 1]</li>
<li>EBUSY       Controller busy</li>
</ul>
</dd>
</dl>
</dd>
<dt>HDIO_SET_SCSI_IDE</dt>
<dd>Not implemented, as of 2.6.8.1</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../process/index.html" class="btn btn-neutral float-right" title="Working with the kernel development community" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cdrom.html" class="btn btn-neutral float-left" title="Summary of CDROM ioctl calls" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>