

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing I2C Clients &mdash; The Linux Kernel 5.4.0-rc3+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel driver i2c-mux-gpio" href="muxes/i2c-mux-gpio.html" />
    <link rel="prev" title="Upgrading I2C Drivers to the new 2.6 Driver Model" href="upgrading-clients.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.4.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ioctl/index.html">IOCTLs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">I2C/SMBus Subsystem</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="dev-interface.html">I2C Device Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-considerations.html">Linux I2C and DMA</a></li>
<li class="toctree-l2"><a class="reference internal" href="fault-codes.html">I2C/SMBUS Fault Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="functionality.html">I2C/SMBus Functionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio-fault-injection.html">Linux I2C fault injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c-protocol.html">I2C Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c-stub.html">i2c-stub</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c-topology.html">I2C topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="instantiating-devices.html">How to instantiate I2C devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="old-module-parameters.html">I2C device driver binding control from user-space</a></li>
<li class="toctree-l2"><a class="reference internal" href="slave-eeprom-backend.html">Linux I2C slave eeprom backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="slave-interface.html">Linux I2C slave interface description</a></li>
<li class="toctree-l2"><a class="reference internal" href="smbus-protocol.html">SMBus Protocol Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">I2C and SMBus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ten-bit-addresses.html">I2C Ten-bit Addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="upgrading-clients.html">Upgrading I2C Drivers to the new 2.6 Driver Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing I2C Clients</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-remarks">General remarks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-driver-structure">The driver structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extra-client-data">Extra client data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-the-client">Accessing the client</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probing-and-attaching">Probing and attaching</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-driver-binding">Device/Driver Binding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-creation">Device Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-detection">Device Detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-deletion">Device Deletion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-the-driver">Initializing the driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-information">Driver Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#power-management">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-shutdown">System Shutdown</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-function">Command function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sending-and-receiving">Sending and receiving</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plain-i2c-communication">Plain I2C communication</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smbus-communication">SMBus communication</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#general-purpose-routines">General purpose routines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="muxes/i2c-mux-gpio.html">Kernel driver i2c-mux-gpio</a></li>
<li class="toctree-l2"><a class="reference internal" href="busses/index.html">I2C Bus Drivers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">I2C/SMBus Subsystem</a> &raquo;</li>
        
      <li>Writing I2C Clients</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/i2c/writing-clients.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-i2c-clients">
<h1>Writing I2C Clients<a class="headerlink" href="#writing-i2c-clients" title="Permalink to this headline">¶</a></h1>
<p>This is a small guide for those who want to write kernel drivers for I2C
or SMBus devices, using Linux as the protocol host/master (not slave).</p>
<p>To set up a driver, you need to do several things. Some are optional, and
some things can be done slightly or completely different. Use this as a
guide, not as a rule book!</p>
<div class="section" id="general-remarks">
<h2>General remarks<a class="headerlink" href="#general-remarks" title="Permalink to this headline">¶</a></h2>
<p>Try to keep the kernel namespace as clean as possible. The best way to
do this is to use a unique prefix for all global symbols. This is
especially important for exported symbols, but it is a good idea to do
it for non-exported symbols too. We will use the prefix <code class="docutils literal notranslate"><span class="pre">foo_</span></code> in this
tutorial.</p>
</div>
<div class="section" id="the-driver-structure">
<h2>The driver structure<a class="headerlink" href="#the-driver-structure" title="Permalink to this headline">¶</a></h2>
<p>Usually, you will implement a single driver structure, and instantiate
all clients from it. Remember, a driver structure contains general access
routines, and should be zero-initialized except for fields with data you
provide.  A client structure holds device-specific information like the
driver model device node, and its I2C address.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct i2c_device_id foo_idtable[] = {
      { &quot;foo&quot;, my_id_for_foo },
      { &quot;bar&quot;, my_id_for_bar },
      { }
};

MODULE_DEVICE_TABLE(i2c, foo_idtable);

static struct i2c_driver foo_driver = {
      .driver = {
              .name   = &quot;foo&quot;,
              .pm     = &amp;foo_pm_ops,  /* optional */
      },

      .id_table       = foo_idtable,
      .probe          = foo_probe,
      .remove         = foo_remove,
      /* if device autodetection is needed: */
      .class          = I2C_CLASS_SOMETHING,
      .detect         = foo_detect,
      .address_list   = normal_i2c,

      .shutdown       = foo_shutdown, /* optional */
      .command        = foo_command,  /* optional, deprecated */
}
</pre></div>
</div>
<p>The name field is the driver name, and must not contain spaces.  It
should match the module name (if the driver can be compiled as a module),
although you can use MODULE_ALIAS (passing “foo” in this example) to add
another name for the module.  If the driver name doesn’t match the module
name, the module won’t be automatically loaded (hotplug/coldplug).</p>
<p>All other fields are for call-back functions which will be explained
below.</p>
</div>
<div class="section" id="extra-client-data">
<h2>Extra client data<a class="headerlink" href="#extra-client-data" title="Permalink to this headline">¶</a></h2>
<p>Each client structure has a special <code class="docutils literal notranslate"><span class="pre">data</span></code> field that can point to any
structure at all.  You should use this to keep device-specific data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* store the value */
void i2c_set_clientdata(struct i2c_client *client, void *data);

/* retrieve the value */
void *i2c_get_clientdata(const struct i2c_client *client);
</pre></div>
</div>
<p>Note that starting with kernel 2.6.34, you don’t have to set the <code class="docutils literal notranslate"><span class="pre">data</span></code> field
to NULL in remove() or if probe() failed anymore. The i2c-core does this
automatically on these occasions. Those are also the only times the core will
touch this field.</p>
</div>
<div class="section" id="accessing-the-client">
<h2>Accessing the client<a class="headerlink" href="#accessing-the-client" title="Permalink to this headline">¶</a></h2>
<p>Let’s say we have a valid client structure. At some time, we will need
to gather information from the client, or write new information to the
client.</p>
<p>I have found it useful to define foo_read and foo_write functions for this.
For some cases, it will be easier to call the i2c functions directly,
but many chips have some kind of register-value idea that can easily
be encapsulated.</p>
<p>The below functions are simple examples, and should not be copied
literally:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int foo_read_value(struct i2c_client *client, u8 reg)
{
      if (reg &lt; 0x10) /* byte-sized register */
              return i2c_smbus_read_byte_data(client, reg);
      else            /* word-sized register */
              return i2c_smbus_read_word_data(client, reg);
}

int foo_write_value(struct i2c_client *client, u8 reg, u16 value)
{
      if (reg == 0x10)        /* Impossible to write - driver error! */
              return -EINVAL;
      else if (reg &lt; 0x10)    /* byte-sized register */
              return i2c_smbus_write_byte_data(client, reg, value);
      else                    /* word-sized register */
              return i2c_smbus_write_word_data(client, reg, value);
}
</pre></div>
</div>
</div>
<div class="section" id="probing-and-attaching">
<h2>Probing and attaching<a class="headerlink" href="#probing-and-attaching" title="Permalink to this headline">¶</a></h2>
<p>The Linux I2C stack was originally written to support access to hardware
monitoring chips on PC motherboards, and thus used to embed some assumptions
that were more appropriate to SMBus (and PCs) than to I2C.  One of these
assumptions was that most adapters and devices drivers support the SMBUS_QUICK
protocol to probe device presence.  Another was that devices and their drivers
can be sufficiently configured using only such probe primitives.</p>
<p>As Linux and its I2C stack became more widely used in embedded systems
and complex components such as DVB adapters, those assumptions became more
problematic.  Drivers for I2C devices that issue interrupts need more (and
different) configuration information, as do drivers handling chip variants
that can’t be distinguished by protocol probing, or which need some board
specific information to operate correctly.</p>
<div class="section" id="device-driver-binding">
<h3>Device/Driver Binding<a class="headerlink" href="#device-driver-binding" title="Permalink to this headline">¶</a></h3>
<p>System infrastructure, typically board-specific initialization code or
boot firmware, reports what I2C devices exist.  For example, there may be
a table, in the kernel or from the boot loader, identifying I2C devices
and linking them to board-specific configuration information about IRQs
and other wiring artifacts, chip type, and so on.  That could be used to
create i2c_client objects for each I2C device.</p>
<p>I2C device drivers using this binding model work just like any other
kind of driver in Linux:  they provide a probe() method to bind to
those devices, and a remove() method to unbind.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int foo_probe(struct i2c_client *client,
                     const struct i2c_device_id *id);
static int foo_remove(struct i2c_client *client);
</pre></div>
</div>
<p>Remember that the i2c_driver does not create those client handles.  The
handle may be used during foo_probe().  If foo_probe() reports success
(zero not a negative status code) it may save the handle and use it until
foo_remove() returns.  That binding model is used by most Linux drivers.</p>
<p>The probe function is called when an entry in the id_table name field
matches the device’s name. It is passed the entry that was matched so
the driver knows which one in the table matched.</p>
</div>
<div class="section" id="device-creation">
<h3>Device Creation<a class="headerlink" href="#device-creation" title="Permalink to this headline">¶</a></h3>
<p>If you know for a fact that an I2C device is connected to a given I2C bus,
you can instantiate that device by simply filling an i2c_board_info
structure with the device address and driver name, and calling
<a class="reference internal" href="../driver-api/i2c.html#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_device()</span></code></a>.  This will create the device, then the driver core will
take care of finding the right driver and will call its probe() method.
If a driver supports different device types, you can specify the type you
want using the type field.  You can also specify an IRQ and platform data
if needed.</p>
<p>Sometimes you know that a device is connected to a given I2C bus, but you
don’t know the exact address it uses.  This happens on TV adapters for
example, where the same driver supports dozens of slightly different
models, and I2C device addresses change from one model to the next.  In
that case, you can use the i2c_new_probed_device() variant, which is
similar to <a class="reference internal" href="../driver-api/i2c.html#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_device()</span></code></a>, except that it takes an additional list of
possible I2C addresses to probe.  A device is created for the first
responsive address in the list.  If you expect more than one device to be
present in the address range, simply call i2c_new_probed_device() that
many times.</p>
<p>The call to <a class="reference internal" href="../driver-api/i2c.html#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_device()</span></code></a> or i2c_new_probed_device() typically happens
in the I2C bus driver. You may want to save the returned i2c_client
reference for later use.</p>
</div>
<div class="section" id="device-detection">
<h3>Device Detection<a class="headerlink" href="#device-detection" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you do not know in advance which I2C devices are connected to
a given I2C bus.  This is for example the case of hardware monitoring
devices on a PC’s SMBus.  In that case, you may want to let your driver
detect supported devices automatically.  This is how the legacy model
was working, and is now available as an extension to the standard
driver model.</p>
<p>You simply have to define a detect callback which will attempt to
identify supported devices (returning 0 for supported ones and -ENODEV
for unsupported ones), a list of addresses to probe, and a device type
(or class) so that only I2C buses which may have that type of device
connected (and not otherwise enumerated) will be probed.  For example,
a driver for a hardware monitoring chip for which auto-detection is
needed would set its class to I2C_CLASS_HWMON, and only I2C adapters
with a class including I2C_CLASS_HWMON would be probed by this driver.
Note that the absence of matching classes does not prevent the use of
a device of that type on the given I2C adapter.  All it prevents is
auto-detection; explicit instantiation of devices is still possible.</p>
<p>Note that this mechanism is purely optional and not suitable for all
devices.  You need some reliable way to identify the supported devices
(typically using device-specific, dedicated identification registers),
otherwise misdetections are likely to occur and things can get wrong
quickly.  Keep in mind that the I2C protocol doesn’t include any
standard way to detect the presence of a chip at a given address, let
alone a standard way to identify devices.  Even worse is the lack of
semantics associated to bus transfers, which means that the same
transfer can be seen as a read operation by a chip and as a write
operation by another chip.  For these reasons, explicit device
instantiation should always be preferred to auto-detection where
possible.</p>
</div>
<div class="section" id="device-deletion">
<h3>Device Deletion<a class="headerlink" href="#device-deletion" title="Permalink to this headline">¶</a></h3>
<p>Each I2C device which has been created using <a class="reference internal" href="../driver-api/i2c.html#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_device()</span></code></a> or
i2c_new_probed_device() can be unregistered by calling
<a class="reference internal" href="../driver-api/i2c.html#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_unregister_device()</span></code></a>.  If you don’t call it explicitly, it will be
called automatically before the underlying I2C bus itself is removed, as a
device can’t survive its parent in the device driver model.</p>
</div>
</div>
<div class="section" id="initializing-the-driver">
<h2>Initializing the driver<a class="headerlink" href="#initializing-the-driver" title="Permalink to this headline">¶</a></h2>
<p>When the kernel is booted, or when your foo driver module is inserted,
you have to do some initializing. Fortunately, just registering the
driver module is usually enough.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __init foo_init(void)
{
      return i2c_add_driver(&amp;foo_driver);
}
module_init(foo_init);

static void __exit foo_cleanup(void)
{
      i2c_del_driver(&amp;foo_driver);
}
module_exit(foo_cleanup);

The module_i2c_driver() macro can be used to reduce above code.

module_i2c_driver(foo_driver);
</pre></div>
</div>
<p>Note that some functions are marked by <code class="docutils literal notranslate"><span class="pre">__init</span></code>.  These functions can
be removed after kernel booting (or module loading) is completed.
Likewise, functions marked by <code class="docutils literal notranslate"><span class="pre">__exit</span></code> are dropped by the compiler when
the code is built into the kernel, as they would never be called.</p>
</div>
<div class="section" id="driver-information">
<h2>Driver Information<a class="headerlink" href="#driver-information" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Substitute your own name and email address */
MODULE_AUTHOR(&quot;Frodo Looijaard &lt;frodol@dds.nl&gt;&quot;
MODULE_DESCRIPTION(&quot;Driver for Barf Inc. Foo I2C devices&quot;);

/* a few non-GPL license types are also allowed */
MODULE_LICENSE(&quot;GPL&quot;);
</pre></div>
</div>
</div>
<div class="section" id="power-management">
<h2>Power Management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h2>
<p>If your I2C device needs special handling when entering a system low
power state – like putting a transceiver into a low power mode, or
activating a system wakeup mechanism – do that by implementing the
appropriate callbacks for the dev_pm_ops of the driver (like suspend
and resume).</p>
<p>These are standard driver model calls, and they work just like they
would for any other driver stack.  The calls can sleep, and can use
I2C messaging to the device being suspended or resumed (since their
parent I2C adapter is active when these calls are issued, and IRQs
are still enabled).</p>
</div>
<div class="section" id="system-shutdown">
<h2>System Shutdown<a class="headerlink" href="#system-shutdown" title="Permalink to this headline">¶</a></h2>
<p>If your I2C device needs special handling when the system shuts down
or reboots (including kexec) – like turning something off – use a
shutdown() method.</p>
<p>Again, this is a standard driver model call, working just like it
would for any other driver stack:  the calls can sleep, and can use
I2C messaging.</p>
</div>
<div class="section" id="command-function">
<h2>Command function<a class="headerlink" href="#command-function" title="Permalink to this headline">¶</a></h2>
<p>A generic ioctl-like function call back is supported. You will seldom
need this, and its use is deprecated anyway, so newer design should not
use it.</p>
</div>
<div class="section" id="sending-and-receiving">
<h2>Sending and receiving<a class="headerlink" href="#sending-and-receiving" title="Permalink to this headline">¶</a></h2>
<p>If you want to communicate with your device, there are several functions
to do this. You can find all of them in &lt;linux/i2c.h&gt;.</p>
<p>If you can choose between plain I2C communication and SMBus level
communication, please use the latter. All adapters understand SMBus level
commands, but only some of them understand plain I2C!</p>
<div class="section" id="plain-i2c-communication">
<h3>Plain I2C communication<a class="headerlink" href="#plain-i2c-communication" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i2c_master_send(struct i2c_client *client, const char *buf,
                    int count);
int i2c_master_recv(struct i2c_client *client, char *buf, int count);
</pre></div>
</div>
<p>These routines read and write some bytes from/to a client. The client
contains the i2c address, so you do not have to include it. The second
parameter contains the bytes to read/write, the third the number of bytes
to read/write (must be less than the length of the buffer, also should be
less than 64k since msg.len is u16.) Returned is the actual number of bytes
read/written.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msg,
                 int num);
</pre></div>
</div>
<p>This sends a series of messages. Each message can be a read or write,
and they can be mixed in any way. The transactions are combined: no
stop bit is sent between transaction. The i2c_msg structure contains
for each message the client address, the number of bytes of the message
and the message data itself.</p>
<p>You can read the file <code class="docutils literal notranslate"><span class="pre">i2c-protocol</span></code> for more information about the
actual I2C protocol.</p>
</div>
<div class="section" id="smbus-communication">
<h3>SMBus communication<a class="headerlink" href="#smbus-communication" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
                   unsigned short flags, char read_write, u8 command,
                   int size, union i2c_smbus_data *data);
</pre></div>
</div>
<p>This is the generic SMBus function. All functions below are implemented
in terms of it. Never use this function directly!</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s32 i2c_smbus_read_byte(struct i2c_client *client);
s32 i2c_smbus_write_byte(struct i2c_client *client, u8 value);
s32 i2c_smbus_read_byte_data(struct i2c_client *client, u8 command);
s32 i2c_smbus_write_byte_data(struct i2c_client *client,
                              u8 command, u8 value);
s32 i2c_smbus_read_word_data(struct i2c_client *client, u8 command);
s32 i2c_smbus_write_word_data(struct i2c_client *client,
                              u8 command, u16 value);
s32 i2c_smbus_read_block_data(struct i2c_client *client,
                              u8 command, u8 *values);
s32 i2c_smbus_write_block_data(struct i2c_client *client,
                               u8 command, u8 length, const u8 *values);
s32 i2c_smbus_read_i2c_block_data(struct i2c_client *client,
                                  u8 command, u8 length, u8 *values);
s32 i2c_smbus_write_i2c_block_data(struct i2c_client *client,
                                   u8 command, u8 length,
                                   const u8 *values);
</pre></div>
</div>
<p>These ones were removed from i2c-core because they had no users, but could
be added back later if needed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s32 i2c_smbus_write_quick(struct i2c_client *client, u8 value);
s32 i2c_smbus_process_call(struct i2c_client *client,
                           u8 command, u16 value);
s32 i2c_smbus_block_process_call(struct i2c_client *client,
                                 u8 command, u8 length, u8 *values);
</pre></div>
</div>
<p>All these transactions return a negative errno value on failure. The ‘write’
transactions return 0 on success; the ‘read’ transactions return the read
value, except for block transactions, which return the number of values
read. The block buffers need not be longer than 32 bytes.</p>
<p>You can read the file <code class="docutils literal notranslate"><span class="pre">smbus-protocol</span></code> for more information about the
actual SMBus protocol.</p>
</div>
</div>
<div class="section" id="general-purpose-routines">
<h2>General purpose routines<a class="headerlink" href="#general-purpose-routines" title="Permalink to this headline">¶</a></h2>
<p>Below all general purpose routines are listed, that were not mentioned
before:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Return the adapter number for a specific adapter */
int i2c_adapter_id(struct i2c_adapter *adap);
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="muxes/i2c-mux-gpio.html" class="btn btn-neutral float-right" title="Kernel driver i2c-mux-gpio" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="upgrading-clients.html" class="btn btn-neutral float-left" title="Upgrading I2C Drivers to the new 2.6 Driver Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>