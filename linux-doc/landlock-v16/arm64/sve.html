

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Scalable Vector Extension support for AArch64 Linux &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="AArch64 TAGGED ADDRESS ABI" href="tagged-address-abi.html" />
    <link rel="prev" title="Silicon Errata and Software Workarounds" href="silicon-errata.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">ARM64 Architecture</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="acpi_object_usage.html">ACPI Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="amu.html">Activity Monitors Unit (AMU) extension in AArch64 Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="arm-acpi.html">ACPI on ARMv8 Servers</a></li>
<li class="toctree-l2"><a class="reference internal" href="booting.html">Booting AArch64 Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpu-feature-registers.html">ARM64 CPU Feature Registers</a></li>
<li class="toctree-l2"><a class="reference internal" href="elf_hwcaps.html">ARM64 ELF hwcaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="hugetlbpage.html">HugeTLBpage on ARM64</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy_instructions.html">Legacy instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">Memory Layout on AArch64 Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="pointer-authentication.html">Pointer authentication in AArch64 Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="silicon-errata.html">Silicon Errata and Software Workarounds</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Scalable Vector Extension support for AArch64 Linux</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general">1.  General</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vector-length-terminology">2.  Vector length terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-call-behaviour">3.  System call behaviour</a></li>
<li class="toctree-l3"><a class="reference internal" href="#signal-handling">4.  Signal handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#signal-return">5.  Signal return</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prctl-extensions">6.  prctl extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ptrace-extensions">7.  ptrace extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elf-coredump-extensions">8.  ELF coredump extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-runtime-configuration">9.  System runtime configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#appendix-a-sve-programmer-s-model-informative">Appendix A.  SVE programmer’s model (informative)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#a-1-registers">A.1.  Registers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-2-procedure-call-standard">A.2.  Procedure call standard</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#appendix-b-armv8-a-fp-simd-programmer-s-model">Appendix B.  ARMv8-A FP/SIMD programmer’s model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tagged-address-abi.html">AArch64 TAGGED ADDRESS ABI</a></li>
<li class="toctree-l2"><a class="reference internal" href="tagged-pointers.html">Tagged virtual addresses in AArch64 Linux</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">ARM64 Architecture</a> &raquo;</li>
        
      <li>Scalable Vector Extension support for AArch64 Linux</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/arm64/sve.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scalable-vector-extension-support-for-aarch64-linux">
<h1>Scalable Vector Extension support for AArch64 Linux<a class="headerlink" href="#scalable-vector-extension-support-for-aarch64-linux" title="Permalink to this headline">¶</a></h1>
<p>Author: Dave Martin &lt;<a class="reference external" href="mailto:Dave&#46;Martin&#37;&#52;&#48;arm&#46;com">Dave<span>&#46;</span>Martin<span>&#64;</span>arm<span>&#46;</span>com</a>&gt;</p>
<p>Date:   4 August 2017</p>
<p>This document outlines briefly the interface provided to userspace by Linux in
order to support use of the ARM Scalable Vector Extension (SVE).</p>
<p>This is an outline of the most important features and issues only and not
intended to be exhaustive.</p>
<p>This document does not aim to describe the SVE architecture or programmer’s
model.  To aid understanding, a minimal description of relevant programmer’s
model features for SVE is included in Appendix A.</p>
<div class="section" id="general">
<h2>1.  General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>SVE registers Z0..Z31, P0..P15 and FFR and the current vector length VL, are
tracked per-thread.</p></li>
<li><p>The presence of SVE is reported to userspace via HWCAP_SVE in the aux vector
AT_HWCAP entry.  Presence of this flag implies the presence of the SVE
instructions and registers, and the Linux-specific system interfaces
described in this document.  SVE is reported in /proc/cpuinfo as “sve”.</p></li>
<li><p>Support for the execution of SVE instructions in userspace can also be
detected by reading the CPU ID register ID_AA64PFR0_EL1 using an MRS
instruction, and checking that the value of the SVE field is nonzero. [3]</p>
<p>It does not guarantee the presence of the system interfaces described in the
following sections: software that needs to verify that those interfaces are
present must check for HWCAP_SVE instead.</p>
</li>
<li><p>On hardware that supports the SVE2 extensions, HWCAP2_SVE2 will also
be reported in the AT_HWCAP2 aux vector entry.  In addition to this,
optional extensions to SVE2 may be reported by the presence of:</p>
<blockquote>
<div><p>HWCAP2_SVE2
HWCAP2_SVEAES
HWCAP2_SVEPMULL
HWCAP2_SVEBITPERM
HWCAP2_SVESHA3
HWCAP2_SVESM4</p>
</div></blockquote>
<p>This list may be extended over time as the SVE architecture evolves.</p>
<p>These extensions are also reported via the CPU ID register ID_AA64ZFR0_EL1,
which userspace can read using an MRS instruction.  See elf_hwcaps.txt and
cpu-feature-registers.txt for details.</p>
</li>
<li><p>Debuggers should restrict themselves to interacting with the target via the
NT_ARM_SVE regset.  The recommended way of detecting support for this regset
is to connect to a target process first and then attempt a
ptrace(PTRACE_GETREGSET, pid, NT_ARM_SVE, &amp;iov).</p></li>
<li><p>Whenever SVE scalable register values (Zn, Pn, FFR) are exchanged in memory
between userspace and the kernel, the register value is encoded in memory in
an endianness-invariant layout, with bits [(8 * i + 7) : (8 * i)] encoded at
byte offset i from the start of the memory representation.  This affects for
example the signal frame (struct sve_context) and ptrace interface
(struct user_sve_header) and associated data.</p>
<p>Beware that on big-endian systems this results in a different byte order than
for the FPSIMD V-registers, which are stored as single host-endian 128-bit
values, with bits [(127 - 8 * i) : (120 - 8 * i)] of the register encoded at
byte offset i.  (struct fpsimd_context, struct user_fpsimd_state).</p>
</li>
</ul>
</div>
<div class="section" id="vector-length-terminology">
<h2>2.  Vector length terminology<a class="headerlink" href="#vector-length-terminology" title="Permalink to this headline">¶</a></h2>
<p>The size of an SVE vector (Z) register is referred to as the “vector length”.</p>
<p>To avoid confusion about the units used to express vector length, the kernel
adopts the following conventions:</p>
<ul class="simple">
<li><p>Vector length (VL) = size of a Z-register in bytes</p></li>
<li><p>Vector quadwords (VQ) = size of a Z-register in units of 128 bits</p></li>
</ul>
<p>(So, VL = 16 * VQ.)</p>
<p>The VQ convention is used where the underlying granularity is important, such
as in data structure definitions.  In most other situations, the VL convention
is used.  This is consistent with the meaning of the “VL” pseudo-register in
the SVE instruction set architecture.</p>
</div>
<div class="section" id="system-call-behaviour">
<h2>3.  System call behaviour<a class="headerlink" href="#system-call-behaviour" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>On syscall, V0..V31 are preserved (as without SVE).  Thus, bits [127:0] of
Z0..Z31 are preserved.  All other bits of Z0..Z31, and all of P0..P15 and FFR
become unspecified on return from a syscall.</p></li>
<li><p>The SVE registers are not used to pass arguments to or receive results from
any syscall.</p></li>
<li><p>In practice the affected registers/bits will be preserved or will be replaced
with zeros on return from a syscall, but userspace should not make
assumptions about this.  The kernel behaviour may vary on a case-by-case
basis.</p></li>
<li><p>All other SVE state of a thread, including the currently configured vector
length, the state of the PR_SVE_VL_INHERIT flag, and the deferred vector
length (if any), is preserved across all syscalls, subject to the specific
exceptions for execve() described in section 6.</p>
<p>In particular, on return from a fork() or clone(), the parent and new child
process or thread share identical SVE configuration, matching that of the
parent before the call.</p>
</li>
</ul>
</div>
<div class="section" id="signal-handling">
<h2>4.  Signal handling<a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A new signal frame record sve_context encodes the SVE registers on signal
delivery. [1]</p></li>
<li><p>This record is supplementary to fpsimd_context.  The FPSR and FPCR registers
are only present in fpsimd_context.  For convenience, the content of V0..V31
is duplicated between sve_context and fpsimd_context.</p></li>
<li><p>The signal frame record for SVE always contains basic metadata, in particular
the thread’s vector length (in sve_context.vl).</p></li>
<li><p>The SVE registers may or may not be included in the record, depending on
whether the registers are live for the thread.  The registers are present if
and only if:
sve_context.head.size &gt;= SVE_SIG_CONTEXT_SIZE(sve_vq_from_vl(sve_context.vl)).</p></li>
<li><p>If the registers are present, the remainder of the record has a vl-dependent
size and layout.  Macros SVE_SIG_* are defined [1] to facilitate access to
the members.</p></li>
<li><p>Each scalable register (Zn, Pn, FFR) is stored in an endianness-invariant
layout, with bits [(8 * i + 7) : (8 * i)] stored at byte offset i from the
start of the register’s representation in memory.</p></li>
<li><p>If the SVE context is too big to fit in sigcontext.__reserved[], then extra
space is allocated on the stack, an extra_context record is written in
__reserved[] referencing this space.  sve_context is then written in the
extra space.  Refer to [1] for further details about this mechanism.</p></li>
</ul>
</div>
<div class="section" id="signal-return">
<h2>5.  Signal return<a class="headerlink" href="#signal-return" title="Permalink to this headline">¶</a></h2>
<p>When returning from a signal handler:</p>
<ul class="simple">
<li><p>If there is no sve_context record in the signal frame, or if the record is
present but contains no register data as desribed in the previous section,
then the SVE registers/bits become non-live and take unspecified values.</p></li>
<li><p>If sve_context is present in the signal frame and contains full register
data, the SVE registers become live and are populated with the specified
data.  However, for backward compatibility reasons, bits [127:0] of Z0..Z31
are always restored from the corresponding members of fpsimd_context.vregs[]
and not from sve_context.  The remaining bits are restored from sve_context.</p></li>
<li><p>Inclusion of fpsimd_context in the signal frame remains mandatory,
irrespective of whether sve_context is present or not.</p></li>
<li><p>The vector length cannot be changed via signal return.  If sve_context.vl in
the signal frame does not match the current vector length, the signal return
attempt is treated as illegal, resulting in a forced SIGSEGV.</p></li>
</ul>
</div>
<div class="section" id="prctl-extensions">
<h2>6.  prctl extensions<a class="headerlink" href="#prctl-extensions" title="Permalink to this headline">¶</a></h2>
<p>Some new prctl() calls are added to allow programs to manage the SVE vector
length:</p>
<p>prctl(PR_SVE_SET_VL, unsigned long arg)</p>
<blockquote>
<div><p>Sets the vector length of the calling thread and related flags, where
arg == vl | flags.  Other threads of the calling process are unaffected.</p>
<p>vl is the desired vector length, where sve_vl_valid(vl) must be true.</p>
<p>flags:</p>
<blockquote>
<div><p>PR_SVE_SET_VL_INHERIT</p>
<blockquote>
<div><p>Inherit the current vector length across execve().  Otherwise, the
vector length is reset to the system default at execve().  (See
Section 9.)</p>
</div></blockquote>
<p>PR_SVE_SET_VL_ONEXEC</p>
<blockquote>
<div><p>Defer the requested vector length change until the next execve()
performed by this thread.</p>
<p>The effect is equivalent to implicit exceution of the following
call immediately after the next execve() (if any) by the thread:</p>
<blockquote>
<div><p>prctl(PR_SVE_SET_VL, arg &amp; ~PR_SVE_SET_VL_ONEXEC)</p>
</div></blockquote>
<p>This allows launching of a new program with a different vector
length, while avoiding runtime side effects in the caller.</p>
<p>Without PR_SVE_SET_VL_ONEXEC, the requested change takes effect
immediately.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Return value: a nonnegative on success, or a negative value on error:</dt><dd><dl class="simple">
<dt>EINVAL: SVE not supported, invalid vector length requested, or</dt><dd><p>invalid flags.</p>
</dd>
</dl>
</dd>
</dl>
<p>On success:</p>
<ul class="simple">
<li><p>Either the calling thread’s vector length or the deferred vector length
to be applied at the next execve() by the thread (dependent on whether
PR_SVE_SET_VL_ONEXEC is present in arg), is set to the largest value
supported by the system that is less than or equal to vl.  If vl ==
SVE_VL_MAX, the value set will be the largest value supported by the
system.</p></li>
<li><p>Any previously outstanding deferred vector length change in the calling
thread is cancelled.</p></li>
<li><p>The returned value describes the resulting configuration, encoded as for
PR_SVE_GET_VL.  The vector length reported in this value is the new
current vector length for this thread if PR_SVE_SET_VL_ONEXEC was not
present in arg; otherwise, the reported vector length is the deferred
vector length that will be applied at the next execve() by the calling
thread.</p></li>
<li><p>Changing the vector length causes all of P0..P15, FFR and all bits of
Z0..Z31 except for Z0 bits [127:0] .. Z31 bits [127:0] to become
unspecified.  Calling PR_SVE_SET_VL with vl equal to the thread’s current
vector length, or calling PR_SVE_SET_VL with the PR_SVE_SET_VL_ONEXEC
flag, does not constitute a change to the vector length for this purpose.</p></li>
</ul>
</div></blockquote>
<p>prctl(PR_SVE_GET_VL)</p>
<blockquote>
<div><p>Gets the vector length of the calling thread.</p>
<p>The following flag may be OR-ed into the result:</p>
<blockquote>
<div><p>PR_SVE_SET_VL_INHERIT</p>
<blockquote>
<div><p>Vector length will be inherited across execve().</p>
</div></blockquote>
</div></blockquote>
<p>There is no way to determine whether there is an outstanding deferred
vector length change (which would only normally be the case between a
fork() or vfork() and the corresponding execve() in typical use).</p>
<p>To extract the vector length from the result, and it with
PR_SVE_VL_LEN_MASK.</p>
<dl class="simple">
<dt>Return value: a nonnegative value on success, or a negative value on error:</dt><dd><p>EINVAL: SVE not supported.</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="ptrace-extensions">
<h2>7.  ptrace extensions<a class="headerlink" href="#ptrace-extensions" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>A new regset NT_ARM_SVE is defined for use with PTRACE_GETREGSET and
PTRACE_SETREGSET.</p>
<p>Refer to [2] for definitions.</p>
</li>
</ul>
<p>The regset data starts with struct user_sve_header, containing:</p>
<blockquote>
<div><p>size</p>
<blockquote>
<div><p>Size of the complete regset, in bytes.
This depends on vl and possibly on other things in the future.</p>
<p>If a call to PTRACE_GETREGSET requests less data than the value of
size, the caller can allocate a larger buffer and retry in order to
read the complete regset.</p>
</div></blockquote>
<p>max_size</p>
<blockquote>
<div><p>Maximum size in bytes that the regset can grow to for the target
thread.  The regset won’t grow bigger than this even if the target
thread changes its vector length etc.</p>
</div></blockquote>
<p>vl</p>
<blockquote>
<div><p>Target thread’s current vector length, in bytes.</p>
</div></blockquote>
<p>max_vl</p>
<blockquote>
<div><p>Maximum possible vector length for the target thread.</p>
</div></blockquote>
<p>flags</p>
<blockquote>
<div><p>either</p>
<blockquote>
<div><p>SVE_PT_REGS_FPSIMD</p>
<blockquote>
<div><p>SVE registers are not live (GETREGSET) or are to be made
non-live (SETREGSET).</p>
<p>The payload is of type struct user_fpsimd_state, with the same
meaning as for NT_PRFPREG, starting at offset
SVE_PT_FPSIMD_OFFSET from the start of user_sve_header.</p>
<p>Extra data might be appended in the future: the size of the
payload should be obtained using SVE_PT_FPSIMD_SIZE(vq, flags).</p>
<p>vq should be obtained using sve_vq_from_vl(vl).</p>
<p>or</p>
</div></blockquote>
<p>SVE_PT_REGS_SVE</p>
<blockquote>
<div><p>SVE registers are live (GETREGSET) or are to be made live
(SETREGSET).</p>
<p>The payload contains the SVE register data, starting at offset
SVE_PT_SVE_OFFSET from the start of user_sve_header, and with
size SVE_PT_SVE_SIZE(vq, flags);</p>
</div></blockquote>
</div></blockquote>
<p>… OR-ed with zero or more of the following flags, which have the same
meaning and behaviour as the corresponding PR_SET_VL_* flags:</p>
<blockquote>
<div><p>SVE_PT_VL_INHERIT</p>
<p>SVE_PT_VL_ONEXEC (SETREGSET only).</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<ul>
<li><p>The effects of changing the vector length and/or flags are equivalent to
those documented for PR_SVE_SET_VL.</p>
<p>The caller must make a further GETREGSET call if it needs to know what VL is
actually set by SETREGSET, unless is it known in advance that the requested
VL is supported.</p>
</li>
<li><p>In the SVE_PT_REGS_SVE case, the size and layout of the payload depends on
the header fields.  The SVE_PT_SVE_*() macros are provided to facilitate
access to the members.</p></li>
<li><p>In either case, for SETREGSET it is permissible to omit the payload, in which
case only the vector length and flags are changed (along with any
consequences of those changes).</p></li>
<li><p>For SETREGSET, if an SVE_PT_REGS_SVE payload is present and the
requested VL is not supported, the effect will be the same as if the
payload were omitted, except that an EIO error is reported.  No
attempt is made to translate the payload data to the correct layout
for the vector length actually set.  The thread’s FPSIMD state is
preserved, but the remaining bits of the SVE registers become
unspecified.  It is up to the caller to translate the payload layout
for the actual VL and retry.</p></li>
<li><p>The effect of writing a partial, incomplete payload is unspecified.</p></li>
</ul>
</div>
<div class="section" id="elf-coredump-extensions">
<h2>8.  ELF coredump extensions<a class="headerlink" href="#elf-coredump-extensions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A NT_ARM_SVE note will be added to each coredump for each thread of the
dumped process.  The contents will be equivalent to the data that would have
been read if a PTRACE_GETREGSET of NT_ARM_SVE were executed for each thread
when the coredump was generated.</p></li>
</ul>
</div>
<div class="section" id="system-runtime-configuration">
<h2>9.  System runtime configuration<a class="headerlink" href="#system-runtime-configuration" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>To mitigate the ABI impact of expansion of the signal frame, a policy
mechanism is provided for administrators, distro maintainers and developers
to set the default vector length for userspace processes:</p></li>
</ul>
<p>/proc/sys/abi/sve_default_vector_length</p>
<blockquote>
<div><p>Writing the text representation of an integer to this file sets the system
default vector length to the specified value, unless the value is greater
than the maximum vector length supported by the system in which case the
default vector length is set to that maximum.</p>
<p>The result can be determined by reopening the file and reading its
contents.</p>
<p>At boot, the default vector length is initially set to 64 or the maximum
supported vector length, whichever is smaller.  This determines the initial
vector length of the init process (PID 1).</p>
<p>Reading this file returns the current system default vector length.</p>
</div></blockquote>
<ul>
<li><p>At every execve() call, the new vector length of the new process is set to
the system default vector length, unless</p>
<blockquote>
<div><ul class="simple">
<li><p>PR_SVE_SET_VL_INHERIT (or equivalently SVE_PT_VL_INHERIT) is set for the
calling thread, or</p></li>
<li><p>a deferred vector length change is pending, established via the
PR_SVE_SET_VL_ONEXEC flag (or SVE_PT_VL_ONEXEC).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Modifying the system default vector length does not affect the vector length
of any existing process or thread that does not make an execve() call.</p></li>
</ul>
<div class="section" id="appendix-a-sve-programmer-s-model-informative">
<h3>Appendix A.  SVE programmer’s model (informative)<a class="headerlink" href="#appendix-a-sve-programmer-s-model-informative" title="Permalink to this headline">¶</a></h3>
<p>This section provides a minimal description of the additions made by SVE to the
ARMv8-A programmer’s model that are relevant to this document.</p>
<p>Note: This section is for information only and not intended to be complete or
to replace any architectural specification.</p>
</div>
</div>
<div class="section" id="a-1-registers">
<h2>A.1.  Registers<a class="headerlink" href="#a-1-registers" title="Permalink to this headline">¶</a></h2>
<p>In A64 state, SVE adds the following:</p>
<ul>
<li><p>32 8VL-bit vector registers Z0..Z31
For each Zn, Zn bits [127:0] alias the ARMv8-A vector register Vn.</p>
<p>A register write using a Vn register name zeros all bits of the corresponding
Zn except for bits [127:0].</p>
</li>
<li><p>16 VL-bit predicate registers P0..P15</p></li>
<li><p>1 VL-bit special-purpose predicate register FFR (the “first-fault register”)</p></li>
<li><p>a VL “pseudo-register” that determines the size of each vector register</p>
<p>The SVE instruction set architecture provides no way to write VL directly.
Instead, it can be modified only by EL1 and above, by writing appropriate
system registers.</p>
</li>
<li><p>The value of VL can be configured at runtime by EL1 and above:
16 &lt;= VL &lt;= VLmax, where VL must be a multiple of 16.</p></li>
<li><p>The maximum vector length is determined by the hardware:
16 &lt;= VLmax &lt;= 256.</p>
<p>(The SVE architecture specifies 256, but permits future architecture
revisions to raise this limit.)</p>
</li>
<li><p>FPSR and FPCR are retained from ARMv8-A, and interact with SVE floating-point
operations in a similar way to the way in which they interact with ARMv8
floating-point operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     8VL-1                       128               0  bit index
    +----          ////            -----------------+
 Z0 |                               :       V0      |
  :                                          :
 Z7 |                               :       V7      |
 Z8 |                               :     * V8      |
  :                                       :  :
Z15 |                               :     *V15      |
Z16 |                               :      V16      |
  :                                          :
Z31 |                               :      V31      |
    +----          ////            -----------------+
                                             31    0
     VL-1                  0                +-------+
    +----       ////      --+          FPSR |       |
 P0 |                       |               +-------+
  : |                       |         *FPCR |       |
P15 |                       |               +-------+
    +----       ////      --+
FFR |                       |               +-----+
    +----       ////      --+            VL |     |
                                            +-----+
</pre></div>
</div>
</li>
</ul>
<dl class="simple">
<dt>(*) callee-save:</dt><dd><p>This only applies to bits [63:0] of Z-/V-registers.
FPCR contains callee-save and caller-save bits.  See [4] for details.</p>
</dd>
</dl>
</div>
<div class="section" id="a-2-procedure-call-standard">
<h2>A.2.  Procedure call standard<a class="headerlink" href="#a-2-procedure-call-standard" title="Permalink to this headline">¶</a></h2>
<p>The ARMv8-A base procedure call standard is extended as follows with respect to
the additional SVE register state:</p>
<ul>
<li><p>All SVE register bits that are not shared with FP/SIMD are caller-save.</p></li>
<li><p>Z8 bits [63:0] .. Z15 bits [63:0] are callee-save.</p>
<p>This follows from the way these bits are mapped to V8..V15, which are caller-
save in the base procedure call standard.</p>
</li>
</ul>
<div class="section" id="appendix-b-armv8-a-fp-simd-programmer-s-model">
<h3>Appendix B.  ARMv8-A FP/SIMD programmer’s model<a class="headerlink" href="#appendix-b-armv8-a-fp-simd-programmer-s-model" title="Permalink to this headline">¶</a></h3>
<p>Note: This section is for information only and not intended to be complete or
to replace any architectural specification.</p>
<p>Refer to [4] for for more information.</p>
<p>ARMv8-A defines the following floating-point / SIMD register state:</p>
<ul class="simple">
<li><p>32 128-bit vector registers V0..V31</p></li>
<li><p>2 32-bit status/control registers FPSR, FPCR</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      127           0  bit index
     +---------------+
  V0 |               |
   : :               :
  V7 |               |
* V8 |               |
:  : :               :
*V15 |               |
 V16 |               |
   : :               :
 V31 |               |
     +---------------+

              31    0
             +-------+
        FPSR |       |
             +-------+
       *FPCR |       |
             +-------+
</pre></div>
</div>
<dl class="simple">
<dt>(*) callee-save:</dt><dd><p>This only applies to bits [63:0] of V-registers.
FPCR contains a mixture of callee-save and caller-save bits.</p>
</dd>
</dl>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>[1] arch/arm64/include/uapi/asm/sigcontext.h</dt><dd><p>AArch64 Linux signal ABI definitions</p>
</dd>
<dt>[2] arch/arm64/include/uapi/asm/ptrace.h</dt><dd><p>AArch64 Linux ptrace ABI definitions</p>
</dd>
</dl>
<p>[3] Documentation/arm64/cpu-feature-registers.rst</p>
<dl class="simple">
<dt>[4] ARM IHI0055C</dt><dd><p><a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055c/IHI0055C_beta_aapcs64.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055c/IHI0055C_beta_aapcs64.pdf</a>
<a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html">http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html</a>
Procedure Call Standard for the ARM 64-bit Architecture (AArch64)</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tagged-address-abi.html" class="btn btn-neutral float-right" title="AArch64 TAGGED ADDRESS ABI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="silicon-errata.html" class="btn btn-neutral float-left" title="Silicon Errata and Software Workarounds" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>