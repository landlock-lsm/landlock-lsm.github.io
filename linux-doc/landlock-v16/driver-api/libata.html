

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>libATA Developer’s Guide &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="target and iSCSI Interfaces Guide" href="target.html" />
    <link rel="prev" title="SCSI Interfaces Guide" href="scsi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">libATA Developer’s Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libata-driver-api">libata Driver API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#struct-ata-port-operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port_operations</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">Error handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#origins-of-commands">Origins of commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-commands-are-issued">How commands are issued</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-commands-are-processed">How commands are processed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-commands-are-completed">How commands are completed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ata-scsi-error"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#problems-with-the-current-eh">Problems with the current EH</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#libata-library">libata Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libata-core-internals">libata Core Internals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libata-scsi-translation-emulation">libata SCSI translation/emulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ata-errors-and-exceptions">ATA errors and exceptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exception-categories">Exception categories</a></li>
<li class="toctree-l4"><a class="reference internal" href="#eh-recovery-actions">EH recovery actions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ata-piix-internals">ata_piix Internals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sata-sil-internals">sata_sil Internals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thanks">Thanks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>libATA Developer’s Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/libata.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="libata-developer-s-guide">
<h1>libATA Developer’s Guide<a class="headerlink" href="#libata-developer-s-guide" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Jeff Garzik</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>libATA is a library used inside the Linux kernel to support ATA host
controllers and devices. libATA provides an ATA driver API, class
transports for ATA and ATAPI devices, and SCSI&lt;-&gt;ATA translation for ATA
devices according to the T10 SAT specification.</p>
<p>This Guide documents the libATA driver API, library functions, library
internals, and a couple sample ATA low-level drivers.</p>
</div>
<div class="section" id="libata-driver-api">
<h2>libata Driver API<a class="headerlink" href="#libata-driver-api" title="Permalink to this headline">¶</a></h2>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port_operations</span></code>
is defined for every low-level libata
hardware driver, and it controls how the low-level driver interfaces
with the ATA and SCSI layers.</p>
<p>FIS-based drivers will hook into the system with <code class="docutils literal notranslate"><span class="pre">-&gt;qc_prep()</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;qc_issue()</span></code> high-level hooks. Hardware which behaves in a manner
similar to PCI IDE hardware may utilize several generic helpers,
defining at a bare minimum the bus I/O addresses of the ATA shadow
register blocks.</p>
<div class="section" id="struct-ata-port-operations">
<h3><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port_operations</span></code><a class="headerlink" href="#struct-ata-port-operations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="disable-ata-port">
<h4>Disable ATA port<a class="headerlink" href="#disable-ata-port" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*port_disable) (struct ata_port *);
</pre></div>
</div>
<p>Called from <a class="reference internal" href="#c.ata_bus_probe" title="ata_bus_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bus_probe()</span></code></a> error path, as well as when unregistering
from the SCSI module (rmmod, hot unplug). This function should do
whatever needs to be done to take the port out of use. In most cases,
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_port_disable()</span></code> can be used as this hook.</p>
<p>Called from <a class="reference internal" href="#c.ata_bus_probe" title="ata_bus_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bus_probe()</span></code></a> on a failed probe. Called from
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_release()</span></code>.</p>
</div>
<div class="section" id="post-identify-device-configuration">
<h4>Post-IDENTIFY device configuration<a class="headerlink" href="#post-identify-device-configuration" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*dev_config) (struct ata_port *, struct ata_device *);
</pre></div>
</div>
<p>Called after IDENTIFY [PACKET] DEVICE is issued to each device found.
Typically used to apply device-specific fixups prior to issue of SET
FEATURES - XFER MODE, and prior to operation.</p>
<p>This entry may be specified as NULL in ata_port_operations.</p>
</div>
<div class="section" id="set-pio-dma-mode">
<h4>Set PIO/DMA mode<a class="headerlink" href="#set-pio-dma-mode" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*set_piomode) (struct ata_port *, struct ata_device *);
void (*set_dmamode) (struct ata_port *, struct ata_device *);
void (*post_set_mode) (struct ata_port *);
unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);
</pre></div>
</div>
<p>Hooks called prior to the issue of SET FEATURES - XFER MODE command. The
optional <code class="docutils literal notranslate"><span class="pre">-&gt;mode_filter()</span></code> hook is called when libata has built a mask of
the possible modes. This is passed to the <code class="docutils literal notranslate"><span class="pre">-&gt;mode_filter()</span></code> function
which should return a mask of valid modes after filtering those
unsuitable due to hardware limits. It is not valid to use this interface
to add modes.</p>
<p><code class="docutils literal notranslate"><span class="pre">dev-&gt;pio_mode</span></code> and <code class="docutils literal notranslate"><span class="pre">dev-&gt;dma_mode</span></code> are guaranteed to be valid when
<code class="docutils literal notranslate"><span class="pre">-&gt;set_piomode()</span></code> and when <code class="docutils literal notranslate"><span class="pre">-&gt;set_dmamode()</span></code> is called. The timings for
any other drive sharing the cable will also be valid at this point. That
is the library records the decisions for the modes of each drive on a
channel before it attempts to set any of them.</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;post_set_mode()</span></code> is called unconditionally, after the SET FEATURES -
XFER MODE command completes successfully.</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;set_piomode()</span></code> is always called (if present), but <code class="docutils literal notranslate"><span class="pre">-&gt;set_dma_mode()</span></code>
is only called if DMA is possible.</p>
</div>
<div class="section" id="taskfile-read-write">
<h4>Taskfile read/write<a class="headerlink" href="#taskfile-read-write" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;tf_load()</span></code> is called to load the given taskfile into hardware
registers / DMA buffers. <code class="docutils literal notranslate"><span class="pre">-&gt;tf_read()</span></code> is called to read the hardware
registers / DMA buffers, to obtain the current set of taskfile register
values. Most drivers for taskfile-based hardware (PIO or MMIO) use
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_tf_load()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_tf_read()</span></code> for these hooks.</p>
</div>
<div class="section" id="pio-data-read-write">
<h4>PIO data read/write<a class="headerlink" href="#pio-data-read-write" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
</pre></div>
</div>
<p>All bmdma-style drivers must implement this hook. This is the low-level
operation that actually copies the data bytes during a PIO data
transfer. Typically the driver will choose one of
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_data_xfer()</span></code>, or <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_data_xfer32()</span></code>.</p>
</div>
<div class="section" id="ata-command-execute">
<h4>ATA command execute<a class="headerlink" href="#ata-command-execute" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
</pre></div>
</div>
<p>causes an ATA command, previously loaded with <code class="docutils literal notranslate"><span class="pre">-&gt;tf_load()</span></code>, to be
initiated in hardware. Most drivers for taskfile-based hardware use
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_exec_command()</span></code> for this hook.</p>
</div>
<div class="section" id="per-cmd-atapi-dma-capabilities-filter">
<h4>Per-cmd ATAPI DMA capabilities filter<a class="headerlink" href="#per-cmd-atapi-dma-capabilities-filter" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*check_atapi_dma) (struct ata_queued_cmd *qc);
</pre></div>
</div>
<p>Allow low-level driver to filter ATA PACKET commands, returning a status
indicating whether or not it is OK to use DMA for the supplied PACKET
command.</p>
<p>This hook may be specified as NULL, in which case libata will assume
that atapi dma can be supported.</p>
</div>
<div class="section" id="read-specific-ata-shadow-registers">
<h4>Read specific ATA shadow registers<a class="headerlink" href="#read-specific-ata-shadow-registers" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8   (*sff_check_status)(struct ata_port *ap);
u8   (*sff_check_altstatus)(struct ata_port *ap);
</pre></div>
</div>
<p>Reads the Status/AltStatus ATA shadow register from hardware. On some
hardware, reading the Status register has the side effect of clearing
the interrupt condition. Most drivers for taskfile-based hardware use
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_check_status()</span></code> for this hook.</p>
</div>
<div class="section" id="write-specific-ata-shadow-register">
<h4>Write specific ATA shadow register<a class="headerlink" href="#write-specific-ata-shadow-register" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);
</pre></div>
</div>
<p>Write the device control ATA shadow register to the hardware. Most
drivers don’t need to define this.</p>
</div>
<div class="section" id="select-ata-device-on-bus">
<h4>Select ATA device on bus<a class="headerlink" href="#select-ata-device-on-bus" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
</pre></div>
</div>
<p>Issues the low-level hardware command(s) that causes one of N hardware
devices to be considered ‘selected’ (active and available for use) on
the ATA bus. This generally has no meaning on FIS-based devices.</p>
<p>Most drivers for taskfile-based hardware use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_dev_select()</span></code> for
this hook.</p>
</div>
<div class="section" id="private-tuning-method">
<h4>Private tuning method<a class="headerlink" href="#private-tuning-method" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*set_mode) (struct ata_port *ap);
</pre></div>
</div>
<p>By default libata performs drive and controller tuning in accordance
with the ATA timing rules and also applies blacklists and cable limits.
Some controllers need special handling and have custom tuning rules,
typically raid controllers that use ATA commands but do not actually do
drive timing.</p>
<blockquote>
<div><p><strong>Warning</strong></p>
<p>This hook should not be used to replace the standard controller
tuning logic when a controller has quirks. Replacing the default
tuning logic in that case would bypass handling for drive and bridge
quirks that may be important to data reliability. If a controller
needs to filter the mode selection it should use the mode_filter
hook instead.</p>
</div></blockquote>
</div>
<div class="section" id="control-pci-ide-bmdma-engine">
<h4>Control PCI IDE BMDMA engine<a class="headerlink" href="#control-pci-ide-bmdma-engine" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*bmdma_setup) (struct ata_queued_cmd *qc);
void (*bmdma_start) (struct ata_queued_cmd *qc);
void (*bmdma_stop) (struct ata_port *ap);
u8   (*bmdma_status) (struct ata_port *ap);
</pre></div>
</div>
<p>When setting up an IDE BMDMA transaction, these hooks arm
(<code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_setup</span></code>), fire (<code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_start</span></code>), and halt (<code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_stop</span></code>) the
hardware’s DMA engine. <code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_status</span></code> is used to read the standard PCI
IDE DMA Status register.</p>
<p>These hooks are typically either no-ops, or simply not implemented, in
FIS-based drivers.</p>
<p>Most legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_setup()</span></code> for the
<code class="xref c c-func docutils literal notranslate"><span class="pre">bmdma_setup()</span></code> hook. <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_setup()</span></code> will write the pointer
to the PRD table to the IDE PRD Table Address register, enable DMA in the DMA
Command register, and call <code class="xref c c-func docutils literal notranslate"><span class="pre">exec_command()</span></code> to begin the transfer.</p>
<p>Most legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_start()</span></code> for the
<code class="xref c c-func docutils literal notranslate"><span class="pre">bmdma_start()</span></code> hook. <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_start()</span></code> will write the
ATA_DMA_START flag to the DMA Command register.</p>
<p>Many legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_stop()</span></code> for the
<code class="xref c c-func docutils literal notranslate"><span class="pre">bmdma_stop()</span></code> hook. <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_stop()</span></code> clears the ATA_DMA_START
flag in the DMA command register.</p>
<p>Many legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_status()</span></code> as the
<code class="xref c c-func docutils literal notranslate"><span class="pre">bmdma_status()</span></code> hook.</p>
</div>
<div class="section" id="high-level-taskfile-hooks">
<h4>High-level taskfile hooks<a class="headerlink" href="#high-level-taskfile-hooks" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum ata_completion_errors (*qc_prep) (struct ata_queued_cmd *qc);
int (*qc_issue) (struct ata_queued_cmd *qc);
</pre></div>
</div>
<p>Higher-level hooks, these two hooks can potentially supersede several of
the above taskfile/DMA engine hooks. <code class="docutils literal notranslate"><span class="pre">-&gt;qc_prep</span></code> is called after the
buffers have been DMA-mapped, and is typically used to populate the
hardware’s DMA scatter-gather table. Some drivers use the standard
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_qc_prep()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_dumb_qc_prep()</span></code> helper
functions, but more advanced drivers roll their own.</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;qc_issue</span></code> is used to make a command active, once the hardware and S/G
tables have been prepared. IDE BMDMA drivers use the helper function
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_qc_issue()</span></code> for taskfile protocol-based dispatch. More
advanced drivers implement their own <code class="docutils literal notranslate"><span class="pre">-&gt;qc_issue</span></code>.</p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_qc_issue()</span></code> calls <code class="docutils literal notranslate"><span class="pre">-&gt;sff_tf_load()</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_setup()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">-&gt;bmdma_start()</span></code> as necessary to initiate a transfer.</p>
</div>
<div class="section" id="exception-and-probe-handling-eh">
<h4>Exception and probe handling (EH)<a class="headerlink" href="#exception-and-probe-handling-eh" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*eng_timeout) (struct ata_port *ap);
void (*phy_reset) (struct ata_port *ap);
</pre></div>
</div>
<p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">-&gt;error_handler()</span></code> instead.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*freeze) (struct ata_port *ap);
void (*thaw) (struct ata_port *ap);
</pre></div>
</div>
<p><a class="reference internal" href="#c.ata_port_freeze" title="ata_port_freeze"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_port_freeze()</span></code></a> is called when HSM violations or some other
condition disrupts normal operation of the port. A frozen port is not
allowed to perform any operation until the port is thawed, which usually
follows a successful reset.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">-&gt;freeze()</span></code> callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine). If a port
cannot be frozen hardware-wise, the interrupt handler must ack and clear
interrupts unconditionally while the port is frozen.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">-&gt;thaw()</span></code> callback is called to perform the opposite of
<code class="docutils literal notranslate"><span class="pre">-&gt;freeze()</span></code>: prepare the port for normal operation once again. Unmask
interrupts, start DMA engine, etc.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*error_handler) (struct ata_port *ap);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;error_handler()</span></code> is a driver’s hook into probe, hotplug, and recovery
and other exceptional conditions. The primary responsibility of an
implementation is to call <a class="reference internal" href="#c.ata_do_eh" title="ata_do_eh"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_do_eh()</span></code></a> or <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_bmdma_drive_eh()</span></code>
with a set of EH hooks as arguments:</p>
<p>‘prereset’ hook (may be NULL) is called during an EH reset, before any
other actions are taken.</p>
<p>‘postreset’ hook (may be NULL) is called after the EH reset is
performed. Based on existing conditions, severity of the problem, and
hardware capabilities,</p>
<p>Either ‘softreset’ (may be NULL) or ‘hardreset’ (may be NULL) will be
called to perform the low-level EH reset.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*post_internal_cmd) (struct ata_queued_cmd *qc);
</pre></div>
</div>
<p>Perform any hardware-specific actions necessary to finish processing
after executing a probe-time or EH-time command via
<a class="reference internal" href="#c.ata_exec_internal" title="ata_exec_internal"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_exec_internal()</span></code></a>.</p>
</div>
<div class="section" id="hardware-interrupt-handling">
<h4>Hardware interrupt handling<a class="headerlink" href="#hardware-interrupt-handling" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
void (*irq_clear) (struct ata_port *);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;irq_handler</span></code> is the interrupt handling routine registered with the
system, by libata. <code class="docutils literal notranslate"><span class="pre">-&gt;irq_clear</span></code> is called during probe just before the
interrupt handler is registered, to be sure hardware is quiet.</p>
<p>The second argument, dev_instance, should be cast to a pointer to
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host_set</span></code>.</p>
<p>Most legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_interrupt()</span></code> for the irq_handler
hook, which scans all ports in the host_set, determines which queued
command was active (if any), and calls ata_sff_host_intr(ap,qc).</p>
<p>Most legacy IDE drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_sff_irq_clear()</span></code> for the
<code class="xref c c-func docutils literal notranslate"><span class="pre">irq_clear()</span></code> hook, which simply clears the interrupt and error flags
in the DMA status register.</p>
</div>
<div class="section" id="sata-phy-read-write">
<h4>SATA phy read/write<a class="headerlink" href="#sata-phy-read-write" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,
         u32 *val);
int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
                   u32 val);
</pre></div>
</div>
<p>Read and write standard SATA phy registers. Currently only used if
<code class="docutils literal notranslate"><span class="pre">-&gt;phy_reset</span></code> hook called the <code class="xref c c-func docutils literal notranslate"><span class="pre">sata_phy_reset()</span></code> helper function.
sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.</p>
</div>
<div class="section" id="init-and-shutdown">
<h4>Init and shutdown<a class="headerlink" href="#init-and-shutdown" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*port_start) (struct ata_port *ap);
void (*port_stop) (struct ata_port *ap);
void (*host_stop) (struct ata_host_set *host_set);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;port_start()</span></code> is called just after the data structures for each port
are initialized. Typically this is used to alloc per-port DMA buffers /
tables / rings, enable DMA engines, and similar tasks. Some drivers also
use this entry point as a chance to allocate driver-private memory for
<code class="docutils literal notranslate"><span class="pre">ap-&gt;private_data</span></code>.</p>
<p>Many drivers use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_port_start()</span></code> as this hook or call it from their
own <code class="xref c c-func docutils literal notranslate"><span class="pre">port_start()</span></code> hooks. <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_port_start()</span></code> allocates space for
a legacy IDE PRD table and returns.</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;port_stop()</span></code> is called after <code class="docutils literal notranslate"><span class="pre">-&gt;host_stop()</span></code>. Its sole function is to
release DMA/memory resources, now that they are no longer actively being
used. Many drivers also free driver-private data from port at this time.</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;host_stop()</span></code> is called after all <code class="docutils literal notranslate"><span class="pre">-&gt;port_stop()</span></code> calls have completed.
The hook must finalize hardware shutdown, release DMA and other
resources, etc. This hook may be specified as NULL, in which case it is
not called.</p>
</div>
</div>
</div>
<div class="section" id="error-handling">
<h2>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes how errors are handled under libata. Readers are
advised to read SCSI EH (Documentation/scsi/scsi_eh.rst) and ATA
exceptions doc first.</p>
<div class="section" id="origins-of-commands">
<h3>Origins of commands<a class="headerlink" href="#origins-of-commands" title="Permalink to this headline">¶</a></h3>
<p>In libata, a command is represented with
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span></code> or qc.
qc’s are preallocated during port initialization and repetitively used
for command executions. Currently only one qc is allocated per port but
yet-to-be-merged NCQ branch allocates one for each tag and maps each qc
to NCQ tag 1-to-1.</p>
<p>libata commands can originate from two sources - libata itself and SCSI
midlayer. libata internal commands are used for initialization and error
handling. All normal blk requests and commands for SCSI emulation are
passed as SCSI commands through queuecommand callback of SCSI host
template.</p>
</div>
<div class="section" id="how-commands-are-issued">
<h3>How commands are issued<a class="headerlink" href="#how-commands-are-issued" title="Permalink to this headline">¶</a></h3>
<dl>
<dt>Internal commands</dt><dd><p>First, qc is allocated and initialized using <a class="reference internal" href="#c.ata_qc_new_init" title="ata_qc_new_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_new_init()</span></code></a>.
Although <a class="reference internal" href="#c.ata_qc_new_init" title="ata_qc_new_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_new_init()</span></code></a> doesn’t implement any wait or retry
mechanism when qc is not available, internal commands are currently
issued only during initialization and error recovery, so no other
command is active and allocation is guaranteed to succeed.</p>
<p>Once allocated qc’s taskfile is initialized for the command to be
executed. qc currently has two mechanisms to notify completion. One
is via <code class="docutils literal notranslate"><span class="pre">qc-&gt;complete_fn()</span></code> callback and the other is completion
<code class="docutils literal notranslate"><span class="pre">qc-&gt;waiting</span></code>. <code class="docutils literal notranslate"><span class="pre">qc-&gt;complete_fn()</span></code> callback is the asynchronous path
used by normal SCSI translated commands and <code class="docutils literal notranslate"><span class="pre">qc-&gt;waiting</span></code> is the
synchronous (issuer sleeps in process context) path used by internal
commands.</p>
<p>Once initialization is complete, host_set lock is acquired and the
qc is issued.</p>
</dd>
<dt>SCSI commands</dt><dd><p>All libata drivers use <a class="reference internal" href="#c.ata_scsi_queuecmd" title="ata_scsi_queuecmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_queuecmd()</span></code></a> as
<code class="docutils literal notranslate"><span class="pre">hostt-&gt;queuecommand</span></code> callback. scmds can either be simulated or
translated. No qc is involved in processing a simulated scmd. The
result is computed right away and the scmd is completed.</p>
<p>For a translated scmd, <a class="reference internal" href="#c.ata_qc_new_init" title="ata_qc_new_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_new_init()</span></code></a> is invoked to allocate a
qc and the scmd is translated into the qc. SCSI midlayer’s
completion notification function pointer is stored into
<code class="docutils literal notranslate"><span class="pre">qc-&gt;scsidone</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">qc-&gt;complete_fn()</span></code> callback is used for completion notification. ATA
commands use <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_qc_complete()</span></code> while ATAPI commands use
<code class="xref c c-func docutils literal notranslate"><span class="pre">atapi_qc_complete()</span></code>. Both functions end up calling <code class="docutils literal notranslate"><span class="pre">qc-&gt;scsidone</span></code>
to notify upper layer when the qc is finished. After translation is
completed, the qc is issued with <a class="reference internal" href="#c.ata_qc_issue" title="ata_qc_issue"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_issue()</span></code></a>.</p>
<p>Note that SCSI midlayer invokes hostt-&gt;queuecommand while holding
host_set lock, so all above occur while holding host_set lock.</p>
</dd>
</dl>
</div>
<div class="section" id="how-commands-are-processed">
<h3>How commands are processed<a class="headerlink" href="#how-commands-are-processed" title="Permalink to this headline">¶</a></h3>
<p>Depending on which protocol and which controller are used, commands are
processed differently. For the purpose of discussion, a controller which
uses taskfile interface and all standard callbacks is assumed.</p>
<p>Currently 6 ATA command protocols are used. They can be sorted into the
following four categories according to how they are processed.</p>
<dl class="simple">
<dt>ATA NO DATA or DMA</dt><dd><p>ATA_PROT_NODATA and ATA_PROT_DMA fall into this category. These
types of commands don’t require any software intervention once
issued. Device will raise interrupt on completion.</p>
</dd>
<dt>ATA PIO</dt><dd><p>ATA_PROT_PIO is in this category. libata currently implements PIO
with polling. ATA_NIEN bit is set to turn off interrupt and
pio_task on ata_wq performs polling and IO.</p>
</dd>
<dt>ATAPI NODATA or DMA</dt><dd><p>ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this
category. packet_task is used to poll BSY bit after issuing PACKET
command. Once BSY is turned off by the device, packet_task
transfers CDB and hands off processing to interrupt handler.</p>
</dd>
<dt>ATAPI PIO</dt><dd><p>ATA_PROT_ATAPI is in this category. ATA_NIEN bit is set and, as
in ATAPI NODATA or DMA, packet_task submits cdb. However, after
submitting cdb, further processing (data transfer) is handed off to
pio_task.</p>
</dd>
</dl>
</div>
<div class="section" id="how-commands-are-completed">
<h3>How commands are completed<a class="headerlink" href="#how-commands-are-completed" title="Permalink to this headline">¶</a></h3>
<p>Once issued, all qc’s are either completed with <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a> or
time out. For commands which are handled by interrupts,
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_host_intr()</span></code> invokes <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a>, and, for PIO tasks,
pio_task invokes <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a>. In error cases, packet_task may
also complete commands.</p>
<p><a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a> does the following.</p>
<ol class="arabic simple">
<li><p>DMA memory is unmapped.</p></li>
<li><p>ATA_QCFLAG_ACTIVE is cleared from qc-&gt;flags.</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">qc-&gt;complete_fn()</span></code> callback is invoked. If the return value of the
callback is not zero. Completion is short circuited and
<a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a> returns.</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">__ata_qc_complete()</span></code> is called, which does</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qc-&gt;flags</span></code> is cleared to zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ap-&gt;active_tag</span></code> and <code class="docutils literal notranslate"><span class="pre">qc-&gt;tag</span></code> are poisoned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qc-&gt;waiting</span></code> is cleared &amp; completed (in that order).</p></li>
<li><p>qc is deallocated by clearing appropriate bit in <code class="docutils literal notranslate"><span class="pre">ap-&gt;qactive</span></code>.</p></li>
</ol>
</li>
</ol>
<p>So, it basically notifies upper layer and deallocates qc. One exception
is short-circuit path in #3 which is used by <code class="xref c c-func docutils literal notranslate"><span class="pre">atapi_qc_complete()</span></code>.</p>
<p>For all non-ATAPI commands, whether it fails or not, almost the same
code path is taken and very little error handling takes place. A qc is
completed with success status if it succeeded, with failed status
otherwise.</p>
<p>However, failed ATAPI commands require more handling as REQUEST SENSE is
needed to acquire sense data. If an ATAPI command fails,
<a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a> is invoked with error status, which in turn invokes
<code class="xref c c-func docutils literal notranslate"><span class="pre">atapi_qc_complete()</span></code> via <code class="docutils literal notranslate"><span class="pre">qc-&gt;complete_fn()</span></code> callback.</p>
<p>This makes <code class="xref c c-func docutils literal notranslate"><span class="pre">atapi_qc_complete()</span></code> set <code class="docutils literal notranslate"><span class="pre">scmd-&gt;result</span></code> to
SAM_STAT_CHECK_CONDITION, complete the scmd and return 1. As the
sense data is empty but <code class="docutils literal notranslate"><span class="pre">scmd-&gt;result</span></code> is CHECK CONDITION, SCSI midlayer
will invoke EH for the scmd, and returning 1 makes <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a>
to return without deallocating the qc. This leads us to
<a class="reference internal" href="#c.ata_scsi_error" title="ata_scsi_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_error()</span></code></a> with partially completed qc.</p>
</div>
<div class="section" id="ata-scsi-error">
<h3><a class="reference internal" href="#c.ata_scsi_error" title="ata_scsi_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_error()</span></code></a><a class="headerlink" href="#ata-scsi-error" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#c.ata_scsi_error" title="ata_scsi_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_error()</span></code></a> is the current <code class="docutils literal notranslate"><span class="pre">transportt-&gt;eh_strategy_handler()</span></code>
for libata. As discussed above, this will be entered in two cases -
timeout and ATAPI error completion. This function calls low level libata
driver’s <code class="xref c c-func docutils literal notranslate"><span class="pre">eng_timeout()</span></code> callback, the standard callback for which is
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_eng_timeout()</span></code>. It checks if a qc is active and calls
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_timeout()</span></code> on the qc if so. Actual error handling occurs in
<code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_timeout()</span></code>.</p>
<p>If EH is invoked for timeout, <code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_timeout()</span></code> stops BMDMA and
completes the qc. Note that as we’re currently in EH, we cannot call
scsi_done. As described in SCSI EH doc, a recovered scmd should be
either retried with <code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_queue_insert()</span></code> or finished with
<code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_finish_command()</span></code>. Here, we override <code class="docutils literal notranslate"><span class="pre">qc-&gt;scsidone</span></code> with
<code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_finish_command()</span></code> and calls <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a>.</p>
<p>If EH is invoked due to a failed ATAPI qc, the qc here is completed but
not deallocated. The purpose of this half-completion is to use the qc as
place holder to make EH code reach this place. This is a bit hackish,
but it works.</p>
<p>Once control reaches here, the qc is deallocated by invoking
<code class="xref c c-func docutils literal notranslate"><span class="pre">__ata_qc_complete()</span></code> explicitly. Then, internal qc for REQUEST SENSE
is issued. Once sense data is acquired, scmd is finished by directly
invoking <code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_finish_command()</span></code> on the scmd. Note that as we already
have completed and deallocated the qc which was associated with the
scmd, we don’t need to/cannot call <a class="reference internal" href="#c.ata_qc_complete" title="ata_qc_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_qc_complete()</span></code></a> again.</p>
</div>
<div class="section" id="problems-with-the-current-eh">
<h3>Problems with the current EH<a class="headerlink" href="#problems-with-the-current-eh" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Error representation is too crude. Currently any and all error
conditions are represented with ATA STATUS and ERROR registers.
Errors which aren’t ATA device errors are treated as ATA device
errors by setting ATA_ERR bit. Better error descriptor which can
properly represent ATA and other errors/exceptions is needed.</p></li>
<li><p>When handling timeouts, no action is taken to make device forget
about the timed out command and ready for new commands.</p></li>
<li><p>EH handling via <a class="reference internal" href="#c.ata_scsi_error" title="ata_scsi_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_error()</span></code></a> is not properly protected from
usual command processing. On EH entrance, the device is not in
quiescent state. Timed out commands may succeed or fail any time.
pio_task and atapi_task may still be running.</p></li>
<li><p>Too weak error recovery. Devices / controllers causing HSM mismatch
errors and other errors quite often require reset to return to known
state. Also, advanced error handling is necessary to support features
like NCQ and hotplug.</p></li>
<li><p>ATA errors are directly handled in the interrupt handler and PIO
errors in pio_task. This is problematic for advanced error handling
for the following reasons.</p>
<p>First, advanced error handling often requires context and internal qc
execution.</p>
<p>Second, even a simple failure (say, CRC error) needs information
gathering and could trigger complex error handling (say, resetting &amp;
reconfiguring). Having multiple code paths to gather information,
enter EH and trigger actions makes life painful.</p>
<p>Third, scattered EH code makes implementing low level drivers
difficult. Low level drivers override libata callbacks. If EH is
scattered over several places, each affected callbacks should perform
its part of error handling. This can be error prone and painful.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="libata-library">
<h2>libata Library<a class="headerlink" href="#libata-library" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ata_link_next">
struct ata_link * <code class="sig-name descname">ata_link_next</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_port *<em> ap</em>, enum ata_link_iter_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_link_next" title="Permalink to this definition">¶</a></dt>
<dd><p>link iteration helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>the previous link, NULL to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port containing links to iterate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ata_link_iter_mode</span> <span class="pre">mode</span></code></dt><dd><p>iteration mode, one of ATA_LITER_*</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Host lock or EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to the next link.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_next">
struct ata_device * <code class="sig-name descname">ata_dev_next</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct ata_link *<em> link</em>, enum ata_dev_iter_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_next" title="Permalink to this definition">¶</a></dt>
<dd><p>device iteration helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the previous device, NULL to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link containing devices to iterate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ata_dev_iter_mode</span> <span class="pre">mode</span></code></dt><dd><p>iteration mode, one of ATA_DITER_*</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Host lock or EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to the next device.</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_cmd_type">
int <code class="sig-name descname">atapi_cmd_type</code><span class="sig-paren">(</span>u8<em> opcode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_cmd_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine ATAPI command type from SCSI opcode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">opcode</span></code></dt><dd><p>SCSI opcode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Determine ATAPI command type from <strong>opcode</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_pack_xfermask">
unsigned long <code class="sig-name descname">ata_pack_xfermask</code><span class="sig-paren">(</span>unsigned long<em> pio_mask</em>, unsigned long<em> mwdma_mask</em>, unsigned long<em> udma_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_pack_xfermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack pio, mwdma and udma masks into xfer_mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pio_mask</span></code></dt><dd><p>pio_mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mwdma_mask</span></code></dt><dd><p>mwdma_mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">udma_mask</span></code></dt><dd><p>udma_mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Pack <strong>pio_mask</strong>, <strong>mwdma_mask</strong> and <strong>udma_mask</strong> into a single
unsigned int xfer_mask.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Packed xfer_mask.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_xfer_mask2mode">
u8 <code class="sig-name descname">ata_xfer_mask2mode</code><span class="sig-paren">(</span>unsigned long<em> xfer_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_xfer_mask2mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matching XFER_* for the given xfer_mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">xfer_mask</span></code></dt><dd><p>xfer_mask of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return matching XFER_* value for <strong>xfer_mask</strong>.  Only the highest
bit of <strong>xfer_mask</strong> is considered.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Matching XFER_* value, 0xff if no match found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_xfer_mode2mask">
unsigned long <code class="sig-name descname">ata_xfer_mode2mask</code><span class="sig-paren">(</span>u8<em> xfer_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_xfer_mode2mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matching xfer_mask for XFER_*</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">xfer_mode</span></code></dt><dd><p>XFER_* of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return matching xfer_mask for <strong>xfer_mode</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Matching xfer_mask, 0 if no match found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_xfer_mode2shift">
int <code class="sig-name descname">ata_xfer_mode2shift</code><span class="sig-paren">(</span>unsigned long<em> xfer_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_xfer_mode2shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Find matching xfer_shift for XFER_*</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">xfer_mode</span></code></dt><dd><p>XFER_* of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return matching xfer_shift for <strong>xfer_mode</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Matching xfer_shift, -1 if no match found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_mode_string">
const char * <code class="sig-name descname">ata_mode_string</code><span class="sig-paren">(</span>unsigned long<em> xfer_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_mode_string" title="Permalink to this definition">¶</a></dt>
<dd><p>convert xfer_mask to string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">xfer_mask</span></code></dt><dd><p>mask of bits supported; only highest bit counts.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Determine string which represents the highest speed
(highest bit in <strong>modemask</strong>).</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Constant C string representing highest speed listed in
<strong>mode_mask</strong>, or the constant C string “&lt;n/a&gt;”.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_classify">
unsigned int <code class="sig-name descname">ata_dev_classify</code><span class="sig-paren">(</span>const struct ata_taskfile *<em> tf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_classify" title="Permalink to this definition">¶</a></dt>
<dd><p>determine device type based on ATA-spec signature</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>ATA taskfile register set for device to be identified</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Determine from taskfile register contents whether a device is
ATA or ATAPI, as per “Signature and persistence” section
of ATA/PI spec (volume 1, sect 5.14).</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Device type, <code class="docutils literal notranslate"><span class="pre">ATA_DEV_ATA</span></code>, <code class="docutils literal notranslate"><span class="pre">ATA_DEV_ATAPI</span></code>, <code class="docutils literal notranslate"><span class="pre">ATA_DEV_PMP</span></code>,
<code class="docutils literal notranslate"><span class="pre">ATA_DEV_ZAC</span></code>, or <code class="docutils literal notranslate"><span class="pre">ATA_DEV_UNKNOWN</span></code> the event of failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_id_string">
void <code class="sig-name descname">ata_id_string</code><span class="sig-paren">(</span>const u16 *<em> id</em>, unsigned char *<em> s</em>, unsigned int<em> ofs</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_id_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert IDENTIFY DEVICE page into string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>IDENTIFY DEVICE results we will examine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>string into which data is output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>offset into identify device page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of string to return. must be an even number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The strings in the IDENTIFY DEVICE page are broken up into
16-bit chunks.  Run through the string, and output each
8-bit chunk linearly, regardless of platform.</p>
<p>LOCKING:
caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_id_c_string">
void <code class="sig-name descname">ata_id_c_string</code><span class="sig-paren">(</span>const u16 *<em> id</em>, unsigned char *<em> s</em>, unsigned int<em> ofs</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_id_c_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert IDENTIFY DEVICE page into C string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>IDENTIFY DEVICE results we will examine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt><dd><p>string into which data is output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>offset into identify device page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of string to return. must be an odd number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is identical to ata_id_string except that it
trims trailing spaces and terminates the resulting string with
null.  <strong>len</strong> must be actual maximum length (even number) + 1.</p>
<p>LOCKING:
caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_id_xfermask">
unsigned long <code class="sig-name descname">ata_id_xfermask</code><span class="sig-paren">(</span>const u16 *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_id_xfermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute xfermask from the given IDENTIFY data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>IDENTIFY data to compute xfer mask from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Compute the xfermask for this device. This is not as trivial
as it seems if we must consider early devices correctly.</p>
<p>FIXME: pre IDE drive timing (do we care ?).</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Computed xfermask</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_pio_need_iordy">
unsigned int <code class="sig-name descname">ata_pio_need_iordy</code><span class="sig-paren">(</span>const struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_pio_need_iordy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if iordy needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>ATA device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if the current speed of the device requires IORDY. Used
by various controllers for chip configuration.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_do_dev_read_id">
unsigned int <code class="sig-name descname">ata_do_dev_read_id</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct ata_taskfile *<em> tf</em>, u16 *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_do_dev_read_id" title="Permalink to this definition">¶</a></dt>
<dd><p>default ID read method</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>proposed taskfile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>data buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue the identify taskfile and hand back the buffer containing
identify data. For some RAID controllers and for pre ATA devices
this function is wrapped or replaced by the driver</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cable_40wire">
int <code class="sig-name descname">ata_cable_40wire</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cable_40wire" title="Permalink to this definition">¶</a></dt>
<dd><p>return 40 wire cable type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Helper method for drivers which want to hardwire 40 wire cable
detection.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cable_80wire">
int <code class="sig-name descname">ata_cable_80wire</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cable_80wire" title="Permalink to this definition">¶</a></dt>
<dd><p>return 80 wire cable type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Helper method for drivers which want to hardwire 80 wire cable
detection.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cable_unknown">
int <code class="sig-name descname">ata_cable_unknown</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cable_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>return unknown PATA cable.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Helper method for drivers which have no PATA cable detection.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cable_ignore">
int <code class="sig-name descname">ata_cable_ignore</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cable_ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>return ignored PATA cable.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Helper method for drivers which don’t use cable type to limit
transfer mode.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cable_sata">
int <code class="sig-name descname">ata_cable_sata</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cable_sata" title="Permalink to this definition">¶</a></dt>
<dd><p>return SATA cable type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Helper method for drivers which have SATA cables</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_pair">
struct ata_device * <code class="sig-name descname">ata_dev_pair</code><span class="sig-paren">(</span>struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>return other device on cable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Obtain the other device on the same cable, or if none is
present NULL is returned</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_do_set_mode">
int <code class="sig-name descname">ata_do_set_mode</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_device **<em> r_failed_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_do_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Program timings and issue SET FEATURES - XFER</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link on which timings will be programmed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">**</span> <span class="pre">r_failed_dev</span></code></dt><dd><p>out parameter for failed device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Standard implementation of the function used to tune and set
ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
ata_dev_set_mode() fails, pointer to the failing device is
returned in <strong>r_failed_dev</strong>.</p>
<p>LOCKING:
PCI/etc. bus probe sem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_wait_after_reset">
int <code class="sig-name descname">ata_wait_after_reset</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned long<em> deadline</em>, int (*check_ready) (struct ata_link<em> *link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_wait_after_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for link to become ready after reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link to be waited on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">deadline</span></code></dt><dd><p>deadline jiffies for the operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">ata_link</span> <span class="pre">*link)</span> <span class="pre">check_ready</span></code></dt><dd><p>callback to check link readiness</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wait for <strong>link</strong> to become ready after reset.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 if <strong>link</strong> is ready before <strong>deadline</strong>; otherwise, -errno.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_prereset">
int <code class="sig-name descname">ata_std_prereset</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned long<em> deadline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_prereset" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to be reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">deadline</span></code></dt><dd><p>deadline jiffies for the operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>link</strong> is about to be reset.  Initialize it.  Failure from
prereset makes libata abort whole reset sequence and give up
that port, so prereset should be best-effort.  It does its
best to prepare for reset sequence but if things go wrong, it
should just whine, not fail.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sata_std_hardreset">
int <code class="sig-name descname">sata_std_hardreset</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned int *<em> class</em>, unsigned long<em> deadline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sata_std_hardreset" title="Permalink to this definition">¶</a></dt>
<dd><p>COMRESET w/o waiting or classification</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link to reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">class</span></code></dt><dd><p>resulting class of attached device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">deadline</span></code></dt><dd><p>deadline jiffies for the operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Standard SATA COMRESET w/o waiting or classification.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 if link offline, -EAGAIN if link online, -errno on errors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_postreset">
void <code class="sig-name descname">ata_std_postreset</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned int *<em> classes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_postreset" title="Permalink to this definition">¶</a></dt>
<dd><p>standard postreset callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>the target ata_link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">classes</span></code></dt><dd><p>classes of attached devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is invoked after a successful reset.  Note that
the device might have been reset more than once using
different reset methods before postreset is invoked.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_set_feature">
unsigned int <code class="sig-name descname">ata_dev_set_feature</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8<em> enable</em>, u8<em> feature</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_set_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue SET FEATURES - SATA FEATURES</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to which command will be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">enable</span></code></dt><dd><p>Whether to enable or disable the feature</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">feature</span></code></dt><dd><p>The sector count represents the feature to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue SET FEATURES - SATA FEATURES command to device <strong>dev</strong>
on port <strong>ap</strong> with sector count</p>
<p>LOCKING:
PCI/etc. bus probe sem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_qc_defer">
int <code class="sig-name descname">ata_std_qc_defer</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_qc_defer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a qc needs to be deferred</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>ATA command in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Non-NCQ commands cannot run with any other command, NCQ or
not.  As upper layer only knows the queue depth, we are
responsible for maintaining exclusion.  This function checks
whether a new command <strong>qc</strong> can be issued.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>ATA_DEFER_* if deferring is needed, 0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_complete">
void <code class="sig-name descname">ata_qc_complete</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete an active ATA command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to complete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Indicate to the mid and upper layers that an ATA command has
completed, with either an ok or not-ok status.</p>
<p>Refrain from calling this function multiple times when
successfully completing multiple NCQ commands.
ata_qc_complete_multiple() should be used instead, which will
properly update IRQ expect state.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_get_active">
u64 <code class="sig-name descname">ata_qc_get_active</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_get_active" title="Permalink to this definition">¶</a></dt>
<dd><p>get bitmask of active qcs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Bitmask of active qcs</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_link_online">
bool <code class="sig-name descname">ata_link_online</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_link_online" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the given link is online</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test whether <strong>link</strong> is online.  This is identical to
<a class="reference internal" href="#c.ata_phys_link_online" title="ata_phys_link_online"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_phys_link_online()</span></code></a> when there’s no slave link.  When
there’s a slave link, this function should only be called on
the master link and will return true if any of M/S links is
online.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if the port online status is available and online.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_link_offline">
bool <code class="sig-name descname">ata_link_offline</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_link_offline" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the given link is offline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test whether <strong>link</strong> is offline.  This is identical to
<a class="reference internal" href="#c.ata_phys_link_offline" title="ata_phys_link_offline"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_phys_link_offline()</span></code></a> when there’s no slave link.  When
there’s a slave link, this function should only be called on
the master link and will return true if both M/S links are
offline.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if the port offline status is available and offline.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_suspend">
int <code class="sig-name descname">ata_host_suspend</code><span class="sig-paren">(</span>struct ata_host *<em> host</em>, pm_message_t<em> mesg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>host to suspend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_message_t</span> <span class="pre">mesg</span></code></dt><dd><p>PM message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Suspend <strong>host</strong>.  Actual operation is performed by port suspend.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_resume">
void <code class="sig-name descname">ata_host_resume</code><span class="sig-paren">(</span>struct ata_host *<em> host</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>resume host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>host to resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Resume <strong>host</strong>.  Actual operation is performed by port resume.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_alloc">
struct ata_host * <code class="sig-name descname">ata_host_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, int<em> max_ports</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and init basic ATA host resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>generic device this host is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_ports</span></code></dt><dd><p>maximum number of ATA ports associated with this host</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate and initialize basic ATA host resources.  LLD calls
this function to allocate a host, initializes it fully and
attaches it using <a class="reference internal" href="#c.ata_host_register" title="ata_host_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_host_register()</span></code></a>.</p>
<p><strong>max_ports</strong> ports are allocated and host-&gt;n_ports is
initialized to <strong>max_ports</strong>.  The caller is allowed to decrease
host-&gt;n_ports before calling <a class="reference internal" href="#c.ata_host_register" title="ata_host_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_host_register()</span></code></a>.  The unused
ports will be automatically freed on registration.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Allocate ATA host on success, NULL on failure.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_alloc_pinfo">
struct ata_host * <code class="sig-name descname">ata_host_alloc_pinfo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, const struct ata_port_info *const *<em> ppi</em>, int<em> n_ports</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_alloc_pinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>alloc host and init with port_info array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>generic device this host is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_port_info</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">ppi</span></code></dt><dd><p>array of ATA port_info to initialize host with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n_ports</span></code></dt><dd><p>number of ATA ports attached to this host</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate ATA host and initialize with info from <strong>ppi</strong>.  If NULL
terminated, <strong>ppi</strong> may contain fewer entries than <strong>n_ports</strong>.  The
last entry will be used for the remaining ports.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Allocate ATA host on success, NULL on failure.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_start">
int <code class="sig-name descname">ata_host_start</code><span class="sig-paren">(</span>struct ata_host *<em> host</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start and freeze ports of an ATA host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>ATA host to start ports for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Start and then freeze ports of <strong>host</strong>.  Started status is
recorded in host-&gt;flags, so this function can be called
multiple times.  Ports are guaranteed to get started only
once.  If host-&gt;ops isn’t initialized yet, its set to the
first non-dummy port ops.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 if all ports are started successfully, -errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_init">
void <code class="sig-name descname">ata_host_init</code><span class="sig-paren">(</span>struct ata_host *<em> host</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct ata_port_operations *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a host struct for sas (ipr, libsas)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>host to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device host is attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port_operations</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>port_ops</p>
</dd>
</dl>
<dl class="function">
<dt id="c.ata_host_register">
int <code class="sig-name descname">ata_host_register</code><span class="sig-paren">(</span>struct ata_host *<em> host</em>, struct scsi_host_template *<em> sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register initialized ATA host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>ATA host to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt><dd><p>template for SCSI host</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Register initialized ATA host.  <strong>host</strong> is allocated using
<a class="reference internal" href="#c.ata_host_alloc" title="ata_host_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_host_alloc()</span></code></a> and fully initialized by LLD.  This function
starts ports, registers <strong>host</strong> with ATA and SCSI layers and
probe registered devices.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_activate">
int <code class="sig-name descname">ata_host_activate</code><span class="sig-paren">(</span>struct ata_host *<em> host</em>, int<em> irq</em>, irq_handler_t<em> irq_handler</em>, unsigned long<em> irq_flags</em>, struct scsi_host_template *<em> sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>start host, request IRQ and register it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>target ATA host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>IRQ to request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">irq_handler</span></code></dt><dd><p>irq_handler used when requesting IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irq_flags</span></code></dt><dd><p>irq_flags used when requesting IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt><dd><p>scsi_host_template to use when registering the host</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After allocating an ATA host and initializing it, most libata
LLDs perform three steps to activate the host - start host,
request IRQ and register it.  This helper takes necessary
arguments and performs the three steps in one go.</p>
<p>An invalid IRQ skips the IRQ registration and expects the host to
have set polling mode on the port. In this case, <strong>irq_handler</strong>
should be NULL.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_host_detach">
void <code class="sig-name descname">ata_host_detach</code><span class="sig-paren">(</span>struct ata_host *<em> host</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_host_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Detach all ports of an ATA host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>Host to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Detach all ports of <strong>host</strong>.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_pci_remove_one">
void <code class="sig-name descname">ata_pci_remove_one</code><span class="sig-paren">(</span>struct pci_dev *<em> pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_pci_remove_one" title="Permalink to this definition">¶</a></dt>
<dd><p>PCI layer callback for device removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt><dd><p>PCI device that was removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>PCI layer indicates to libata via this hook that hot-unplug or
module unload event has occurred.  Detach all ports.  Resource
release is handled via devres.</p>
<p>LOCKING:
Inherited from PCI layer (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_platform_remove_one">
int <code class="sig-name descname">ata_platform_remove_one</code><span class="sig-paren">(</span>struct platform_device *<em> pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_platform_remove_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Platform layer callback for device removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt><dd><p>Platform device that was removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Platform layer indicates to libata via this hook that hot-unplug or
module unload event has occurred.  Detach all ports.  Resource
release is handled via devres.</p>
<p>LOCKING:
Inherited from platform layer (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_msleep">
void <code class="sig-name descname">ata_msleep</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, unsigned int<em> msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_msleep" title="Permalink to this definition">¶</a></dt>
<dd><p>ATA EH owner aware msleep</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to attribute the sleep to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt><dd><p>duration to sleep in milliseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Sleeps <strong>msecs</strong>.  If the current task is owner of <strong>ap</strong>’s EH, the
ownership is released before going to sleep and reacquired
after the sleep is complete.  IOW, other ports sharing the
<strong>ap-&gt;host</strong> will be allowed to own the EH while this task is
sleeping.</p>
<p>LOCKING:
Might sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_wait_register">
u32 <code class="sig-name descname">ata_wait_register</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, void __iomem *<em> reg</em>, u32<em> mask</em>, u32<em> val</em>, unsigned long<em> interval</em>, unsigned long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_wait_register" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until register value changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to wait register for, can be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">reg</span></code></dt><dd><p>IO-mapped register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>Mask to apply to read register value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>Wait condition</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">interval</span></code></dt><dd><p>polling interval in milliseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout in milliseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Waiting for some bits of register to change is a common
operation for ATA controllers.  This function reads 32bit LE
IO-mapped register <strong>reg</strong> and tests for the following condition.</p>
<p>(<strong>*reg</strong> &amp; mask) != val</p>
<p>If the condition is met, it returns; otherwise, the process is
repeated after <strong>interval_msec</strong> until timeout.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>The final register value.</p>
</div></blockquote>
</div>
<div class="section" id="libata-core-internals">
<h2>libata Core Internals<a class="headerlink" href="#libata-core-internals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ata_dev_phys_link">
struct ata_link * <code class="sig-name descname">ata_dev_phys_link</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_phys_link" title="Permalink to this definition">¶</a></dt>
<dd><p>find physical link for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to look up physical link for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Look up physical link which <strong>dev</strong> is attached to.  Note that
this is different from <strong>dev-&gt;link</strong> only when <strong>dev</strong> is on slave
link.  For all other cases, it’s the same as <strong>dev-&gt;link</strong>.</p>
<p>LOCKING:
Don’t care.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to the found physical link.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_force_cbl">
void <code class="sig-name descname">ata_force_cbl</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_force_cbl" title="Permalink to this definition">¶</a></dt>
<dd><p>force cable type according to libata.force</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Force cable type according to libata.force and whine about it.
The last entry which has matching port number is used, so it
can be specified as part of device force parameters.  For
example, both “a:40c,1.00:udma4” and “1.00:40c,udma4” have the
same effect.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_force_link_limits">
void <code class="sig-name descname">ata_force_link_limits</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_force_link_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>force link limits according to libata.force</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Force link flags and SATA spd limit according to libata.force
and whine about it.  When only the port part is specified
(e.g. 1:), the limit applies to all links connected to both
the host link and all fan-out ports connected via PMP.  If the
device part is specified as 0 (e.g. 1.00:), it specifies the
first fan-out link not the host link.  Device number 15 always
points to the host link whether PMP is attached or not.  If the
controller has slave link, device number 16 points to it.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_force_xfermask">
void <code class="sig-name descname">ata_force_xfermask</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_force_xfermask" title="Permalink to this definition">¶</a></dt>
<dd><p>force xfermask according to libata.force</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Force xfer_mask according to libata.force and whine about it.
For consistency with link selection, device number 15 selects
the first device connected to the host link.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_force_horkage">
void <code class="sig-name descname">ata_force_horkage</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_force_horkage" title="Permalink to this definition">¶</a></dt>
<dd><p>force horkage according to libata.force</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Force horkage according to libata.force and whine about it.
For consistency with link selection, device number 15 selects
the first device connected to the host link.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_rwcmd_protocol">
int <code class="sig-name descname">ata_rwcmd_protocol</code><span class="sig-paren">(</span>struct ata_taskfile *<em> tf</em>, struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_rwcmd_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>set taskfile r/w commands and protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>command to examine and configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device tf belongs to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Examine the device configuration and tf-&gt;flags to calculate
the proper read/write commands and protocol to use.</p>
<p>LOCKING:
caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_tf_read_block">
u64 <code class="sig-name descname">ata_tf_read_block</code><span class="sig-paren">(</span>const struct ata_taskfile *<em> tf</em>, struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_tf_read_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Read block address from ATA taskfile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>ATA taskfile of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device <strong>tf</strong> belongs to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
None.</p>
<p>Read block address from <strong>tf</strong>.  This function can handle all
three address formats - LBA, LBA48 and CHS.  tf-&gt;protocol and
flags select the address format to use.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Block address read from <strong>tf</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_build_rw_tf">
int <code class="sig-name descname">ata_build_rw_tf</code><span class="sig-paren">(</span>struct ata_taskfile *<em> tf</em>, struct ata_device *<em> dev</em>, u64<em> block</em>, u32<em> n_block</em>, unsigned int<em> tf_flags</em>, unsigned int<em> tag</em>, int<em> class</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_build_rw_tf" title="Permalink to this definition">¶</a></dt>
<dd><p>Build ATA taskfile for given read/write request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>Target ATA taskfile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device <strong>tf</strong> belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">block</span></code></dt><dd><p>Block address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">n_block</span></code></dt><dd><p>Number of blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tf_flags</span></code></dt><dd><p>RW/FUA etc…</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tag</span></code></dt><dd><p>tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">class</span></code></dt><dd><p>IO priority class</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
None.</p>
<p>Build ATA taskfile <strong>tf</strong> for read/write request described by
<strong>block</strong>, <strong>n_block</strong>, <strong>tf_flags</strong> and <strong>tag</strong> on <strong>dev</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -ERANGE if the request is too large for <strong>dev</strong>,
-EINVAL if the request is invalid.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_unpack_xfermask">
void <code class="sig-name descname">ata_unpack_xfermask</code><span class="sig-paren">(</span>unsigned long<em> xfer_mask</em>, unsigned long *<em> pio_mask</em>, unsigned long *<em> mwdma_mask</em>, unsigned long *<em> udma_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_unpack_xfermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack xfer_mask into pio, mwdma and udma masks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">xfer_mask</span></code></dt><dd><p>xfer_mask to unpack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">pio_mask</span></code></dt><dd><p>resulting pio_mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">mwdma_mask</span></code></dt><dd><p>resulting mwdma_mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">udma_mask</span></code></dt><dd><p>resulting udma_mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unpack <strong>xfer_mask</strong> into <strong>pio_mask</strong>, <strong>mwdma_mask</strong> and <strong>udma_mask</strong>.
Any NULL destination masks will be ignored.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_read_native_max_address">
int <code class="sig-name descname">ata_read_native_max_address</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u64 *<em> max_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_read_native_max_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Read native max address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">max_sectors</span></code></dt><dd><p>out parameter for the result native max address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform an LBA48 or LBA28 native size query upon the device in
question.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -EACCES if command is aborted by the drive.
-EIO on other errors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_set_max_sectors">
int <code class="sig-name descname">ata_set_max_sectors</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u64<em> new_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_set_max_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Set max sectors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">new_sectors</span></code></dt><dd><p>new max sectors value to set for the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set max sectors of <strong>dev</strong> to <strong>new_sectors</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -EACCES if command is aborted or denied (due to
previous non-volatile SET_MAX) by the drive.  -EIO on other
errors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_hpa_resize">
int <code class="sig-name descname">ata_hpa_resize</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_hpa_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize a device with an HPA set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to resize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read the size of an LBA28 or LBA48 disk with HPA features and resize
it if required to the full size of the media. The caller must check
the drive has the HPA feature set enabled.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dump_id">
void <code class="sig-name descname">ata_dump_id</code><span class="sig-paren">(</span>const u16 *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dump_id" title="Permalink to this definition">¶</a></dt>
<dd><p>IDENTIFY DEVICE info debugging output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>IDENTIFY DEVICE page to dump</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Dump selected 16-bit words from the given IDENTIFY DEVICE
page.</p>
<p>LOCKING:
caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_exec_internal_sg">
unsigned <code class="sig-name descname">ata_exec_internal_sg</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct ata_taskfile *<em> tf</em>, const u8 *<em> cdb</em>, int<em> dma_dir</em>, struct scatterlist *<em> sgl</em>, unsigned int<em> n_elem</em>, unsigned long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_exec_internal_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>execute libata internal command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to which the command is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>Taskfile registers for the command and the result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt><dd><p>CDB for packet command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma_dir</span></code></dt><dd><p>Data transfer direction of the command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt><dd><p>sg list for the data buffer of the command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_elem</span></code></dt><dd><p>Number of sg entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>Timeout in msecs (0 for default)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Executes libata internal command with timeout.  <strong>tf</strong> contains
command on entry and result on return.  Timeout and error
conditions are reported via return value.  No recovery action
is taken after a command times out.  It’s caller’s duty to
clean up after timeout.</p>
<p>LOCKING:
None.  Should be called with kernel context, might sleep.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, AC_ERR_* mask on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_exec_internal">
unsigned <code class="sig-name descname">ata_exec_internal</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct ata_taskfile *<em> tf</em>, const u8 *<em> cdb</em>, int<em> dma_dir</em>, void *<em> buf</em>, unsigned int<em> buflen</em>, unsigned long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_exec_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>execute libata internal command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to which the command is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>Taskfile registers for the command and the result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt><dd><p>CDB for packet command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma_dir</span></code></dt><dd><p>Data transfer direction of the command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Data buffer of the command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>Length of data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>Timeout in msecs (0 for default)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wrapper around <a class="reference internal" href="#c.ata_exec_internal_sg" title="ata_exec_internal_sg"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_exec_internal_sg()</span></code></a> which takes simple
buffer instead of sg list.</p>
<p>LOCKING:
None.  Should be called with kernel context, might sleep.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, AC_ERR_* mask on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_pio_mask_no_iordy">
u32 <code class="sig-name descname">ata_pio_mask_no_iordy</code><span class="sig-paren">(</span>const struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_pio_mask_no_iordy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non IORDY mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>ATA device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Compute the highest mode possible if we are not using iordy. Return
-1 if no iordy mode is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_read_id">
int <code class="sig-name descname">ata_dev_read_id</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int *<em> p_class</em>, unsigned int<em> flags</em>, u16 *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_read_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Read ID data from the specified device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">p_class</span></code></dt><dd><p>pointer to class of the target device (may be changed)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>ATA_READID_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>buffer to read IDENTIFY data into</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read ID data from the specified device.  ATA_CMD_ID_ATA is
performed on ATA devices and ATA_CMD_ID_ATAPI on ATAPI
devices.  This function also issues ATA_CMD_INIT_DEV_PARAMS
for pre-ATA4 drives.</p>
<p>FIXME: ATA_CMD_ID_ATA is optional for early drives and right
now we abort if we hit that case.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_read_log_page">
unsigned int <code class="sig-name descname">ata_read_log_page</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8<em> log</em>, u8<em> page</em>, void *<em> buf</em>, unsigned int<em> sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_read_log_page" title="Permalink to this definition">¶</a></dt>
<dd><p>read a specific log page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">log</span></code></dt><dd><p>log to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">page</span></code></dt><dd><p>page to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>buffer to store read page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sectors</span></code></dt><dd><p>number of sectors to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read log page using READ_LOG_EXT command.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_configure">
int <code class="sig-name descname">ata_dev_configure</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the specified ATA/ATAPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Target device to configure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Configure <strong>dev</strong> according to <strong>dev-&gt;id</strong>.  Generic and low-level
driver specific fixups are also applied.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_bus_probe">
int <code class="sig-name descname">ata_bus_probe</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_bus_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset and probe ATA bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Bus to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Master ATA bus probing function.  Initiates a hardware-dependent
bus reset, then attempts to identify any devices found on
the bus.</p>
<p>LOCKING:
PCI/etc. bus probe sem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, negative errno otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sata_print_link_status">
void <code class="sig-name descname">sata_print_link_status</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sata_print_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Print SATA link status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>SATA link to printk link status about</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function prints link speed and status of a SATA link.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sata_down_spd_limit">
int <code class="sig-name descname">sata_down_spd_limit</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, u32<em> spd_limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sata_down_spd_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust SATA spd limit downward</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>Link to adjust SATA spd limit for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">spd_limit</span></code></dt><dd><p>Additional limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adjust SATA spd limit of <strong>link</strong> downward.  Note that this
function only adjusts the limit.  The change must be applied
using sata_set_spd().</p>
<p>If <strong>spd_limit</strong> is non-zero, the speed is limited to equal to or
lower than <strong>spd_limit</strong> if such speed is supported.  If
<strong>spd_limit</strong> is slower than any supported speed, only the lowest
supported speed is allowed.</p>
<p>LOCKING:
Inherited from caller.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_timing_cycle2mode">
u8 <code class="sig-name descname">ata_timing_cycle2mode</code><span class="sig-paren">(</span>unsigned int<em> xfer_shift</em>, int<em> cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_timing_cycle2mode" title="Permalink to this definition">¶</a></dt>
<dd><p>find xfer mode for the specified cycle duration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">xfer_shift</span></code></dt><dd><p>ATA_SHIFT_* value for transfer type to examine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cycle</span></code></dt><dd><p>cycle duration in ns</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return matching xfer mode for <strong>cycle</strong>.  The returned mode is of
the transfer type specified by <strong>xfer_shift</strong>.  If <strong>cycle</strong> is too
slow for <strong>xfer_shift</strong>, 0xff is returned.  If <strong>cycle</strong> is faster
than the fastest known mode, the fasted mode is returned.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Matching xfer_mode, 0xff if no match found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_down_xfermask_limit">
int <code class="sig-name descname">ata_down_xfermask_limit</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int<em> sel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_down_xfermask_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust dev xfer masks downward</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to adjust xfer masks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sel</span></code></dt><dd><p>ATA_DNXFER_* selector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adjust xfer masks of <strong>dev</strong> downward.  Note that this function
does not apply the change.  Invoking <a class="reference internal" href="#c.ata_set_mode" title="ata_set_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_set_mode()</span></code></a> afterwards
will apply the limit.</p>
<p>LOCKING:
Inherited from caller.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_wait_ready">
int <code class="sig-name descname">ata_wait_ready</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned long<em> deadline</em>, int (*check_ready) (struct ata_link<em> *link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_wait_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for link to become ready</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link to be waited on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">deadline</span></code></dt><dd><p>deadline jiffies for the operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">ata_link</span> <span class="pre">*link)</span> <span class="pre">check_ready</span></code></dt><dd><p>callback to check link readiness</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wait for <strong>link</strong> to become ready.  <strong>check_ready</strong> should return
positive number if <strong>link</strong> is ready, 0 if it isn’t, -ENODEV if
link doesn’t seem to be occupied, other errno for other error
conditions.</p>
<p>Transient -ENODEV conditions are allowed for
ATA_TMOUT_FF_WAIT.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 if <strong>link</strong> is ready before <strong>deadline</strong>; otherwise, -errno.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_same_device">
int <code class="sig-name descname">ata_dev_same_device</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int<em> new_class</em>, const u16 *<em> new_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_same_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether new ID matches configured device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to compare against</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_class</span></code></dt><dd><p>class of the new device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">*</span> <span class="pre">new_id</span></code></dt><dd><p>IDENTIFY page of the new device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Compare <strong>new_class</strong> and <strong>new_id</strong> against <strong>dev</strong> and determine
whether <strong>dev</strong> is the device indicated by <strong>new_class</strong> and
<strong>new_id</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>1 if <strong>dev</strong> matches <strong>new_class</strong> and <strong>new_id</strong>, 0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_reread_id">
int <code class="sig-name descname">ata_dev_reread_id</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int<em> readid_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_reread_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-read IDENTIFY data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target ATA device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">readid_flags</span></code></dt><dd><p>read ID flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Re-read IDENTIFY page and make sure <strong>dev</strong> is still attached to
the port.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_revalidate">
int <code class="sig-name descname">ata_dev_revalidate</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int<em> new_class</em>, unsigned int<em> readid_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_revalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Revalidate ATA device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to revalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_class</span></code></dt><dd><p>new class code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">readid_flags</span></code></dt><dd><p>read ID flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Re-read IDENTIFY page, make sure <strong>dev</strong> is still attached to the
port and reconfigure it according to the new IDENTIFY page.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_is_40wire">
int <code class="sig-name descname">ata_is_40wire</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_is_40wire" title="Permalink to this definition">¶</a></dt>
<dd><p>check drive side detection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform drive side detection decoding, allowing for device vendors
who can’t follow the documentation.</p>
</div></blockquote>
<dl class="function">
<dt id="c.cable_is_40wire">
int <code class="sig-name descname">cable_is_40wire</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cable_is_40wire" title="Permalink to this definition">¶</a></dt>
<dd><p>40/80/SATA decider</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port to consider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function encapsulates the policy for speed management
in one place. At the moment we don’t cache the result but
there is a good case for setting ap-&gt;cbl to the result when
we are called with unknown cables (and figuring out if it
impacts hotplug at all).</p>
<p>Return 1 if the cable appears to be 40 wire.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_xfermask">
void <code class="sig-name descname">ata_dev_xfermask</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_xfermask" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute supported xfermask of the given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to compute xfermask for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Compute supported xfermask of <strong>dev</strong> and store it in
dev-&gt;*_mask.  This function is responsible for applying all
known limits including host controller limits, device
blacklist, etc…</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_set_xfermode">
unsigned int <code class="sig-name descname">ata_dev_set_xfermode</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_set_xfermode" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue SET FEATURES - XFER MODE command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to which command will be sent</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue SET FEATURES - XFER MODE command to device <strong>dev</strong>
on port <strong>ap</strong>.</p>
<p>LOCKING:
PCI/etc. bus probe sem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_init_params">
unsigned int <code class="sig-name descname">ata_dev_init_params</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u16<em> heads</em>, u16<em> sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_init_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue INIT DEV PARAMS command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to which command will be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">heads</span></code></dt><dd><p>Number of heads (taskfile parameter)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">sectors</span></code></dt><dd><p>Number of sectors (taskfile parameter)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_check_dma">
int <code class="sig-name descname">atapi_check_dma</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_check_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether ATAPI DMA can be supported</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Metadata associated with taskfile to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allow low-level driver to filter ATA PACKET commands, returning
a status indicating whether or not it is OK to use DMA for the
supplied PACKET command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 when ATAPI DMA can be used</dt><dd><p>nonzero otherwise</p>
</dd>
</dl>
<dl class="function">
<dt id="c.ata_sg_init">
void <code class="sig-name descname">ata_sg_init</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em>, struct scatterlist *<em> sg</em>, unsigned int<em> n_elem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_sg_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate command with scatter-gather table.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to be associated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt><dd><p>Scatter-gather table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_elem</span></code></dt><dd><p>Number of elements in s/g table.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize the data-related elements of queued_cmd <strong>qc</strong>
to point to a scatter-gather table <strong>sg</strong>, containing <strong>n_elem</strong>
elements.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_sg_clean">
void <code class="sig-name descname">ata_sg_clean</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_sg_clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap DMA memory associated with command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command containing DMA memory to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unmap all mapped DMA memory associated with this command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_sg_setup">
int <code class="sig-name descname">ata_sg_setup</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_sg_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>DMA-map the scatter-gather table associated with a command.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command with scatter-gather table to be mapped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>DMA-map the scatter-gather table associated with queued_cmd <strong>qc</strong>.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, negative on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.swap_buf_le16">
void <code class="sig-name descname">swap_buf_le16</code><span class="sig-paren">(</span>u16 *<em> buf</em>, unsigned int<em> buf_words</em><span class="sig-paren">)</span><a class="headerlink" href="#c.swap_buf_le16" title="Permalink to this definition">¶</a></dt>
<dd><p>swap halves of 16-bit words in place</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Buffer to swap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buf_words</span></code></dt><dd><p>Number of 16-bit words in buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Swap halves of 16-bit words if needed to convert from
little-endian byte order to native cpu byte order, or
vice-versa.</p>
<p>LOCKING:
Inherited from caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_new_init">
struct ata_queued_cmd * <code class="sig-name descname">ata_qc_new_init</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, int<em> tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_new_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Request an available ATA command, and initialize it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device from whom we request an available command structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tag</span></code></dt><dd><p>tag</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_free">
void <code class="sig-name descname">ata_qc_free</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free unused ata_queued_cmd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to complete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Designed to free unused ata_queued_cmd object
in case something prevents using it.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_issue">
void <code class="sig-name descname">ata_qc_issue</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_issue" title="Permalink to this definition">¶</a></dt>
<dd><p>issue taskfile to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>command to issue to device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Prepare an ATA command to submission to device.
This includes mapping the data into a DMA-able
area, filling in the S/G table, and finally
writing the taskfile to hardware, starting the command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_phys_link_online">
bool <code class="sig-name descname">ata_phys_link_online</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_phys_link_online" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the given link is online</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test whether <strong>link</strong> is online.  Note that this function returns
0 if online status of <strong>link</strong> cannot be obtained, so
ata_link_online(link) != !ata_link_offline(link).</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if the port online status is available and online.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_phys_link_offline">
bool <code class="sig-name descname">ata_phys_link_offline</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_phys_link_offline" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the given link is offline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Test whether <strong>link</strong> is offline.  Note that this function
returns 0 if offline status of <strong>link</strong> cannot be obtained, so
ata_link_online(link) != !ata_link_offline(link).</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if the port offline status is available and offline.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_init">
void <code class="sig-name descname">ata_dev_init</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an ata_device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device structure to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize <strong>dev</strong> in preparation for probing.</p>
<p>LOCKING:
Inherited from caller.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_link_init">
void <code class="sig-name descname">ata_link_init</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct ata_link *<em> link</em>, int<em> pmp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_link_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an ata_link structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port link is attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>Link structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pmp</span></code></dt><dd><p>Port multiplier port number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize <strong>link</strong>.</p>
<p>LOCKING:
Kernel thread context (may sleep)</p>
</div></blockquote>
<dl class="function">
<dt id="c.sata_link_init_spd">
int <code class="sig-name descname">sata_link_init_spd</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sata_link_init_spd" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize link-&gt;sata_spd_limit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>Link to configure sata_spd_limit for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize <strong>link</strong>-&gt;[<a href="#id1"><span class="problematic" id="id2">hw_</span></a>]sata_spd_limit to the currently
configured value.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_alloc">
struct ata_port * <code class="sig-name descname">ata_port_alloc</code><span class="sig-paren">(</span>struct ata_host *<em> host</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize basic ATA port resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>ATA host this allocated port belongs to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate and initialize basic ATA port resources.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Allocate ATA port on success, NULL on failure.</p>
<p>LOCKING:
Inherited from calling layer (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_finalize_port_ops">
void <code class="sig-name descname">ata_finalize_port_ops</code><span class="sig-paren">(</span>struct ata_port_operations *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_finalize_port_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>finalize ata_port_operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port_operations</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>ata_port_operations to finalize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>An ata_port_operations can inherit from another ops and that
ops can again inherit from another.  This can go on as many
times as necessary as long as there is no loop in the
inheritance chain.</p>
<p>Ops tables are finalized when the host is started.  NULL or
unspecified entries are inherited from the closet ancestor
which has the method and the entry is populated with it.
After finalization, the ops table directly points to all the
methods and -&gt;inherits is no longer necessary and cleared.</p>
<p>Using ATA_OP_NULL, inheriting ops can force a method to NULL.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_detach">
void <code class="sig-name descname">ata_port_detach</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Detach ATA port in preparation of device removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to be detached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Detach all ATA devices and the associated SCSI devices of <strong>ap</strong>;
then, remove the associated SCSI host.  <strong>ap</strong> is guaranteed to
be quiescent on return from this function.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.__ata_ehi_push_desc">
void <code class="sig-name descname">__ata_ehi_push_desc</code><span class="sig-paren">(</span>struct ata_eh_info *<em> ehi</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.__ata_ehi_push_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>push error description without adding separator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_eh_info</span> <span class="pre">*</span> <span class="pre">ehi</span></code></dt><dd><p>target EHI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>printf format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Format string according to <strong>fmt</strong> and append it to <strong>ehi-&gt;desc</strong>.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_ehi_push_desc">
void <code class="sig-name descname">ata_ehi_push_desc</code><span class="sig-paren">(</span>struct ata_eh_info *<em> ehi</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.ata_ehi_push_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>push error description with separator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_eh_info</span> <span class="pre">*</span> <span class="pre">ehi</span></code></dt><dd><p>target EHI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>printf format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Format string according to <strong>fmt</strong> and append it to <strong>ehi-&gt;desc</strong>.
If <strong>ehi-&gt;desc</strong> is not empty, “, ” is added in-between.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_ehi_clear_desc">
void <code class="sig-name descname">ata_ehi_clear_desc</code><span class="sig-paren">(</span>struct ata_eh_info *<em> ehi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_ehi_clear_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>clean error description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_eh_info</span> <span class="pre">*</span> <span class="pre">ehi</span></code></dt><dd><p>target EHI</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Clear <strong>ehi-&gt;desc</strong>.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_desc">
void <code class="sig-name descname">ata_port_desc</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, const char *<em> fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>append port description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>target ATA port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt><dd><p>printf format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Format string according to <strong>fmt</strong> and append it to port
description.  If port description is not empty, ” ” is added
in-between.  This function is to be used while initializing
ata_host.  The description is printed on host registration.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_pbar_desc">
void <code class="sig-name descname">ata_port_pbar_desc</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, int<em> bar</em>, ssize_t<em> offset</em>, const char *<em> name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_pbar_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>append PCI BAR description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>target ATA port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>target PCI BAR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">offset</span></code></dt><dd><p>offset into PCI BAR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>name of the area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If <strong>offset</strong> is negative, this function formats a string which
contains the name, address, size and type of the BAR and
appends it to the port description.  If <strong>offset</strong> is zero or
positive, only name and offsetted address is appended.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_internal_cmd_timeout">
unsigned long <code class="sig-name descname">ata_internal_cmd_timeout</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_internal_cmd_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>determine timeout for an internal command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>internal command to be issued</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Determine timeout for internal command <strong>cmd</strong> for <strong>dev</strong>.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Determined timeout.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_internal_cmd_timed_out">
void <code class="sig-name descname">ata_internal_cmd_timed_out</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_internal_cmd_timed_out" title="Permalink to this definition">¶</a></dt>
<dd><p>notification for internal command timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>internal command which timed out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Notify EH that internal command <strong>cmd</strong> for <strong>dev</strong> timed out.  This
function should be called only for commands whose timeouts are
determined using <a class="reference internal" href="#c.ata_internal_cmd_timeout" title="ata_internal_cmd_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_internal_cmd_timeout()</span></code></a>.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_acquire">
void <code class="sig-name descname">ata_eh_acquire</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire EH ownership</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to acquire EH ownership for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Acquire EH ownership for <strong>ap</strong>.  This is the basic exclusion
mechanism for ports sharing a host.  Only one port hanging off
the same host can claim the ownership of EH.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_release">
void <code class="sig-name descname">ata_eh_release</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release EH ownership</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to release EH ownership for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Release EH ownership for <strong>ap</strong> if the caller.  The caller must
have acquired EH ownership using <a class="reference internal" href="#c.ata_eh_acquire" title="ata_eh_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_eh_acquire()</span></code></a> previously.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_error">
void <code class="sig-name descname">ata_scsi_error</code><span class="sig-paren">(</span>struct Scsi_Host *<em> host</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_error" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI layer error handler callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>SCSI host on which error occurred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Handles SCSI-layer-thrown error events.</p>
<p>LOCKING:
Inherited from SCSI layer (none, can sleep)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_cmd_error_handler">
void <code class="sig-name descname">ata_scsi_cmd_error_handler</code><span class="sig-paren">(</span>struct Scsi_Host *<em> host</em>, struct ata_port *<em> ap</em>, struct list_head *<em> eh_work_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_cmd_error_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>error callback for a list of commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>scsi host containing the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port within the host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">eh_work_q</span></code></dt><dd><p>list of commands to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>process the given list of commands and return those finished to the
ap-&gt;eh_done_q.  This function is the first part of the libata error
handler which processes a given list of failed commands.</p>
<dl class="function">
<dt id="c.ata_scsi_port_error_handler">
void <code class="sig-name descname">ata_scsi_port_error_handler</code><span class="sig-paren">(</span>struct Scsi_Host *<em> host</em>, struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_port_error_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>recover the port after the commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt><dd><p>SCSI host containing the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>the ATA port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle the recovery of the port <strong>ap</strong> after all the commands
have been recovered.</p>
<dl class="function">
<dt id="c.ata_port_wait_eh">
void <code class="sig-name descname">ata_port_wait_eh</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_wait_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for the currently pending EH to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port to wait EH for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wait until the currently pending EH is complete.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_set_pending">
void <code class="sig-name descname">ata_eh_set_pending</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, int<em> fastdrain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_set_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>set ATA_PFLAG_EH_PENDING and activate fast drain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>target ATA port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fastdrain</span></code></dt><dd><p>activate fast drain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set ATA_PFLAG_EH_PENDING and activate fast drain if <strong>fastdrain</strong>
is non-zero and EH wasn’t pending before.  Fast drain ensures
that EH kicks in in timely manner.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_qc_schedule_eh">
void <code class="sig-name descname">ata_qc_schedule_eh</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_qc_schedule_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule qc for error handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>command to schedule error handling for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Schedule error handling for <strong>qc</strong>.  EH will kick in as soon as
other commands are drained.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_sched_eh">
void <code class="sig-name descname">ata_std_sched_eh</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_sched_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>non-libsas ata_ports issue eh with this common routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to schedule EH for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING: inherited from ata_port_schedule_eh
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_end_eh">
void <code class="sig-name descname">ata_std_end_eh</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_end_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>non-libsas ata_ports complete eh with this common routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to end EH for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In the libata object model there is a 1:1 mapping of ata_port to
shost, so host fields can be directly manipulated under ap-&gt;lock, in
the libsas case we need to hold a lock at the ha-&gt;level to coordinate
these events.</p>
<blockquote>
<div><p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_schedule_eh">
void <code class="sig-name descname">ata_port_schedule_eh</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_schedule_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule error handling without a qc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to schedule EH for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Schedule error handling for <strong>ap</strong>.  EH will kick in as soon as
all commands are drained.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_link_abort">
int <code class="sig-name descname">ata_link_abort</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_link_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>abort all qc’s on the link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to abort qc’s for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Abort all active qc’s active on <strong>link</strong> and schedule EH.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Number of aborted qc’s.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_abort">
int <code class="sig-name descname">ata_port_abort</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>abort all qc’s on the port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to abort qc’s for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Abort all active qc’s of <strong>ap</strong> and schedule EH.</p>
<p>LOCKING:
spin_lock_irqsave(host_set lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Number of aborted qc’s.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__ata_port_freeze">
void <code class="sig-name descname">__ata_port_freeze</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ata_port_freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>freeze port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to freeze</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called when HSM violation or some other
condition disrupts normal operation of the port.  Frozen port
is not allowed to perform any operation until the port is
thawed, which usually follows a successful reset.</p>
<p>ap-&gt;ops-&gt;freeze() callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
port cannot be frozen hardware-wise, the interrupt handler
must ack and clear interrupts unconditionally while the port
is frozen.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_port_freeze">
int <code class="sig-name descname">ata_port_freeze</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_port_freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>abort &amp; freeze port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to freeze</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Abort and freeze <strong>ap</strong>.  The freeze operation must be called
first, because some hardware requires special operations
before the taskfile registers are accessible.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Number of aborted commands.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_freeze_port">
void <code class="sig-name descname">ata_eh_freeze_port</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_freeze_port" title="Permalink to this definition">¶</a></dt>
<dd><p>EH helper to freeze port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to freeze</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Freeze <strong>ap</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_thaw_port">
void <code class="sig-name descname">ata_eh_thaw_port</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_thaw_port" title="Permalink to this definition">¶</a></dt>
<dd><p>EH helper to thaw port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to thaw</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Thaw frozen port <strong>ap</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_qc_complete">
void <code class="sig-name descname">ata_eh_qc_complete</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_qc_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete an active ATA command from EH</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to complete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Indicate to the mid and upper layers that an ATA command has
completed.  To be used from EH.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_qc_retry">
void <code class="sig-name descname">ata_eh_qc_retry</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_qc_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell midlayer to retry an ATA command after EH</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to retry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Indicate to the mid and upper layers that an ATA command
should be retried.  To be used from EH.</p>
<p>SCSI midlayer limits the number of retries to scmd-&gt;allowed.
scmd-&gt;allowed is incremented for commands which get retried
due to unrelated failures (qc-&gt;err_mask is zero).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dev_disable">
void <code class="sig-name descname">ata_dev_disable</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dev_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable ATA device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable <strong>dev</strong>.</p>
<p>Locking:
EH context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_detach_dev">
void <code class="sig-name descname">ata_eh_detach_dev</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_detach_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>detach ATA device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Detach <strong>dev</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_about_to_do">
void <code class="sig-name descname">ata_eh_about_to_do</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_device *<em> dev</em>, unsigned int<em> action</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_about_to_do" title="Permalink to this definition">¶</a></dt>
<dd><p>about to perform eh_action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>target ATA link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target ATA dev for per-dev action (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">action</span></code></dt><dd><p>action about to be performed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Called just before performing EH actions to clear related bits
in <strong>link-&gt;eh_info</strong> such that eh actions are not unnecessarily
repeated.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_done">
void <code class="sig-name descname">ata_eh_done</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_device *<em> dev</em>, unsigned int<em> action</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_done" title="Permalink to this definition">¶</a></dt>
<dd><p>EH action complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link for which EH actions are complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target ATA dev for per-dev action (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">action</span></code></dt><dd><p>action just completed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Called right after performing EH actions to clear related bits
in <strong>link-&gt;eh_context</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_err_string">
const char * <code class="sig-name descname">ata_err_string</code><span class="sig-paren">(</span>unsigned int<em> err_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_err_string" title="Permalink to this definition">¶</a></dt>
<dd><p>convert err_mask to descriptive string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">err_mask</span></code></dt><dd><p>error mask to convert to string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Convert <strong>err_mask</strong> to descriptive string.  Errors are
prioritized according to severity and only the most severe
error is reported.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Descriptive string for <strong>err_mask</strong></p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_eh_tur">
unsigned int <code class="sig-name descname">atapi_eh_tur</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8 *<em> r_sense_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_eh_tur" title="Permalink to this definition">¶</a></dt>
<dd><p>perform ATAPI TEST_UNIT_READY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>target ATAPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">r_sense_key</span></code></dt><dd><p>out parameter for sense_key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform ATAPI TEST_UNIT_READY.</p>
<p>LOCKING:
EH context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_request_sense">
void <code class="sig-name descname">ata_eh_request_sense</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_request_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>perform REQUEST_SENSE_DATA_EXT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>qc to perform REQUEST_SENSE_SENSE_DATA_EXT to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>scsi command for which the sense code should be set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform REQUEST_SENSE_DATA_EXT after the device reported CHECK
SENSE.  This function is an EH helper.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_eh_request_sense">
unsigned int <code class="sig-name descname">atapi_eh_request_sense</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8 *<em> sense_buf</em>, u8<em> dfl_sense_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_eh_request_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>perform ATAPI REQUEST_SENSE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to perform REQUEST_SENSE to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buf</span></code></dt><dd><p>result sense data buffer (SCSI_SENSE_BUFFERSIZE bytes long)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dfl_sense_key</span></code></dt><dd><p>default sense key to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform ATAPI REQUEST_SENSE after the device reported CHECK
SENSE.  This function is EH helper.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, AC_ERR_* mask on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_analyze_serror">
void <code class="sig-name descname">ata_eh_analyze_serror</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_analyze_serror" title="Permalink to this definition">¶</a></dt>
<dd><p>analyze SError for a failed port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link to analyze SError for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Analyze SError if available and further determine cause of
failure.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_analyze_tf">
unsigned int <code class="sig-name descname">ata_eh_analyze_tf</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em>, const struct ata_taskfile *<em> tf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_analyze_tf" title="Permalink to this definition">¶</a></dt>
<dd><p>analyze taskfile of a failed qc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>qc to analyze</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>Taskfile registers to analyze</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Analyze taskfile of <strong>qc</strong> and further determine cause of
failure.  This function also requests ATAPI sense data if
available.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Determined recovery action</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_speed_down_verdict">
unsigned int <code class="sig-name descname">ata_eh_speed_down_verdict</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_speed_down_verdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine speed down verdict</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function examines error ring of <strong>dev</strong> and determines
whether NCQ needs to be turned off, transfer speed should be
stepped down, or falling back to PIO is necessary.</p>
<p>ECAT_ATA_BUS    : ATA_BUS error for any command</p>
<dl class="simple">
<dt>ECAT_TOUT_HSM<span class="classifier">TIMEOUT for any command or HSM violation for</span></dt><dd><p>IO commands</p>
</dd>
</dl>
<p>ECAT_UNK_DEV    : Unknown DEV error for IO commands</p>
<dl class="simple">
<dt>ECAT_DUBIOUS_*<span class="classifier">Identical to above three but occurred while</span></dt><dd><p>data transfer hasn’t been verified.</p>
</dd>
</dl>
<p>Verdicts are</p>
<p>NCQ_OFF         : Turn off NCQ.</p>
<dl class="simple">
<dt>SPEED_DOWN<span class="classifier">Speed down transfer speed but don’t fall back</span></dt><dd><p>to PIO.</p>
</dd>
</dl>
<p>FALLBACK_TO_PIO : Fall back to PIO.</p>
<p>Even if multiple verdicts are returned, only one action is
taken per error.  An action triggered by non-DUBIOUS errors
clears ering, while one triggered by DUBIOUS_* errors doesn’t.
This is to expedite speed down decisions right after device is
initially configured.</p>
<p>The following are speed down rules.  #1 and #2 deal with
DUBIOUS errors.</p>
<ol class="arabic simple">
<li><p>If more than one DUBIOUS_ATA_BUS or DUBIOUS_TOUT_HSM errors
occurred during last 5 mins, SPEED_DOWN and FALLBACK_TO_PIO.</p></li>
<li><p>If more than one DUBIOUS_TOUT_HSM or DUBIOUS_UNK_DEV errors
occurred during last 5 mins, NCQ_OFF.</p></li>
<li><p>If more than 8 ATA_BUS, TOUT_HSM or UNK_DEV errors
occurred during last 5 mins, FALLBACK_TO_PIO</p></li>
<li><p>If more than 3 TOUT_HSM or UNK_DEV errors occurred
during last 10 mins, NCQ_OFF.</p></li>
<li><p>If more than 3 ATA_BUS or TOUT_HSM errors, or more than 6
UNK_DEV errors occurred during last 10 mins, SPEED_DOWN.</p></li>
</ol>
<p>LOCKING:
Inherited from caller.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>OR of ATA_EH_SPDN_* flags.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_speed_down">
unsigned int <code class="sig-name descname">ata_eh_speed_down</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, unsigned int<em> eflags</em>, unsigned int<em> err_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_speed_down" title="Permalink to this definition">¶</a></dt>
<dd><p>record error and speed down if necessary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Failed device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">eflags</span></code></dt><dd><p>mask of ATA_EFLAG_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">err_mask</span></code></dt><dd><p>err_mask of the error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Record error and examine error history to determine whether
adjusting transmission speed is necessary.  It also sets
transmission limits appropriately if such adjustment is
necessary.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Determined recovery action.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_worth_retry">
int <code class="sig-name descname">ata_eh_worth_retry</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_worth_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>analyze error and decide whether to retry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>qc to possibly retry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Look at the cause of the error and decide if a retry
might be useful or not.  We don’t want to retry media errors
because the drive itself has probably already taken 10-30 seconds
doing its own internal retries before reporting the failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_quiet">
bool <code class="sig-name descname">ata_eh_quiet</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_quiet" title="Permalink to this definition">¶</a></dt>
<dd><p>check if we need to be quiet about a command error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>qc to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Look at the qc flags anbd its scsi command request flags to determine
if we need to be quiet about the command failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_link_autopsy">
void <code class="sig-name descname">ata_eh_link_autopsy</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_link_autopsy" title="Permalink to this definition">¶</a></dt>
<dd><p>analyze error and determine recovery action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>host link to perform autopsy on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Analyze why <strong>link</strong> failed and determine which recovery actions
are needed.  This function also sets more detailed AC_ERR_*
values and fills sense data for ATAPI CHECK SENSE.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_autopsy">
void <code class="sig-name descname">ata_eh_autopsy</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_autopsy" title="Permalink to this definition">¶</a></dt>
<dd><p>analyze error and determine recovery action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>host port to perform autopsy on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Analyze all links of <strong>ap</strong> and determine why they failed and
which recovery actions are needed.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_get_cmd_descript">
const char * <code class="sig-name descname">ata_get_cmd_descript</code><span class="sig-paren">(</span>u8<em> command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_get_cmd_descript" title="Permalink to this definition">¶</a></dt>
<dd><p>get description for ATA command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>ATA command code to get description for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Return a textual description of the given command, or NULL if the
command is not known.</p>
<p>LOCKING:
None</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_link_report">
void <code class="sig-name descname">ata_eh_link_report</code><span class="sig-paren">(</span>struct ata_link *<em> link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_link_report" title="Permalink to this definition">¶</a></dt>
<dd><p>report error handling to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>ATA link EH is going on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Report EH to user.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_report">
void <code class="sig-name descname">ata_eh_report</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_report" title="Permalink to this definition">¶</a></dt>
<dd><p>report error handling to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to report EH about</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Report EH to user.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_set_mode">
int <code class="sig-name descname">ata_set_mode</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_device **<em> r_failed_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Program timings and issue SET FEATURES - XFER</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link on which timings will be programmed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">**</span> <span class="pre">r_failed_dev</span></code></dt><dd><p>out parameter for failed device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
<a class="reference internal" href="#c.ata_set_mode" title="ata_set_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_set_mode()</span></code></a> fails, pointer to the failing device is
returned in <strong>r_failed_dev</strong>.</p>
<p>LOCKING:
PCI/etc. bus probe sem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, negative errno otherwise</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_eh_clear_ua">
int <code class="sig-name descname">atapi_eh_clear_ua</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_eh_clear_ua" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear ATAPI UNIT ATTENTION after reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATAPI device to clear UA for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Resets and other operations can make an ATAPI device raise
UNIT ATTENTION which causes the next operation to fail.  This
function clears UA.</p>
<p>LOCKING:
EH context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_maybe_retry_flush">
int <code class="sig-name descname">ata_eh_maybe_retry_flush</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_maybe_retry_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Retry FLUSH if necessary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device which may need FLUSH retry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If <strong>dev</strong> failed FLUSH, it needs to be reported upper layer
immediately as it means that <strong>dev</strong> failed to remap and already
lost at least a sector and further FLUSH retrials won’t make
any difference to the lost sector.  However, if FLUSH failed
for other reasons, for example transmission error, FLUSH needs
to be retried.</p>
<p>This function determines whether FLUSH failure retry is
necessary and performs it if so.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 if EH can continue, -errno if EH needs to be repeated.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_set_lpm">
int <code class="sig-name descname">ata_eh_set_lpm</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, enum ata_lpm_policy<em> policy</em>, struct ata_device **<em> r_failed_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_set_lpm" title="Permalink to this definition">¶</a></dt>
<dd><p>configure SATA interface power management</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link to configure power management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ata_lpm_policy</span> <span class="pre">policy</span></code></dt><dd><p>the link power management policy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">**</span> <span class="pre">r_failed_dev</span></code></dt><dd><p>out parameter for failed device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enable SATA Interface power management.  This will enable
Device Interface Power Management (DIPM) for min_power and
medium_power_with_dipm policies, and then call driver specific
callbacks for enabling Host Initiated Power management.</p>
<p>LOCKING:
EH context.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_recover">
int <code class="sig-name descname">ata_eh_recover</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, ata_prereset_fn_t<em> prereset</em>, ata_reset_fn_t<em> softreset</em>, ata_reset_fn_t<em> hardreset</em>, ata_postreset_fn_t<em> postreset</em>, struct ata_link **<em> r_failed_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_recover" title="Permalink to this definition">¶</a></dt>
<dd><p>recover host port after error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>host port to recover</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_prereset_fn_t</span> <span class="pre">prereset</span></code></dt><dd><p>prereset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_reset_fn_t</span> <span class="pre">softreset</span></code></dt><dd><p>softreset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_reset_fn_t</span> <span class="pre">hardreset</span></code></dt><dd><p>hardreset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_postreset_fn_t</span> <span class="pre">postreset</span></code></dt><dd><p>postreset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">**</span> <span class="pre">r_failed_link</span></code></dt><dd><p>out parameter for failed link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is the alpha and omega, eum and yang, heart and soul of
libata exception handling.  On entry, actions required to
recover each link and hotplug requests are recorded in the
link’s eh_context.  This function executes all the operations
with appropriate retrials and fallbacks to resurrect failed
devices, detach goners and greet newcomers.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, -errno on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_finish">
void <code class="sig-name descname">ata_eh_finish</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish up EH</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>host port to finish EH for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Recovery is complete.  Clean up EH states and retry or finish
failed qcs.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_do_eh">
void <code class="sig-name descname">ata_do_eh</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, ata_prereset_fn_t<em> prereset</em>, ata_reset_fn_t<em> softreset</em>, ata_reset_fn_t<em> hardreset</em>, ata_postreset_fn_t<em> postreset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_do_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>do standard error handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>host port to handle error for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_prereset_fn_t</span> <span class="pre">prereset</span></code></dt><dd><p>prereset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_reset_fn_t</span> <span class="pre">softreset</span></code></dt><dd><p>softreset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_reset_fn_t</span> <span class="pre">hardreset</span></code></dt><dd><p>hardreset method (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_postreset_fn_t</span> <span class="pre">postreset</span></code></dt><dd><p>postreset method (can be NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform standard error handling sequence.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_std_error_handler">
void <code class="sig-name descname">ata_std_error_handler</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_error_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>standard error handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>host port to handle error for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Standard error handler</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_handle_port_suspend">
void <code class="sig-name descname">ata_eh_handle_port_suspend</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_handle_port_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>perform port suspend operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port to suspend</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Suspend <strong>ap</strong>.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_eh_handle_port_resume">
void <code class="sig-name descname">ata_eh_handle_port_resume</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_eh_handle_port_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>perform port resume operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>port to resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Resume <strong>ap</strong>.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
</div>
<div class="section" id="libata-scsi-translation-emulation">
<h2>libata SCSI translation/emulation<a class="headerlink" href="#libata-scsi-translation-emulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ata_std_bios_param">
int <code class="sig-name descname">ata_std_bios_param</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em>, struct block_device *<em> bdev</em>, sector_t<em> capacity</em>, int<em> geom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_std_bios_param" title="Permalink to this definition">¶</a></dt>
<dd><p>generic bios head/sector/cylinder calculator used by sd.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device for which BIOS geometry is to be determined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt><dd><p>block device associated with <strong>sdev</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>capacity of SCSI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">geom</span></code></dt><dd><p>location to which geometry will be output</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generic bios head/sector/cylinder calculator
used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)
mapping. Some situations may arise where the disk is not
bootable if this is not used.</p>
<p>LOCKING:
Defined by the SCSI layer.  We don’t really care.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_unlock_native_capacity">
void <code class="sig-name descname">ata_scsi_unlock_native_capacity</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_unlock_native_capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock native capacity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to adjust device capacity for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called if a partition on <strong>sdev</strong> extends beyond
the end of the device.  It requests EH to unlock HPA.</p>
<p>LOCKING:
Defined by the SCSI layer.  Might sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_slave_config">
int <code class="sig-name descname">ata_scsi_slave_config</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_slave_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Set SCSI device attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to examine</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is called before we actually start reading
and writing to the device, to configure certain
SCSI mid-layer behaviors.</p>
<p>LOCKING:
Defined by SCSI layer.  We don’t really care.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_slave_destroy">
void <code class="sig-name descname">ata_scsi_slave_destroy</code><span class="sig-paren">(</span>struct scsi_device *<em> sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_slave_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI device is about to be destroyed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>sdev</strong> is about to be destroyed for hot/warm unplugging.  If
this unplugging was initiated by libata as indicated by NULL
dev-&gt;sdev, this function doesn’t have to do anything.
Otherwise, SCSI layer initiated warm-unplug is in progress.
Clear dev-&gt;sdev, schedule the device for ATA detach and invoke
EH.</p>
<p>LOCKING:
Defined by SCSI layer.  We don’t really care.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_queuecmd">
int <code class="sig-name descname">ata_scsi_queuecmd</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_queuecmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue SCSI cdb to libata-managed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>SCSI host of command to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command to be sent</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>In some cases, this function translates SCSI commands into
ATA taskfiles, and queues the taskfiles to be sent to
hardware.  In other cases, this function simulates a
SCSI device by evaluating and responding to certain
SCSI commands.  This creates the overall effect of
ATA and ATAPI devices appearing as SCSI devices.</p>
<p>LOCKING:
ATA host lock</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Return value from __ata_scsi_queuecmd() if <strong>cmd</strong> can be queued,
0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_get_identity">
int <code class="sig-name descname">ata_get_identity</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct scsi_device *<em> sdev</em>, void __user *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_get_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Handler for HDIO_GET_IDENTITY ioctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>target port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt><dd><p>SCSI device to get identify data for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>User buffer area for identify data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Defined by the SCSI layer.  We don’t really care.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, negative errno on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_cmd_ioctl">
int <code class="sig-name descname">ata_cmd_ioctl</code><span class="sig-paren">(</span>struct scsi_device *<em> scsidev</em>, void __user *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_cmd_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Handler for HDIO_DRIVE_CMD ioctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">scsidev</span></code></dt><dd><p>Device to which we are issuing command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>User provided data for issuing command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Defined by the SCSI layer.  We don’t really care.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, negative errno on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_task_ioctl">
int <code class="sig-name descname">ata_task_ioctl</code><span class="sig-paren">(</span>struct scsi_device *<em> scsidev</em>, void __user *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_task_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Handler for HDIO_DRIVE_TASK ioctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">scsidev</span></code></dt><dd><p>Device to which we are issuing command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>User provided data for issuing command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
Defined by the SCSI layer.  We don’t really care.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, negative errno on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_qc_new">
struct ata_queued_cmd * <code class="sig-name descname">ata_scsi_qc_new</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_qc_new" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire new ata_queued_cmd reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to which the new command is attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command that originated this ATA command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Obtain a reference to an unused ata_queued_cmd structure,
which is the basic libata structure representing a single
ATA command sent to the hardware.</p>
<p>If a command was available, fill in the SCSI-specific
portions of the structure with information on the
current command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Command allocated, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if none available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_dump_status">
void <code class="sig-name descname">ata_dump_status</code><span class="sig-paren">(</span>unsigned<em> id</em>, struct ata_taskfile *<em> tf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_dump_status" title="Permalink to this definition">¶</a></dt>
<dd><p>user friendly display of error info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">id</span></code></dt><dd><p>id of the port in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_taskfile</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt><dd><p>ptr to filled out taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Decode and dump the ATA error/status registers for the user so
that they have some idea what really happened at the non
make-believe layer.</p>
<p>LOCKING:
inherited from caller</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_to_sense_error">
void <code class="sig-name descname">ata_to_sense_error</code><span class="sig-paren">(</span>unsigned<em> id</em>, u8<em> drv_stat</em>, u8<em> drv_err</em>, u8 *<em> sk</em>, u8 *<em> asc</em>, u8 *<em> ascq</em>, int<em> verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_to_sense_error" title="Permalink to this definition">¶</a></dt>
<dd><p>convert ATA error to SCSI error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">id</span></code></dt><dd><p>ATA device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">drv_stat</span></code></dt><dd><p>value contained in ATA status register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">drv_err</span></code></dt><dd><p>value contained in ATA error register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt><dd><p>the sense key we’ll fill out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">asc</span></code></dt><dd><p>the additional sense code we’ll fill out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ascq</span></code></dt><dd><p>the additional sense code qualifier we’ll fill out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">verbose</span></code></dt><dd><p>be verbose</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Converts an ATA error into a SCSI error.  Fill out pointers to
SK, ASC, and ASCQ bytes for later use in fixed or descriptor
format sense blocks.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_gen_ata_sense">
void <code class="sig-name descname">ata_gen_ata_sense</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_gen_ata_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a SCSI fixed sense block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command that we are erroring out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generate sense block for a failed ATA command <strong>qc</strong>.  Descriptor
format is used to accommodate LBA48 block address.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_drain_needed">
int <code class="sig-name descname">atapi_drain_needed</code><span class="sig-paren">(</span>struct request *<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_drain_needed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether data transfer may overflow</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt><dd><p>request to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>ATAPI commands which transfer variable length data to host
might overflow due to application error or hardware bug.  This
function checks whether overflow should be drained and ignored
for <strong>request</strong>.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>1 if ; otherwise, 0.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_start_stop_xlat">
unsigned int <code class="sig-name descname">ata_scsi_start_stop_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_start_stop_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate SCSI START STOP UNIT command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY
(to start). Perhaps these commands should be preceded by
CHECK POWER MODE to see what power mode the device is already in.
[See SAT revision 5 at www.t10.org]</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_flush_xlat">
unsigned int <code class="sig-name descname">ata_scsi_flush_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_flush_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate SCSI SYNCHRONIZE CACHE command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Sets up an ATA taskfile to issue FLUSH CACHE or
FLUSH CACHE EXT.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_6_lba_len">
void <code class="sig-name descname">scsi_6_lba_len</code><span class="sig-paren">(</span>const u8 *<em> cdb</em>, u64 *<em> plba</em>, u32 *<em> plen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_6_lba_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LBA and transfer length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt><dd><p>SCSI command to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">plba</span></code></dt><dd><p>the LBA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">plen</span></code></dt><dd><p>the transfer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Calculate LBA and transfer length for 6-byte commands.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_10_lba_len">
void <code class="sig-name descname">scsi_10_lba_len</code><span class="sig-paren">(</span>const u8 *<em> cdb</em>, u64 *<em> plba</em>, u32 *<em> plen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_10_lba_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LBA and transfer length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt><dd><p>SCSI command to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">plba</span></code></dt><dd><p>the LBA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">plen</span></code></dt><dd><p>the transfer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Calculate LBA and transfer length for 10-byte commands.</p>
</div></blockquote>
<dl class="function">
<dt id="c.scsi_16_lba_len">
void <code class="sig-name descname">scsi_16_lba_len</code><span class="sig-paren">(</span>const u8 *<em> cdb</em>, u64 *<em> plba</em>, u32 *<em> plen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_16_lba_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LBA and transfer length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt><dd><p>SCSI command to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">plba</span></code></dt><dd><p>the LBA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">plen</span></code></dt><dd><p>the transfer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Calculate LBA and transfer length for 16-byte commands.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_verify_xlat">
unsigned int <code class="sig-name descname">ata_scsi_verify_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_verify_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate SCSI VERIFY command into an ATA one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Converts SCSI VERIFY command to an ATA READ VERIFY command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_rw_xlat">
unsigned int <code class="sig-name descname">ata_scsi_rw_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_rw_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate SCSI r/w command into an ATA one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Converts any of six SCSI read/write commands into the
ATA counterpart, including starting sector (LBA),
sector count, and taking into account the device’s LBA48
support.</p>
<p>Commands <code class="docutils literal notranslate"><span class="pre">READ_6</span></code>, <code class="docutils literal notranslate"><span class="pre">READ_10</span></code>, <code class="docutils literal notranslate"><span class="pre">READ_16</span></code>, <code class="docutils literal notranslate"><span class="pre">WRITE_6</span></code>, <code class="docutils literal notranslate"><span class="pre">WRITE_10</span></code>, and
<code class="docutils literal notranslate"><span class="pre">WRITE_16</span></code> are currently supported.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_translate">
int <code class="sig-name descname">ata_scsi_translate</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct scsi_cmnd *<em> cmd</em>, ata_xlat_func_t<em> xlat_func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate then issue SCSI command to ATA device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to which the command is addressed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command to execute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ata_xlat_func_t</span> <span class="pre">xlat_func</span></code></dt><dd><p>Actor which translates <strong>cmd</strong> to an ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Our -&gt;queuecommand() function has decided that the SCSI
command issued can be directly translated into an ATA
command, rather than handled internally.</p>
<p>This function sets up an ata_queued_cmd structure for the
SCSI command, and sends that ata_queued_cmd to the hardware.</p>
<p>The xlat_func argument (actor) returns 0 if ready to execute
ATA command, else 1 to finish translation. If 1 is returned
then cmd-&gt;result (and possibly cmd-&gt;sense_buffer) are assumed
to be set reflecting an error condition or clean (early)
termination.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, SCSI_ML_QUEUE_DEVICE_BUSY if the command
needs to be deferred.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_rbuf_get">
void * <code class="sig-name descname">ata_scsi_rbuf_get</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em>, bool<em> copy_in</em>, unsigned long *<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_rbuf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Map response buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command containing buffer to be mapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">copy_in</span></code></dt><dd><p>copy in from user buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt><dd><p>unsigned long variable to store irq enable status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Prepare buffer for simulated SCSI commands.</p>
<p>LOCKING:
spin_lock_irqsave(ata_scsi_rbuf_lock) on success</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to response buffer.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_rbuf_put">
void <code class="sig-name descname">ata_scsi_rbuf_put</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em>, bool<em> copy_out</em>, unsigned long *<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_rbuf_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap response buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command containing buffer to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">copy_out</span></code></dt><dd><p>copy out result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt><dd><p><strong>flags</strong> passed to <a class="reference internal" href="#c.ata_scsi_rbuf_get" title="ata_scsi_rbuf_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ata_scsi_rbuf_get()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns rbuf buffer.  The result is copied to <strong>cmd</strong>’s buffer if
<strong>copy_back</strong> is true.</p>
<p>LOCKING:
Unlocks ata_scsi_rbuf_lock.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_rbuf_fill">
void <code class="sig-name descname">ata_scsi_rbuf_fill</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, unsigned int (*actor) (struct ata_scsi_args<em> *args</em>, u8<em> *rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_rbuf_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for SCSI command simulators</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*args,</span> <span class="pre">u8</span> <span class="pre">*rbuf)</span> <span class="pre">actor</span></code></dt><dd><p>Callback hook for desired SCSI command simulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Takes care of the hard work of simulating a SCSI command…
Mapping the response buffer, calling the command’s handler,
and handling the handler’s return value.  This return value
indicates whether the handler wishes the SCSI command to be
completed successfully (0), or not (in which case cmd-&gt;result
and sense buffer are assumed to be set).</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_inq_std">
unsigned int <code class="sig-name descname">ata_scsiop_inq_std</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_inq_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate INQUIRY command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns standard device identification data associated
with non-VPD INQUIRY command output.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_inq_00">
unsigned int <code class="sig-name descname">ata_scsiop_inq_00</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_inq_00" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate INQUIRY VPD page 0, list of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns list of inquiry VPD pages available.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_inq_80">
unsigned int <code class="sig-name descname">ata_scsiop_inq_80</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_inq_80" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate INQUIRY VPD page 80, device serial number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns ATA device serial number.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_inq_83">
unsigned int <code class="sig-name descname">ata_scsiop_inq_83</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_inq_83" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate INQUIRY VPD page 83, device identity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><dl class="simple">
<dt>Yields two logical unit device identification designators:</dt><dd><ul class="simple">
<li><p>vendor specific ASCII containing the ATA serial number</p></li>
<li><p>SAT defined “t10 vendor id based” containing ASCII vendor
name (“ATA     “), model and serial numbers.</p></li>
</ul>
</dd>
</dl>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_inq_89">
unsigned int <code class="sig-name descname">ata_scsiop_inq_89</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_inq_89" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate INQUIRY VPD page 89, ATA info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Yields SAT-specified ATA VPD page.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.modecpy">
void <code class="sig-name descname">modecpy</code><span class="sig-paren">(</span>u8 *<em> dest</em>, const u8 *<em> src</em>, int<em> n</em>, bool<em> changeable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.modecpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare response for MODE SENSE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>data being copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>length of mode page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changeable</span></code></dt><dd><p>whether changeable parameters are requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generate a generic MODE SENSE page for either current or changeable
parameters.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_msense_caching">
unsigned int <code class="sig-name descname">ata_msense_caching</code><span class="sig-paren">(</span>u16 *<em> id</em>, u8 *<em> buf</em>, bool<em> changeable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_msense_caching" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SENSE caching info page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>device IDENTIFY data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changeable</span></code></dt><dd><p>whether changeable parameters are requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generate a caching info page, which conditionally indicates
write caching to the SCSI layer, depending on device
capabilities.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_msense_control">
unsigned int <code class="sig-name descname">ata_msense_control</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8 *<em> buf</em>, bool<em> changeable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_msense_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SENSE control mode page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changeable</span></code></dt><dd><p>whether changeable parameters are requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generate a generic MODE SENSE control mode page.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_msense_rw_recovery">
unsigned int <code class="sig-name descname">ata_msense_rw_recovery</code><span class="sig-paren">(</span>u8 *<em> buf</em>, bool<em> changeable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_msense_rw_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SENSE r/w error recovery page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changeable</span></code></dt><dd><p>whether changeable parameters are requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generate a generic MODE SENSE r/w error recovery page.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_mode_sense">
unsigned int <code class="sig-name descname">ata_scsiop_mode_sense</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_mode_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SENSE 6, 10 commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Simulate MODE SENSE commands. Assume this is invoked for direct
access devices (e.g. disks) only. There should be no block
descriptor for other device types.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_read_cap">
unsigned int <code class="sig-name descname">ata_scsiop_read_cap</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_read_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate READ CAPACITY[ 16] commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Simulate READ CAPACITY commands.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_report_luns">
unsigned int <code class="sig-name descname">ata_scsiop_report_luns</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_report_luns" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate REPORT LUNS command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device IDENTIFY data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Simulate REPORT LUNS command.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.atapi_xlat">
unsigned int <code class="sig-name descname">atapi_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atapi_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize PACKET taskfile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>command structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_find_dev">
struct ata_device * <code class="sig-name descname">ata_scsi_find_dev</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, const struct scsi_device *<em> scsidev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_find_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup ata_device from scsi_cmnd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to which the device is attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*</span> <span class="pre">scsidev</span></code></dt><dd><p>SCSI device from which we derive the ATA device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Given various information provided in struct scsi_cmnd,
map that onto an ATA bus, and using that mapping
determine which ata_device is associated with the
SCSI command to be sent.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Associated ATA device, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not found.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_pass_thru">
unsigned int <code class="sig-name descname">ata_scsi_pass_thru</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_pass_thru" title="Permalink to this definition">¶</a></dt>
<dd><p>convert ATA pass-thru CDB to taskfile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>command structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Handles either 12, 16, or 32-byte versions of the CDB.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_format_dsm_trim_descr">
size_t <code class="sig-name descname">ata_format_dsm_trim_descr</code><span class="sig-paren">(</span>struct scsi_cmnd *<em> cmd</em>, u32<em> trmax</em>, u64<em> sector</em>, u32<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_format_dsm_trim_descr" title="Permalink to this definition">¶</a></dt>
<dd><p>SATL Write Same to DSM Trim</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command being translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">trmax</span></code></dt><dd><p>Maximum number of entries that will fit in sector_size bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">sector</span></code></dt><dd><p>Starting sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">count</span></code></dt><dd><p>Total Range of request in logical sectors</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rewrite the WRITE SAME descriptor to be a DSM TRIM little-endian formatted
descriptor.</p>
<dl>
<dt>Upto 64 entries of the format:</dt><dd><blockquote>
<div><p>63:48 Range Length
47:0  LBA</p>
</div></blockquote>
<p>Range Length of 0 is ignored.
LBA’s should be sorted order and not overlap.</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>this is the same format as ADD LBA(S) TO NV CACHE PINNED SET</p>
<p><strong>Return</strong></p>
<p>Number of bytes copied into sglist.</p>
<dl class="function">
<dt id="c.ata_scsi_write_same_xlat">
unsigned int <code class="sig-name descname">ata_scsi_write_same_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_write_same_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>SATL Write Same to ATA SCT Write Same</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to be translated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Translate a SCSI WRITE SAME command to be either a DSM TRIM command or
an SCT Write Same command.
Based on WRITE SAME has the UNMAP flag:</p>
<blockquote>
<div><ul class="simple">
<li><p>When set translate to DSM TRIM</p></li>
<li><p>When clear translate to SCT Write Same</p></li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsiop_maint_in">
unsigned int <code class="sig-name descname">ata_scsiop_maint_in</code><span class="sig-paren">(</span>struct ata_scsi_args *<em> args</em>, u8 *<em> rbuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsiop_maint_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a subset of MAINTENANCE_IN</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_scsi_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt><dd><p>device MAINTENANCE_IN data / SCSI command of interest.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rbuf</span></code></dt><dd><p>Response buffer, to which simulated SCSI cmd output is sent.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Yields a subset to satisfy <a class="reference internal" href="scsi.html#c.scsi_report_opcode" title="scsi_report_opcode"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_report_opcode()</span></code></a></p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_report_zones_complete">
void <code class="sig-name descname">ata_scsi_report_zones_complete</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_report_zones_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>convert ATA output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>command structure returning the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Convert T-13 little-endian field representation into
T-10 big-endian field representation.
What a mess.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_mselect_caching">
int <code class="sig-name descname">ata_mselect_caching</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em>, const u8 *<em> buf</em>, int<em> len</em>, u16 *<em> fp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_mselect_caching" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SELECT for caching info page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of valid bytes in the input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">fp</span></code></dt><dd><p>out parameter for the failed field on error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Prepare a taskfile to modify caching information for the device.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_mselect_control">
int <code class="sig-name descname">ata_mselect_control</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em>, const u8 *<em> buf</em>, int<em> len</em>, u16 *<em> fp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_mselect_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SELECT for control page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of valid bytes in the input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">fp</span></code></dt><dd><p>out parameter for the failed field on error</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Prepare a taskfile to modify caching information for the device.</p>
<p>LOCKING:
None.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_mode_select_xlat">
unsigned int <code class="sig-name descname">ata_scsi_mode_select_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_mode_select_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate MODE SELECT 6, 10 commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Storage for translated ATA taskfile</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Converts a MODE SELECT command to an ATA SET FEATURES taskfile.
Assume this is invoked for direct access devices (e.g. disks) only.
There should be no block descriptor for other device types.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_var_len_cdb_xlat">
unsigned int <code class="sig-name descname">ata_scsi_var_len_cdb_xlat</code><span class="sig-paren">(</span>struct ata_queued_cmd *<em> qc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_var_len_cdb_xlat" title="Permalink to this definition">¶</a></dt>
<dd><p>SATL variable length CDB to Handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_queued_cmd</span> <span class="pre">*</span> <span class="pre">qc</span></code></dt><dd><p>Command to be translated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Translate a SCSI variable length CDB to specified commands.
It checks a service action value in CDB to call corresponding handler.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, non-zero on failure</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_get_xlat_func">
ata_xlat_func_t <code class="sig-name descname">ata_get_xlat_func</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_get_xlat_func" title="Permalink to this definition">¶</a></dt>
<dd><p>check if SCSI to ATA translation is possible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command opcode to consider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Look up the SCSI command given, and determine whether the
SCSI command is to be translated or simulated.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to translation function if possible, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_dump_cdb">
void <code class="sig-name descname">ata_scsi_dump_cdb</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_dump_cdb" title="Permalink to this definition">¶</a></dt>
<dd><p>dump SCSI command contents to dmesg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>ATA port to which the command was being sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command to dump</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Prints the contents of a SCSI command via <a class="reference internal" href="basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_simulate">
void <code class="sig-name descname">ata_scsi_simulate</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em>, struct scsi_cmnd *<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>simulate SCSI command on ATA device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt><dd><p>SCSI command being sent to device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Interprets and directly executes a select list of SCSI commands
that can be handled internally.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_offline_dev">
int <code class="sig-name descname">ata_scsi_offline_dev</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_offline_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>offline attached SCSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to offline attached SCSI device for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called from ata_eh_hotplug() and responsible
for taking the SCSI device attached to <strong>dev</strong> offline.  This
function is called with host lock which protects dev-&gt;sdev
against clearing.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>1 if attached SCSI device exists, 0 otherwise.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_remove_dev">
void <code class="sig-name descname">ata_scsi_remove_dev</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_remove_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>remove attached SCSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>ATA device to remove attached SCSI device for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called from ata_eh_scsi_hotplug() and
responsible for removing the SCSI device attached to <strong>dev</strong>.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_media_change_notify">
void <code class="sig-name descname">ata_scsi_media_change_notify</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_media_change_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>send media change event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Pointer to the disk device with media change event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Tell the block layer to send a media change notification
event.</p>
<p>LOCKING:
spin_lock_irqsave(host lock)</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_hotplug">
void <code class="sig-name descname">ata_scsi_hotplug</code><span class="sig-paren">(</span>struct work_struct *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_hotplug" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI part of hotplug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>Pointer to ATA port to perform SCSI hotplug on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Perform SCSI part of hotplug.  It’s executed from a separate
workqueue after EH completes.  This is necessary because SCSI
hot plugging requires working EH and hot unplugging is
synchronized with hot plugging with a mutex.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_user_scan">
int <code class="sig-name descname">ata_scsi_user_scan</code><span class="sig-paren">(</span>struct Scsi_Host *<em> shost</em>, unsigned int<em> channel</em>, unsigned int<em> id</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_user_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>indication for user-initiated bus scan</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt><dd><p>SCSI host to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>Channel to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>ID to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>LUN to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called when user explicitly requests bus
scan.  Set probe pending flag and invoke EH.</p>
<p>LOCKING:
SCSI layer (we don’t care)</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ata_scsi_dev_rescan">
void <code class="sig-name descname">ata_scsi_dev_rescan</code><span class="sig-paren">(</span>struct work_struct *<em> work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ata_scsi_dev_rescan" title="Permalink to this definition">¶</a></dt>
<dd><p>initiate scsi_rescan_device()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt><dd><p>Pointer to ATA port to perform scsi_rescan_device()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After ATA pass thru (SAT) commands are executed successfully,
libata need to propagate the changes to SCSI layer.</p>
<p>LOCKING:
Kernel thread context (may sleep).</p>
</div></blockquote>
</div>
<div class="section" id="ata-errors-and-exceptions">
<h2>ATA errors and exceptions<a class="headerlink" href="#ata-errors-and-exceptions" title="Permalink to this headline">¶</a></h2>
<p>This chapter tries to identify what error/exception conditions exist for
ATA/ATAPI devices and describe how they should be handled in
implementation-neutral way.</p>
<p>The term ‘error’ is used to describe conditions where either an explicit
error condition is reported from device or a command has timed out.</p>
<p>The term ‘exception’ is either used to describe exceptional conditions
which are not errors (say, power or hotplug events), or to describe both
errors and non-error exceptional conditions. Where explicit distinction
between error and exception is necessary, the term ‘non-error exception’
is used.</p>
<div class="section" id="exception-categories">
<h3>Exception categories<a class="headerlink" href="#exception-categories" title="Permalink to this headline">¶</a></h3>
<p>Exceptions are described primarily with respect to legacy taskfile + bus
master IDE interface. If a controller provides other better mechanism
for error reporting, mapping those into categories described below
shouldn’t be difficult.</p>
<p>In the following sections, two recovery actions - reset and
reconfiguring transport - are mentioned. These are described further in
<a class="reference external" href="#exrec">EH recovery actions</a>.</p>
<div class="section" id="hsm-violation">
<h4>HSM violation<a class="headerlink" href="#hsm-violation" title="Permalink to this headline">¶</a></h4>
<p>This error is indicated when STATUS value doesn’t match HSM requirement
during issuing or execution any ATA/ATAPI command.</p>
<ul class="simple">
<li><p>ATA_STATUS doesn’t contain !BSY &amp;&amp; DRDY &amp;&amp; !DRQ while trying to
issue a command.</p></li>
<li><p>!BSY &amp;&amp; !DRQ during PIO data transfer.</p></li>
<li><p>DRQ on command completion.</p></li>
<li><p>!BSY &amp;&amp; ERR after CDB transfer starts but before the last byte of CDB
is transferred. ATA/ATAPI standard states that “The device shall not
terminate the PACKET command with an error before the last byte of
the command packet has been written” in the error outputs description
of PACKET command and the state diagram doesn’t include such
transitions.</p></li>
</ul>
<p>In these cases, HSM is violated and not much information regarding the
error can be acquired from STATUS or ERROR register. IOW, this error can
be anything - driver bug, faulty device, controller and/or cable.</p>
<p>As HSM is violated, reset is necessary to restore known state.
Reconfiguring transport for lower speed might be helpful too as
transmission errors sometimes cause this kind of errors.</p>
</div>
<div class="section" id="ata-atapi-device-error-non-ncq-non-check-condition">
<h4>ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)<a class="headerlink" href="#ata-atapi-device-error-non-ncq-non-check-condition" title="Permalink to this headline">¶</a></h4>
<p>These are errors detected and reported by ATA/ATAPI devices indicating
device problems. For this type of errors, STATUS and ERROR register
values are valid and describe error condition. Note that some of ATA bus
errors are detected by ATA/ATAPI devices and reported using the same
mechanism as device errors. Those cases are described later in this
section.</p>
<p>For ATA commands, this type of errors are indicated by !BSY &amp;&amp; ERR
during command execution and on completion.</p>
<p>For ATAPI commands,</p>
<ul class="simple">
<li><p>!BSY &amp;&amp; ERR &amp;&amp; ABRT right after issuing PACKET indicates that PACKET
command is not supported and falls in this category.</p></li>
<li><p>!BSY &amp;&amp; ERR(==CHK) &amp;&amp; !ABRT after the last byte of CDB is transferred
indicates CHECK CONDITION and doesn’t fall in this category.</p></li>
<li><p>!BSY &amp;&amp; ERR(==CHK) &amp;&amp; ABRT after the last byte of CDB is transferred
*probably* indicates CHECK CONDITION and doesn’t fall in this
category.</p></li>
</ul>
<p>Of errors detected as above, the following are not ATA/ATAPI device
errors but ATA bus errors and should be handled according to
<a class="reference external" href="#excatATAbusErr">ATA bus error</a>.</p>
<dl>
<dt>CRC error during data transfer</dt><dd><p>This is indicated by ICRC bit in the ERROR register and means that
corruption occurred during data transfer. Up to ATA/ATAPI-7, the
standard specifies that this bit is only applicable to UDMA
transfers but ATA/ATAPI-8 draft revision 1f says that the bit may be
applicable to multiword DMA and PIO.</p>
</dd>
<dt>ABRT error during data transfer or on completion</dt><dd><p>Up to ATA/ATAPI-7, the standard specifies that ABRT could be set on
ICRC errors and on cases where a device is not able to complete a
command. Combined with the fact that MWDMA and PIO transfer errors
aren’t allowed to use ICRC bit up to ATA/ATAPI-7, it seems to imply
that ABRT bit alone could indicate transfer errors.</p>
<p>However, ATA/ATAPI-8 draft revision 1f removes the part that ICRC
errors can turn on ABRT. So, this is kind of gray area. Some
heuristics are needed here.</p>
</dd>
</dl>
<p>ATA/ATAPI device errors can be further categorized as follows.</p>
<dl>
<dt>Media errors</dt><dd><p>This is indicated by UNC bit in the ERROR register. ATA devices
reports UNC error only after certain number of retries cannot
recover the data, so there’s nothing much else to do other than
notifying upper layer.</p>
<p>READ and WRITE commands report CHS or LBA of the first failed sector
but ATA/ATAPI standard specifies that the amount of transferred data
on error completion is indeterminate, so we cannot assume that
sectors preceding the failed sector have been transferred and thus
cannot complete those sectors successfully as SCSI does.</p>
</dd>
<dt>Media changed / media change requested error</dt><dd><p>&lt;&lt;TODO: fill here&gt;&gt;</p>
</dd>
<dt>Address error</dt><dd><p>This is indicated by IDNF bit in the ERROR register. Report to upper
layer.</p>
</dd>
<dt>Other errors</dt><dd><p>This can be invalid command or parameter indicated by ABRT ERROR bit
or some other error condition. Note that ABRT bit can indicate a lot
of things including ICRC and Address errors. Heuristics needed.</p>
</dd>
</dl>
<p>Depending on commands, not all STATUS/ERROR bits are applicable. These
non-applicable bits are marked with “na” in the output descriptions but
up to ATA/ATAPI-7 no definition of “na” can be found. However,
ATA/ATAPI-8 draft revision 1f describes “N/A” as follows.</p>
<blockquote>
<div><dl class="simple">
<dt>3.2.3.3a N/A</dt><dd><p>A keyword the indicates a field has no defined value in this
standard and should not be checked by the host or device. N/A
fields should be cleared to zero.</p>
</dd>
</dl>
</div></blockquote>
<p>So, it seems reasonable to assume that “na” bits are cleared to zero by
devices and thus need no explicit masking.</p>
</div>
<div class="section" id="atapi-device-check-condition">
<h4>ATAPI device CHECK CONDITION<a class="headerlink" href="#atapi-device-check-condition" title="Permalink to this headline">¶</a></h4>
<p>ATAPI device CHECK CONDITION error is indicated by set CHK bit (ERR bit)
in the STATUS register after the last byte of CDB is transferred for a
PACKET command. For this kind of errors, sense data should be acquired
to gather information regarding the errors. REQUEST SENSE packet command
should be used to acquire sense data.</p>
<p>Once sense data is acquired, this type of errors can be handled
similarly to other SCSI errors. Note that sense data may indicate ATA
bus error (e.g. Sense Key 04h HARDWARE ERROR &amp;&amp; ASC/ASCQ 47h/00h SCSI
PARITY ERROR). In such cases, the error should be considered as an ATA
bus error and handled according to <a class="reference external" href="#excatATAbusErr">ATA bus error</a>.</p>
</div>
<div class="section" id="ata-device-error-ncq">
<h4>ATA device error (NCQ)<a class="headerlink" href="#ata-device-error-ncq" title="Permalink to this headline">¶</a></h4>
<p>NCQ command error is indicated by cleared BSY and set ERR bit during NCQ
command phase (one or more NCQ commands outstanding). Although STATUS
and ERROR registers will contain valid values describing the error, READ
LOG EXT is required to clear the error condition, determine which
command has failed and acquire more information.</p>
<p>READ LOG EXT Log Page 10h reports which tag has failed and taskfile
register values describing the error. With this information the failed
command can be handled as a normal ATA command error as in
<a class="reference external" href="#excatDevErr">ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</a>
and all other in-flight commands must be retried. Note that this retry
should not be counted - it’s likely that commands retried this way would
have completed normally if it were not for the failed command.</p>
<p>Note that ATA bus errors can be reported as ATA device NCQ errors. This
should be handled as described in <a class="reference external" href="#excatATAbusErr">ATA bus error</a>.</p>
<p>If READ LOG EXT Log Page 10h fails or reports NQ, we’re thoroughly
screwed. This condition should be treated according to
<a class="reference external" href="#excatHSMviolation">HSM violation</a>.</p>
</div>
<div class="section" id="ata-bus-error">
<h4>ATA bus error<a class="headerlink" href="#ata-bus-error" title="Permalink to this headline">¶</a></h4>
<p>ATA bus error means that data corruption occurred during transmission
over ATA bus (SATA or PATA). This type of errors can be indicated by</p>
<ul class="simple">
<li><p>ICRC or ABRT error as described in
<a class="reference external" href="#excatDevErr">ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</a>.</p></li>
<li><p>Controller-specific error completion with error information
indicating transmission error.</p></li>
<li><p>On some controllers, command timeout. In this case, there may be a
mechanism to determine that the timeout is due to transmission error.</p></li>
<li><p>Unknown/random errors, timeouts and all sorts of weirdities.</p></li>
</ul>
<p>As described above, transmission errors can cause wide variety of
symptoms ranging from device ICRC error to random device lockup, and,
for many cases, there is no way to tell if an error condition is due to
transmission error or not; therefore, it’s necessary to employ some kind
of heuristic when dealing with errors and timeouts. For example,
encountering repetitive ABRT errors for known supported command is
likely to indicate ATA bus error.</p>
<p>Once it’s determined that ATA bus errors have possibly occurred,
lowering ATA bus transmission speed is one of actions which may
alleviate the problem. See <a class="reference external" href="#exrecReconf">Reconfigure transport</a> for
more information.</p>
</div>
<div class="section" id="pci-bus-error">
<h4>PCI bus error<a class="headerlink" href="#pci-bus-error" title="Permalink to this headline">¶</a></h4>
<p>Data corruption or other failures during transmission over PCI (or other
system bus). For standard BMDMA, this is indicated by Error bit in the
BMDMA Status register. This type of errors must be logged as it
indicates something is very wrong with the system. Resetting host
controller is recommended.</p>
</div>
<div class="section" id="late-completion">
<h4>Late completion<a class="headerlink" href="#late-completion" title="Permalink to this headline">¶</a></h4>
<p>This occurs when timeout occurs and the timeout handler finds out that
the timed out command has completed successfully or with error. This is
usually caused by lost interrupts. This type of errors must be logged.
Resetting host controller is recommended.</p>
</div>
<div class="section" id="unknown-error-timeout">
<h4>Unknown error (timeout)<a class="headerlink" href="#unknown-error-timeout" title="Permalink to this headline">¶</a></h4>
<p>This is when timeout occurs and the command is still processing or the
host and device are in unknown state. When this occurs, HSM could be in
any valid or invalid state. To bring the device to known state and make
it forget about the timed out command, resetting is necessary. The timed
out command may be retried.</p>
<p>Timeouts can also be caused by transmission errors. Refer to
<a class="reference external" href="#excatATAbusErr">ATA bus error</a> for more details.</p>
</div>
<div class="section" id="hotplug-and-power-management-exceptions">
<h4>Hotplug and power management exceptions<a class="headerlink" href="#hotplug-and-power-management-exceptions" title="Permalink to this headline">¶</a></h4>
<p>&lt;&lt;TODO: fill here&gt;&gt;</p>
</div>
</div>
<div class="section" id="eh-recovery-actions">
<h3>EH recovery actions<a class="headerlink" href="#eh-recovery-actions" title="Permalink to this headline">¶</a></h3>
<p>This section discusses several important recovery actions.</p>
<div class="section" id="clearing-error-condition">
<h4>Clearing error condition<a class="headerlink" href="#clearing-error-condition" title="Permalink to this headline">¶</a></h4>
<p>Many controllers require its error registers to be cleared by error
handler. Different controllers may have different requirements.</p>
<p>For SATA, it’s strongly recommended to clear at least SError register
during error handling.</p>
</div>
<div class="section" id="reset">
<h4>Reset<a class="headerlink" href="#reset" title="Permalink to this headline">¶</a></h4>
<p>During EH, resetting is necessary in the following cases.</p>
<ul class="simple">
<li><p>HSM is in unknown or invalid state</p></li>
<li><p>HBA is in unknown or invalid state</p></li>
<li><p>EH needs to make HBA/device forget about in-flight commands</p></li>
<li><p>HBA/device behaves weirdly</p></li>
</ul>
<p>Resetting during EH might be a good idea regardless of error condition
to improve EH robustness. Whether to reset both or either one of HBA and
device depends on situation but the following scheme is recommended.</p>
<ul class="simple">
<li><p>When it’s known that HBA is in ready state but ATA/ATAPI device is in
unknown state, reset only device.</p></li>
<li><p>If HBA is in unknown state, reset both HBA and device.</p></li>
</ul>
<p>HBA resetting is implementation specific. For a controller complying to
taskfile/BMDMA PCI IDE, stopping active DMA transaction may be
sufficient iff BMDMA state is the only HBA context. But even mostly
taskfile/BMDMA PCI IDE complying controllers may have implementation
specific requirements and mechanism to reset themselves. This must be
addressed by specific drivers.</p>
<p>OTOH, ATA/ATAPI standard describes in detail ways to reset ATA/ATAPI
devices.</p>
<dl>
<dt>PATA hardware reset</dt><dd><p>This is hardware initiated device reset signalled with asserted PATA
RESET- signal. There is no standard way to initiate hardware reset
from software although some hardware provides registers that allow
driver to directly tweak the RESET- signal.</p>
</dd>
<dt>Software reset</dt><dd><p>This is achieved by turning CONTROL SRST bit on for at least 5us.
Both PATA and SATA support it but, in case of SATA, this may require
controller-specific support as the second Register FIS to clear SRST
should be transmitted while BSY bit is still set. Note that on PATA,
this resets both master and slave devices on a channel.</p>
</dd>
<dt>EXECUTE DEVICE DIAGNOSTIC command</dt><dd><p>Although ATA/ATAPI standard doesn’t describe exactly, EDD implies
some level of resetting, possibly similar level with software reset.
Host-side EDD protocol can be handled with normal command processing
and most SATA controllers should be able to handle EDD’s just like
other commands. As in software reset, EDD affects both devices on a
PATA bus.</p>
<p>Although EDD does reset devices, this doesn’t suit error handling as
EDD cannot be issued while BSY is set and it’s unclear how it will
act when device is in unknown/weird state.</p>
</dd>
<dt>ATAPI DEVICE RESET command</dt><dd><p>This is very similar to software reset except that reset can be
restricted to the selected device without affecting the other device
sharing the cable.</p>
</dd>
<dt>SATA phy reset</dt><dd><p>This is the preferred way of resetting a SATA device. In effect,
it’s identical to PATA hardware reset. Note that this can be done
with the standard SCR Control register. As such, it’s usually easier
to implement than software reset.</p>
</dd>
</dl>
<p>One more thing to consider when resetting devices is that resetting
clears certain configuration parameters and they need to be set to their
previous or newly adjusted values after reset.</p>
<p>Parameters affected are.</p>
<ul class="simple">
<li><p>CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)</p></li>
<li><p>Parameters set with SET FEATURES including transfer mode setting</p></li>
<li><p>Block count set with SET MULTIPLE MODE</p></li>
<li><p>Other parameters (SET MAX, MEDIA LOCK…)</p></li>
</ul>
<p>ATA/ATAPI standard specifies that some parameters must be maintained
across hardware or software reset, but doesn’t strictly specify all of
them. Always reconfiguring needed parameters after reset is required for
robustness. Note that this also applies when resuming from deep sleep
(power-off).</p>
<p>Also, ATA/ATAPI standard requires that IDENTIFY DEVICE / IDENTIFY PACKET
DEVICE is issued after any configuration parameter is updated or a
hardware reset and the result used for further operation. OS driver is
required to implement revalidation mechanism to support this.</p>
</div>
<div class="section" id="reconfigure-transport">
<h4>Reconfigure transport<a class="headerlink" href="#reconfigure-transport" title="Permalink to this headline">¶</a></h4>
<p>For both PATA and SATA, a lot of corners are cut for cheap connectors,
cables or controllers and it’s quite common to see high transmission
error rate. This can be mitigated by lowering transmission speed.</p>
<p>The following is a possible scheme Jeff Garzik suggested.</p>
<blockquote>
<div><p>If more than $N (3?) transmission errors happen in 15 minutes,</p>
<ul class="simple">
<li><p>if SATA, decrease SATA PHY speed. if speed cannot be decreased,</p></li>
<li><p>decrease UDMA xfer speed. if at UDMA0, switch to PIO4,</p></li>
<li><p>decrease PIO xfer speed. if at PIO3, complain, but continue</p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="ata-piix-internals">
<h2>ata_piix Internals<a class="headerlink" href="#ata-piix-internals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ich_pata_cable_detect">
int <code class="sig-name descname">ich_pata_cable_detect</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ich_pata_cable_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Probe host controller cable detect info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port for which cable detect info is desired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read 80c cable indicator from ATA PCI device’s PCI config
register.  This register is normally set by firmware (BIOS).</p>
<p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.piix_pata_prereset">
int <code class="sig-name descname">piix_pata_prereset</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, unsigned long<em> deadline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.piix_pata_prereset" title="Permalink to this definition">¶</a></dt>
<dd><p>prereset for PATA host controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>Target link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">deadline</span></code></dt><dd><p>deadline jiffies for the operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.piix_set_piomode">
void <code class="sig-name descname">piix_set_piomode</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.piix_set_piomode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize host controller PATA PIO timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port whose timings we are configuring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>Drive in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set PIO mode for device, in host controller PCI config space.</p>
<p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.do_pata_set_dmamode">
void <code class="sig-name descname">do_pata_set_dmamode</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct ata_device *<em> adev</em>, int<em> isich</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_pata_set_dmamode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize host controller PATA PIO timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port whose timings we are configuring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>Drive in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">isich</span></code></dt><dd><p>set if the chip is an ICH device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set UDMA mode for device, in host controller PCI config space.</p>
<p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.piix_set_dmamode">
void <code class="sig-name descname">piix_set_dmamode</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.piix_set_dmamode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize host controller PATA DMA timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port whose timings we are configuring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>um</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set MW/UDMA mode for device, in host controller PCI config space.</p>
<p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.ich_set_dmamode">
void <code class="sig-name descname">ich_set_dmamode</code><span class="sig-paren">(</span>struct ata_port *<em> ap</em>, struct ata_device *<em> adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ich_set_dmamode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize host controller PATA DMA timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_port</span> <span class="pre">*</span> <span class="pre">ap</span></code></dt><dd><p>Port whose timings we are configuring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt><dd><p>um</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Set MW/UDMA mode for device, in host controller PCI config space.</p>
<p>LOCKING:
None (inherited from caller).</p>
</div></blockquote>
<dl class="function">
<dt id="c.piix_check_450nx_errata">
int <code class="sig-name descname">piix_check_450nx_errata</code><span class="sig-paren">(</span>struct pci_dev *<em> ata_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.piix_check_450nx_errata" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for problem 450NX setup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">ata_dev</span></code></dt><dd><p>the PCI device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check for the present of 450NX errata #19 and errata #25. If
they are found return an error code so we can turn off DMA</p>
</div></blockquote>
<dl class="function">
<dt id="c.piix_init_one">
int <code class="sig-name descname">piix_init_one</code><span class="sig-paren">(</span>struct pci_dev *<em> pdev</em>, const struct <a class="reference internal" href="basics.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> *<em> ent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.piix_init_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Register PIIX ATA PCI device with kernel services</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt><dd><p>PCI device to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*</span> <span class="pre">ent</span></code></dt><dd><p>Entry in piix_pci_tbl matching with <strong>pdev</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Called from kernel PCI layer.  We probe for combined mode (sigh),
and then hand over control to libata, for it to do the rest.</p>
<p>LOCKING:
Inherited from PCI layer (may sleep).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Zero on success, or -ERRNO value.</p>
</div></blockquote>
</div>
<div class="section" id="sata-sil-internals">
<h2>sata_sil Internals<a class="headerlink" href="#sata-sil-internals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sil_set_mode">
int <code class="sig-name descname">sil_set_mode</code><span class="sig-paren">(</span>struct ata_link *<em> link</em>, struct ata_device **<em> r_failed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sil_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>wrap set_mode functions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt><dd><p>link to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">**</span> <span class="pre">r_failed</span></code></dt><dd><p>returned device when we fail</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wrap the libata method for device setup as after the setup we need
to inspect the results and do some configuration work</p>
</div></blockquote>
<dl class="function">
<dt id="c.sil_dev_config">
void <code class="sig-name descname">sil_dev_config</code><span class="sig-paren">(</span>struct ata_device *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sil_dev_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply device/host-specific errata fixups</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ata_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>Device to be examined</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>After the IDENTIFY [PACKET] DEVICE step is complete, and a
device is known to be present, this function is called.
We apply two errata fixups which are specific to Silicon Image,
a Seagate and a Maxtor fixup.</p>
<p>For certain Seagate devices, we must limit the maximum sectors
to under 8K.</p>
<p>For certain Maxtor devices, we must not program the drive
beyond udma5.</p>
<p>Both fixups are unfairly pessimistic.  As soon as I get more
information on these errata, I will create a more exhaustive
list, and apply the fixups to only the specific
devices/hosts/firmwares that need it.</p>
<p>20040111 - Seagate drives affected by the Mod15Write bug are blacklisted
The Maxtor quirk is in the blacklist, but I’m keeping the original
pessimistic fix for the following reasons…
- There seems to be less info on it, only one device gleaned off the
Windows driver, maybe only one is affected.  More info would be greatly
appreciated.
- But then again UDMA5 is hardly anything to complain about</p>
</div></blockquote>
</div>
<div class="section" id="thanks">
<h2>Thanks<a class="headerlink" href="#thanks" title="Permalink to this headline">¶</a></h2>
<p>The bulk of the ATA knowledge comes thanks to long conversations with
Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA and
SCSI specifications.</p>
<p>Thanks to Alan Cox for pointing out similarities between SATA and SCSI,
and in general for motivation to hack on libata.</p>
<p>libata’s device detection method, ata_pio_devchk, and in general all
the early probing was based on extensive study of Hale Landis’s
probe/reset code in his ATADRVR driver (www.ata-atapi.com).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="target.html" class="btn btn-neutral float-right" title="target and iSCSI Interfaces Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="scsi.html" class="btn btn-neutral float-left" title="SCSI Interfaces Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>