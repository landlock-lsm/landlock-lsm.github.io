

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cfg80211 subsystem &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="mac80211 subsystem (basics)" href="mac80211.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux 802.11 Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">cfg80211 subsystem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-registration">Device registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#actions-and-configuration">Actions and configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scanning-and-bss-list-handling">Scanning and BSS list handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-path-helpers">Data path helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#regulatory-enforcement-infrastructure">Regulatory enforcement infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rfkill-integration">RFkill integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-mode">Test mode</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mac80211.html">mac80211 subsystem (basics)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mac80211-advanced.html">mac80211 subsystem (advanced)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux 802.11 Driver Developer’s Guide</a> &raquo;</li>
        
      <li>cfg80211 subsystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/80211/cfg80211.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cfg80211-subsystem">
<h1>cfg80211 subsystem<a class="headerlink" href="#cfg80211-subsystem" title="Permalink to this headline">¶</a></h1>
<p>cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
userspace and drivers, and offers some utility functionality associated
with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
by all modern wireless drivers in Linux, so that they offer a consistent
API through nl80211. For backward compatibility, cfg80211 also offers
wireless extensions to userspace, but hides them from drivers completely.</p>
<p>Additionally, cfg80211 contains code to help enforce regulatory spectrum
use restrictions.</p>
<div class="section" id="device-registration">
<h2>Device registration<a class="headerlink" href="#device-registration" title="Permalink to this headline">¶</a></h2>
<p>In order for a driver to use cfg80211, it must register the hardware device
with cfg80211. This happens through a number of hardware capability structs
described below.</p>
<p>The fundamental structure for each device is the ‘wiphy’, of which each
instance describes a physical wireless device connected to the system. Each
such wiphy can have zero, one, or many virtual interfaces associated with
it, which need to be identified as such by pointing the network interface’s
<strong>ieee80211_ptr</strong> pointer to a <a class="reference internal" href="#c.wireless_dev" title="wireless_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span></code></a> which further describes
the wireless part of the interface, normally this struct is embedded in the
network interface’s private data area. Drivers can optionally allow creating
or destroying virtual interfaces on the fly, but without at least one or the
ability to create some the wireless device isn’t useful.</p>
<p>Each wiphy structure contains device capability information, and also has
a pointer to the various operations the driver offers. The definitions and
structures here describe these capabilities in detail.</p>
<dl class="type">
<dt id="c.ieee80211_channel_flags">
enum <code class="sig-name descname">ieee80211_channel_flags</code><a class="headerlink" href="#c.ieee80211_channel_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>channel flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_DISABLED</span></code></dt><dd><p>This channel is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_IR</span></code></dt><dd><p>do not initiate radiation, this includes
sending probe requests or beaconing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_RADAR</span></code></dt><dd><p>Radar detection is required on this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_HT40PLUS</span></code></dt><dd><p>extension channel above this channel
is not permitted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_HT40MINUS</span></code></dt><dd><p>extension channel below this channel
is not permitted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_OFDM</span></code></dt><dd><p>OFDM is not allowed on this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_80MHZ</span></code></dt><dd><p>If the driver supports 80 MHz on the band,
this flag indicates that an 80 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_160MHZ</span></code></dt><dd><p>If the driver supports 160 MHz on the band,
this flag indicates that an 160 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_INDOOR_ONLY</span></code></dt><dd><p>see <code class="docutils literal notranslate"><span class="pre">NL80211_FREQUENCY_ATTR_INDOOR_ONLY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_IR_CONCURRENT</span></code></dt><dd><p>see <code class="docutils literal notranslate"><span class="pre">NL80211_FREQUENCY_ATTR_IR_CONCURRENT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_20MHZ</span></code></dt><dd><p>20 MHz bandwidth is not permitted
on this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_10MHZ</span></code></dt><dd><p>10 MHz bandwidth is not permitted
on this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_CHAN_NO_HE</span></code></dt><dd><p>HE operation is not permitted on this channel.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Channel flags set by the regulatory control code.</p>
<dl class="type">
<dt id="c.ieee80211_channel">
struct <code class="sig-name descname">ieee80211_channel</code><a class="headerlink" href="#c.ieee80211_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>channel definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_channel {
  enum nl80211_band band;
  u32 center_freq;
  u16 hw_value;
  u32 flags;
  int max_antenna_gain;
  int max_power;
  int max_reg_power;
  bool beacon_found;
  u32 orig_flags;
  int orig_mag, orig_mpwr;
  enum nl80211_dfs_state dfs_state;
  unsigned long dfs_state_entered;
  unsigned int dfs_cac_ms;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">band</span></code></dt><dd><p>band this channel belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">center_freq</span></code></dt><dd><p>center frequency in MHz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_value</span></code></dt><dd><p>hardware-specific value for the channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>channel flags from <a class="reference internal" href="#c.ieee80211_channel_flags" title="ieee80211_channel_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_channel_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_antenna_gain</span></code></dt><dd><p>maximum antenna gain in dBi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_power</span></code></dt><dd><p>maximum transmission power (in dBm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_reg_power</span></code></dt><dd><p>maximum regulatory transmission power (in dBm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_found</span></code></dt><dd><p>helper to regulatory code to indicate when a beacon
has been found on this channel. Use regulatory_hint_found_beacon()
to enable this, this is useful only on 5 GHz band.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">orig_flags</span></code></dt><dd><p>channel flags at registration time, used by regulatory
code to support devices with additional restrictions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">orig_mag</span></code></dt><dd><p>internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">orig_mpwr</span></code></dt><dd><p>internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dfs_state</span></code></dt><dd><p>current state of this channel. Only relevant if radar is required
on this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dfs_state_entered</span></code></dt><dd><p>timestamp (jiffies) when the dfs state was entered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dfs_cac_ms</span></code></dt><dd><p>DFS CAC time in milliseconds, this is valid for DFS channels.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a single channel for use
with cfg80211.</p>
<dl class="type">
<dt id="c.ieee80211_rate_flags">
enum <code class="sig-name descname">ieee80211_rate_flags</code><a class="headerlink" href="#c.ieee80211_rate_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>rate flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_SHORT_PREAMBLE</span></code></dt><dd><p>Hardware can send with short
preamble on this bitrate; only relevant in 2.4GHz band and
with CCK rates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_MANDATORY_A</span></code></dt><dd><p>This bitrate is a mandatory rate
when used with 802.11a (on the 5 GHz band); filled by the
core code when registering the wiphy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_MANDATORY_B</span></code></dt><dd><p>This bitrate is a mandatory rate
when used with 802.11b (on the 2.4 GHz band); filled by the
core code when registering the wiphy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_MANDATORY_G</span></code></dt><dd><p>This bitrate is a mandatory rate
when used with 802.11g (on the 2.4 GHz band); filled by the
core code when registering the wiphy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_ERP_G</span></code></dt><dd><p>This is an ERP rate in 802.11g mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_SUPPORTS_5MHZ</span></code></dt><dd><p>Rate can be used in 5 MHz mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RATE_SUPPORTS_10MHZ</span></code></dt><dd><p>Rate can be used in 10 MHz mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hardware/specification flags for rates. These are structured
in a way that allows using the same bitrate structure for
different bands/PHY modes.</p>
<dl class="type">
<dt id="c.ieee80211_rate">
struct <code class="sig-name descname">ieee80211_rate</code><a class="headerlink" href="#c.ieee80211_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_rate {
  u32 flags;
  u16 bitrate;
  u16 hw_value, hw_value_short;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>rate-specific flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitrate</span></code></dt><dd><p>bitrate in units of 100 Kbps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_value</span></code></dt><dd><p>driver/hardware value for this rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_value_short</span></code></dt><dd><p>driver/hardware value for this rate when
short preamble is used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a bitrate that an 802.11 PHY can
operate with. The two values <strong>hw_value</strong> and <strong>hw_value_short</strong>
are only for driver use when pointers to this structure are
passed around.</p>
<dl class="type">
<dt id="c.ieee80211_sta_ht_cap">
struct <code class="sig-name descname">ieee80211_sta_ht_cap</code><a class="headerlink" href="#c.ieee80211_sta_ht_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>STA’s HT capabilities</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_sta_ht_cap {
  u16 cap;
  bool ht_supported;
  u8 ampdu_factor;
  u8 ampdu_density;
  struct ieee80211_mcs_info mcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cap</span></code></dt><dd><p>HT capabilities map as described in 802.11n spec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_supported</span></code></dt><dd><p>is HT supported by the STA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_factor</span></code></dt><dd><p>Maximum A-MPDU length factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_density</span></code></dt><dd><p>Minimum A-MPDU spacing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mcs</span></code></dt><dd><p>Supported MCS rates</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes most essential parameters needed
to describe 802.11n HT capabilities for an STA.</p>
<dl class="type">
<dt id="c.ieee80211_supported_band">
struct <code class="sig-name descname">ieee80211_supported_band</code><a class="headerlink" href="#c.ieee80211_supported_band" title="Permalink to this definition">¶</a></dt>
<dd><p>frequency band definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_supported_band {
  struct ieee80211_channel *channels;
  struct ieee80211_rate *bitrates;
  enum nl80211_band band;
  int n_channels;
  int n_bitrates;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
  struct ieee80211_edmg edmg_cap;
  u16 n_iftype_data;
  const struct ieee80211_sband_iftype_data *iftype_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt><dd><p>Array of channels the hardware can operate in
in this band.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitrates</span></code></dt><dd><p>Array of bitrates the hardware can operate with
in this band. Must be sorted to give a valid “supported
rates” IE, i.e. CCK rates first, then OFDM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">band</span></code></dt><dd><p>the band this structure represents</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_channels</span></code></dt><dd><p>Number of channels in <strong>channels</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_bitrates</span></code></dt><dd><p>Number of bitrates in <strong>bitrates</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_cap</span></code></dt><dd><p>HT capabilities in this band</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_cap</span></code></dt><dd><p>VHT capabilities in this band</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edmg_cap</span></code></dt><dd><p>EDMG capabilities in this band</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_iftype_data</span></code></dt><dd><p>number of iftype data entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iftype_data</span></code></dt><dd><p>interface type data entries.  Note that the bits in
<strong>types_mask</strong> inside this structure cannot overlap (i.e. only
one occurrence of each type is allowed across all instances of
iftype_data).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a frequency band a wiphy
is able to operate in.</p>
<dl class="type">
<dt id="c.cfg80211_signal_type">
enum <code class="sig-name descname">cfg80211_signal_type</code><a class="headerlink" href="#c.cfg80211_signal_type" title="Permalink to this definition">¶</a></dt>
<dd><p>signal type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CFG80211_SIGNAL_TYPE_NONE</span></code></dt><dd><p>no signal strength information available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFG80211_SIGNAL_TYPE_MBM</span></code></dt><dd><p>signal strength in mBm (100*dBm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CFG80211_SIGNAL_TYPE_UNSPEC</span></code></dt><dd><p>signal strength, increasing from 0 through 100</p>
</dd>
</dl>
<dl class="type">
<dt id="c.wiphy_params_flags">
enum <code class="sig-name descname">wiphy_params_flags</code><a class="headerlink" href="#c.wiphy_params_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>set_wiphy_params bitfield values</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_RETRY_SHORT</span></code></dt><dd><p>wiphy-&gt;retry_short has changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_RETRY_LONG</span></code></dt><dd><p>wiphy-&gt;retry_long has changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_FRAG_THRESHOLD</span></code></dt><dd><p>wiphy-&gt;frag_threshold has changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_RTS_THRESHOLD</span></code></dt><dd><p>wiphy-&gt;rts_threshold has changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_COVERAGE_CLASS</span></code></dt><dd><p>coverage class changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_DYN_ACK</span></code></dt><dd><p>dynack has been enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_TXQ_LIMIT</span></code></dt><dd><p>TXQ packet limit has been changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_TXQ_MEMORY_LIMIT</span></code></dt><dd><p>TXQ memory limit has been changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_PARAM_TXQ_QUANTUM</span></code></dt><dd><p>TXQ scheduler quantum</p>
</dd>
</dl>
<dl class="type">
<dt id="c.wiphy_flags">
enum <code class="sig-name descname">wiphy_flags</code><a class="headerlink" href="#c.wiphy_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>wiphy capability flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_NETNS_OK</span></code></dt><dd><p>if not set, do not allow changing the netns of this
wiphy at all</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_PS_ON_BY_DEFAULT</span></code></dt><dd><p>if set to true, powersave will be enabled
by default – this flag will be set depending on the kernel’s default
on <a class="reference internal" href="#c.wiphy_new" title="wiphy_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_new()</span></code></a>, but can be changed by the driver if it has a good
reason to override the default</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_4ADDR_AP</span></code></dt><dd><p>supports 4addr mode even on AP (with a single station
on a VLAN interface). This flag also serves an extra purpose of
supporting 4ADDR AP mode on devices which do not support AP/VLAN iftype.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_4ADDR_STATION</span></code></dt><dd><p>supports 4addr mode even as a station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_CONTROL_PORT_PROTOCOL</span></code></dt><dd><p>This device supports setting the
control port protocol ethertype. The device also honours the
control_port_no_encrypt flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_IBSS_RSN</span></code></dt><dd><p>The device supports IBSS RSN.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_MESH_AUTH</span></code></dt><dd><p>The device supports mesh authentication by routing
auth frames to userspace. See <strong>NL80211_MESH_SETUP_USERSPACE_AUTH</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_SUPPORTS_FW_ROAM</span></code></dt><dd><p>The device supports roaming feature in the
firmware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_AP_UAPSD</span></code></dt><dd><p>The device supports uapsd on AP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_SUPPORTS_TDLS</span></code></dt><dd><p>The device supports TDLS (802.11z) operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_TDLS_EXTERNAL_SETUP</span></code></dt><dd><p>The device does not handle TDLS (802.11z)
link setup/discovery operations internally. Setup, discovery and
teardown packets should be sent through the <strong>NL80211_CMD_TDLS_MGMT</strong>
command. When this flag is not set, <strong>NL80211_CMD_TDLS_OPER</strong> should be
used for asking the driver/firmware to perform a TDLS operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_HAVE_AP_SME</span></code></dt><dd><p>device integrates AP SME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_REPORTS_OBSS</span></code></dt><dd><p>the device will report beacons from other BSSes
when there are virtual interfaces in AP mode by calling
cfg80211_report_obss_beacon().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</span></code></dt><dd><p>When operating as an AP, the device
responds to probe-requests in hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_OFFCHAN_TX</span></code></dt><dd><p>Device supports direct off-channel TX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL</span></code></dt><dd><p>Device supports remain-on-channel call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_SUPPORTS_5_10_MHZ</span></code></dt><dd><p>Device supports 5 MHz and 10 MHz channels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_HAS_CHANNEL_SWITCH</span></code></dt><dd><p>Device supports channel switch in
beaconing mode (AP, IBSS, Mesh, …).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WIPHY_FLAG_HAS_STATIC_WEP</span></code></dt><dd><p>The device supports static WEP key installation
before connection.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.wiphy">
struct <code class="sig-name descname">wiphy</code><a class="headerlink" href="#c.wiphy" title="Permalink to this definition">¶</a></dt>
<dd><p>wireless hardware description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wiphy {
  u8 perm_addr[ETH_ALEN];
  u8 addr_mask[ETH_ALEN];
  struct mac_address *addresses;
  const struct ieee80211_txrx_stypes *mgmt_stypes;
  const struct ieee80211_iface_combination *iface_combinations;
  int n_iface_combinations;
  u16 software_iftypes;
  u16 n_addresses;
  u16 interface_modes;
  u16 max_acl_mac_addrs;
  u32 flags, regulatory_flags, features;
  u8 ext_features[DIV_ROUND_UP(NUM_NL80211_EXT_FEATURES, 8)];
  u32 ap_sme_capa;
  enum cfg80211_signal_type signal_type;
  int bss_priv_size;
  u8 max_scan_ssids;
  u8 max_sched_scan_reqs;
  u8 max_sched_scan_ssids;
  u8 max_match_sets;
  u16 max_scan_ie_len;
  u16 max_sched_scan_ie_len;
  u32 max_sched_scan_plans;
  u32 max_sched_scan_plan_interval;
  u32 max_sched_scan_plan_iterations;
  int n_cipher_suites;
  const u32 *cipher_suites;
  int n_akm_suites;
  const u32 *akm_suites;
  const struct wiphy_iftype_akm_suites *iftype_akm_suites;
  unsigned int num_iftype_akm_suites;
  u8 retry_short;
  u8 retry_long;
  u32 frag_threshold;
  u32 rts_threshold;
  u8 coverage_class;
  char fw_version[ETHTOOL_FWVERS_LEN];
  u32 hw_version;
#ifdef CONFIG_PM;
  const struct wiphy_wowlan_support *wowlan;
  struct cfg80211_wowlan *wowlan_config;
#endif;
  u16 max_remain_on_channel_duration;
  u8 max_num_pmkids;
  u32 available_antennas_tx;
  u32 available_antennas_rx;
  u32 probe_resp_offload;
  const u8 *extended_capabilities, *extended_capabilities_mask;
  u8 extended_capabilities_len;
  const struct wiphy_iftype_ext_capab *iftype_ext_capab;
  unsigned int num_iftype_ext_capab;
  const void *privid;
  struct ieee80211_supported_band *bands[NUM_NL80211_BANDS];
  void (*reg_notifier)(struct wiphy *wiphy, struct regulatory_request *request);
  const struct ieee80211_regdomain __rcu *regd;
  struct device dev;
  bool registered;
  struct dentry *debugfsdir;
  const struct ieee80211_ht_cap *ht_capa_mod_mask;
  const struct ieee80211_vht_cap *vht_capa_mod_mask;
  struct list_head wdev_list;
  possible_net_t _net;
#ifdef CONFIG_CFG80211_WEXT;
  const struct iw_handler_def *wext;
#endif;
  const struct wiphy_coalesce_support *coalesce;
  const struct wiphy_vendor_command *vendor_commands;
  const struct nl80211_vendor_cmd_info *vendor_events;
  int n_vendor_commands, n_vendor_events;
  u16 max_ap_assoc_sta;
  u8 max_num_csa_counters;
  u32 bss_select_support;
  u8 nan_supported_bands;
  u32 txq_limit;
  u32 txq_memory_limit;
  u32 txq_quantum;
  unsigned long tx_queue_len;
  u8 support_mbssid:1, support_only_he_mbssid:1;
  const struct cfg80211_pmsr_capabilities *pmsr_capa;
  struct {
    u64 peer, vif;
    u8 max_retry;
  } tid_config_support;
  u8 max_data_retry_count;
  char priv[0] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">perm_addr</span></code></dt><dd><p>permanent MAC address of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_mask</span></code></dt><dd><p>If the device supports multiple MAC addresses by masking,
set this to a mask with variable bits set to 1, e.g. if the last
four bits are variable then set it to 00-00-00-00-00-0f. The actual
variable bits shall be determined by the interfaces added, with
interfaces not matching the mask being rejected to be brought up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addresses</span></code></dt><dd><p>If the device has more than one address, set this pointer
to a list of addresses (6 bytes each). The first one will be used
by default for perm_addr. In this case, the mask should be set to
all-zeroes. In this case it is assumed that the device can handle
the same number of arbitrary MAC addresses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_stypes</span></code></dt><dd><p>bitmasks of frame subtypes that can be subscribed to or
transmitted through nl80211, points to an array indexed by interface
type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iface_combinations</span></code></dt><dd><p>Valid interface combinations array, should not
list single interface types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_iface_combinations</span></code></dt><dd><p>number of entries in <strong>iface_combinations</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">software_iftypes</span></code></dt><dd><p>bitmask of software interface types, these are not
subject to any restrictions since they are purely managed in SW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_addresses</span></code></dt><dd><p>number of addresses in <strong>addresses</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interface_modes</span></code></dt><dd><p>bitmask of interfaces types valid for this wiphy,
must be set by driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_acl_mac_addrs</span></code></dt><dd><p>Maximum number of MAC addresses that the device
supports for ACL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>wiphy flags, see <a class="reference internal" href="#c.wiphy_flags" title="wiphy_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wiphy_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulatory_flags</span></code></dt><dd><p>wiphy regulatory flags, see
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_regulatory_flags</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>features advertised to nl80211, see <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_feature_flags</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_features</span></code></dt><dd><p>extended features advertised to nl80211, see
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_ext_feature_index</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ap_sme_capa</span></code></dt><dd><p>AP SME capabilities, flags from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_ap_sme_features</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_type</span></code></dt><dd><p>signal type reported in <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_priv_size</span></code></dt><dd><p>each BSS struct has private data allocated with it,
this variable determines its size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_scan_ssids</span></code></dt><dd><p>maximum number of SSIDs the device can scan for in
any given scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_reqs</span></code></dt><dd><p>maximum number of scheduled scan requests that
the device can run concurrently.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_ssids</span></code></dt><dd><p>maximum number of SSIDs the device can scan
for in any given scheduled scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_match_sets</span></code></dt><dd><p>maximum number of match sets the device can handle
when performing a scheduled scan, 0 if filtering is not
supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_scan_ie_len</span></code></dt><dd><p>maximum length of user-controlled IEs device can
add to probe request frames transmitted during a scan, must not
include fixed IEs like supported rates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_ie_len</span></code></dt><dd><p>same as max_scan_ie_len, but for scheduled
scans</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_plans</span></code></dt><dd><p>maximum number of scan plans (scan interval and number
of iterations) for scheduled scan supported by the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_plan_interval</span></code></dt><dd><p>maximum interval (in seconds) for a
single scan plan supported by the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sched_scan_plan_iterations</span></code></dt><dd><p>maximum number of iterations for a single
scan plan supported by the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_cipher_suites</span></code></dt><dd><p>number of supported cipher suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cipher_suites</span></code></dt><dd><p>supported cipher suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_akm_suites</span></code></dt><dd><p>number of supported AKM suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">akm_suites</span></code></dt><dd><p>supported AKM suites. These are the default AKMs supported if
the supported AKMs not advertized for a specific interface type in
iftype_akm_suites.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iftype_akm_suites</span></code></dt><dd><p>array of supported akm suites info per interface type.
Note that the bits in <strong>iftypes_mask</strong> inside this structure cannot
overlap (i.e. only one occurrence of each type is allowed across all
instances of iftype_akm_suites).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_iftype_akm_suites</span></code></dt><dd><p>number of interface types for which supported akm
suites are specified separately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retry_short</span></code></dt><dd><p>Retry limit for short frames (dot11ShortRetryLimit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retry_long</span></code></dt><dd><p>Retry limit for long frames (dot11LongRetryLimit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frag_threshold</span></code></dt><dd><p>Fragmentation threshold (dot11FragmentationThreshold);
-1 = fragmentation disabled, only odd values &gt;= 256 used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rts_threshold</span></code></dt><dd><p>RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coverage_class</span></code></dt><dd><p>current coverage class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_version</span></code></dt><dd><p>firmware version for ethtool reporting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_version</span></code></dt><dd><p>hardware version for ethtool reporting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wowlan</span></code></dt><dd><p>WoWLAN support information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wowlan_config</span></code></dt><dd><p>current WoWLAN configuration; this should usually not be
used since access to it is necessarily racy, use the parameter passed
to the suspend() operation instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_remain_on_channel_duration</span></code></dt><dd><p>Maximum time a remain-on-channel operation
may request, if implemented.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_num_pmkids</span></code></dt><dd><p>maximum number of PMKIDs supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">available_antennas_tx</span></code></dt><dd><p>bitmap of antennas which are available to be
configured as TX antennas. Antenna configuration commands will be
rejected unless this or <strong>available_antennas_rx</strong> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">available_antennas_rx</span></code></dt><dd><p>bitmap of antennas which are available to be
configured as RX antennas. Antenna configuration commands will be
rejected unless this or <strong>available_antennas_tx</strong> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_resp_offload</span></code></dt><dd><p>Bitmap of supported protocols for probe response offloading.
See <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_probe_resp_offload_support_attr</span></code>. Only valid
when the wiphy flag <strong>WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</strong> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extended_capabilities</span></code></dt><dd><p>extended capabilities supported by the driver,
additional capabilities might be supported by userspace; these are
the 802.11 extended capabilities (“Extended Capabilities element”)
and are in the same format as in the information element. See
802.11-2012 8.4.2.29 for the defined fields. These are the default
extended capabilities to be used if the capabilities are not specified
for a specific interface type in iftype_ext_capab.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extended_capabilities_mask</span></code></dt><dd><p>mask of the valid values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extended_capabilities_len</span></code></dt><dd><p>length of the extended capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iftype_ext_capab</span></code></dt><dd><p>array of extended capabilities per interface type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_iftype_ext_capab</span></code></dt><dd><p>number of interface types for which extended
capabilities are specified separately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">privid</span></code></dt><dd><p>a pointer that drivers can use to identify if an arbitrary
wiphy is theirs, e.g. in global notifiers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bands</span></code></dt><dd><p>information about bands/channels supported by this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_notifier</span></code></dt><dd><p>the driver’s regulatory notification callback,
note that if your driver uses <a class="reference internal" href="#c.wiphy_apply_custom_regulatory" title="wiphy_apply_custom_regulatory"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_apply_custom_regulatory()</span></code></a>
the reg_notifier’s request can be passed as NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regd</span></code></dt><dd><p>the driver’s regulatory domain, if one was requested via
the <a class="reference internal" href="#c.regulatory_hint" title="regulatory_hint"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulatory_hint()</span></code></a> API. This can be used by the driver
on the reg_notifier() if it chooses to ignore future
regulatory domain changes caused by other drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>(virtual) struct device for this wiphy. The item in
/sys/class/ieee80211/ points to this. You need use <a class="reference internal" href="#c.set_wiphy_dev" title="set_wiphy_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_wiphy_dev()</span></code></a>
(see below).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">registered</span></code></dt><dd><p>protects -&gt;resume and -&gt;suspend sysfs callbacks against
unregister hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfsdir</span></code></dt><dd><p>debugfs directory used for this wiphy (ieee80211/&lt;wiphyname&gt;).
It will be renamed automatically on wiphy renames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa_mod_mask</span></code></dt><dd><p>Specify what ht_cap values can be over-ridden.
If null, then none can be over-ridden.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa_mod_mask</span></code></dt><dd><p>Specify what VHT capabilities can be over-ridden.
If null, then none can be over-ridden.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wdev_list</span></code></dt><dd><p>the list of associated (virtual) interfaces; this list must
not be modified by the driver, but can be read with RTNL/RCU protection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_net</span></code></dt><dd><p>the network namespace this wiphy currently lives in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext</span></code></dt><dd><p>wireless extension handlers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coalesce</span></code></dt><dd><p>packet coalescing support information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vendor_commands</span></code></dt><dd><p>array of vendor commands supported by the hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vendor_events</span></code></dt><dd><p>array of vendor events supported by the hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_vendor_commands</span></code></dt><dd><p>number of vendor commands</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_vendor_events</span></code></dt><dd><p>number of vendor events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_ap_assoc_sta</span></code></dt><dd><p>maximum number of associated stations supported in AP mode
(including P2P GO) or 0 to indicate no such limit is advertised. The
driver is allowed to advertise a theoretical limit that it can reach in
some cases, but may not always reach.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_num_csa_counters</span></code></dt><dd><p>Number of supported csa_counters in beacons
and probe responses.  This value should be set if the driver
wishes to limit the number of csa counters. Default (0) means
infinite.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_select_support</span></code></dt><dd><p>bitmask indicating the BSS selection criteria supported
by the driver in the .connect() callback. The bit position maps to the
attribute indices defined in <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_bss_select_attr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nan_supported_bands</span></code></dt><dd><p>bands supported by the device in NAN mode, a
bitmap of <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_band</span></code> values.  For instance, for
NL80211_BAND_2GHZ, bit 0 would be set
(i.e. BIT(NL80211_BAND_2GHZ)).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq_limit</span></code></dt><dd><p>configuration of internal TX queue frame limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq_memory_limit</span></code></dt><dd><p>configuration internal TX queue memory limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq_quantum</span></code></dt><dd><p>configuration of internal TX queue scheduler quantum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">support_mbssid</span></code></dt><dd><p>can HW support association with nontransmitted AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">support_only_he_mbssid</span></code></dt><dd><p>don’t parse MBSSID elements if it is not
HE AP, in order to avoid compatibility issues.
<strong>support_mbssid</strong> must be set for this to have any effect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsr_capa</span></code></dt><dd><p>peer measurement capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_config_support</span></code></dt><dd><p>describes the per-TID config support that the
device has</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_config_support.peer</span></code></dt><dd><p>bitmap of attributes (configurations)
supported by the driver for each peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_config_support.vif</span></code></dt><dd><p>bitmap of attributes (configurations)
supported by the driver for each vif</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_config_support.max_retry</span></code></dt><dd><p>maximum supported retry count for
long/short retry configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>driver private data (sized according to <a class="reference internal" href="#c.wiphy_new" title="wiphy_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_new()</span></code></a> parameter)</p>
</dd>
</dl>
<dl class="type">
<dt id="c.wireless_dev">
struct <code class="sig-name descname">wireless_dev</code><a class="headerlink" href="#c.wireless_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>wireless device state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wireless_dev {
  struct wiphy *wiphy;
  enum nl80211_iftype iftype;
  struct list_head list;
  struct net_device *netdev;
  u32 identifier;
  struct list_head mgmt_registrations;
  spinlock_t mgmt_registrations_lock;
  struct mutex mtx;
  bool use_4addr, is_running;
  u8 address[ETH_ALEN] ;
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len, mesh_id_len, mesh_id_up_len;
  struct cfg80211_conn *conn;
  struct cfg80211_cached_keys *connect_keys;
  enum ieee80211_bss_type conn_bss_type;
  u32 conn_owner_nlportid;
  struct work_struct disconnect_wk;
  u8 disconnect_bssid[ETH_ALEN];
  struct list_head event_list;
  spinlock_t event_lock;
  struct cfg80211_internal_bss *current_bss;
  struct cfg80211_chan_def preset_chandef;
  struct cfg80211_chan_def chandef;
  bool ibss_fixed;
  bool ibss_dfs_possible;
  bool ps;
  int ps_timeout;
  int beacon_interval;
  u32 ap_unexpected_nlportid;
  u32 owner_nlportid;
  bool nl_owner_dead;
  bool cac_started;
  unsigned long cac_start_time;
  unsigned int cac_time_ms;
#ifdef CONFIG_CFG80211_WEXT;
  struct {
    struct cfg80211_ibss_params ibss;
    struct cfg80211_connect_params connect;
    struct cfg80211_cached_keys *keys;
    const u8 *ie;
    size_t ie_len;
    u8 bssid[ETH_ALEN];
    u8 prev_bssid[ETH_ALEN];
    u8 ssid[IEEE80211_MAX_SSID_LEN];
    s8 default_key, default_mgmt_key;
    bool prev_bssid_valid;
  } wext;
#endif;
  struct cfg80211_cqm_config *cqm_config;
  struct list_head pmsr_list;
  spinlock_t pmsr_lock;
  struct work_struct pmsr_free_wk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wiphy</span></code></dt><dd><p>pointer to hardware description</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iftype</span></code></dt><dd><p>interface type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>(private) Used to collect the interfaces</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev</span></code></dt><dd><p>(private) Used to reference back to the netdev, may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>(private) Identifier used in nl80211 to identify this
wireless device if it has no netdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_registrations</span></code></dt><dd><p>list of registrations for management frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_registrations_lock</span></code></dt><dd><p>lock for the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtx</span></code></dt><dd><p>mutex used to lock data in this struct, may be used by drivers
and some API functions require it held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_4addr</span></code></dt><dd><p>indicates 4addr mode is used on this interface, must be
set by driver (if supported) on add_interface BEFORE registering the
netdev and may otherwise be used by driver read-only, will be update
by cfg80211 on change_interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_running</span></code></dt><dd><p>true if this is a non-netdev device that has been started, e.g.
the P2P Device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>The address for this device, valid only if <strong>netdev</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>(private) Used by the internal configuration code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>(private) Used by the internal configuration code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mesh_id_len</span></code></dt><dd><p>(private) Used by the internal configuration code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mesh_id_up_len</span></code></dt><dd><p>(private) Used by the internal configuration code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn</span></code></dt><dd><p>(private) cfg80211 software SME connection state machine data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect_keys</span></code></dt><dd><p>(private) keys to set after connection is established</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_bss_type</span></code></dt><dd><p>connecting/connected BSS type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_owner_nlportid</span></code></dt><dd><p>(private) connection owner socket port ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect_wk</span></code></dt><dd><p>(private) auto-disconnect work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect_bssid</span></code></dt><dd><p>(private) the BSSID to use for auto-disconnect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_list</span></code></dt><dd><p>(private) list for internal event processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_lock</span></code></dt><dd><p>(private) lock for event list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_bss</span></code></dt><dd><p>(private) Used by the internal configuration code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preset_chandef</span></code></dt><dd><p>(private) Used by the internal configuration code to
track the channel to be used for AP later</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chandef</span></code></dt><dd><p>(private) Used by the internal configuration code to track
the user-set channel definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ibss_fixed</span></code></dt><dd><p>(private) IBSS is using fixed BSSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ibss_dfs_possible</span></code></dt><dd><p>(private) IBSS may change to a DFS channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ps</span></code></dt><dd><p>powersave mode is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ps_timeout</span></code></dt><dd><p>dynamic powersave timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_interval</span></code></dt><dd><p>beacon interval used on this device for transmitting
beacons, 0 when not valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ap_unexpected_nlportid</span></code></dt><dd><p>(private) netlink port ID of application
registered for unexpected class 3 frames (AP mode)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner_nlportid</span></code></dt><dd><p>(private) owner socket port ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nl_owner_dead</span></code></dt><dd><p>(private) owner socket went away</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cac_started</span></code></dt><dd><p>true if DFS channel availability check has been started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cac_start_time</span></code></dt><dd><p>timestamp (jiffies) when the dfs state was entered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cac_time_ms</span></code></dt><dd><p>CAC time in ms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext</span></code></dt><dd><p>(private) Used by the internal wireless extensions compat code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.ibss</span></code></dt><dd><p>(private) IBSS data part of wext handling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.connect</span></code></dt><dd><p>(private) connection handling data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.keys</span></code></dt><dd><p>(private) (WEP) key data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.ie</span></code></dt><dd><p>(private) extra elements for association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.ie_len</span></code></dt><dd><p>(private) length of extra elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.bssid</span></code></dt><dd><p>(private) selected network BSSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.prev_bssid</span></code></dt><dd><p>(private) previous BSSID for reassociation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.ssid</span></code></dt><dd><p>(private) selected network SSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.default_key</span></code></dt><dd><p>(private) selected default key index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.default_mgmt_key</span></code></dt><dd><p>(private) selected default management key index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wext.prev_bssid_valid</span></code></dt><dd><p>(private) previous BSSID validity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cqm_config</span></code></dt><dd><p>(private) nl80211 RSSI monitor state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsr_list</span></code></dt><dd><p>(private) peer measurement requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsr_lock</span></code></dt><dd><p>(private) peer measurements requests/results lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmsr_free_wk</span></code></dt><dd><p>(private) peer measurements cleanup work</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For netdevs, this structure must be allocated by the driver
that uses the ieee80211_ptr field in struct net_device (this
is intentional so it can be allocated along with the netdev.)
It need not be registered then as netdev registration will
be intercepted by cfg80211 to see the new wireless device.</p>
<p>For non-netdev uses, it must also be allocated by the driver
in response to the cfg80211 callbacks that require it, as
there’s no netdev registration in that case it may not be
allocated outside of callback operations that return it.</p>
<dl class="function">
<dt id="c.wiphy_new">
struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> * <code class="sig-name descname">wiphy_new</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cfg80211_ops" title="cfg80211_ops">cfg80211_ops</a> *<em> ops</em>, int<em> sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new wiphy for use with cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cfg80211_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>The configuration operations for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>The size of the private area to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new wiphy and associate the given operations with it.
<strong>sizeof_priv</strong> bytes are allocated for private use.</p>
<p><strong>Return</strong></p>
<p>A pointer to the new wiphy. This pointer must be
assigned to each netdev’s ieee80211_ptr for proper operation.</p>
<dl class="function">
<dt id="c.wiphy_read_of_freq_limits">
void <code class="sig-name descname">wiphy_read_of_freq_limits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_read_of_freq_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>read frequency limits from device tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wireless device to get extra limits for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices may have extra limitations specified in DT. This may be useful
for chipsets that normally support more bands but are limited due to board
design (e.g. by antennas or external power amplifier).</p>
<p>This function reads info from DT and uses it to <em>modify</em> channels (disable
unavailable ones). It’s usually a <em>bad</em> idea to use it in drivers with
shared channel data as DT limitations are device specific. You should make
sure to call it only if channels in wiphy are copied and can be modified
without affecting other devices.</p>
<p>As this function access device node it has to be called after set_wiphy_dev.
It also modifies channels so they have to be set first.
If using this helper, call it before <a class="reference internal" href="#c.wiphy_register" title="wiphy_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_register()</span></code></a>.</p>
<dl class="function">
<dt id="c.wiphy_register">
int <code class="sig-name descname">wiphy_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a wiphy with cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy to register.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A non-negative wiphy index or a negative error code.</p>
<dl class="function">
<dt id="c.wiphy_unregister">
void <code class="sig-name descname">wiphy_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a wiphy from cfg80211</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy to unregister.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, no more requests can be made with this priv
pointer, but the call may sleep to wait for an outstanding
request that is being handled.</p>
<dl class="function">
<dt id="c.wiphy_free">
void <code class="sig-name descname">wiphy_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy to free</p>
</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_name">
const char * <code class="sig-name descname">wiphy_name</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get wiphy name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy whose name to return</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The name of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.wiphy_dev">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">wiphy_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>get wiphy dev pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy whose device struct to look up</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The dev of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.wiphy_priv">
void * <code class="sig-name descname">wiphy_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return priv from wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy whose priv pointer to return</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The priv of <strong>wiphy</strong>.</p>
<dl class="function">
<dt id="c.priv_to_wiphy">
struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> * <code class="sig-name descname">priv_to_wiphy</code><span class="sig-paren">(</span>void *<em> priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.priv_to_wiphy" title="Permalink to this definition">¶</a></dt>
<dd><p>return the wiphy containing the priv</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt><dd><p>a pointer previously returned by wiphy_priv</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The wiphy of <strong>priv</strong>.</p>
<dl class="function">
<dt id="c.set_wiphy_dev">
void <code class="sig-name descname">set_wiphy_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_wiphy_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>set device pointer for wiphy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>The wiphy whose device to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>The device to parent it to</p>
</dd>
</dl>
<dl class="function">
<dt id="c.wdev_priv">
void * <code class="sig-name descname">wdev_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em> wdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wdev_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return wiphy priv from wireless_dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt><dd><p>The wireless device whose wiphy’s priv pointer to return</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The wiphy priv of <strong>wdev</strong>.</p>
<dl class="type">
<dt id="c.ieee80211_iface_limit">
struct <code class="sig-name descname">ieee80211_iface_limit</code><a class="headerlink" href="#c.ieee80211_iface_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>limit on certain interface types</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_iface_limit {
  u16 max;
  u16 types;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt><dd><p>maximum number of interfaces of these types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">types</span></code></dt><dd><p>interface types (bits)</p>
</dd>
</dl>
<dl class="type">
<dt id="c.ieee80211_iface_combination">
struct <code class="sig-name descname">ieee80211_iface_combination</code><a class="headerlink" href="#c.ieee80211_iface_combination" title="Permalink to this definition">¶</a></dt>
<dd><p>possible interface combination</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_iface_combination {
  const struct ieee80211_iface_limit *limits;
  u32 num_different_channels;
  u16 max_interfaces;
  u8 n_limits;
  bool beacon_int_infra_match;
  u8 radar_detect_widths;
  u8 radar_detect_regions;
  u32 beacon_int_min_gcd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">limits</span></code></dt><dd><p>limits for the given interface types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_different_channels</span></code></dt><dd><p>can use up to this many different channels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_interfaces</span></code></dt><dd><p>maximum number of interfaces in total allowed in this group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_limits</span></code></dt><dd><p>number of limitations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_int_infra_match</span></code></dt><dd><p>In this combination, the beacon intervals between infrastructure
and AP types must match. This is required only in special cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radar_detect_widths</span></code></dt><dd><p>bitmap of channel widths supported for radar detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">radar_detect_regions</span></code></dt><dd><p>bitmap of regions supported for radar detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_int_min_gcd</span></code></dt><dd><p>This interface combination supports different beacon intervals.</p>
<dl class="simple">
<dt>= 0</dt><dd><p>all beacon intervals for different interface must be same.</p>
</dd>
<dt>&gt; 0</dt><dd><p>any beacon interval for the interface part of this combination AND
GCD of all beacon intervals from beaconing interfaces of this
combination must be greater or equal to this value.</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>With this structure the driver can describe which interface
combinations it supports concurrently.</p>
<p><strong>Examples</strong></p>
<ol class="arabic">
<li><p>Allow #STA &lt;= 1, #AP &lt;= 1, matching BI, channels = 1, 2 total:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_STATION</span><span class="p">),</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_AP</span><span class="p">},</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">beacon_int_infra_match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>Allow #{AP, P2P-GO} &lt;= 8, channels = 1, 8 total:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_AP</span><span class="p">)</span> <span class="o">|</span>
                             <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_GO</span><span class="p">),</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits2</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="p">.</span><span class="n">num_different_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>Allow #STA &lt;= 1, #{P2P-client,P2P-GO} &lt;= 3 on two channels, 4 total.</p>
<p>This allows for an infrastructure connection and three P2P connections.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ieee80211_iface_limit</span> <span class="n">limits3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_STATION</span><span class="p">),</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_GO</span><span class="p">)</span> <span class="o">|</span>
                             <span class="n">BIT</span><span class="p">(</span><span class="n">NL80211_IFTYPE_P2P_CLIENT</span><span class="p">),</span> <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee80211_iface_combination</span> <span class="n">combination3</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits3</span><span class="p">,</span>
        <span class="p">.</span><span class="n">n_limits</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">limits3</span><span class="p">),</span>
        <span class="p">.</span><span class="n">max_interfaces</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">.</span><span class="n">num_different_channels</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ol>
<dl class="function">
<dt id="c.cfg80211_check_combinations">
int <code class="sig-name descname">cfg80211_check_combinations</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, struct iface_combination_params *<em> params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_check_combinations" title="Permalink to this definition">¶</a></dt>
<dd><p>check interface combinations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iface_combination_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>the interface combinations parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called by the driver to check whether a
combination of interfaces and their types are allowed according to
the interface combinations.</p>
</div>
<div class="section" id="actions-and-configuration">
<h2>Actions and configuration<a class="headerlink" href="#actions-and-configuration" title="Permalink to this headline">¶</a></h2>
<p>Each wireless device and each virtual interface offer a set of configuration
operations and other actions that are invoked by userspace. Each of these
actions is described in the operations structure, and the parameters these
operations use are described separately.</p>
<p>Additionally, some operations are asynchronous and expect to get status
information via some functions that drivers need to call.</p>
<p>Scanning and BSS list handling with its associated functionality is described
in a separate chapter.</p>
<dl class="type">
<dt id="c.cfg80211_ops">
struct <code class="sig-name descname">cfg80211_ops</code><a class="headerlink" href="#c.cfg80211_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>backend description for wireless configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_ops {
  int (*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
  int (*resume)(struct wiphy *wiphy);
  void (*set_wakeup)(struct wiphy *wiphy, bool enabled);
  struct wireless_dev * (*add_virtual_intf)(struct wiphy *wiphy,const char *name,unsigned char name_assign_type,enum nl80211_iftype type, struct vif_params *params);
  int (*del_virtual_intf)(struct wiphy *wiphy, struct wireless_dev *wdev);
  int (*change_virtual_intf)(struct wiphy *wiphy,struct net_device *dev,enum nl80211_iftype type, struct vif_params *params);
  int (*add_key)(struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr, struct key_params *params);
  int (*get_key)(struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void *cookie, void (*callback)(void *cookie, struct key_params*));
  int (*del_key)(struct wiphy *wiphy, struct net_device *netdev, u8 key_index, bool pairwise, const u8 *mac_addr);
  int (*set_default_key)(struct wiphy *wiphy,struct net_device *netdev, u8 key_index, bool unicast, bool multicast);
  int (*set_default_mgmt_key)(struct wiphy *wiphy,struct net_device *netdev, u8 key_index);
  int (*set_default_beacon_key)(struct wiphy *wiphy,struct net_device *netdev, u8 key_index);
  int (*start_ap)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_ap_settings *settings);
  int (*change_beacon)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_beacon_data *info);
  int (*stop_ap)(struct wiphy *wiphy, struct net_device *dev);
  int (*add_station)(struct wiphy *wiphy, struct net_device *dev,const u8 *mac, struct station_parameters *params);
  int (*del_station)(struct wiphy *wiphy, struct net_device *dev, struct station_del_parameters *params);
  int (*change_station)(struct wiphy *wiphy, struct net_device *dev,const u8 *mac, struct station_parameters *params);
  int (*get_station)(struct wiphy *wiphy, struct net_device *dev, const u8 *mac, struct station_info *sinfo);
  int (*dump_station)(struct wiphy *wiphy, struct net_device *dev, int idx, u8 *mac, struct station_info *sinfo);
  int (*add_mpath)(struct wiphy *wiphy, struct net_device *dev, const u8 *dst, const u8 *next_hop);
  int (*del_mpath)(struct wiphy *wiphy, struct net_device *dev, const u8 *dst);
  int (*change_mpath)(struct wiphy *wiphy, struct net_device *dev, const u8 *dst, const u8 *next_hop);
  int (*get_mpath)(struct wiphy *wiphy, struct net_device *dev, u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (*get_mpp)(struct wiphy *wiphy, struct net_device *dev, u8 *dst, u8 *mpp, struct mpath_info *pinfo);
  int (*dump_mpp)(struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *mpp, struct mpath_info *pinfo);
  int (*get_mesh_config)(struct wiphy *wiphy,struct net_device *dev, struct mesh_config *conf);
  int (*update_mesh_config)(struct wiphy *wiphy,struct net_device *dev, u32 mask, const struct mesh_config *nconf);
  int (*join_mesh)(struct wiphy *wiphy, struct net_device *dev,const struct mesh_config *conf, const struct mesh_setup *setup);
  int (*leave_mesh)(struct wiphy *wiphy, struct net_device *dev);
  int (*join_ocb)(struct wiphy *wiphy, struct net_device *dev, struct ocb_setup *setup);
  int (*leave_ocb)(struct wiphy *wiphy, struct net_device *dev);
  int (*change_bss)(struct wiphy *wiphy, struct net_device *dev, struct bss_parameters *params);
  int (*set_txq_params)(struct wiphy *wiphy, struct net_device *dev, struct ieee80211_txq_params *params);
  int (*libertas_set_mesh_channel)(struct wiphy *wiphy,struct net_device *dev, struct ieee80211_channel *chan);
  int (*set_monitor_channel)(struct wiphy *wiphy, struct cfg80211_chan_def *chandef);
  int (*scan)(struct wiphy *wiphy, struct cfg80211_scan_request *request);
  void (*abort_scan)(struct wiphy *wiphy, struct wireless_dev *wdev);
  int (*auth)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_auth_request *req);
  int (*assoc)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_assoc_request *req);
  int (*deauth)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_deauth_request *req);
  int (*disassoc)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_disassoc_request *req);
  int (*connect)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_connect_params *sme);
  int (*update_connect_params)(struct wiphy *wiphy,struct net_device *dev,struct cfg80211_connect_params *sme, u32 changed);
  int (*disconnect)(struct wiphy *wiphy, struct net_device *dev, u16 reason_code);
  int (*join_ibss)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_ibss_params *params);
  int (*leave_ibss)(struct wiphy *wiphy, struct net_device *dev);
  int (*set_mcast_rate)(struct wiphy *wiphy, struct net_device *dev, int rate[NUM_NL80211_BANDS]);
  int (*set_wiphy_params)(struct wiphy *wiphy, u32 changed);
  int (*set_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev, enum nl80211_tx_power_setting type, int mbm);
  int (*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev, int *dbm);
  int (*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev, const u8 *addr);
  void (*rfkill_poll)(struct wiphy *wiphy);
#ifdef CONFIG_NL80211_TESTMODE;
  int (*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev, void *data, int len);
  int (*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,struct netlink_callback *cb, void *data, int len);
#endif;
  int (*set_bitrate_mask)(struct wiphy *wiphy,struct net_device *dev,const u8 *peer, const struct cfg80211_bitrate_mask *mask);
  int (*dump_survey)(struct wiphy *wiphy, struct net_device *netdev, int idx, struct survey_info *info);
  int (*set_pmksa)(struct wiphy *wiphy, struct net_device *netdev, struct cfg80211_pmksa *pmksa);
  int (*del_pmksa)(struct wiphy *wiphy, struct net_device *netdev, struct cfg80211_pmksa *pmksa);
  int (*flush_pmksa)(struct wiphy *wiphy, struct net_device *netdev);
  int (*remain_on_channel)(struct wiphy *wiphy,struct wireless_dev *wdev,struct ieee80211_channel *chan,unsigned int duration, u64 *cookie);
  int (*cancel_remain_on_channel)(struct wiphy *wiphy,struct wireless_dev *wdev, u64 cookie);
  int (*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,struct cfg80211_mgmt_tx_params *params, u64 *cookie);
  int (*mgmt_tx_cancel_wait)(struct wiphy *wiphy,struct wireless_dev *wdev, u64 cookie);
  int (*set_power_mgmt)(struct wiphy *wiphy, struct net_device *dev, bool enabled, int timeout);
  int (*set_cqm_rssi_config)(struct wiphy *wiphy,struct net_device *dev, s32 rssi_thold, u32 rssi_hyst);
  int (*set_cqm_rssi_range_config)(struct wiphy *wiphy,struct net_device *dev, s32 rssi_low, s32 rssi_high);
  int (*set_cqm_txe_config)(struct wiphy *wiphy,struct net_device *dev, u32 rate, u32 pkts, u32 intvl);
  void (*mgmt_frame_register)(struct wiphy *wiphy,struct wireless_dev *wdev, u16 frame_type, bool reg);
  int (*set_antenna)(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
  int (*get_antenna)(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
  int (*sched_scan_start)(struct wiphy *wiphy,struct net_device *dev, struct cfg80211_sched_scan_request *request);
  int (*sched_scan_stop)(struct wiphy *wiphy, struct net_device *dev, u64 reqid);
  int (*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_gtk_rekey_data *data);
  int (*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u8 action_code,  u8 dialog_token,u16 status_code, u32 peer_capability, bool initiator, const u8 *buf, size_t len);
  int (*tdls_oper)(struct wiphy *wiphy, struct net_device *dev, const u8 *peer, enum nl80211_tdls_operation oper);
  int (*probe_client)(struct wiphy *wiphy, struct net_device *dev, const u8 *peer, u64 *cookie);
  int (*set_noack_map)(struct wiphy *wiphy,struct net_device *dev, u16 noack_map);
  int (*get_channel)(struct wiphy *wiphy,struct wireless_dev *wdev, struct cfg80211_chan_def *chandef);
  int (*start_p2p_device)(struct wiphy *wiphy, struct wireless_dev *wdev);
  void (*stop_p2p_device)(struct wiphy *wiphy, struct wireless_dev *wdev);
  int (*set_mac_acl)(struct wiphy *wiphy, struct net_device *dev, const struct cfg80211_acl_data *params);
  int (*start_radar_detection)(struct wiphy *wiphy,struct net_device *dev,struct cfg80211_chan_def *chandef, u32 cac_time_ms);
  void (*end_cac)(struct wiphy *wiphy, struct net_device *dev);
  int (*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_update_ft_ies_params *ftie);
  int (*crit_proto_start)(struct wiphy *wiphy,struct wireless_dev *wdev,enum nl80211_crit_proto_id protocol, u16 duration);
  void (*crit_proto_stop)(struct wiphy *wiphy, struct wireless_dev *wdev);
  int (*set_coalesce)(struct wiphy *wiphy, struct cfg80211_coalesce *coalesce);
  int (*channel_switch)(struct wiphy *wiphy,struct net_device *dev, struct cfg80211_csa_settings *params);
  int (*set_qos_map)(struct wiphy *wiphy,struct net_device *dev, struct cfg80211_qos_map *qos_map);
  int (*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_chan_def *chandef);
  int (*add_tx_ts)(struct wiphy *wiphy, struct net_device *dev,u8 tsid, const u8 *peer, u8 user_prio, u16 admitted_time);
  int (*del_tx_ts)(struct wiphy *wiphy, struct net_device *dev, u8 tsid, const u8 *peer);
  int (*tdls_channel_switch)(struct wiphy *wiphy,struct net_device *dev,const u8 *addr, u8 oper_class, struct cfg80211_chan_def *chandef);
  void (*tdls_cancel_channel_switch)(struct wiphy *wiphy,struct net_device *dev, const u8 *addr);
  int (*start_nan)(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_nan_conf *conf);
  void (*stop_nan)(struct wiphy *wiphy, struct wireless_dev *wdev);
  int (*add_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_nan_func *nan_func);
  void (*del_nan_func)(struct wiphy *wiphy, struct wireless_dev *wdev, u64 cookie);
  int (*nan_change_conf)(struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_nan_conf *conf, u32 changes);
  int (*set_multicast_to_unicast)(struct wiphy *wiphy,struct net_device *dev, const bool enabled);
  int (*get_txq_stats)(struct wiphy *wiphy,struct wireless_dev *wdev, struct cfg80211_txq_stats *txqstats);
  int (*set_pmk)(struct wiphy *wiphy, struct net_device *dev, const struct cfg80211_pmk_conf *conf);
  int (*del_pmk)(struct wiphy *wiphy, struct net_device *dev, const u8 *aa);
  int (*external_auth)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_external_auth_params *params);
  int (*tx_control_port)(struct wiphy *wiphy,struct net_device *dev,const u8 *buf, size_t len,const u8 *dest, const __be16 proto, const bool noencrypt);
  int (*get_ftm_responder_stats)(struct wiphy *wiphy,struct net_device *dev, struct cfg80211_ftm_responder_stats *ftm_stats);
  int (*start_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_pmsr_request *request);
  void (*abort_pmsr)(struct wiphy *wiphy, struct wireless_dev *wdev, struct cfg80211_pmsr_request *request);
  int (*update_owe_info)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_update_owe_info *owe_info);
  int (*probe_mesh_link)(struct wiphy *wiphy, struct net_device *dev, const u8 *buf, size_t len);
  int (*set_tid_config)(struct wiphy *wiphy, struct net_device *dev, struct cfg80211_tid_config *tid_conf);
  int (*reset_tid_config)(struct wiphy *wiphy, struct net_device *dev, const u8 *peer, u8 tids);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>wiphy device needs to be suspended. The variable <strong>wow</strong> will
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or contain the enabled Wake-on-Wireless triggers that are
configured for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>wiphy device needs to be resumed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_wakeup</span></code></dt><dd><p>Called when WoWLAN is enabled/disabled, use this callback
to call device_set_wakeup_enable() to enable/disable wakeup from
the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_virtual_intf</span></code></dt><dd><p>create a new virtual interface with the given name,
must set the struct wireless_dev’s iftype. Beware: You must create
the new netdev in the wiphy’s network namespace! Returns the struct
wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
also set the address member in the wdev.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_virtual_intf</span></code></dt><dd><p>remove the virtual interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_virtual_intf</span></code></dt><dd><p>change type/configuration of virtual interface,
keep the struct wireless_dev’s iftype updated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_key</span></code></dt><dd><p>add a key with the given parameters. <strong>mac_addr</strong> will be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
when adding a group key.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_key</span></code></dt><dd><p>get information about the key with the given parameters.
<strong>mac_addr</strong> will be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when requesting information for a group
key. All pointers given to the <strong>callback</strong> function need not be valid
after it returns. This function should return an error if it is
not possible to retrieve the key, -ENOENT if it doesn’t exist.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_key</span></code></dt><dd><p>remove a key given the <strong>mac_addr</strong> (<code class="docutils literal notranslate"><span class="pre">NULL</span></code> for a group key)
and <strong>key_index</strong>, return -ENOENT if the key doesn’t exist.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_default_key</span></code></dt><dd><p>set the default key on an interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_default_mgmt_key</span></code></dt><dd><p>set the default management frame key on an interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_default_beacon_key</span></code></dt><dd><p>set the default Beacon frame key on an interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_ap</span></code></dt><dd><p>Start acting in AP mode defined by the parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_beacon</span></code></dt><dd><p>Change the beacon parameters for an access point mode
interface. This should reject the call when AP mode wasn’t started.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_ap</span></code></dt><dd><p>Stop being an AP, including stopping beaconing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_station</span></code></dt><dd><p>Add a new station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_station</span></code></dt><dd><p>Remove a station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_station</span></code></dt><dd><p>Modify a given station. Note that flags changes are not much
validated in cfg80211, in particular the auth/assoc/authorized flags
might come to the driver in invalid combinations – make sure to check
them, also against the existing state! Drivers must call
cfg80211_check_station_change() to validate the information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_station</span></code></dt><dd><p>get station information for the station identified by <strong>mac</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dump_station</span></code></dt><dd><p>dump station callback – resume dump at index <strong>idx</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_mpath</span></code></dt><dd><p>add a fixed mesh path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_mpath</span></code></dt><dd><p>delete a given mesh path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_mpath</span></code></dt><dd><p>change a given mesh path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mpath</span></code></dt><dd><p>get a mesh path for the given parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dump_mpath</span></code></dt><dd><p>dump mesh path callback – resume dump at index <strong>idx</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mpp</span></code></dt><dd><p>get a mesh proxy path for the given parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dump_mpp</span></code></dt><dd><p>dump mesh proxy path callback – resume dump at index <strong>idx</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mesh_config</span></code></dt><dd><p>Get the current mesh configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_mesh_config</span></code></dt><dd><p>Update mesh parameters on a running mesh.
The mask is a bitfield which tells us which parameters to
set, and which to leave alone.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">join_mesh</span></code></dt><dd><p>join the mesh network with the specified parameters
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leave_mesh</span></code></dt><dd><p>leave the current mesh network
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">join_ocb</span></code></dt><dd><p>join the OCB network with the specified parameters
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leave_ocb</span></code></dt><dd><p>leave the current OCB network
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_bss</span></code></dt><dd><p>Modify parameters for a given BSS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_txq_params</span></code></dt><dd><p>Set TX queue parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">libertas_set_mesh_channel</span></code></dt><dd><p>Only for backward compatibility for libertas,
as it doesn’t implement join_mesh and needs to set the channel to
join the mesh instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_monitor_channel</span></code></dt><dd><p>Set the monitor mode channel for the device. If other
interfaces are active this callback should reject the configuration.
If no interfaces are active or the device is down, the channel should
be stored for when a monitor interface becomes active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scan</span></code></dt><dd><p>Request to do a scan. If returning zero, the scan request is given
the driver, and will be valid until passed to <a class="reference internal" href="#c.cfg80211_scan_done" title="cfg80211_scan_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_scan_done()</span></code></a>.
For scan results, call <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_inform_bss()</span></code></a>; you can call this outside
the scan/scan_done bracket too.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_scan</span></code></dt><dd><p>Tell the driver to abort an ongoing scan. The driver shall
indicate the status of the scan through <a class="reference internal" href="#c.cfg80211_scan_done" title="cfg80211_scan_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_scan_done()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth</span></code></dt><dd><p>Request to authenticate with the specified peer
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assoc</span></code></dt><dd><p>Request to (re)associate with the specified peer
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deauth</span></code></dt><dd><p>Request to deauthenticate from the specified peer
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disassoc</span></code></dt><dd><p>Request to disassociate from the specified peer
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect</span></code></dt><dd><p>Connect to the ESS with the specified parameters. When connected,
call <a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>/<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a> with status code
<code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_SUCCESS</span></code>. If the connection fails for some reason, call
<a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>/<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a> with the status code
from the AP or <a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a> if no frame with status code
was received.
The driver is allowed to roam to other BSSes within the ESS when the
other BSS matches the connect parameters. When such roaming is initiated
by the driver, the driver is expected to verify that the target matches
the configured security parameters and to use Reassociation Request
frame instead of Association Request frame.
The connect function can also be used to request the driver to perform a
specific roam when connected to an ESS. In that case, the prev_bssid
parameter is set to the BSSID of the currently associated BSS as an
indication of requesting reassociation.
In both the driver-initiated and new connect() call initiated roaming
cases, the result of roaming is indicated with a call to
<a class="reference internal" href="#c.cfg80211_roamed" title="cfg80211_roamed"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_roamed()</span></code></a>. (invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_connect_params</span></code></dt><dd><p>Update the connect parameters while connected to a
BSS. The updated parameters can be used by driver/firmware for
subsequent BSS selection (roaming) decisions and to form the
Authentication/(Re)Association Request frames. This call does not
request an immediate disassociation or reassociation with the current
BSS, i.e., this impacts only subsequent (re)associations. The bits in
changed are defined in <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cfg80211_connect_params_changed</span></code>.
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>Disconnect from the BSS/ESS or stop connection attempts if
connection is in progress. Once done, call <a class="reference internal" href="#c.cfg80211_disconnected" title="cfg80211_disconnected"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_disconnected()</span></code></a> in
case connection was already established (invoked with the
wireless_dev mutex held), otherwise call <a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">join_ibss</span></code></dt><dd><p>Join the specified IBSS (or create if necessary). Once done, call
<a class="reference internal" href="#c.cfg80211_ibss_joined" title="cfg80211_ibss_joined"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_ibss_joined()</span></code></a>, also call that function when changing BSSID due
to a merge.
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leave_ibss</span></code></dt><dd><p>Leave the IBSS.
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_mcast_rate</span></code></dt><dd><p>Set the specified multicast rate (only if vif is in ADHOC or
MESH mode)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_wiphy_params</span></code></dt><dd><p>Notify that wiphy parameters have changed;
<strong>changed</strong> bitfield (see <a class="reference internal" href="#c.wiphy_params_flags" title="wiphy_params_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wiphy_params_flags</span></code></a>) describes which values
have changed. The actual parameter values are available in
struct wiphy. If returning an error, no value should be changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tx_power</span></code></dt><dd><p>set the transmit power according to the parameters,
the power passed is in mBm, to get dBm use MBM_TO_DBM(). The
wdev may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if power was set for the wiphy, and will
always be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> unless the driver supports per-vif TX power
(as advertised by the nl80211 feature flag.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_tx_power</span></code></dt><dd><p>store the current TX power into the dbm variable;
return 0 if successful</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_wds_peer</span></code></dt><dd><p>set the WDS peer for a WDS interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rfkill_poll</span></code></dt><dd><p>polls the hw rfkill line, use cfg80211 reporting
functions to adjust rfkill hw state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">testmode_cmd</span></code></dt><dd><p>run a test mode command; <strong>wdev</strong> may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">testmode_dump</span></code></dt><dd><p>Implement a test mode dump. The cb-&gt;args[2] and up may be
used by the function, but 0 and 1 must not be touched. Additionally,
return error codes other than -ENOBUFS and -ENOENT will terminate the
dump and return to userspace with an error, so be careful. If any data
was passed in from userspace then the data/len arguments will be present
and point to the data contained in <code class="docutils literal notranslate"><span class="pre">NL80211_ATTR_TESTDATA</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_bitrate_mask</span></code></dt><dd><p>set the bitrate mask configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dump_survey</span></code></dt><dd><p>get site survey information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_pmksa</span></code></dt><dd><p>Cache a PMKID for a BSSID. This is mostly useful for fullmac
devices running firmwares capable of generating the (re) association
RSN IE. It allows for faster roaming between WPA2 BSSIDs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_pmksa</span></code></dt><dd><p>Delete a cached PMKID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_pmksa</span></code></dt><dd><p>Flush all cached PMKIDs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remain_on_channel</span></code></dt><dd><p>Request the driver to remain awake on the specified
channel for the specified duration to complete an off-channel
operation (e.g., public action frame exchange). When the driver is
ready on the requested channel, it must indicate this with an event
notification by calling <a class="reference internal" href="#c.cfg80211_ready_on_channel" title="cfg80211_ready_on_channel"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_ready_on_channel()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cancel_remain_on_channel</span></code></dt><dd><p>Cancel an on-going remain-on-channel operation.
This allows the operation to be terminated prior to timeout based on
the duration value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_tx</span></code></dt><dd><p>Transmit a management frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_tx_cancel_wait</span></code></dt><dd><p>Cancel the wait time from transmitting a management
frame on another channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_power_mgmt</span></code></dt><dd><p>Configure WLAN power management. A timeout value of -1
allows the driver to adjust the dynamic ps timeout value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cqm_rssi_config</span></code></dt><dd><p>Configure connection quality monitor RSSI threshold.
After configuration, the driver should (soon) send an event indicating
the current level is above/below the configured threshold; this may
need some care when the configuration is changed (without first being
disabled.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cqm_rssi_range_config</span></code></dt><dd><p>Configure two RSSI thresholds in the
connection quality monitor.  An event is to be sent only when the
signal level is found to be outside the two values.  The driver should
set <code class="docutils literal notranslate"><span class="pre">NL80211_EXT_FEATURE_CQM_RSSI_LIST</span></code> if this method is implemented.
If it is provided then there’s no point providing <strong>set_cqm_rssi_config</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cqm_txe_config</span></code></dt><dd><p>Configure connection quality monitor TX error
thresholds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgmt_frame_register</span></code></dt><dd><p>Notify driver that a management frame type was
registered. The callback is allowed to sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_antenna</span></code></dt><dd><p>Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <strong>NL80211_ATTR_WIPHY_ANTENNA_TX</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_antenna</span></code></dt><dd><p>Get current antenna configuration from device (tx_ant, rx_ant).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_scan_start</span></code></dt><dd><p>Tell the driver to start a scheduled scan.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_scan_stop</span></code></dt><dd><p>Tell the driver to stop an ongoing scheduled scan with
given request id. This call must stop the scheduled scan and be ready
for starting a new one before it returns, i.e. <strong>sched_scan_start</strong> may be
called immediately after that again and should not fail in that case.
The driver should not call cfg80211_sched_scan_stopped() for a requested
stop (when this method returns 0).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_rekey_data</span></code></dt><dd><p>give the data necessary for GTK rekeying to the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_mgmt</span></code></dt><dd><p>Transmit a TDLS management frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_oper</span></code></dt><dd><p>Perform a high-level TDLS operation (e.g. TDLS link setup).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_client</span></code></dt><dd><p>probe an associated client, must return a cookie that it
later passes to cfg80211_probe_status().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_noack_map</span></code></dt><dd><p>Set the NoAck Map for the TIDs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_channel</span></code></dt><dd><p>Get the current operating channel for the virtual interface.
For monitor interfaces, it should return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> unless there’s a single
current monitoring channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_p2p_device</span></code></dt><dd><p>Start the given P2P device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_p2p_device</span></code></dt><dd><p>Stop the given P2P device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_mac_acl</span></code></dt><dd><p>Sets MAC address control list in AP and P2P GO mode.
Parameters include ACL policy, an array of MAC address of stations
and the number of MAC addresses. If there is already a list in driver
this new list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers which
advertise the support for MAC based ACL have to implement this callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_radar_detection</span></code></dt><dd><p>Start radar detection in the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_cac</span></code></dt><dd><p>End running CAC, probably because a related CAC
was finished on another phy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_ft_ies</span></code></dt><dd><p>Provide updated Fast BSS Transition information to the
driver. If the SME is in the driver/firmware, this information can be
used in building Authentication and Reassociation Request frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crit_proto_start</span></code></dt><dd><p>Indicates a critical protocol needs more link reliability
for a given duration (milliseconds). The protocol is provided so the
driver can take the most appropriate actions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crit_proto_stop</span></code></dt><dd><p>Indicates critical protocol no longer needs increased link
reliability. This operation can not fail.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_coalesce</span></code></dt><dd><p>Set coalesce parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_switch</span></code></dt><dd><p>initiate channel-switch procedure (with CSA). Driver is
responsible for veryfing if the switch is possible. Since this is
inherently tricky driver may decide to disconnect an interface later
with cfg80211_stop_iface(). This doesn’t mean driver can accept
everything. It should do it’s best to verify requests and reject them
as soon as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_qos_map</span></code></dt><dd><p>Set QoS mapping information to the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ap_chanwidth</span></code></dt><dd><p>Set the AP (including P2P GO) mode channel width for the
given interface This is used e.g. for dynamic HT 20/40 MHz channel width
changes during the lifetime of the BSS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_tx_ts</span></code></dt><dd><p>validate (if admitted_time is 0) or add a TX TS to the device
with the given parameters; action frame exchange has been handled by
userspace so this just has to modify the TX path to take the TS into
account.
If the admitted time is 0 just validate the parameters to make sure
the session can be created at all; it is valid to just always return
success for that but that may result in inefficient behaviour (handshake
with the peer followed by immediate teardown when the addition is later
rejected)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_tx_ts</span></code></dt><dd><p>remove an existing TX TS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_channel_switch</span></code></dt><dd><p>Start channel-switching with a TDLS peer. The driver
is responsible for continually initiating channel-switching operations
and returning to the base channel for communication with the AP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_cancel_channel_switch</span></code></dt><dd><p>Stop channel-switching with a TDLS peer. Both
peers must be on the base channel when the call completes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_nan</span></code></dt><dd><p>Start the NAN interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_nan</span></code></dt><dd><p>Stop the NAN interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_nan_func</span></code></dt><dd><p>Add a NAN function. Returns negative value on failure.
On success <strong>nan_func</strong> ownership is transferred to the driver and
it may access it outside of the scope of this function. The driver
should free the <strong>nan_func</strong> when no longer needed by calling
cfg80211_free_nan_func().
On success the driver should assign an instance_id in the
provided <strong>nan_func</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_nan_func</span></code></dt><dd><p>Delete a NAN function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nan_change_conf</span></code></dt><dd><p>changes NAN configuration. The changed parameters must
be specified in <strong>changes</strong> (using <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cfg80211_nan_conf_changes</span></code>);
All other parameters must be ignored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_multicast_to_unicast</span></code></dt><dd><p>configure multicast to unicast conversion for BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_txq_stats</span></code></dt><dd><p>Get TXQ stats for interface or phy. If wdev is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, this
function should return phy stats, and interface stats otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_pmk</span></code></dt><dd><p>configure the PMK to be used for offloaded 802.1X 4-Way handshake.
If not deleted through <strong>del_pmk</strong> the PMK remains valid until disconnect
upon which the driver should clear it.
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">del_pmk</span></code></dt><dd><p>delete the previously configured PMK for the given authenticator.
(invoked with the wireless_dev mutex held)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">external_auth</span></code></dt><dd><p>indicates result of offloaded authentication processing from
user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_control_port</span></code></dt><dd><p>TX a control port frame (EAPoL).  The noencrypt parameter
tells the driver that the frame should not be encrypted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_ftm_responder_stats</span></code></dt><dd><p>Retrieve FTM responder statistics, if available.
Statistics should be cumulative, currently no way to reset is provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_pmsr</span></code></dt><dd><p>start peer measurement (e.g. FTM)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_pmsr</span></code></dt><dd><p>abort peer measurement</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_owe_info</span></code></dt><dd><p>Provide updated OWE info to driver. Driver implementing SME
but offloading OWE processing to the user space will get the updated
DH IE through this interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_mesh_link</span></code></dt><dd><p>Probe direct Mesh peer’s link quality by sending data frame
and overrule HWMP path selection algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tid_config</span></code></dt><dd><p>TID specific configuration, this can be peer or BSS specific
This callback may sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_tid_config</span></code></dt><dd><p>Reset TID specific configuration for the peer, for the
given TIDs. This callback may sleep.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct is registered by fullmac card drivers and/or wireless stacks
in order to handle configuration requests on their interfaces.</p>
<p>All callbacks except where otherwise noted should return 0
on success or a negative error code.</p>
<p>All operations are currently invoked under rtnl for consistency with the
wireless extensions but this is subject to reevaluation as soon as this
code is used more widely and we have a first user without wext.</p>
<dl class="type">
<dt id="c.vif_params">
struct <code class="sig-name descname">vif_params</code><a class="headerlink" href="#c.vif_params" title="Permalink to this definition">¶</a></dt>
<dd><p>describes virtual interface parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vif_params {
  u32 flags;
  int use_4addr;
  u8 macaddr[ETH_ALEN];
  const u8 *vht_mumimo_groups;
  const u8 *vht_mumimo_follow_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>monitor interface flags, unchanged if 0, otherwise
<code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_CHANGED</span></code> will be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_4addr</span></code></dt><dd><p>use 4-address frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">macaddr</span></code></dt><dd><p>address to use for this virtual interface.
If this parameter is set to zero address the driver may
determine the address as needed.
This feature is only fully supported by drivers that enable the
<code class="docutils literal notranslate"><span class="pre">NL80211_FEATURE_MAC_ON_CREATE</span></code> flag.  Others may support creating
*     only p2p devices with specified MAC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_mumimo_groups</span></code></dt><dd><p>MU-MIMO groupID, used for monitoring MU-MIMO packets
belonging to that MU-MIMO groupID; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_mumimo_follow_addr</span></code></dt><dd><p>MU-MIMO follow address, used for monitoring
MU-MIMO packets going to the specified station; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not changed</p>
</dd>
</dl>
<dl class="type">
<dt id="c.key_params">
struct <code class="sig-name descname">key_params</code><a class="headerlink" href="#c.key_params" title="Permalink to this definition">¶</a></dt>
<dd><p>key information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct key_params {
  const u8 *key;
  const u8 *seq;
  int key_len;
  int seq_len;
  u16 vlan_id;
  u32 cipher;
  enum nl80211_key_mode mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>key material</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>sequence counter (IV/PN) for TKIP and CCMP keys, only used
with the get_key() callback, must be in little endian,
length given by <strong>seq_len</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_len</span></code></dt><dd><p>length of key material</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq_len</span></code></dt><dd><p>length of <strong>seq</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_id</span></code></dt><dd><p>vlan_id for VLAN group key (if nonzero)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cipher</span></code></dt><dd><p>cipher suite selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>key install mode (RX_TX, NO_TX or SET_TX)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Information about a key</p>
<dl class="type">
<dt id="c.survey_info_flags">
enum <code class="sig-name descname">survey_info_flags</code><a class="headerlink" href="#c.survey_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>survey information flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_NOISE_DBM</span></code></dt><dd><p>noise (in dBm) was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_IN_USE</span></code></dt><dd><p>channel is currently being used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME</span></code></dt><dd><p>active time (in ms) was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_BUSY</span></code></dt><dd><p>busy time was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_EXT_BUSY</span></code></dt><dd><p>extension channel busy time was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_RX</span></code></dt><dd><p>receive time was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_TX</span></code></dt><dd><p>transmit time was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_SCAN</span></code></dt><dd><p>scan time was filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SURVEY_INFO_TIME_BSS_RX</span></code></dt><dd><p>local BSS receive time was filled in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate which info in <a class="reference internal" href="#c.survey_info" title="survey_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">survey_info</span></code></a>
it has filled in during the get_survey().</p>
<dl class="type">
<dt id="c.survey_info">
struct <code class="sig-name descname">survey_info</code><a class="headerlink" href="#c.survey_info" title="Permalink to this definition">¶</a></dt>
<dd><p>channel survey response</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct survey_info {
  struct ieee80211_channel *channel;
  u64 time;
  u64 time_busy;
  u64 time_ext_busy;
  u64 time_rx;
  u64 time_tx;
  u64 time_scan;
  u64 time_bss_rx;
  u32 filled;
  s8 noise;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>the channel this survey record reports, may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for a single
record to report global statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>amount of time in ms the radio was turn on (on the channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_busy</span></code></dt><dd><p>amount of time the primary channel was sensed busy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_ext_busy</span></code></dt><dd><p>amount of time the extension channel was sensed busy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_rx</span></code></dt><dd><p>amount of time the radio spent receiving data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_tx</span></code></dt><dd><p>amount of time the radio spent transmitting data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_scan</span></code></dt><dd><p>amount of time the radio spent for scanning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_bss_rx</span></code></dt><dd><p>amount of time the radio spent receiving data on a local BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filled</span></code></dt><dd><p>bitflag of flags from <a class="reference internal" href="#c.survey_info_flags" title="survey_info_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">survey_info_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">noise</span></code></dt><dd><p>channel noise in dBm. This and all following fields are
optional</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by dump_survey() to report back per-channel survey information.</p>
<p>This structure can later be expanded with things like
channel duty cycle etc.</p>
<dl class="type">
<dt id="c.cfg80211_beacon_data">
struct <code class="sig-name descname">cfg80211_beacon_data</code><a class="headerlink" href="#c.cfg80211_beacon_data" title="Permalink to this definition">¶</a></dt>
<dd><p>beacon data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_beacon_data {
  const u8 *head, *tail;
  const u8 *beacon_ies;
  const u8 *proberesp_ies;
  const u8 *assocresp_ies;
  const u8 *probe_resp;
  const u8 *lci;
  const u8 *civicloc;
  s8 ftm_responder;
  size_t head_len, tail_len;
  size_t beacon_ies_len;
  size_t proberesp_ies_len;
  size_t assocresp_ies_len;
  size_t probe_resp_len;
  size_t lci_len;
  size_t civicloc_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>head portion of beacon (before TIM IE)
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail</span></code></dt><dd><p>tail portion of beacon (after TIM IE)
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_ies</span></code></dt><dd><p>extra information element(s) to add into Beacon frames or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proberesp_ies</span></code></dt><dd><p>extra information element(s) to add into Probe Response
frames or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assocresp_ies</span></code></dt><dd><p>extra information element(s) to add into (Re)Association
Response frames or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_resp</span></code></dt><dd><p>probe response template (AP mode only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lci</span></code></dt><dd><p>Measurement Report element content, starting with Measurement Token
(measurement type 8)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">civicloc</span></code></dt><dd><p>Measurement Report element content, starting with Measurement
Token (measurement type 11)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ftm_responder</span></code></dt><dd><p>enable FTM responder functionality; -1 for no change
(which also implies no change in LCI/civic location data)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_len</span></code></dt><dd><p>length of <strong>head</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail_len</span></code></dt><dd><p>length of <strong>tail</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_ies_len</span></code></dt><dd><p>length of beacon_ies in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proberesp_ies_len</span></code></dt><dd><p>length of proberesp_ies in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assocresp_ies_len</span></code></dt><dd><p>length of assocresp_ies in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_resp_len</span></code></dt><dd><p>length of probe response template (<strong>probe_resp</strong>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lci_len</span></code></dt><dd><p>LCI data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">civicloc_len</span></code></dt><dd><p>Civic location data length</p>
</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_ap_settings">
struct <code class="sig-name descname">cfg80211_ap_settings</code><a class="headerlink" href="#c.cfg80211_ap_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>AP configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_ap_settings {
  struct cfg80211_chan_def chandef;
  struct cfg80211_beacon_data beacon;
  int beacon_interval, dtim_period;
  const u8 *ssid;
  size_t ssid_len;
  enum nl80211_hidden_ssid hidden_ssid;
  struct cfg80211_crypto_settings crypto;
  bool privacy;
  enum nl80211_auth_type auth_type;
  enum nl80211_smps_mode smps_mode;
  int inactivity_timeout;
  u8 p2p_ctwindow;
  bool p2p_opp_ps;
  const struct cfg80211_acl_data *acl;
  bool pbss;
  struct cfg80211_bitrate_mask beacon_rate;
  const struct ieee80211_ht_cap *ht_cap;
  const struct ieee80211_vht_cap *vht_cap;
  const struct ieee80211_he_cap_elem *he_cap;
  const struct ieee80211_he_operation *he_oper;
  bool ht_required, vht_required;
  bool twt_responder;
  u32 flags;
  struct ieee80211_he_obss_pd he_obss_pd;
  struct cfg80211_he_bss_color he_bss_color;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chandef</span></code></dt><dd><p>defines the channel to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon</span></code></dt><dd><p>beacon data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_interval</span></code></dt><dd><p>beacon interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dtim_period</span></code></dt><dd><p>DTIM period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>SSID to be used in the BSS (note: may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not provided from
user space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>length of <strong>ssid</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hidden_ssid</span></code></dt><dd><p>whether to hide the SSID in Beacon/Probe Response frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto</span></code></dt><dd><p>crypto settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">privacy</span></code></dt><dd><p>the BSS uses privacy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth_type</span></code></dt><dd><p>Authentication type (algorithm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smps_mode</span></code></dt><dd><p>SMPS mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inactivity_timeout</span></code></dt><dd><p>time in seconds to determine station’s inactivity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p2p_ctwindow</span></code></dt><dd><p>P2P CT Window</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p2p_opp_ps</span></code></dt><dd><p>P2P opportunistic PS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acl</span></code></dt><dd><p>ACL configuration used by the drivers which has support for
MAC address based access control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbss</span></code></dt><dd><p>If set, start as a PCP instead of AP. Relevant for DMG
networks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_rate</span></code></dt><dd><p>bitrate to be used for beacons</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_cap</span></code></dt><dd><p>HT capabilities (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if HT isn’t enabled)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_cap</span></code></dt><dd><p>VHT capabilities (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if VHT isn’t enabled)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_cap</span></code></dt><dd><p>HE capabilities (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if HE isn’t enabled)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_oper</span></code></dt><dd><p>HE operation IE (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if HE isn’t enabled)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_required</span></code></dt><dd><p>stations must support HT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_required</span></code></dt><dd><p>stations must support VHT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">twt_responder</span></code></dt><dd><p>Enable Target Wait Time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags, as defined in enum cfg80211_ap_settings_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_obss_pd</span></code></dt><dd><p>OBSS Packet Detection settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_bss_color</span></code></dt><dd><p>BSS Color settings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to configure an AP interface.</p>
<dl class="type">
<dt id="c.station_parameters">
struct <code class="sig-name descname">station_parameters</code><a class="headerlink" href="#c.station_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>station parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct station_parameters {
  const u8 *supported_rates;
  struct net_device *vlan;
  u32 sta_flags_mask, sta_flags_set;
  u32 sta_modify_mask;
  int listen_interval;
  u16 aid;
  u16 vlan_id;
  u16 peer_aid;
  u8 supported_rates_len;
  u8 plink_action;
  u8 plink_state;
  const struct ieee80211_ht_cap *ht_capa;
  const struct ieee80211_vht_cap *vht_capa;
  u8 uapsd_queues;
  u8 max_sp;
  enum nl80211_mesh_power_mode local_pm;
  u16 capability;
  const u8 *ext_capab;
  u8 ext_capab_len;
  const u8 *supported_channels;
  u8 supported_channels_len;
  const u8 *supported_oper_classes;
  u8 supported_oper_classes_len;
  u8 opmode_notif;
  bool opmode_notif_used;
  int support_p2p_ps;
  const struct ieee80211_he_cap_elem *he_capa;
  u8 he_capa_len;
  u16 airtime_weight;
  struct sta_txpwr txpwr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supported_rates</span></code></dt><dd><p>supported rates in IEEE 802.11 format
(or NULL for no change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan</span></code></dt><dd><p>vlan interface station should belong to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_flags_mask</span></code></dt><dd><p>station flags that changed
(bitmask of BIT(<code class="docutils literal notranslate"><span class="pre">NL80211_STA_FLAG_</span></code>…))</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_flags_set</span></code></dt><dd><p>station flags values
(bitmask of BIT(<code class="docutils literal notranslate"><span class="pre">NL80211_STA_FLAG_</span></code>…))</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_modify_mask</span></code></dt><dd><p>bitmap indicating which parameters changed
(for those that don’t have a natural “no change” value),
see <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">station_parameters_apply_mask</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">listen_interval</span></code></dt><dd><p>listen interval or -1 for no change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aid</span></code></dt><dd><p>AID or zero for no change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_id</span></code></dt><dd><p>VLAN ID for station (if nonzero)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_aid</span></code></dt><dd><p>mesh peer AID or zero for no change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_rates_len</span></code></dt><dd><p>number of supported rates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plink_action</span></code></dt><dd><p>plink action to take</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plink_state</span></code></dt><dd><p>set the peer link state for a station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa</span></code></dt><dd><p>HT capabilities of station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa</span></code></dt><dd><p>VHT capabilities of station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uapsd_queues</span></code></dt><dd><p>bitmap of queues configured for uapsd. same format
as the AC bitmap in the QoS info field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sp</span></code></dt><dd><p>max Service Period. same format as the MAX_SP in the
QoS info field (but already shifted down)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_pm</span></code></dt><dd><p>local link-specific mesh power save mode (no change when set
to unknown)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capability</span></code></dt><dd><p>station capability</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_capab</span></code></dt><dd><p>extended capabilities of the station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_capab_len</span></code></dt><dd><p>number of extended capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_channels</span></code></dt><dd><p>supported channels in IEEE 802.11 format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_channels_len</span></code></dt><dd><p>number of supported channels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_oper_classes</span></code></dt><dd><p>supported oper classes in IEEE 802.11 format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_oper_classes_len</span></code></dt><dd><p>number of supported operating classes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opmode_notif</span></code></dt><dd><p>operating mode field from Operating Mode Notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opmode_notif_used</span></code></dt><dd><p>information if operating mode field is used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">support_p2p_ps</span></code></dt><dd><p>information if station supports P2P PS mechanism</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_capa</span></code></dt><dd><p>HE capabilities of station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_capa_len</span></code></dt><dd><p>the length of the HE capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">airtime_weight</span></code></dt><dd><p>airtime scheduler weight for this station</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to change and create a new station.</p>
<dl class="type">
<dt id="c.rate_info_flags">
enum <code class="sig-name descname">rate_info_flags</code><a class="headerlink" href="#c.rate_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate info flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_MCS</span></code></dt><dd><p>mcs field filled with HT MCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_VHT_MCS</span></code></dt><dd><p>mcs field filled with VHT MCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_SHORT_GI</span></code></dt><dd><p>400ns guard interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_DMG</span></code></dt><dd><p>60GHz MCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_HE_MCS</span></code></dt><dd><p>HE MCS information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RATE_INFO_FLAGS_EDMG</span></code></dt><dd><p>60GHz MCS in EDMG mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate the specific rate transmission
type for 802.11n transmissions.</p>
<dl class="type">
<dt id="c.rate_info">
struct <code class="sig-name descname">rate_info</code><a class="headerlink" href="#c.rate_info" title="Permalink to this definition">¶</a></dt>
<dd><p>bitrate information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rate_info {
  u8 flags;
  u8 mcs;
  u16 legacy;
  u8 nss;
  u8 bw;
  u8 he_gi;
  u8 he_dcm;
  u8 he_ru_alloc;
  u8 n_bonded_ch;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>bitflag of flags from <a class="reference internal" href="#c.rate_info_flags" title="rate_info_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rate_info_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mcs</span></code></dt><dd><p>mcs index if struct describes an HT/VHT/HE rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy</span></code></dt><dd><p>bitrate in 100kbit/s for 802.11abg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nss</span></code></dt><dd><p>number of streams (VHT &amp; HE only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bw</span></code></dt><dd><p>bandwidth (from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rate_info_bw</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_gi</span></code></dt><dd><p>HE guard interval (from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_he_gi</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_dcm</span></code></dt><dd><p>HE DCM value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">he_ru_alloc</span></code></dt><dd><p>HE RU allocation (from <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_he_ru_alloc</span></code>,
only valid if bw is <code class="docutils literal notranslate"><span class="pre">RATE_INFO_BW_HE_RU</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_bonded_ch</span></code></dt><dd><p>In case of EDMG the number of bonded channels (1-4)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Information about a receiving or transmitting bitrate</p>
<dl class="type">
<dt id="c.station_info">
struct <code class="sig-name descname">station_info</code><a class="headerlink" href="#c.station_info" title="Permalink to this definition">¶</a></dt>
<dd><p>station information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct station_info {
  u64 filled;
  u32 connected_time;
  u32 inactive_time;
  u64 assoc_at;
  u64 rx_bytes;
  u64 tx_bytes;
  u16 llid;
  u16 plid;
  u8 plink_state;
  s8 signal;
  s8 signal_avg;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
  struct rate_info txrate;
  struct rate_info rxrate;
  u32 rx_packets;
  u32 tx_packets;
  u32 tx_retries;
  u32 tx_failed;
  u32 rx_dropped_misc;
  struct sta_bss_parameters bss_param;
  struct nl80211_sta_flag_update sta_flags;
  int generation;
  const u8 *assoc_req_ies;
  size_t assoc_req_ies_len;
  u32 beacon_loss_count;
  s64 t_offset;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
  u32 expected_throughput;
  u64 tx_duration;
  u64 rx_duration;
  u64 rx_beacon;
  u8 rx_beacon_signal_avg;
  u8 connected_to_gate;
  struct cfg80211_tid_stats *pertid;
  s8 ack_signal;
  s8 avg_ack_signal;
  u16 airtime_weight;
  u32 rx_mpdu_count;
  u32 fcs_err_count;
  u32 airtime_link_metric;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">filled</span></code></dt><dd><p>bitflag of flags using the bits of <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_sta_info</span></code> to
indicate the relevant values in this struct for them</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connected_time</span></code></dt><dd><p>time(in secs) since a station is last connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inactive_time</span></code></dt><dd><p>time since last station activity (tx/rx) in milliseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assoc_at</span></code></dt><dd><p>bootime (ns) of the last association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_bytes</span></code></dt><dd><p>bytes (size of MPDUs) received from this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_bytes</span></code></dt><dd><p>bytes (size of MPDUs) transmitted to this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">llid</span></code></dt><dd><p>mesh local link id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plid</span></code></dt><dd><p>mesh peer link id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plink_state</span></code></dt><dd><p>mesh peer link state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>The signal strength, type depends on the wiphy’s signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_avg</span></code></dt><dd><p>Average signal strength, type depends on the wiphy’s signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chains</span></code></dt><dd><p>bitmask for filled values in <strong>chain_signal</strong>, <strong>chain_signal_avg</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_signal</span></code></dt><dd><p>per-chain signal strength of last received packet in dBm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_signal_avg</span></code></dt><dd><p>per-chain signal strength average in dBm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txrate</span></code></dt><dd><p>current unicast bitrate from this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rxrate</span></code></dt><dd><p>current unicast bitrate to this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_packets</span></code></dt><dd><p>packets (MSDUs &amp; MMPDUs) received from this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_packets</span></code></dt><dd><p>packets (MSDUs &amp; MMPDUs) transmitted to this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_retries</span></code></dt><dd><p>cumulative retry counts (MPDUs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_failed</span></code></dt><dd><p>number of failed transmissions (MPDUs) (retries exceeded, no ACK)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_dropped_misc</span></code></dt><dd><p>Dropped for un-specified reason.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_param</span></code></dt><dd><p>current BSS parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_flags</span></code></dt><dd><p>station flags mask &amp; values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>generation number for nl80211 dumps.
This number should increase every time the list of stations
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assoc_req_ies</span></code></dt><dd><p>IEs from (Re)Association Request.
This is used only when in AP mode with drivers that do not use
user space MLME/SME implementation. The information is provided for
the <a class="reference internal" href="#c.cfg80211_new_sta" title="cfg80211_new_sta"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_new_sta()</span></code></a> calls to notify user space of the IEs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assoc_req_ies_len</span></code></dt><dd><p>Length of assoc_req_ies buffer in octets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_loss_count</span></code></dt><dd><p>Number of times beacon loss event has triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">t_offset</span></code></dt><dd><p>Time offset of the station relative to this host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_pm</span></code></dt><dd><p>local mesh STA power save mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_pm</span></code></dt><dd><p>peer mesh STA power save mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nonpeer_pm</span></code></dt><dd><p>non-peer mesh STA power save mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">expected_throughput</span></code></dt><dd><p>expected throughput in kbps (including 802.11 headers)
towards this station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_duration</span></code></dt><dd><p>aggregate PPDU duration(usecs) for all the frames to a peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_duration</span></code></dt><dd><p>aggregate PPDU duration(usecs) for all the frames from a peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_beacon</span></code></dt><dd><p>number of beacons received from this peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_beacon_signal_avg</span></code></dt><dd><p>signal strength average (in dBm) for beacons received
from this peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connected_to_gate</span></code></dt><dd><p>true if mesh STA has a path to mesh gate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pertid</span></code></dt><dd><p>per-TID statistics, see <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_tid_stats</span></code>, using the last
(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.
Note that this doesn’t use the <strong>filled</strong> bit, but is used if non-NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack_signal</span></code></dt><dd><p>signal strength (in dBm) of the last ACK frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">avg_ack_signal</span></code></dt><dd><p>average rssi value of ack packet for the no of msdu’s has
been sent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">airtime_weight</span></code></dt><dd><p>current airtime scheduling weight</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_mpdu_count</span></code></dt><dd><p>number of MPDUs received from this station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fcs_err_count</span></code></dt><dd><p>number of packets (MPDUs) received from this station with
an FCS error. This counter should be incremented only when TA of the
received packet with an FCS error matches the peer MAC address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">airtime_link_metric</span></code></dt><dd><p>mesh airtime link metric.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Station information filled by driver for get_station() and dump_station.</p>
<dl class="type">
<dt id="c.monitor_flags">
enum <code class="sig-name descname">monitor_flags</code><a class="headerlink" href="#c.monitor_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>monitor flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_CHANGED</span></code></dt><dd><p>set if the flags were changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_FCSFAIL</span></code></dt><dd><p>pass frames with bad FCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_PLCPFAIL</span></code></dt><dd><p>pass frames with bad PLCP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_CONTROL</span></code></dt><dd><p>pass control frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_OTHER_BSS</span></code></dt><dd><p>disable BSSID filtering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_COOK_FRAMES</span></code></dt><dd><p>report frames after processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MONITOR_FLAG_ACTIVE</span></code></dt><dd><p>active monitor, ACKs frames on its MAC address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Monitor interface configuration flags. Note that these must be the bits
according to the nl80211 flags.</p>
<dl class="type">
<dt id="c.mpath_info_flags">
enum <code class="sig-name descname">mpath_info_flags</code><a class="headerlink" href="#c.mpath_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>mesh path information flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_FRAME_QLEN</span></code></dt><dd><p><strong>frame_qlen</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_SN</span></code></dt><dd><p><strong>sn</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_METRIC</span></code></dt><dd><p><strong>metric</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_EXPTIME</span></code></dt><dd><p><strong>exptime</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_DISCOVERY_TIMEOUT</span></code></dt><dd><p><strong>discovery_timeout</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_DISCOVERY_RETRIES</span></code></dt><dd><p><strong>discovery_retries</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_FLAGS</span></code></dt><dd><p><strong>flags</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_HOP_COUNT</span></code></dt><dd><p><strong>hop_count</strong> filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPATH_INFO_PATH_CHANGE</span></code></dt><dd><p><strong>path_change_count</strong> filled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by the driver to indicate which info in <a class="reference internal" href="#c.mpath_info" title="mpath_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mpath_info</span></code></a> it has filled
in during get_station() or dump_station().</p>
<dl class="type">
<dt id="c.mpath_info">
struct <code class="sig-name descname">mpath_info</code><a class="headerlink" href="#c.mpath_info" title="Permalink to this definition">¶</a></dt>
<dd><p>mesh path information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mpath_info {
  u32 filled;
  u32 frame_qlen;
  u32 sn;
  u32 metric;
  u32 exptime;
  u32 discovery_timeout;
  u8 discovery_retries;
  u8 flags;
  u8 hop_count;
  u32 path_change_count;
  int generation;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">filled</span></code></dt><dd><p>bitfield of flags from <a class="reference internal" href="#c.mpath_info_flags" title="mpath_info_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mpath_info_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame_qlen</span></code></dt><dd><p>number of queued frames for this destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sn</span></code></dt><dd><p>target sequence number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metric</span></code></dt><dd><p>metric (cost) of this mesh path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exptime</span></code></dt><dd><p>expiration time for the mesh path from now, in msecs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">discovery_timeout</span></code></dt><dd><p>total mesh path discovery timeout, in msecs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">discovery_retries</span></code></dt><dd><p>mesh path discovery retries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>mesh path flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hop_count</span></code></dt><dd><p>hops to destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_change_count</span></code></dt><dd><p>total number of path changes to destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>generation number for nl80211 dumps.
This number should increase every time the list of mesh paths
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mesh path information filled by driver for get_mpath() and dump_mpath().</p>
<dl class="type">
<dt id="c.bss_parameters">
struct <code class="sig-name descname">bss_parameters</code><a class="headerlink" href="#c.bss_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bss_parameters {
  int use_cts_prot;
  int use_short_preamble;
  int use_short_slot_time;
  const u8 *basic_rates;
  u8 basic_rates_len;
  int ap_isolate;
  int ht_opmode;
  s8 p2p_ctwindow, p2p_opp_ps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">use_cts_prot</span></code></dt><dd><p>Whether to use CTS protection
(0 = no, 1 = yes, -1 = do not change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_short_preamble</span></code></dt><dd><p>Whether the use of short preambles is allowed
(0 = no, 1 = yes, -1 = do not change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_short_slot_time</span></code></dt><dd><p>Whether the use of short slot time is allowed
(0 = no, 1 = yes, -1 = do not change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">basic_rates</span></code></dt><dd><p>basic rates in IEEE 802.11 format
(or NULL for no change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">basic_rates_len</span></code></dt><dd><p>number of basic rates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ap_isolate</span></code></dt><dd><p>do not forward packets between connected stations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_opmode</span></code></dt><dd><p>HT Operation mode
(u16 = opmode, -1 = do not change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p2p_ctwindow</span></code></dt><dd><p>P2P CT Window (-1 = no change)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p2p_opp_ps</span></code></dt><dd><p>P2P opportunistic PS (-1 = no change)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to change BSS parameters (mainly for AP mode).</p>
<dl class="type">
<dt id="c.ieee80211_txq_params">
struct <code class="sig-name descname">ieee80211_txq_params</code><a class="headerlink" href="#c.ieee80211_txq_params" title="Permalink to this definition">¶</a></dt>
<dd><p>TX queue parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_txq_params {
  enum nl80211_ac ac;
  u16 txop;
  u16 cwmin;
  u16 cwmax;
  u8 aifs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ac</span></code></dt><dd><p>AC identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txop</span></code></dt><dd><p>Maximum burst time in units of 32 usecs, 0 meaning disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cwmin</span></code></dt><dd><p>Minimum contention window [a value of the form 2^n-1 in the range
1..32767]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cwmax</span></code></dt><dd><p>Maximum contention window [a value of the form 2^n-1 in the range
1..32767]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aifs</span></code></dt><dd><p>Arbitration interframe space [0..255]</p>
</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_crypto_settings">
struct <code class="sig-name descname">cfg80211_crypto_settings</code><a class="headerlink" href="#c.cfg80211_crypto_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Crypto settings</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_crypto_settings {
  u32 wpa_versions;
  u32 cipher_group;
  int n_ciphers_pairwise;
  u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
  int n_akm_suites;
  u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
  bool control_port;
  __be16 control_port_ethertype;
  bool control_port_no_encrypt;
  bool control_port_over_nl80211;
  bool control_port_no_preauth;
  struct key_params *wep_keys;
  int wep_tx_key;
  const u8 *psk;
  const u8 *sae_pwd;
  u8 sae_pwd_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wpa_versions</span></code></dt><dd><p>indicates which, if any, WPA versions are enabled
(from enum nl80211_wpa_versions)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cipher_group</span></code></dt><dd><p>group key cipher suite (or 0 if unset)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_ciphers_pairwise</span></code></dt><dd><p>number of AP supported unicast ciphers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ciphers_pairwise</span></code></dt><dd><p>unicast key cipher suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_akm_suites</span></code></dt><dd><p>number of AKM suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">akm_suites</span></code></dt><dd><p>AKM suites</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port</span></code></dt><dd><p>Whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="docutils literal notranslate"><span class="pre">NL80211_STA_FLAG_AUTHORIZED</span></code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port_ethertype</span></code></dt><dd><p>the control port protocol that should be
allowed through even on unauthorized ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port_no_encrypt</span></code></dt><dd><p>TRUE to prevent encryption of control port
protocol frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port_over_nl80211</span></code></dt><dd><p>TRUE if userspace expects to exchange control
port frames over NL80211 instead of the network interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wep_keys</span></code></dt><dd><p>static WEP keys, if not NULL points to an array of
CFG80211_MAX_WEP_KEYS WEP keys</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wep_tx_key</span></code></dt><dd><p>key index (0..3) of the default TX static WEP key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">psk</span></code></dt><dd><p>PSK (for devices supporting 4-way-handshake offload)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sae_pwd</span></code></dt><dd><p>password for SAE authentication (for devices supporting SAE
offload)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sae_pwd_len</span></code></dt><dd><p>length of SAE password (for devices supporting SAE offload)</p>
</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_auth_request">
struct <code class="sig-name descname">cfg80211_auth_request</code><a class="headerlink" href="#c.cfg80211_auth_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Authentication request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_auth_request {
  struct cfg80211_bss *bss;
  const u8 *ie;
  size_t ie_len;
  enum nl80211_auth_type auth_type;
  const u8 *key;
  u8 key_len, key_idx;
  const u8 *auth_data;
  size_t auth_data_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bss</span></code></dt><dd><p>The BSS to authenticate with, the callee must obtain a reference
to it if it needs to keep it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>Extra IEs to add to Authentication frame or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>Length of ie buffer in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth_type</span></code></dt><dd><p>Authentication type (algorithm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_len</span></code></dt><dd><p>length of WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_idx</span></code></dt><dd><p>index of WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth_data</span></code></dt><dd><p>Fields and elements in Authentication frames. This contains
the authentication frame body (non-IE and IE data), excluding the
Authentication algorithm number, i.e., starting at the Authentication
transaction sequence number field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth_data_len</span></code></dt><dd><p>Length of auth_data buffer in octets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
authentication.</p>
<dl class="type">
<dt id="c.cfg80211_assoc_request">
struct <code class="sig-name descname">cfg80211_assoc_request</code><a class="headerlink" href="#c.cfg80211_assoc_request" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)Association request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_assoc_request {
  struct cfg80211_bss *bss;
  const u8 *ie, *prev_bssid;
  size_t ie_len;
  struct cfg80211_crypto_settings crypto;
  bool use_mfp;
  u32 flags;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa, vht_capa_mask;
  const u8 *fils_kek;
  size_t fils_kek_len;
  const u8 *fils_nonces;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bss</span></code></dt><dd><p>The BSS to associate with. If the call is successful the driver is
given a reference that it must give back to cfg80211_send_rx_assoc()
or to <a class="reference internal" href="#c.cfg80211_assoc_timeout" title="cfg80211_assoc_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_assoc_timeout()</span></code></a>. To ensure proper refcounting, new
association requests while already associating must be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>Extra IEs to add to (Re)Association Request frame or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev_bssid</span></code></dt><dd><p>previous BSSID, if not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>Length of ie buffer in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto</span></code></dt><dd><p>crypto settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_mfp</span></code></dt><dd><p>Use management frame protection (IEEE 802.11w) in this association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>See <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cfg80211_assoc_req_flags</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa</span></code></dt><dd><p>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa_mask</span></code></dt><dd><p>The bits of ht_capa which are to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa</span></code></dt><dd><p>VHT capability override</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa_mask</span></code></dt><dd><p>VHT capability mask indicating which fields to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_kek</span></code></dt><dd><p>FILS KEK for protecting (Re)Association Request/Response frame or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if FILS is not used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_kek_len</span></code></dt><dd><p>Length of fils_kek in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_nonces</span></code></dt><dd><p>FILS nonces (part of AAD) for protecting (Re)Association
Request/Response frame or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if FILS is not used. This field starts
with 16 octets of STA Nonce followed by 16 octets of AP Nonce.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
(re)association.</p>
<dl class="type">
<dt id="c.cfg80211_deauth_request">
struct <code class="sig-name descname">cfg80211_deauth_request</code><a class="headerlink" href="#c.cfg80211_deauth_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Deauthentication request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_deauth_request {
  const u8 *bssid;
  const u8 *ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>the BSSID of the BSS to deauthenticate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>Extra IEs to add to Deauthentication frame or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>Length of ie buffer in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reason_code</span></code></dt><dd><p>The reason code for the deauthentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_state_change</span></code></dt><dd><p>if set, change local state only and
do not set a deauth frame</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
deauthentication.</p>
<dl class="type">
<dt id="c.cfg80211_disassoc_request">
struct <code class="sig-name descname">cfg80211_disassoc_request</code><a class="headerlink" href="#c.cfg80211_disassoc_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Disassociation request data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_disassoc_request {
  struct cfg80211_bss *bss;
  const u8 *ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bss</span></code></dt><dd><p>the BSS to disassociate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>Extra IEs to add to Disassociation frame or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>Length of ie buffer in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reason_code</span></code></dt><dd><p>The reason code for the disassociation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_state_change</span></code></dt><dd><p>This is a request for a local state only, i.e., no
Disassociation frame is to be transmitted.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
disassociation.</p>
<dl class="type">
<dt id="c.cfg80211_ibss_params">
struct <code class="sig-name descname">cfg80211_ibss_params</code><a class="headerlink" href="#c.cfg80211_ibss_params" title="Permalink to this definition">¶</a></dt>
<dd><p>IBSS parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_ibss_params {
  const u8 *ssid;
  const u8 *bssid;
  struct cfg80211_chan_def chandef;
  const u8 *ie;
  u8 ssid_len, ie_len;
  u16 beacon_interval;
  u32 basic_rates;
  bool channel_fixed;
  bool privacy;
  bool control_port;
  bool control_port_over_nl80211;
  bool userspace_handles_dfs;
  int mcast_rate[NUM_NL80211_BANDS];
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct key_params *wep_keys;
  int wep_tx_key;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>The SSID, will always be non-null.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>Fixed BSSID requested, maybe be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, if set do not
search for IBSSs with a different BSSID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chandef</span></code></dt><dd><p>defines the channel to use if no other IBSS to join can be found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>information element(s) to include in the beacon</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>The length of the SSID, will always be non-zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>length of that</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_interval</span></code></dt><dd><p>beacon interval to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">basic_rates</span></code></dt><dd><p>bitmap of basic rates to use when creating the IBSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_fixed</span></code></dt><dd><p>The channel should be fixed – do not search for
IBSSs to join on other channels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">privacy</span></code></dt><dd><p>this is a protected network, keys will be configured
after joining</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port</span></code></dt><dd><p>whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="docutils literal notranslate"><span class="pre">NL80211_STA_FLAG_AUTHORIZED</span></code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">control_port_over_nl80211</span></code></dt><dd><p>TRUE if userspace expects to exchange control
port frames over NL80211 instead of the network interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">userspace_handles_dfs</span></code></dt><dd><p>whether user space controls DFS operation, i.e.
changes the channel when a radar is detected. This is required
to operate on DFS channels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mcast_rate</span></code></dt><dd><p>per-band multicast rate index + 1 (0: disabled)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa</span></code></dt><dd><p>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa_mask</span></code></dt><dd><p>The bits of ht_capa which are to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wep_keys</span></code></dt><dd><p>static WEP keys, if not NULL points to an array of
CFG80211_MAX_WEP_KEYS WEP keys</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wep_tx_key</span></code></dt><dd><p>key index (0..3) of the default TX static WEP key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines the IBSS parameters for the join_ibss()
method.</p>
<dl class="type">
<dt id="c.cfg80211_connect_params">
struct <code class="sig-name descname">cfg80211_connect_params</code><a class="headerlink" href="#c.cfg80211_connect_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection parameters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_connect_params {
  struct ieee80211_channel *channel;
  struct ieee80211_channel *channel_hint;
  const u8 *bssid;
  const u8 *bssid_hint;
  const u8 *ssid;
  size_t ssid_len;
  enum nl80211_auth_type auth_type;
  const u8 *ie;
  size_t ie_len;
  bool privacy;
  enum nl80211_mfp mfp;
  struct cfg80211_crypto_settings crypto;
  const u8 *key;
  u8 key_len, key_idx;
  u32 flags;
  int bg_scan_period;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
  bool pbss;
  struct cfg80211_bss_selection bss_select;
  const u8 *prev_bssid;
  const u8 *fils_erp_username;
  size_t fils_erp_username_len;
  const u8 *fils_erp_realm;
  size_t fils_erp_realm_len;
  u16 fils_erp_next_seq_num;
  const u8 *fils_erp_rrk;
  size_t fils_erp_rrk_len;
  bool want_1x;
  struct ieee80211_edmg edmg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>The channel to use or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified (auto-select based
on scan results)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel_hint</span></code></dt><dd><p>The channel of the recommended BSS for initial connection or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>The AP BSSID or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified (auto-select based on scan
results)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid_hint</span></code></dt><dd><p>The recommended AP BSSID for initial connection to the BSS or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified. Unlike the <strong>bssid</strong> parameter, the driver is
allowed to ignore this <strong>bssid_hint</strong> if it has knowledge of a better BSS
to use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>SSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>Length of ssid in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auth_type</span></code></dt><dd><p>Authentication type (algorithm)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>IEs for association request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>Length of assoc_ie in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">privacy</span></code></dt><dd><p>indicates whether privacy-enabled APs should be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfp</span></code></dt><dd><p>indicate whether management frame protection is used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto</span></code></dt><dd><p>crypto settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_len</span></code></dt><dd><p>length of WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_idx</span></code></dt><dd><p>index of WEP key for shared key authentication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>See <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cfg80211_assoc_req_flags</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bg_scan_period</span></code></dt><dd><p>Background scan period in seconds
or -1 to indicate that default value is to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa</span></code></dt><dd><p>HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ht_capa_mask</span></code></dt><dd><p>The bits of ht_capa which are to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa</span></code></dt><dd><p>VHT Capability overrides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vht_capa_mask</span></code></dt><dd><p>The bits of vht_capa which are to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbss</span></code></dt><dd><p>if set, connect to a PCP instead of AP. Valid for DMG
networks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_select</span></code></dt><dd><p>criteria to be used for BSS selection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev_bssid</span></code></dt><dd><p>previous BSSID, if not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_username</span></code></dt><dd><p>EAP re-authentication protocol (ERP) username part of the
NAI or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified. This is used to construct FILS wrapped
data IE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_username_len</span></code></dt><dd><p>Length of <strong>fils_erp_username</strong> in octets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_realm</span></code></dt><dd><p>EAP re-authentication protocol (ERP) realm part of NAI or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified. This specifies the domain name of ER server and
is used to construct FILS wrapped data IE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_realm_len</span></code></dt><dd><p>Length of <strong>fils_erp_realm</strong> in octets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_next_seq_num</span></code></dt><dd><p>The next sequence number to use in the FILS ERP
messages. This is also used to construct FILS wrapped data IE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_rrk</span></code></dt><dd><p>ERP re-authentication Root Key (rRK) used to derive additional
keys in FILS or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils_erp_rrk_len</span></code></dt><dd><p>Length of <strong>fils_erp_rrk</strong> in octets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">want_1x</span></code></dt><dd><p>indicates user-space supports and wants to use 802.1X driver
offload of 4-way handshake.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edmg</span></code></dt><dd><p>define the EDMG channels.
This may specify multiple channels and bonding options for the driver
to choose from, based on BSS configuration.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure provides information needed to complete IEEE 802.11
authentication and association.</p>
<dl class="type">
<dt id="c.cfg80211_pmksa">
struct <code class="sig-name descname">cfg80211_pmksa</code><a class="headerlink" href="#c.cfg80211_pmksa" title="Permalink to this definition">¶</a></dt>
<dd><p>PMK Security Association</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_pmksa {
  const u8 *bssid;
  const u8 *pmkid;
  const u8 *pmk;
  size_t pmk_len;
  const u8 *ssid;
  size_t ssid_len;
  const u8 *cache_id;
  u32 pmk_lifetime;
  u8 pmk_reauth_threshold;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>The AP’s BSSID (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmkid</span></code></dt><dd><p>The identifier to refer a PMKSA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmk</span></code></dt><dd><p>The PMK for the PMKSA identified by <strong>pmkid</strong>. This is used for key
derivation by a FILS STA. Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmk_len</span></code></dt><dd><p>Length of the <strong>pmk</strong>. The length of <strong>pmk</strong> can differ depending on
the hash algorithm used to generate this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>SSID to specify the ESS within which a PMKSA is valid when using FILS
cache identifier (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>Length of the <strong>ssid</strong> in octets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache_id</span></code></dt><dd><p>2-octet cache identifier advertized by a FILS AP identifying the
scope of PMKSA. This is valid only if <strong>ssid_len</strong> is non-zero (may be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmk_lifetime</span></code></dt><dd><p>Maximum lifetime for PMKSA in seconds
(dot11RSNAConfigPMKLifetime) or 0 if not specified.
The configured PMKSA must not be used for PMKSA caching after
expiration and any keys derived from this PMK become invalid on
expiration, i.e., the current association must be dropped if the PMK
used for it expires.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmk_reauth_threshold</span></code></dt><dd><p>Threshold time for reauthentication (percentage of
PMK lifetime, dot11RSNAConfigPMKReauthThreshold) or 0 if not specified.
Drivers are expected to trigger a full authentication instead of using
this PMKSA for caching when reassociating to a new BSS after this
threshold to generate a new PMK before the current one expires.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is passed to the set/del_pmksa() method for PMKSA
caching.</p>
<dl class="function">
<dt id="c.cfg80211_rx_mlme_mgmt">
void <code class="sig-name descname">cfg80211_rx_mlme_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_mlme_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of processed MLME management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>authentication frame (header + body)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the frame data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever an authentication, disassociation or
deauthentication frame has been received and processed in station mode.
After being asked to authenticate via cfg80211_ops::auth() the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_auth_timeout()</span></code></a>.
After being asked to associate via cfg80211_ops::assoc() the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_auth_timeout()</span></code></a>.
While connected, the driver must calls this for received and processed
disassociation and deauthentication frames. If the frame couldn’t be used
because it was unprotected, the driver must call the function
cfg80211_rx_unprot_mlme_mgmt() instead.</p>
<p>This function may sleep. The caller must hold the corresponding wdev’s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_auth_timeout">
void <code class="sig-name descname">cfg80211_auth_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_auth_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of timed out authentication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>The MAC address of the device with which the authentication timed out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function may sleep. The caller must hold the corresponding wdev’s
mutex.</p>
<dl class="function">
<dt id="c.cfg80211_rx_assoc_resp">
void <code class="sig-name descname">cfg80211_rx_assoc_resp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em> bss</em>, const u8 *<em> buf</em>, size_t<em> len</em>, int<em> uapsd_queues</em>, const u8 *<em> req_ies</em>, size_t<em> req_ies_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_assoc_resp" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of processed association response</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt><dd><p>the BSS that association was requested with, ownership of the pointer
moves to cfg80211 in this call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>(Re)Association Response frame (header + body)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the frame data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">uapsd_queues</span></code></dt><dd><p>bitmap of queues configured for uapsd. Same format
as the AC bitmap in the QoS info field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ies</span></code></dt><dd><p>information elements from the (Re)Association Request frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">req_ies_len</span></code></dt><dd><p>length of req_ies data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After being asked to associate via cfg80211_ops::assoc() the driver must
call either this function or <a class="reference internal" href="#c.cfg80211_auth_timeout" title="cfg80211_auth_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_auth_timeout()</span></code></a>.</p>
<p>This function may sleep. The caller must hold the corresponding wdev’s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_assoc_timeout">
void <code class="sig-name descname">cfg80211_assoc_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em> bss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_assoc_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of timed out association</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt><dd><p>The BSS entry with which association timed out.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function may sleep. The caller must hold the corresponding wdev’s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_tx_mlme_mgmt">
void <code class="sig-name descname">cfg80211_tx_mlme_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_tx_mlme_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of transmitted deauth/disassoc frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>802.11 frame (header + body)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the frame data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever deauthentication has been processed in
station mode. This includes both received deauthentication frames and
locally generated ones. This function may sleep. The caller must hold the
corresponding wdev’s mutex.</p>
<dl class="function">
<dt id="c.cfg80211_ibss_joined">
void <code class="sig-name descname">cfg80211_ibss_joined</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> bssid</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em> channel</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_ibss_joined" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 that device joined an IBSS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt><dd><p>the BSSID of the IBSS joined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">channel</span></code></dt><dd><p>the channel of the IBSS joined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function notifies cfg80211 that the device joined an IBSS or
switched to a different BSSID. Before this function can be called,
either a beacon has to have been received from the IBSS, or one of
the cfg80211_inform_bss{,_frame} functions must have been called
with the locally generated beacon – this guarantees that there is
always a scan result for this IBSS. cfg80211 will handle the rest.</p>
<dl class="type">
<dt id="c.cfg80211_connect_resp_params">
struct <code class="sig-name descname">cfg80211_connect_resp_params</code><a class="headerlink" href="#c.cfg80211_connect_resp_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection response params</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_connect_resp_params {
  int status;
  const u8 *bssid;
  struct cfg80211_bss *bss;
  const u8 *req_ie;
  size_t req_ie_len;
  const u8 *resp_ie;
  size_t resp_ie_len;
  struct cfg80211_fils_resp_params fils;
  enum nl80211_timeout_reason timeout_reason;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Status code, <code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_SUCCESS</span></code> for successful connection, use
<code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_UNSPECIFIED_FAILURE</span></code> if your device cannot give you
the real status code for failures. If this call is used to report a
failure due to a timeout (e.g., not receiving an Authentication frame
from the AP) instead of an explicit rejection by the AP, -1 is used to
indicate that this is a failure, but without a status code.
<strong>timeout_reason</strong> is used to report the reason for the timeout in that
case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>The BSSID of the AP (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss</span></code></dt><dd><p>Entry of bss to which STA got connected to, can be obtained through
cfg80211_get_bss() (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). But it is recommended to store the
bss from the connect_request and hold a reference to it and return
through this param to avoid a warning if the bss is expired during the
connection, esp. for those drivers implementing connect op.
Only one parameter among <strong>bssid</strong> and <strong>bss</strong> needs to be specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_ie</span></code></dt><dd><p>Association request IEs (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_ie_len</span></code></dt><dd><p>Association request IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resp_ie</span></code></dt><dd><p>Association response IEs (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resp_ie_len</span></code></dt><dd><p>Association response IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fils</span></code></dt><dd><p>FILS connection response parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout_reason</span></code></dt><dd><p>Reason for connection timeout. This is used when the
connection fails due to a timeout instead of an explicit rejection from
the AP. <code class="docutils literal notranslate"><span class="pre">NL80211_TIMEOUT_UNSPECIFIED</span></code> is used when the timeout reason is
not known. This value is used only if <strong>status</strong> &lt; 0 to indicate that the
failure is due to a timeout and not due to explicit rejection by the AP.
This value is ignored in other cases (<strong>status</strong> &gt;= 0).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_connect_done">
void <code class="sig-name descname">cfg80211_connect_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct <a class="reference internal" href="#c.cfg80211_connect_resp_params" title="cfg80211_connect_resp_params">cfg80211_connect_resp_params</a> *<em> params</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_done" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_connect_resp_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>connection response parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver once execution of the connection
request from connect() has been completed. This is similar to
<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a>, but takes a structure pointer for connection response
parameters. Only one of the functions among <a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a>,
<a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>, <a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a>,
and <a class="reference internal" href="#c.cfg80211_connect_done" title="cfg80211_connect_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_done()</span></code></a> should be called.</p>
<dl class="function">
<dt id="c.cfg80211_connect_result">
void <code class="sig-name descname">cfg80211_connect_result</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> bssid</em>, const u8 *<em> req_ie</em>, size_t<em> req_ie_len</em>, const u8 *<em> resp_ie</em>, size_t<em> resp_ie_len</em>, u16<em> status</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_result" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt><dd><p>the BSSID of the AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt><dd><p>association request IEs (maybe be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt><dd><p>association request IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">resp_ie</span></code></dt><dd><p>association response IEs (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">resp_ie_len</span></code></dt><dd><p>assoc response IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">status</span></code></dt><dd><p>status code, <code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_SUCCESS</span></code> for successful connection, use
<code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_UNSPECIFIED_FAILURE</span></code> if your device cannot give you
the real status code for failures.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver once execution of the connection
request from connect() has been completed. This is similar to
<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a> which allows the exact bss entry to be specified. Only
one of the functions among <a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a>, <a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>,
<a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a>, and <a class="reference internal" href="#c.cfg80211_connect_done" title="cfg80211_connect_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_done()</span></code></a> should be called.</p>
<dl class="function">
<dt id="c.cfg80211_connect_bss">
void <code class="sig-name descname">cfg80211_connect_bss</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> bssid</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em> bss</em>, const u8 *<em> req_ie</em>, size_t<em> req_ie_len</em>, const u8 *<em> resp_ie</em>, size_t<em> resp_ie_len</em>, int<em> status</em>, gfp_t<em> gfp</em>, enum nl80211_timeout_reason<em> timeout_reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt><dd><p>the BSSID of the AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt><dd><p>Entry of bss to which STA got connected to, can be obtained through
cfg80211_get_bss() (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>). But it is recommended to store the
bss from the connect_request and hold a reference to it and return
through this param to avoid a warning if the bss is expired during the
connection, esp. for those drivers implementing connect op.
Only one parameter among <strong>bssid</strong> and <strong>bss</strong> needs to be specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt><dd><p>association request IEs (maybe be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt><dd><p>association request IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">resp_ie</span></code></dt><dd><p>association response IEs (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">resp_ie_len</span></code></dt><dd><p>assoc response IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>status code, <code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_SUCCESS</span></code> for successful connection, use
<code class="docutils literal notranslate"><span class="pre">WLAN_STATUS_UNSPECIFIED_FAILURE</span></code> if your device cannot give you
the real status code for failures. If this call is used to report a
failure due to a timeout (e.g., not receiving an Authentication frame
from the AP) instead of an explicit rejection by the AP, -1 is used to
indicate that this is a failure, but without a status code.
<strong>timeout_reason</strong> is used to report the reason for the timeout in that
case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_timeout_reason</span> <span class="pre">timeout_reason</span></code></dt><dd><p>reason for connection timeout. This is used when the
connection fails due to a timeout instead of an explicit rejection from
the AP. <code class="docutils literal notranslate"><span class="pre">NL80211_TIMEOUT_UNSPECIFIED</span></code> is used when the timeout reason is
not known. This value is used only if <strong>status</strong> &lt; 0 to indicate that the
failure is due to a timeout and not due to explicit rejection by the AP.
This value is ignored in other cases (<strong>status</strong> &gt;= 0).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver once execution of the connection
request from connect() has been completed. This is similar to
<a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>, but with the option of identifying the exact bss
entry for the connection. Only one of the functions among
<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a>, <a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>,
<a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a>, and <a class="reference internal" href="#c.cfg80211_connect_done" title="cfg80211_connect_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_done()</span></code></a> should be called.</p>
<dl class="function">
<dt id="c.cfg80211_connect_timeout">
void <code class="sig-name descname">cfg80211_connect_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> bssid</em>, const u8 *<em> req_ie</em>, size_t<em> req_ie_len</em>, gfp_t<em> gfp</em>, enum nl80211_timeout_reason<em> timeout_reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_connect_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of connection timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt><dd><p>the BSSID of the AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">req_ie</span></code></dt><dd><p>association request IEs (maybe be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">req_ie_len</span></code></dt><dd><p>association request IEs length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_timeout_reason</span> <span class="pre">timeout_reason</span></code></dt><dd><p>reason for connection timeout.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It should be called by the underlying driver whenever connect() has failed
in a sequence where no explicit authentication/association rejection was
received from the AP. This could happen, e.g., due to not being able to send
out the Authentication or Association Request frame or timing out while
waiting for the response. Only one of the functions among
<a class="reference internal" href="#c.cfg80211_connect_bss" title="cfg80211_connect_bss"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_bss()</span></code></a>, <a class="reference internal" href="#c.cfg80211_connect_result" title="cfg80211_connect_result"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_result()</span></code></a>,
<a class="reference internal" href="#c.cfg80211_connect_timeout" title="cfg80211_connect_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_timeout()</span></code></a>, and <a class="reference internal" href="#c.cfg80211_connect_done" title="cfg80211_connect_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_connect_done()</span></code></a> should be called.</p>
<dl class="function">
<dt id="c.cfg80211_roamed">
void <code class="sig-name descname">cfg80211_roamed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, struct cfg80211_roam_info *<em> info</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_roamed" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 of roaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_roam_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>information about the new BSS. struct <code class="xref c c-type docutils literal notranslate"><span class="pre">cfg80211_roam_info</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function may be called with the driver passing either the BSSID of the
new AP or passing the bss entry to avoid a race in timeout of the bss entry.
It should be called by the underlying driver whenever it roamed from one AP
to another while connected. Drivers which have roaming implemented in
firmware should pass the bss entry to avoid a race in bss entry timeout where
the bss entry of the new AP is seen in the driver, but gets timed out by the
time it is accessed in __cfg80211_roamed() due to delay in scheduling
rdev-&gt;event_work. In case of any failures, the reference is released
either in <a class="reference internal" href="#c.cfg80211_roamed" title="cfg80211_roamed"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_roamed()</span></code></a> or in __cfg80211_romed(), Otherwise, it will be
released while disconnecting from the current bss.</p>
<dl class="function">
<dt id="c.cfg80211_disconnected">
void <code class="sig-name descname">cfg80211_disconnected</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, u16<em> reason</em>, const u8 *<em> ie</em>, size_t<em> ie_len</em>, bool<em> locally_generated</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_disconnected" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 that connection was dropped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">reason</span></code></dt><dd><p>reason code for the disconnection, set it to 0 if unknown</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ie</span></code></dt><dd><p>information elements of the deauth/disassoc frame (may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">ie_len</span></code></dt><dd><p>length of IEs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">locally_generated</span></code></dt><dd><p>disconnection was requested locally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After it calls this function, the driver should enter an idle state
and not try to connect to any AP any more.</p>
<dl class="function">
<dt id="c.cfg80211_ready_on_channel">
void <code class="sig-name descname">cfg80211_ready_on_channel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em> wdev</em>, u64<em> cookie</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em> chan</em>, unsigned int<em> duration</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_ready_on_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of remain_on_channel start</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt><dd><p>wireless device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt><dd><p>the request cookie</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>The current channel (from remain_on_channel request)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duration</span></code></dt><dd><p>Duration in milliseconds that the driver intents to remain on the
channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_remain_on_channel_expired">
void <code class="sig-name descname">cfg80211_remain_on_channel_expired</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em> wdev</em>, u64<em> cookie</em>, struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> *<em> chan</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_remain_on_channel_expired" title="Permalink to this definition">¶</a></dt>
<dd><p>remain_on_channel duration expired</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt><dd><p>wireless device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt><dd><p>the request cookie</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt><dd><p>The current channel (from remain_on_channel request)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_new_sta">
void <code class="sig-name descname">cfg80211_new_sta</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> mac_addr</em>, struct <a class="reference internal" href="#c.station_info" title="station_info">station_info</a> *<em> sinfo</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_new_sta" title="Permalink to this definition">¶</a></dt>
<dd><p>notify userspace about station</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the netdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mac_addr</span></code></dt><dd><p>the station’s address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">station_info</span> <span class="pre">*</span> <span class="pre">sinfo</span></code></dt><dd><p>the station information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_rx_mgmt">
bool <code class="sig-name descname">cfg80211_rx_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em> wdev</em>, int<em> freq</em>, int<em> sig_dbm</em>, const u8 *<em> buf</em>, size_t<em> len</em>, u32<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_rx_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of received, unprocessed management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt><dd><p>wireless device receiving the frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">freq</span></code></dt><dd><p>Frequency on which the frame was received in MHz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig_dbm</span></code></dt><dd><p>signal strength in dBm, or 0 if unknown</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Management frame (header + body)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the frame data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags, as defined in enum nl80211_rxmgmt_flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever an Action frame is received for a station
mode interface, but is not processed in kernel.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if a user space application has registered for this frame.
For action frames, that makes it responsible for rejecting unrecognized
action frames; <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise, in which case for action frames the
driver is responsible for rejecting the frame.</p>
<dl class="function">
<dt id="c.cfg80211_mgmt_tx_status">
void <code class="sig-name descname">cfg80211_mgmt_tx_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wireless_dev" title="wireless_dev">wireless_dev</a> *<em> wdev</em>, u64<em> cookie</em>, const u8 *<em> buf</em>, size_t<em> len</em>, bool<em> ack</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_mgmt_tx_status" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of TX status for management frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wireless_dev</span> <span class="pre">*</span> <span class="pre">wdev</span></code></dt><dd><p>wireless device receiving the frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">cookie</span></code></dt><dd><p>Cookie returned by cfg80211_ops::mgmt_tx()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Management frame (header + body)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the frame data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ack</span></code></dt><dd><p>Whether frame was acknowledged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>context flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever a management frame was requested to be
transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
transmission attempt.</p>
<dl class="function">
<dt id="c.cfg80211_cqm_rssi_notify">
void <code class="sig-name descname">cfg80211_cqm_rssi_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, enum nl80211_cqm_rssi_threshold_event<em> rssi_event</em>, s32<em> rssi_level</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_cqm_rssi_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>connection quality monitoring rssi event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_cqm_rssi_threshold_event</span> <span class="pre">rssi_event</span></code></dt><dd><p>the triggered RSSI event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">rssi_level</span></code></dt><dd><p>new RSSI level value or 0 if not available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>context flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when a configured connection quality monitoring
rssi threshold reached event occurs.</p>
<dl class="function">
<dt id="c.cfg80211_cqm_pktloss_notify">
void <code class="sig-name descname">cfg80211_cqm_pktloss_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> peer</em>, u32<em> num_packets</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_cqm_pktloss_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notify userspace about packetloss to peer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">peer</span></code></dt><dd><p>peer’s MAC address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">num_packets</span></code></dt><dd><p>how many packets were lost – should be a fixed threshold
but probably no less than maybe 50, or maybe a throughput dependent
threshold (to account for temporary interference)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>context flags</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_michael_mic_failure">
void <code class="sig-name descname">cfg80211_michael_mic_failure</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em> dev</em>, const u8 *<em> addr</em>, enum nl80211_key_type<em> key_type</em>, int<em> key_id</em>, const u8 *<em> tsc</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_michael_mic_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>notification of Michael MIC failure (TKIP)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>The source MAC address of the frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_key_type</span> <span class="pre">key_type</span></code></dt><dd><p>The key type that the received frame used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">key_id</span></code></dt><dd><p>Key identifier (0..3). Can be -1 if missing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">tsc</span></code></dt><dd><p>The TSC value of the frame that generated the MIC failure (6 octets)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called whenever the local MAC detects a MIC failure in a
received frame. This matches with MLME-MICHAELMICFAILURE.indication()
primitive.</p>
</div>
<div class="section" id="scanning-and-bss-list-handling">
<h2>Scanning and BSS list handling<a class="headerlink" href="#scanning-and-bss-list-handling" title="Permalink to this headline">¶</a></h2>
<p>The scanning process itself is fairly simple, but cfg80211 offers quite
a bit of helper functionality. To start a scan, the scan operation will
be invoked with a scan definition. This scan definition contains the
channels to scan, and the SSIDs to send probe requests for (including the
wildcard, if desired). A passive scan is indicated by having no SSIDs to
probe. Additionally, a scan request may contain extra information elements
that should be added to the probe request. The IEs are guaranteed to be
well-formed, and will not exceed the maximum length the driver advertised
in the wiphy structure.</p>
<p>When scanning finds a BSS, cfg80211 needs to be notified of that, because
it is responsible for maintaining the BSS list; the driver should not
maintain a list itself. For this notification, various functions exist.</p>
<p>Since drivers do not maintain a BSS list, there are also a number of
functions to search for a BSS and obtain information about it from the
BSS structure cfg80211 maintains. The BSS list is also made available
to userspace.</p>
<dl class="type">
<dt id="c.cfg80211_ssid">
struct <code class="sig-name descname">cfg80211_ssid</code><a class="headerlink" href="#c.cfg80211_ssid" title="Permalink to this definition">¶</a></dt>
<dd><p>SSID description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_ssid {
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ssid</span></code></dt><dd><p>the SSID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssid_len</span></code></dt><dd><p>length of the ssid</p>
</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_scan_request">
struct <code class="sig-name descname">cfg80211_scan_request</code><a class="headerlink" href="#c.cfg80211_scan_request" title="Permalink to this definition">¶</a></dt>
<dd><p>scan request description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_scan_request {
  struct cfg80211_ssid *ssids;
  int n_ssids;
  u32 n_channels;
  enum nl80211_bss_scan_width scan_width;
  const u8 *ie;
  size_t ie_len;
  u16 duration;
  bool duration_mandatory;
  u32 flags;
  u32 rates[NUM_NL80211_BANDS];
  struct wireless_dev *wdev;
  u8 mac_addr[ETH_ALEN] ;
  u8 mac_addr_mask[ETH_ALEN] ;
  u8 bssid[ETH_ALEN] ;
  struct wiphy *wiphy;
  unsigned long scan_start;
  struct cfg80211_scan_info info;
  bool notified;
  bool no_cck;
  struct ieee80211_channel *channels[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ssids</span></code></dt><dd><p>SSIDs to scan for (active scan only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_ssids</span></code></dt><dd><p>number of SSIDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_channels</span></code></dt><dd><p>total number of channels to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scan_width</span></code></dt><dd><p>channel width for scanning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie</span></code></dt><dd><p>optional information element(s) to add into Probe Request or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ie_len</span></code></dt><dd><p>length of ie in octets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duration</span></code></dt><dd><p>how long to listen on each channel, in TUs. If
<code class="docutils literal notranslate"><span class="pre">duration_mandatory</span></code> is not set, this is the maximum dwell time and
the actual dwell time may be shorter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duration_mandatory</span></code></dt><dd><p>if set, the scan duration must be as specified by the
<code class="docutils literal notranslate"><span class="pre">duration</span></code> field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>bit field of flags controlling operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rates</span></code></dt><dd><p>bitmap of rates to advertise for each band</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wdev</span></code></dt><dd><p>the wireless device to scan for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_addr</span></code></dt><dd><p>MAC address used with randomisation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_addr_mask</span></code></dt><dd><p>MAC address mask used with randomisation, bits that
are 0 in the mask should be randomised, bits that are 1 should
be taken from the <strong>mac_addr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>BSSID to scan for (most commonly, the wildcard BSSID)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wiphy</span></code></dt><dd><p>the wiphy this was for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scan_start</span></code></dt><dd><p>time (in jiffies) when the scan started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>(internal) information about completed scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notified</span></code></dt><dd><p>(internal) scan request was notified as done or aborted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_cck</span></code></dt><dd><p>used to send probe requests at non CCK rate in 2GHz band</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt><dd><p>channels to scan on.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_scan_done">
void <code class="sig-name descname">cfg80211_scan_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cfg80211_scan_request" title="cfg80211_scan_request">cfg80211_scan_request</a> *<em> request</em>, struct cfg80211_scan_info *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_scan_done" title="Permalink to this definition">¶</a></dt>
<dd><p>notify that scan finished</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_scan_request</span> <span class="pre">*</span> <span class="pre">request</span></code></dt><dd><p>the corresponding scan request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_scan_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>information about the completed scan</p>
</dd>
</dl>
<dl class="type">
<dt id="c.cfg80211_bss">
struct <code class="sig-name descname">cfg80211_bss</code><a class="headerlink" href="#c.cfg80211_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_bss {
  struct ieee80211_channel *channel;
  enum nl80211_bss_scan_width scan_width;
  const struct cfg80211_bss_ies __rcu *ies;
  const struct cfg80211_bss_ies __rcu *beacon_ies;
  const struct cfg80211_bss_ies __rcu *proberesp_ies;
  struct cfg80211_bss *hidden_beacon_bss;
  struct cfg80211_bss *transmitted_bss;
  struct list_head nontrans_list;
  s32 signal;
  u16 beacon_interval;
  u16 capability;
  u8 bssid[ETH_ALEN];
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  u8 bssid_index;
  u8 max_bssid_indicator;
  u8 priv[0] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>channel this BSS is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scan_width</span></code></dt><dd><p>width of the control channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ies</span></code></dt><dd><p>the information elements (Note that there is no guarantee that these
are well-formed!); this is a pointer to either the beacon_ies or
proberesp_ies depending on whether Probe Response frame has been
received. It is always non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_ies</span></code></dt><dd><p>the information elements from the last Beacon frame
(implementation note: if <strong>hidden_beacon_bss</strong> is set this struct doesn’t
own the beacon_ies, but they’re just pointers to the ones from the
<strong>hidden_beacon_bss</strong> struct)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proberesp_ies</span></code></dt><dd><p>the information elements from the last Probe Response frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hidden_beacon_bss</span></code></dt><dd><p>in case this BSS struct represents a probe response from
a BSS that hides the SSID in its beacon, this points to the BSS struct
that holds the beacon data. <strong>beacon_ies</strong> is still valid, of course, and
points to the same data as hidden_beacon_bss-&gt;beacon_ies in that case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transmitted_bss</span></code></dt><dd><p>pointer to the transmitted BSS, if this is a
non-transmitted one (multi-BSSID support)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nontrans_list</span></code></dt><dd><p>list of non-transmitted BSS, if this is a transmitted one
(multi-BSSID support)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>signal strength value (type depends on the wiphy’s signal_type)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">beacon_interval</span></code></dt><dd><p>the beacon interval as from the frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capability</span></code></dt><dd><p>the capability field in host byte order</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid</span></code></dt><dd><p>BSSID of the BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chains</span></code></dt><dd><p>bitmask for filled values in <strong>chain_signal</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_signal</span></code></dt><dd><p>per-chain signal strength of last received BSS in dBm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bssid_index</span></code></dt><dd><p>index in the multiple BSS set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_bssid_indicator</span></code></dt><dd><p>max number of members in the BSS set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>private area for driver use, has at least wiphy-&gt;bss_priv_size bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure describes a BSS (which may also be a mesh network)
for use in scan results and similar.</p>
<dl class="type">
<dt id="c.cfg80211_inform_bss">
struct <code class="sig-name descname">cfg80211_inform_bss</code><a class="headerlink" href="#c.cfg80211_inform_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>BSS inform data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cfg80211_inform_bss {
  struct ieee80211_channel *chan;
  enum nl80211_bss_scan_width scan_width;
  s32 signal;
  u64 boottime_ns;
  u64 parent_tsf;
  u8 parent_bssid[ETH_ALEN] ;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan</span></code></dt><dd><p>channel the frame was received on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scan_width</span></code></dt><dd><p>scan width that was used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>signal strength value, according to the wiphy’s
signal type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boottime_ns</span></code></dt><dd><p>timestamp (CLOCK_BOOTTIME) when the information was
received; should match the time when the frame was actually
received by the device (not just by the host, in case it was
buffered on the device) and be accurate to about 10ms.
If the frame isn’t buffered, just passing the return value of
<a class="reference internal" href="../../core-api/timekeeping.html#c.ktime_get_boottime_ns" title="ktime_get_boottime_ns"><code class="xref c c-func docutils literal notranslate"><span class="pre">ktime_get_boottime_ns()</span></code></a> is likely appropriate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_tsf</span></code></dt><dd><p>the time at the start of reception of the first octet of the
timestamp field of the frame. The time is the TSF of the BSS specified
by <code class="docutils literal notranslate"><span class="pre">parent_bssid</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_bssid</span></code></dt><dd><p>the BSS according to which <code class="docutils literal notranslate"><span class="pre">parent_tsf</span></code> is set. This is set to
the BSS that requested the scan in which the beacon/probe was received.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chains</span></code></dt><dd><p>bitmask for filled values in <strong>chain_signal</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_signal</span></code></dt><dd><p>per-chain signal strength of last received BSS in dBm.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.cfg80211_inform_bss_frame_data">
struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> * <code class="sig-name descname">cfg80211_inform_bss_frame_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss">cfg80211_inform_bss</a> *<em> data</em>, struct ieee80211_mgmt *<em> mgmt</em>, size_t<em> len</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_inform_bss_frame_data" title="Permalink to this definition">¶</a></dt>
<dd><p>inform cfg80211 of a received BSS frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy reporting the BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_inform_bss</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>the BSS metadata</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_mgmt</span> <span class="pre">*</span> <span class="pre">mgmt</span></code></dt><dd><p>the management frame (probe response or beacon)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the management frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>context flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This informs cfg80211 that BSS information was found and
the BSS should be updated/added.</p>
<p><strong>Return</strong></p>
<p>A referenced struct, must be released with cfg80211_put_bss()!
Or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.cfg80211_inform_bss_data">
struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> * <code class="sig-name descname">cfg80211_inform_bss_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_inform_bss" title="cfg80211_inform_bss">cfg80211_inform_bss</a> *<em> data</em>, enum cfg80211_bss_frame_type<em> ftype</em>, const u8 *<em> bssid</em>, u64<em> tsf</em>, u16<em> capability</em>, u16<em> beacon_interval</em>, const u8 *<em> ie</em>, size_t<em> ielen</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_inform_bss_data" title="Permalink to this definition">¶</a></dt>
<dd><p>inform cfg80211 of a new BSS</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy reporting the BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_inform_bss</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>the BSS metadata</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">cfg80211_bss_frame_type</span> <span class="pre">ftype</span></code></dt><dd><p>frame type (if known)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">bssid</span></code></dt><dd><p>the BSSID of the BSS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tsf</span></code></dt><dd><p>the TSF sent by the peer in the beacon/probe response (or 0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">capability</span></code></dt><dd><p>the capability field sent by the peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">beacon_interval</span></code></dt><dd><p>the beacon interval announced by the peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ie</span></code></dt><dd><p>additional IEs sent by the peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">ielen</span></code></dt><dd><p>length of the additional IEs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>context flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This informs cfg80211 that BSS information was found and
the BSS should be updated/added.</p>
<p><strong>Return</strong></p>
<p>A referenced struct, must be released with cfg80211_put_bss()!
Or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
<dl class="function">
<dt id="c.cfg80211_unlink_bss">
void <code class="sig-name descname">cfg80211_unlink_bss</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em> bss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_unlink_bss" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink BSS from internal data structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt><dd><p>the bss to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes the given BSS from the internal data structures
thereby making it no longer show up in scan results etc. Use this
function when you detect a BSS is gone. Normally BSSes will also time
out, so it is not necessary to use this function at all.</p>
<dl class="function">
<dt id="c.cfg80211_find_ie">
const u8 * <code class="sig-name descname">cfg80211_find_ie</code><span class="sig-paren">(</span>u8<em> eid</em>, const u8 *<em> ies</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_find_ie" title="Permalink to this definition">¶</a></dt>
<dd><p>find information element in data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">eid</span></code></dt><dd><p>element ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">ies</span></code></dt><dd><p>data consisting of IEs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the element ID could not be found or if
the element is invalid (claims to be longer than the given
data), or a pointer to the first byte of the requested
element, that is the byte containing the element ID.</p>
<p><strong>Note</strong></p>
<p>There are no checks on the element length other than
having to fit into the given data.</p>
<dl class="function">
<dt id="c.ieee80211_bss_get_ie">
const u8 * <code class="sig-name descname">ieee80211_bss_get_ie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cfg80211_bss" title="cfg80211_bss">cfg80211_bss</a> *<em> bss</em>, u8<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_bss_get_ie" title="Permalink to this definition">¶</a></dt>
<dd><p>find IE with given ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_bss</span> <span class="pre">*</span> <span class="pre">bss</span></code></dt><dd><p>the bss to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">id</span></code></dt><dd><p>the element ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the return value is an RCU-protected pointer, so
<a class="reference internal" href="../../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> must be held when calling this function.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not found.</p>
</div>
<div class="section" id="utility-functions">
<h2>Utility functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<p>cfg80211 offers a number of utility functions that can be useful.</p>
<dl class="function">
<dt id="c.ieee80211_channel_to_frequency">
int <code class="sig-name descname">ieee80211_channel_to_frequency</code><span class="sig-paren">(</span>int<em> chan</em>, enum nl80211_band<em> band</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_channel_to_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>convert channel number to frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chan</span></code></dt><dd><p>channel number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_band</span> <span class="pre">band</span></code></dt><dd><p>band, necessary due to channel number overlap</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The corresponding frequency (in MHz), or 0 if the conversion failed.</p>
<dl class="function">
<dt id="c.ieee80211_frequency_to_channel">
int <code class="sig-name descname">ieee80211_frequency_to_channel</code><span class="sig-paren">(</span>int<em> freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_frequency_to_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>convert frequency to channel number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">freq</span></code></dt><dd><p>center frequency</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The corresponding channel, or 0 if the conversion failed.</p>
<dl class="function">
<dt id="c.ieee80211_get_channel">
struct <a class="reference internal" href="#c.ieee80211_channel" title="ieee80211_channel">ieee80211_channel</a> * <code class="sig-name descname">ieee80211_get_channel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, int<em> freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>get channel struct from wiphy for specified frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the struct wiphy to get the channel for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">freq</span></code></dt><dd><p>the center frequency of the channel</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The channel struct from <strong>wiphy</strong> at <strong>freq</strong>.</p>
<dl class="function">
<dt id="c.ieee80211_get_response_rate">
struct <a class="reference internal" href="#c.ieee80211_rate" title="ieee80211_rate">ieee80211_rate</a> * <code class="sig-name descname">ieee80211_get_response_rate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_supported_band" title="ieee80211_supported_band">ieee80211_supported_band</a> *<em> sband</em>, u32<em> basic_rates</em>, int<em> bitrate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_response_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get basic rate for a given rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_supported_band</span> <span class="pre">*</span> <span class="pre">sband</span></code></dt><dd><p>the band to look for rates in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">basic_rates</span></code></dt><dd><p>bitmap of basic rates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bitrate</span></code></dt><dd><p>the bitrate for which to find the basic rate</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The basic rate corresponding to a given bitrate, that
is the next lower bitrate contained in the basic rate map,
which is, for this function, given as a bitmap of indices of
rates in the band’s bitrate table.</p>
<dl class="function">
<dt id="c.ieee80211_hdrlen">
unsigned int __attribute_const__ <code class="sig-name descname">ieee80211_hdrlen</code><span class="sig-paren">(</span>__le16<em> fc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_hdrlen" title="Permalink to this definition">¶</a></dt>
<dd><p>get header length in bytes from frame control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__le16</span> <span class="pre">fc</span></code></dt><dd><p>frame control field in little-endian format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The header length in bytes.</p>
<dl class="function">
<dt id="c.ieee80211_get_hdrlen_from_skb">
unsigned int <code class="sig-name descname">ieee80211_get_hdrlen_from_skb</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_hdrlen_from_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>get header length from data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the frame</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an skb with a raw 802.11 header at the data pointer this function
returns the 802.11 header length.</p>
<p><strong>Return</strong></p>
<p>The 802.11 header length in bytes (not including encryption
headers). Or 0 if the data in the sk_buff is too short to contain a valid
802.11 header.</p>
<dl class="type">
<dt id="c.ieee80211_radiotap_iterator">
struct <code class="sig-name descname">ieee80211_radiotap_iterator</code><a class="headerlink" href="#c.ieee80211_radiotap_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>tracks walk thru present radiotap args</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_radiotap_iterator {
  struct ieee80211_radiotap_header *_rtheader;
  const struct ieee80211_radiotap_vendor_namespaces *_vns;
  const struct ieee80211_radiotap_namespace *current_namespace;
  unsigned char *_arg, *_next_ns_data;
  __le32 *_next_bitmap;
  unsigned char *this_arg;
  int this_arg_index;
  int this_arg_size;
  int is_radiotap_ns;
  int _max_length;
  int _arg_index;
  uint32_t _bitmap_shifter;
  int _reset_on_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_rtheader</span></code></dt><dd><p>pointer to the radiotap header we are walking through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_vns</span></code></dt><dd><p>vendor namespace definitions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_namespace</span></code></dt><dd><p>pointer to the current namespace definition
(or internally <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the current namespace is unknown)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_arg</span></code></dt><dd><p>next argument pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_next_ns_data</span></code></dt><dd><p>beginning of the next namespace’s data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_next_bitmap</span></code></dt><dd><p>internal pointer to next present u32</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">this_arg</span></code></dt><dd><p>pointer to current radiotap arg; it is valid after each
call to ieee80211_radiotap_iterator_next() but also after
ieee80211_radiotap_iterator_init() where it will point to
the beginning of the actual data portion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">this_arg_index</span></code></dt><dd><p>index of current arg, valid after each successful call
to ieee80211_radiotap_iterator_next()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">this_arg_size</span></code></dt><dd><p>length of the current arg, for convenience</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_radiotap_ns</span></code></dt><dd><p>indicates whether the current namespace is the default
radiotap namespace or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_max_length</span></code></dt><dd><p>length of radiotap header in cpu byte ordering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_arg_index</span></code></dt><dd><p>next argument index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_bitmap_shifter</span></code></dt><dd><p>internal shifter for curr u32 bitmap, b0 set == arg present</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_reset_on_ext</span></code></dt><dd><p>internal; reset the arg index to 0 when going to the
next bitmap word</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes the radiotap parser state. Fields prefixed with an underscore
must not be used by users of the parser, only by the parser internally.</p>
</div>
<div class="section" id="data-path-helpers">
<h2>Data path helpers<a class="headerlink" href="#data-path-helpers" title="Permalink to this headline">¶</a></h2>
<p>In addition to generic utilities, cfg80211 also offers
functions that help implement the data path for devices
that do not do the 802.11/802.3 conversion on the device.</p>
<dl class="function">
<dt id="c.ieee80211_data_to_8023">
int <code class="sig-name descname">ieee80211_data_to_8023</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, const u8 *<em> addr</em>, enum nl80211_iftype<em> iftype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_data_to_8023" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an 802.11 data frame to 802.3</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the 802.11 data frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>the device MAC address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_iftype</span> <span class="pre">iftype</span></code></dt><dd><p>the virtual interface type</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success. Non-zero on error.</p>
<dl class="function">
<dt id="c.ieee80211_amsdu_to_8023s">
void <code class="sig-name descname">ieee80211_amsdu_to_8023s</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct sk_buff_head *<em> list</em>, const u8 *<em> addr</em>, enum nl80211_iftype<em> iftype</em>, const unsigned int<em> extra_headroom</em>, const u8 *<em> check_da</em>, const u8 *<em> check_sa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_amsdu_to_8023s" title="Permalink to this definition">¶</a></dt>
<dd><p>decode an IEEE 802.11n A-MSDU frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The input A-MSDU frame without any headers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>The output list of 802.3 frames. It must be allocated and
initialized by by the caller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt><dd><p>The device MAC address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">nl80211_iftype</span> <span class="pre">iftype</span></code></dt><dd><p>The device interface type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">extra_headroom</span></code></dt><dd><p>The hardware extra headroom for SKBs in the <strong>list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">check_da</span></code></dt><dd><p>DA to check in the inner ethernet header, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">check_sa</span></code></dt><dd><p>SA to check in the inner ethernet header, or NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
The <strong>list</strong> will be empty if the decode fails. The <strong>skb</strong> must be fully
header-less before being passed in here; it is freed in this function.</p>
<dl class="function">
<dt id="c.cfg80211_classify8021d">
unsigned int <code class="sig-name descname">cfg80211_classify8021d</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, struct cfg80211_qos_map *<em> qos_map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_classify8021d" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the 802.1p/1d tag for a data frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>the data frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_qos_map</span> <span class="pre">*</span> <span class="pre">qos_map</span></code></dt><dd><p>Interworking QoS mapping or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not in use</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The 802.1p/1d tag.</p>
</div>
<div class="section" id="regulatory-enforcement-infrastructure">
<h2>Regulatory enforcement infrastructure<a class="headerlink" href="#regulatory-enforcement-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<dl class="function">
<dt id="c.regulatory_hint">
int <code class="sig-name descname">regulatory_hint</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, const char *<em> alpha2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulatory_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>driver hint to the wireless core a regulatory domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wireless device giving the hint (used only for reporting
conflicts)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alpha2</span></code></dt><dd><p>the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
should be in. If <strong>rd</strong> is set this should be NULL. Note that if you
set this to NULL you should still set rd-&gt;alpha2 to some accepted
alpha2.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wireless drivers can use this function to hint to the wireless core
what it believes should be the current regulatory domain by
giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
domain should be in or by providing a completely build regulatory domain.
If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
for a regulatory domain structure for the respective country.</p>
<p>The wiphy must have been registered to cfg80211 prior to this call.
For cfg80211 drivers this means you must first use <a class="reference internal" href="#c.wiphy_register" title="wiphy_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">wiphy_register()</span></code></a>,
for mac80211 drivers you must first use <a class="reference internal" href="mac80211.html#c.ieee80211_register_hw" title="ieee80211_register_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_register_hw()</span></code></a>.</p>
<p>Drivers should check the return value, its possible you can get
an -ENOMEM.</p>
<p><strong>Return</strong></p>
<p>0 on success. -ENOMEM.</p>
<dl class="function">
<dt id="c.wiphy_apply_custom_regulatory">
void <code class="sig-name descname">wiphy_apply_custom_regulatory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, const struct ieee80211_regdomain *<em> regd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_apply_custom_regulatory" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a custom driver regulatory domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wireless device we want to process the regulatory domain on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_regdomain</span> <span class="pre">*</span> <span class="pre">regd</span></code></dt><dd><p>the custom regulatory domain to use for this wiphy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can sometimes have custom regulatory domains which do not apply
to a specific country. Drivers can use this to apply such custom regulatory
domains. This routine must be called prior to wiphy registration. The
custom regulatory domain will be trusted completely and as such previous
default channel settings will be disregarded. If no rule is found for a
channel on the regulatory domain the channel will be disabled.
Drivers using this for a wiphy should also set the wiphy flag
REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
that called this helper.</p>
<dl class="function">
<dt id="c.freq_reg_info">
const struct ieee80211_reg_rule * <code class="sig-name descname">freq_reg_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, u32<em> center_freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freq_reg_info" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulatory information for the given frequency</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy for which we want to process this rule for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">center_freq</span></code></dt><dd><p>Frequency in KHz for which we want regulatory information for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to get the regulatory rule for a specific frequency on
a given wireless device. If the device has a specific regulatory domain
it wants to follow we respect that unless a country IE has been received
and processed already.</p>
<p><strong>Return</strong></p>
<p>A valid pointer, or, when an error occurs, for example if no rule
can be found, the return value is encoded using ERR_PTR(). Use IS_ERR() to
check and PTR_ERR() to obtain the numeric return value. The numeric return
value will be -ERANGE if we determine the given center_freq does not even
have a regulatory rule for a frequency range in the center_freq’s band.
See freq_in_rule_band() for our current definition of a band – this is
purely subjective and right now it’s 802.11 specific.</p>
</div>
<div class="section" id="rfkill-integration">
<h2>RFkill integration<a class="headerlink" href="#rfkill-integration" title="Permalink to this headline">¶</a></h2>
<p>RFkill integration in cfg80211 is almost invisible to drivers,
as cfg80211 automatically registers an rfkill instance for each
wireless device it knows about. Soft kill is also translated
into disconnecting and turning all interfaces off, drivers are
expected to turn off the device when all interfaces are down.</p>
<p>However, devices may have a hard RFkill line, in which case they
also need to interact with the rfkill subsystem, via cfg80211.
They can do this with a few helper functions documented here.</p>
<dl class="function">
<dt id="c.wiphy_rfkill_set_hw_state">
void <code class="sig-name descname">wiphy_rfkill_set_hw_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, bool<em> blocked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_set_hw_state" title="Permalink to this definition">¶</a></dt>
<dd><p>notify cfg80211 about hw block state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">blocked</span></code></dt><dd><p>block status</p>
</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_rfkill_start_polling">
void <code class="sig-name descname">wiphy_rfkill_start_polling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_start_polling" title="Permalink to this definition">¶</a></dt>
<dd><p>start polling rfkill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
</dl>
<dl class="function">
<dt id="c.wiphy_rfkill_stop_polling">
void <code class="sig-name descname">wiphy_rfkill_stop_polling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wiphy_rfkill_stop_polling" title="Permalink to this definition">¶</a></dt>
<dd><p>stop polling rfkill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
</dl>
</div>
<div class="section" id="test-mode">
<h2>Test mode<a class="headerlink" href="#test-mode" title="Permalink to this headline">¶</a></h2>
<p>Test mode is a set of utility functions to allow drivers to
interact with driver-specific tools to aid, for instance,
factory programming.</p>
<p>This chapter describes how drivers interact with it, for more
information see the nl80211 book’s chapter on it.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_alloc_reply_skb">
struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">cfg80211_testmode_alloc_reply_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, int<em> approxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_alloc_reply_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate testmode reply</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">approxlen</span></code></dt><dd><p>an upper bound of the length of the data that will
be put into the skb</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and pre-fills an skb for a reply to
the testmode command. Since it is intended for a reply, calling
it outside of the <strong>testmode_cmd</strong> operation is invalid.</p>
<p>The returned skb is pre-filled with the wiphy index and set up in
a way that any data that is put into the skb (with <a class="reference internal" href="../../networking/kapi.html#c.skb_put" title="skb_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_put()</span></code></a>,
nla_put() or similar) will end up being within the
<code class="docutils literal notranslate"><span class="pre">NL80211_ATTR_TESTDATA</span></code> attribute, so all that needs to be done
with the skb is adding data for the corresponding userspace tool
which can then read that data out of the testdata attribute. You
must not modify the skb in any other way.</p>
<p>When done, call <a class="reference internal" href="#c.cfg80211_testmode_reply" title="cfg80211_testmode_reply"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_reply()</span></code></a> with the skb and return
its error code as the result of the <strong>testmode_cmd</strong> operation.</p>
<p><strong>Return</strong></p>
<p>An allocated and pre-filled skb. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if any errors happen.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_reply">
int <code class="sig-name descname">cfg80211_testmode_reply</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_reply" title="Permalink to this definition">¶</a></dt>
<dd><p>send the reply skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The skb, must have been allocated with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_reply_skb" title="cfg80211_testmode_alloc_reply_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_alloc_reply_skb()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since calling this function will usually be the last thing
before returning from the <strong>testmode_cmd</strong> you should return
the error code.  Note that this function consumes the skb
regardless of the return value.</p>
<p><strong>Return</strong></p>
<p>An error code or 0 on success.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_alloc_event_skb">
struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">cfg80211_testmode_alloc_event_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wiphy" title="wiphy">wiphy</a> *<em> wiphy</em>, int<em> approxlen</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_alloc_event_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate testmode event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wiphy</span> <span class="pre">*</span> <span class="pre">wiphy</span></code></dt><dd><p>the wiphy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">approxlen</span></code></dt><dd><p>an upper bound of the length of the data that will
be put into the skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and pre-fills an skb for an event on the
testmode multicast group.</p>
<p>The returned skb is set up in the same way as with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_reply_skb" title="cfg80211_testmode_alloc_reply_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_alloc_reply_skb()</span></code></a> but prepared for an event. As
there, you should simply add data to it that will then end up in the
<code class="docutils literal notranslate"><span class="pre">NL80211_ATTR_TESTDATA</span></code> attribute. Again, you must not modify the skb
in any other way.</p>
<p>When done filling the skb, call <a class="reference internal" href="#c.cfg80211_testmode_event" title="cfg80211_testmode_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_event()</span></code></a> with the
skb to send the event.</p>
<p><strong>Return</strong></p>
<p>An allocated and pre-filled skb. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if any errors happen.</p>
<dl class="function">
<dt id="c.cfg80211_testmode_event">
void <code class="sig-name descname">cfg80211_testmode_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em> skb</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cfg80211_testmode_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send the event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt><dd><p>The skb, must have been allocated with
<a class="reference internal" href="#c.cfg80211_testmode_alloc_event_skb" title="cfg80211_testmode_alloc_event_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_alloc_event_skb()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends the given <strong>skb</strong>, which must have been allocated
by <a class="reference internal" href="#c.cfg80211_testmode_alloc_event_skb" title="cfg80211_testmode_alloc_event_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">cfg80211_testmode_alloc_event_skb()</span></code></a>, as an event. It always
consumes it.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mac80211.html" class="btn btn-neutral float-right" title="mac80211 subsystem (basics)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>