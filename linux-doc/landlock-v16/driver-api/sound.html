

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sound Devices &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frame Buffer Library" href="frame-buffer.html" />
    <link rel="prev" title="InfiniBand and Remote DMA (RDMA) Interfaces" href="infiniband.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Sound Devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/sound.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sound-devices">
<h1>Sound Devices<a class="headerlink" href="#sound-devices" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.snd_card_unref">
void <code class="sig-name descname">snd_card_unref</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Unreference the card object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card object to unreference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function for the card object that was obtained via <a class="reference internal" href="#c.snd_card_ref" title="snd_card_ref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_ref()</span></code></a>
or <a class="reference internal" href="#c.snd_lookup_minor_data" title="snd_lookup_minor_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_lookup_minor_data()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_printk">
<code class="sig-name descname">snd_printk</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printk" title="Permalink to this definition">¶</a></dt>
<dd><p>printk wrapper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> but prints the file and the line of the caller
when configured with CONFIG_SND_VERBOSE_PRINTK.</p>
<dl class="function">
<dt id="c.snd_printd">
<code class="sig-name descname">snd_printd</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG is not set.</p>
<dl class="function">
<dt id="c.snd_BUG">
<code class="sig-name descname">snd_BUG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG" title="Permalink to this definition">¶</a></dt>
<dd><p>give a BUG warning message and stack trace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Calls WARN() if CONFIG_SND_DEBUG is set.
Ignored when CONFIG_SND_DEBUG is not set.</p>
<dl class="function">
<dt id="c.snd_printd_ratelimit">
<code class="sig-name descname">snd_printd_ratelimit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd_ratelimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.snd_BUG_ON">
<code class="sig-name descname">snd_BUG_ON</code><span class="sig-paren">(</span><em>cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG_ON" title="Permalink to this definition">¶</a></dt>
<dd><p>debugging check macro</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>condition to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Has the same behavior as WARN_ON when CONFIG_SND_DEBUG is set,
otherwise just evaluates the conditional and returns the value.</p>
<dl class="function">
<dt id="c.snd_printdd">
<code class="sig-name descname">snd_printdd</code><span class="sig-paren">(</span><em>format</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printdd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.</p>
<dl class="function">
<dt id="c.register_sound_special_device">
int <code class="sig-name descname">register_sound_special_device</code><span class="sig-paren">(</span>const struct file_operations *<em> fops</em>, int<em> unit</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_special_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a special sound node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>Unit number to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a special sound device by minor number from the sound
subsystem.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>The allocated number is returned on success. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.register_sound_mixer">
int <code class="sig-name descname">register_sound_mixer</code><span class="sig-paren">(</span>const struct file_operations *<em> fops</em>, int<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>register a mixer device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>Unit number to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a mixer device. Unit is the number of the mixer requested.
Pass -1 to request the next free mixer unit.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>On success, the allocated number is returned. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.register_sound_dsp">
int <code class="sig-name descname">register_sound_dsp</code><span class="sig-paren">(</span>const struct file_operations *<em> fops</em>, int<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_dsp" title="Permalink to this definition">¶</a></dt>
<dd><p>register a DSP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>Unit number to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a DSP device. Unit is the number of the DSP requested.
Pass -1 to request the next free DSP unit.</p>
<p>This function allocates both the audio and dsp device entries together
and will always allocate them as a matching pair - eg dsp3/audio3</p>
</div></blockquote>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>On success, the allocated number is returned. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.unregister_sound_special">
void <code class="sig-name descname">unregister_sound_special</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_special" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a special sound device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Release a sound device that was allocated with
register_sound_special(). The unit passed is the return value from
the register function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_sound_mixer">
void <code class="sig-name descname">unregister_sound_mixer</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a mixer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Release a sound device that was allocated with <a class="reference internal" href="#c.register_sound_mixer" title="register_sound_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_sound_mixer()</span></code></a>.
The unit passed is the return value from the register function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_sound_dsp">
void <code class="sig-name descname">unregister_sound_dsp</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_dsp" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a DSP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Release a sound device that was allocated with <a class="reference internal" href="#c.register_sound_dsp" title="register_sound_dsp"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_sound_dsp()</span></code></a>.
The unit passed is the return value from the register function.</p>
<p>Both of the allocated units are released together automatically.</p>
</div></blockquote>
<dl class="function">
<dt id="c.snd_pcm_stream_linked">
int <code class="sig-name descname">snd_pcm_stream_linked</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_linked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is linked with others</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>substream to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the given substream is being linked with others.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irqsave">
<code class="sig-name descname">snd_pcm_stream_lock_irqsave</code><span class="sig-paren">(</span><em>substream</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>irq flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> but with the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_group_for_each_entry">
<code class="sig-name descname">snd_pcm_group_for_each_entry</code><span class="sig-paren">(</span><em>s</em>, <em>substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_group_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over the linked substreams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt><dd><p>the substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the all linked substreams to the given <strong>substream</strong>.
When <strong>substream</strong> isn’t linked with any others, this gives returns <strong>substream</strong>
itself once.</p>
<dl class="function">
<dt id="c.snd_pcm_running">
int <code class="sig-name descname">snd_pcm_running</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_running" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is in a running state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>substream to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the given substream is in the state RUNNING, or in the
state DRAINING for playback.</p>
<dl class="function">
<dt id="c.bytes_to_samples">
ssize_t <code class="sig-name descname">bytes_to_samples</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to samples</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bytes_to_frames">
snd_pcm_sframes_t <code class="sig-name descname">bytes_to_frames</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to frames</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.samples_to_bytes">
ssize_t <code class="sig-name descname">samples_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.samples_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from samples to bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in samples</p>
</dd>
</dl>
<dl class="function">
<dt id="c.frames_to_bytes">
ssize_t <code class="sig-name descname">frames_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, snd_pcm_sframes_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frames_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from frames to bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_sframes_t</span> <span class="pre">size</span></code></dt><dd><p>size in frames</p>
</dd>
</dl>
<dl class="function">
<dt id="c.frame_aligned">
int <code class="sig-name descname">frame_aligned</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, ssize_t<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frame_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the byte size is aligned to frames</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">bytes</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_buffer_bytes">
size_t <code class="sig-name descname">snd_pcm_lib_buffer_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size of the current PCM in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_period_bytes">
size_t <code class="sig-name descname">snd_pcm_lib_period_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_period_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size of the current PCM in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_playback_avail">
snd_pcm_uframes_t <code class="sig-name descname">snd_pcm_playback_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (writable) space for playback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<dl class="function">
<dt id="c.snd_pcm_capture_avail">
snd_pcm_uframes_t <code class="sig-name descname">snd_pcm_capture_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (readable) space for capture</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<dl class="function">
<dt id="c.snd_pcm_playback_hw_avail">
snd_pcm_sframes_t <code class="sig-name descname">snd_pcm_playback_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the queued space for playback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_capture_hw_avail">
snd_pcm_sframes_t <code class="sig-name descname">snd_pcm_capture_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the free space for capture</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_playback_ready">
int <code class="sig-name descname">snd_pcm_playback_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough free space is available on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_capture_ready">
int <code class="sig-name descname">snd_pcm_capture_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough capture data is available on the capture buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_playback_data">
int <code class="sig-name descname">snd_pcm_playback_data</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_data" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether any data exists on the playback buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether any data exists on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if any data exists, or zero if not. If stop_threshold
is bigger or equal to boundary, then this function returns always non-zero.</p>
<dl class="function">
<dt id="c.snd_pcm_playback_empty">
int <code class="sig-name descname">snd_pcm_playback_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the playback buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_capture_empty">
int <code class="sig-name descname">snd_pcm_capture_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the capture buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_trigger_done">
void <code class="sig-name descname">snd_pcm_trigger_done</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, struct snd_pcm_substream *<em> master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_trigger_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the master substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">master</span></code></dt><dd><p>the linked master substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When multiple substreams of the same card are linked and the hardware
supports the single-shot operation, the driver calls this in the loop
in <a class="reference internal" href="#c.snd_pcm_group_for_each_entry" title="snd_pcm_group_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_group_for_each_entry()</span></code></a> for marking the substream as “done”.
Then most of trigger operations are performed only to the given master
substream.</p>
<p>The trigger_master mark is cleared at timestamp updates at the end
of trigger operations.</p>
<dl class="function">
<dt id="c.params_channels">
unsigned int <code class="sig-name descname">params_channels</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of channels from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.params_rate">
unsigned int <code class="sig-name descname">params_rate</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sample rate from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.params_period_size">
unsigned int <code class="sig-name descname">params_period_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_period_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size (in frames) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.params_periods">
unsigned int <code class="sig-name descname">params_periods</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of periods from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.params_buffer_size">
unsigned int <code class="sig-name descname">params_buffer_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in frames) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.params_buffer_bytes">
unsigned int <code class="sig-name descname">params_buffer_bytes</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in bytes) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_single">
int <code class="sig-name descname">snd_pcm_hw_constraint_single</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, snd_pcm_hw_param_t<em> var</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrain parameter to a single value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>The hw_params variable to constrain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>The value to constrain to</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_format_cpu_endian">
int <code class="sig-name descname">snd_pcm_format_cpu_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_cpu_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is CPU-endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.</p>
<dl class="function">
<dt id="c.snd_pcm_set_runtime_buffer">
void <code class="sig-name descname">snd_pcm_set_runtime_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, struct snd_dma_buffer *<em> bufp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_runtime_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the PCM runtime buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">bufp</span></code></dt><dd><p>the buffer information, NULL to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the buffer information to runtime-&gt;dma_buffer when <strong>bufp</strong> is non-NULL.
Otherwise it clears the current buffer information.</p>
<dl class="function">
<dt id="c.snd_pcm_gettime">
void <code class="sig-name descname">snd_pcm_gettime</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, struct timespec64 *<em> tv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_gettime" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the timespec64 depending on the timestamp mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">tv</span></code></dt><dd><p>timespec64 to fill</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_buffer">
int <code class="sig-name descname">snd_pcm_lib_alloc_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtual DMA buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream to allocate the buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the PCM substream buffer using <a class="reference internal" href="../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, i.e., the memory is
contiguous in kernel virtual space, but not in physical memory.  Use this
if the buffer is accessed by kernel code but not by device DMA.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_32_buffer">
int <code class="sig-name descname">snd_pcm_lib_alloc_vmalloc_32_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_32_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate 32-bit-addressable buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream to allocate the buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works like <a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a>, but uses
<a class="reference internal" href="../core-api/mm-api.html#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc_32()</span></code></a>, i.e., the pages are allocated from 32-bit-addressable memory.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_addr">
dma_addr_t <code class="sig-name descname">snd_pcm_sgbuf_get_addr</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned int<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the DMA address at the corresponding offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>byte offset</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_ptr">
void * <code class="sig-name descname">snd_pcm_sgbuf_get_ptr</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned int<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the virtual address at the corresponding offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>byte offset</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_chunk_size">
unsigned int <code class="sig-name descname">snd_pcm_sgbuf_get_chunk_size</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned int<em> ofs</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max size that fits within the contig. page from the given size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>byte offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>byte size to examine</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_open">
void <code class="sig-name descname">snd_pcm_mmap_data_open</code><span class="sig-paren">(</span>struct vm_area_struct *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_open" title="Permalink to this definition">¶</a></dt>
<dd><p>increase the mmap counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_close">
void <code class="sig-name descname">snd_pcm_mmap_data_close</code><span class="sig-paren">(</span>struct vm_area_struct *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_close" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease the mmap counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
<dl class="function">
<dt id="c.snd_pcm_limit_isa_dma_size">
void <code class="sig-name descname">snd_pcm_limit_isa_dma_size</code><span class="sig-paren">(</span>int<em> dma</em>, size_t *<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_limit_isa_dma_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max size fitting with ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt><dd><p>DMA number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">max</span></code></dt><dd><p>pointer to store the max size</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_stream_str">
const char * <code class="sig-name descname">snd_pcm_stream_str</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string naming the direction of a stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A string naming the direction of the stream.</p>
<dl class="function">
<dt id="c.snd_pcm_chmap_substream">
struct snd_pcm_substream * <code class="sig-name descname">snd_pcm_chmap_substream</code><span class="sig-paren">(</span>struct snd_pcm_chmap *<em> info</em>, unsigned int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_chmap_substream" title="Permalink to this definition">¶</a></dt>
<dd><p>get the PCM substream assigned to the given chmap info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>chmap information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>the substream number index</p>
</dd>
</dl>
<dl class="function">
<dt id="c.pcm_format_to_bits">
u64 <code class="sig-name descname">pcm_format_to_bits</code><span class="sig-paren">(</span>snd_pcm_format_t<em> pcm_format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_format_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Strong-typed conversion of pcm_format to bitwise</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">pcm_format</span></code></dt><dd><p>PCM format</p>
</dd>
</dl>
<dl class="function">
<dt id="c.pcm_for_each_format">
<code class="sig-name descname">pcm_for_each_format</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_for_each_format" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to iterate for each format type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>the iterator variable in snd_pcm_format_t type</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_format_name">
const char * <code class="sig-name descname">snd_pcm_format_name</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a name string for the given PCM format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>PCM format</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_new_stream">
int <code class="sig-name descname">snd_pcm_new_stream</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em>, int<em> stream</em>, int<em> substream_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>the stream direction, SNDRV_PCM_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">substream_count</span></code></dt><dd><p>the number of substreams</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
<a class="reference internal" href="#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_new">
int <code class="sig-name descname">snd_pcm_new</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> id</em>, int<em> device</em>, int<em> playback_count</em>, int<em> capture_count</em>, struct snd_pcm **<em> rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt><dd><p>the number of substreams for playback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt><dd><p>the number of substreams for capture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**</span> <span class="pre">rpcm</span></code></dt><dd><p>the pointer to store the new pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new PCM instance.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_new_internal">
int <code class="sig-name descname">snd_pcm_new_internal</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> id</em>, int<em> device</em>, int<em> playback_count</em>, int<em> capture_count</em>, struct snd_pcm **<em> rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new internal PCM instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero based - shared with normal PCMs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt><dd><p>the number of substreams for playback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt><dd><p>the number of substreams for capture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**</span> <span class="pre">rpcm</span></code></dt><dd><p>the pointer to store the new pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new internal PCM instance with no userspace device or procfs
entries. This is used by ASoC Back End PCMs in order to create a PCM that
will only be used internally by kernel drivers. i.e. it cannot be opened
by userspace. It provides existing ASoC components drivers with a substream
and access to any private data.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_notify">
int <code class="sig-name descname">snd_pcm_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_pcm_notify" title="snd_pcm_notify">snd_pcm_notify</a> *<em> notify</em>, int<em> nfree</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add/remove the notify list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt><dd><p>PCM notify list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nfree</span></code></dt><dd><p>0 = register, 1 = unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the given notifier to the global list so that the callback is
called for each registered PCM devices.  This exists only for PCM OSS
emulation, so far.</p>
<dl class="function">
<dt id="c.snd_device_new">
int <code class="sig-name descname">snd_device_new</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, enum snd_device_type<em> type</em>, void *<em> device_data</em>, const struct snd_device_ops *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create an ALSA device component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_device_type</span> <span class="pre">type</span></code></dt><dd><p>the device type, SNDRV_DEV_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt><dd><p>the data pointer of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_device_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.</p>
<p>The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_device_disconnect">
void <code class="sig-name descname">snd_device_disconnect</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, void *<em> device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt><dd><p>the data pointer to disconnect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turns the device into the disconnection state, invoking
dev_disconnect callback, if the device was already registered.</p>
<p>Usually called from <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
<dl class="function">
<dt id="c.snd_device_free">
void <code class="sig-name descname">snd_device_free</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, void *<em> device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release the device from the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt><dd><p>the data pointer to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the device from the list on the card and invokes the
callbacks, dev_disconnect and dev_free, corresponding to the state.
Then release the device.</p>
<dl class="function">
<dt id="c.snd_device_register">
int <code class="sig-name descname">snd_device_register</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, void *<em> device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt><dd><p>the data pointer to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the device which was already created via
<a class="reference internal" href="#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a>.  Usually this is called from <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>,
but it can be called later if any new devices are created after
invocation of <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
<dl class="function">
<dt id="c.snd_device_get_state">
int <code class="sig-name descname">snd_device_get_state</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, void *<em> device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt><dd><p>the data pointer to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the current state of the given device object.  For the valid
device, either <strong>SNDRV_DEV_BUILD</strong>, <strong>SNDRV_DEV_REGISTERED</strong> or
<strong>SNDRV_DEV_DISCONNECTED</strong> is returned.
Or for a non-existing device, -1 is returned as an error.</p>
<dl class="function">
<dt id="c.snd_info_get_line">
int <code class="sig-name descname">snd_info_get_line</code><span class="sig-paren">(</span>struct snd_info_buffer *<em> buffer</em>, char *<em> line</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>read one line from the procfs buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>the procfs buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">line</span></code></dt><dd><p>the buffer to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>the max. buffer size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads one line from the buffer and stores the string.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or 1 if error or EOF.</p>
<dl class="function">
<dt id="c.snd_info_get_str">
const char * <code class="sig-name descname">snd_info_get_str</code><span class="sig-paren">(</span>char *<em> dest</em>, const char *<em> src</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_str" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string token</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt><dd><p>the buffer to store the string token</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>the original string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>the max. length of token - 1</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the original string and copy a token to the given
string buffer.</p>
<p><strong>Return</strong></p>
<p>The updated pointer of the original string so that
it can be used for the next call.</p>
<dl class="function">
<dt id="c.snd_info_create_module_entry">
struct snd_info_entry * <code class="sig-name descname">snd_info_create_module_entry</code><span class="sig-paren">(</span>struct module *<em> module</em>, const char *<em> name</em>, struct snd_info_entry *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_module_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt><dd><p>the module pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>the parent directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given module.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_info_create_card_entry">
struct snd_info_entry * <code class="sig-name descname">snd_info_create_card_entry</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> name</em>, struct snd_info_entry *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_card_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>the parent directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given card.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_info_free_entry">
void <code class="sig-name descname">snd_info_free_entry</code><span class="sig-paren">(</span>struct snd_info_entry *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_free_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>release the info entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the info entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the info entry.</p>
<dl class="function">
<dt id="c.snd_info_register">
int <code class="sig-name descname">snd_info_register</code><span class="sig-paren">(</span>struct snd_info_entry *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the info entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the info entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the proc info entry.
The all children entries are registered recursively.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_card_rw_proc_new">
int <code class="sig-name descname">snd_card_rw_proc_new</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> name</em>, void *<em> private_data</em>, void (*read) (struct snd_info_entry<em> *</em>, struct snd_info_buffer<em> *</em>, void (*<a class="reference internal" href="../media/uapi/dvb/video-fwrite.html#c.write" title="write">write</a>) (struct snd_info_entry<em> *entry</em>, struct snd_info_buffer<em> *buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_rw_proc_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read/write text proc file entry for the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt><dd><p>the arbitrary private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*)</span> <span class="pre">read</span></code></dt><dd><p>the read callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*entry,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*buffer)</span> <span class="pre">write</span></code></dt><dd><p>the write callback, NULL for read-only</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This proc file entry will be registered via <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> call, and
it will be removed automatically at the card removal, too.</p>
<dl class="function">
<dt id="c.snd_rawmidi_receive">
int <code class="sig-name descname">snd_rawmidi_receive</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, const unsigned char *<em> buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_receive" title="Permalink to this definition">¶</a></dt>
<dd><p>receive the input data from the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the data size to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the data from the internal buffer.</p>
<p><strong>Return</strong></p>
<p>The size of read data, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_empty">
int <code class="sig-name descname">snd_rawmidi_transmit_empty</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the output buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the internal output buffer is empty, 0 if not.</p>
<dl class="function">
<dt id="c.__snd_rawmidi_transmit_peek">
int <code class="sig-name descname">__snd_rawmidi_transmit_peek</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, unsigned char *<em> buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__snd_rawmidi_transmit_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the internal buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>data size to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.snd_rawmidi_transmit_peek" title="snd_rawmidi_transmit_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_peek()</span></code></a> without spinlock.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_peek">
int <code class="sig-name descname">snd_rawmidi_transmit_peek</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, unsigned char *<em> buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the internal buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>data size to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the internal output buffer to the given buffer.</p>
<p>Call this in the interrupt handler when the midi output is ready,
and call <a class="reference internal" href="#c.snd_rawmidi_transmit_ack" title="snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_ack()</span></code></a> after the transmission is
finished.</p>
<p><strong>Return</strong></p>
<p>The size of copied data, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.__snd_rawmidi_transmit_ack">
int <code class="sig-name descname">__snd_rawmidi_transmit_ack</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__snd_rawmidi_transmit_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>acknowledge the transmission</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the transferred count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.__snd_rawmidi_transmit_ack" title="__snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">__snd_rawmidi_transmit_ack()</span></code></a> without spinlock.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_ack">
int <code class="sig-name descname">snd_rawmidi_transmit_ack</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>acknowledge the transmission</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the transferred count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.</p>
<p><strong>Return</strong></p>
<p>The advanced size if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit">
int <code class="sig-name descname">snd_rawmidi_transmit</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em>, unsigned char *<em> buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit" title="Permalink to this definition">¶</a></dt>
<dd><p>copy from the buffer to the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the data size to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the buffer to the device and advances the pointer.</p>
<p><strong>Return</strong></p>
<p>The copied size if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_proceed">
int <code class="sig-name descname">snd_rawmidi_proceed</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_proceed" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard the all pending bytes and proceed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>rawmidi substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of discarded bytes</p>
<dl class="function">
<dt id="c.snd_rawmidi_new">
int <code class="sig-name descname">snd_rawmidi_new</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, char *<em> id</em>, int<em> device</em>, int<em> output_count</em>, int<em> input_count</em>, struct snd_rawmidi **<em> rrawmidi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a rawmidi instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">output_count</span></code></dt><dd><p>the number of output streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">input_count</span></code></dt><dd><p>the number of input streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">**</span> <span class="pre">rrawmidi</span></code></dt><dd><p>the pointer to store the new rawmidi instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rawmidi instance.
Use <a class="reference internal" href="#c.snd_rawmidi_set_ops" title="snd_rawmidi_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_set_ops()</span></code></a> to set the operators to the new instance.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_set_ops">
void <code class="sig-name descname">snd_rawmidi_set_ops</code><span class="sig-paren">(</span>struct snd_rawmidi *<em> rmidi</em>, int<em> stream</em>, const struct snd_rawmidi_ops *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the rawmidi operators</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">*</span> <span class="pre">rmidi</span></code></dt><dd><p>the rawmidi instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>the stream direction, SNDRV_RAWMIDI_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_rawmidi_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the rawmidi operators for the given stream direction.</p>
<dl class="function">
<dt id="c.snd_request_card">
void <code class="sig-name descname">snd_request_card</code><span class="sig-paren">(</span>int<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_request_card" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load the card module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">card</span></code></dt><dd><p>the card number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to load the module “snd-card-X” for the given card number
via request_module.  Returns immediately if already loaded.</p>
<dl class="function">
<dt id="c.snd_lookup_minor_data">
void * <code class="sig-name descname">snd_lookup_minor_data</code><span class="sig-paren">(</span>unsigned int<em> minor</em>, int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_lookup_minor_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get user data of a registered device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minor</span></code></dt><dd><p>the minor number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>device type (SNDRV_DEVICE_TYPE_XXX)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a minor device with the specified type is registered, and returns
its user data pointer.</p>
<p>This function increments the reference counter of the card instance
if an associated instance with the given minor number and type is found.
The caller must call <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a> appropriately later.</p>
<p><strong>Return</strong></p>
<p>The user data pointer if the specified device is found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
otherwise.</p>
<dl class="function">
<dt id="c.snd_register_device">
int <code class="sig-name descname">snd_register_device</code><span class="sig-paren">(</span>int<em> type</em>, struct snd_card *<em> card</em>, int<em> dev</em>, const struct file_operations *<em> f_ops</em>, void *<em> private_data</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the ALSA device file for the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the device type, SNDRV_DEVICE_TYPE_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>the device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">f_ops</span></code></dt><dd><p>the file operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt><dd><p>user pointer for f_ops-&gt;open()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt><dd><p>the device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_unregister_device">
int <code class="sig-name descname">snd_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the device on the given card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>the device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters the device file already registered via
<a class="reference internal" href="#c.snd_register_device" title="snd_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_register_device()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.copy_to_user_fromio">
int <code class="sig-name descname">copy_to_user_fromio</code><span class="sig-paren">(</span>void __user *<em> dst</em>, const volatile void __iomem *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_to_user_fromio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from mmio-space to user-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>the destination pointer on user-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>the source pointer on mmio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the data size to copy in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from mmio-space to user-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
<dl class="function">
<dt id="c.copy_from_user_toio">
int <code class="sig-name descname">copy_from_user_toio</code><span class="sig-paren">(</span>volatile void __iomem *<em> dst</em>, const void __user *<em> src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_from_user_toio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from user-space to mmio-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>the destination pointer on mmio-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>the source pointer on user-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the data size to copy in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from user-space to mmio-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_free_for_all">
void <code class="sig-name descname">snd_pcm_lib_preallocate_free_for_all</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_free_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>release all pre-allocated buffers on the pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all the pre-allocated buffers on the given pcm.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages">
void <code class="sig-name descname">snd_pcm_lib_preallocate_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, int<em> type</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for the given DMA type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages_for_all">
void <code class="sig-name descname">snd_pcm_lib_preallocate_pages_for_all</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em>, int<em> type</em>, void *<em> data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for continuous memory type (all substreams)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the
specified DMA type.</p>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer">
void <code class="sig-name descname">snd_pcm_set_managed_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, int<em> type</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for a substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type, and set the managed
buffer allocation mode to the given substream.
In this mode, PCM core will allocate a buffer automatically before PCM
hw_params ops call, and release the buffer after PCM hw_free ops call
as well, so that the driver doesn’t need to invoke the allocation and
the release explicitly in its callback.
When a buffer is actually allocated before the PCM hw_params call, it
turns on the runtime buffer_changed flag for drivers changing their h/w
parameters accordingly.</p>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer_all">
void <code class="sig-name descname">snd_pcm_set_managed_buffer_all</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em>, int<em> type</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer_all" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for all substreams for all substreams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the specified DMA
type and size, and set the managed_buffer_alloc flag to each substream.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_malloc_pages">
int <code class="sig-name descname">snd_pcm_lib_malloc_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_malloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the DMA buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream to allocate the DMA buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the DMA buffer on the BUS type given earlier to
snd_pcm_lib_preallocate_xxx_pages().</p>
<p><strong>Return</strong></p>
<p>1 if the buffer is changed, 0 if not changed, or a negative
code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_free_pages">
int <code class="sig-name descname">snd_pcm_lib_free_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated DMA buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream to release the DMA buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the DMA buffer allocated via <a class="reference internal" href="#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_free_vmalloc_buffer">
int <code class="sig-name descname">snd_pcm_lib_free_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>free vmalloc buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_get_vmalloc_page">
struct page * <code class="sig-name descname">snd_pcm_lib_get_vmalloc_page</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned long<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_get_vmalloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc buffer offset to page struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is to be used as the page callback in the PCM ops.</p>
<p><strong>Return</strong></p>
<p>The page struct, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_device_initialize">
void <code class="sig-name descname">snd_device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> dev</em>, struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize struct device for sound devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt><dd><p>device to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>card to assign, optional</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_new">
int <code class="sig-name descname">snd_card_new</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> parent</em>, int<em> idx</em>, const char *<em> xid</em>, struct module *<em> module</em>, int<em> extra_size</em>, struct snd_card **<em> card_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a soundcard structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>the parent device object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>card index (address) [0 … (SNDRV_CARDS-1)]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">xid</span></code></dt><dd><p>card identification (ASCII string)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt><dd><p>top level module for locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extra_size</span></code></dt><dd><p>allocate this extra size after the main soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">**</span> <span class="pre">card_ret</span></code></dt><dd><p>the pointer to store the created card instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Creates and initializes a soundcard structure.</p>
<p>The function allocates snd_card instance via kzalloc with the given
space for the driver to use freely.  The allocated struct is stored
in the given card_ret pointer.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_ref">
struct snd_card * <code class="sig-name descname">snd_card_ref</code><span class="sig-paren">(</span>int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the card object from the index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>the card index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a card object corresponding to the given index or NULL if not found.
Release the object via <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_card_disconnect">
int <code class="sig-name descname">snd_card_disconnect</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect all APIs from the file-operations (user space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disconnects all APIs from the file-operations (user space).</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero, otherwise a negative error code.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The current implementation replaces all active file-&gt;f_op with special</dt><dd><p>dummy file operations (they do nothing except release).</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_disconnect_sync">
void <code class="sig-name descname">snd_card_disconnect_sync</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect card and wait until files get closed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>card object to disconnect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This calls <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a> for disconnecting all belonging components
and waits until all pending files get closed.
It assures that all accesses from user-space finished so that the driver
can release its resources gracefully.</p>
<dl class="function">
<dt id="c.snd_card_free_when_closed">
int <code class="sig-name descname">snd_card_free_when_closed</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free_when_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect the card, free it later eventually</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>, this function doesn’t try to release the card
resource immediately, but tries to disconnect at first.  When the card
is still in use, the function returns before freeing the resources.
The card resources will be freed when the refcount gets to zero.</p>
<dl class="function">
<dt id="c.snd_card_free">
int <code class="sig-name descname">snd_card_free</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees given soundcard structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don’t have to release the devices
by yourself.</p>
<p>This function waits until the all resources are properly released.</p>
<p><strong>Return</strong></p>
<p>Zero. Frees all associated devices and frees the control
interface associated to given soundcard.</p>
<dl class="function">
<dt id="c.snd_card_set_id">
void <code class="sig-name descname">snd_card_set_id</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_set_id" title="Permalink to this definition">¶</a></dt>
<dd><p>set card identification name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">nid</span></code></dt><dd><p>new identification string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function sets the card identification and checks for name
collisions.</p>
</div></blockquote>
<dl class="function">
<dt id="c.snd_card_add_dev_attr">
int <code class="sig-name descname">snd_card_add_dev_attr</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const struct attribute_group *<em> group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_add_dev_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a new sysfs attribute group to card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">group</span></code></dt><dd><p>attribute group to append</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_register">
int <code class="sig-name descname">snd_card_register</code><span class="sig-paren">(</span>struct snd_card *<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the soundcard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code if the registration failed.</p>
<dl class="function">
<dt id="c.snd_component_add">
int <code class="sig-name descname">snd_component_add</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, const char *<em> component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_component_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">component</span></code></dt><dd><p>the component id string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_file_add">
int <code class="sig-name descname">snd_card_file_add</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct file *<em> file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the file to the file list of the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>file pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>zero or a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_file_remove">
int <code class="sig-name descname">snd_card_file_remove</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct file *<em> file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the file from the file list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>file pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function removes the file formerly added to the card via
<a class="reference internal" href="#c.snd_card_file_add" title="snd_card_file_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_file_add()</span></code></a> function.
If all files are removed and <a class="reference internal" href="#c.snd_card_free_when_closed" title="snd_card_free_when_closed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_when_closed()</span></code></a> was
called beforehand, it processes the pending release of
resources.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero or a negative error code.</p>
<dl class="function">
<dt id="c.snd_power_wait">
int <code class="sig-name descname">snd_power_wait</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, unsigned int<em> power_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the power-state is changed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">power_state</span></code></dt><dd><p>expected power state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Waits until the power-state is changed.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_dma_program">
void <code class="sig-name descname">snd_dma_program</code><span class="sig-paren">(</span>unsigned long<em> dma</em>, unsigned long<em> addr</em>, unsigned int<em> size</em>, unsigned short<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_program" title="Permalink to this definition">¶</a></dt>
<dd><p>program an ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>the physical address of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the DMA transfer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mode</span></code></dt><dd><p>the DMA transfer mode, DMA_MODE_XXX</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Programs an ISA DMA transfer for the given buffer.</p>
<dl class="function">
<dt id="c.snd_dma_disable">
void <code class="sig-name descname">snd_dma_disable</code><span class="sig-paren">(</span>unsigned long<em> dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the ISA DMA transfer.</p>
<dl class="function">
<dt id="c.snd_dma_pointer">
unsigned int <code class="sig-name descname">snd_dma_pointer</code><span class="sig-paren">(</span>unsigned long<em> dma</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current pointer to DMA transfer buffer in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the dma transfer size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The current pointer in DMA transfer buffer in bytes.</p>
<dl class="function">
<dt id="c.snd_ctl_notify">
void <code class="sig-name descname">snd_ctl_notify</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, unsigned int<em> mask</em>, struct snd_ctl_elem_id *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Send notification to user-space for a control change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card to send notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the event mask, SNDRV_CTL_EVENT_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the ctl element id to send notification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds an event record with the given id and mask, appends
to the list and wakes up the user-space for notification.  This can be
called in the atomic context.</p>
<dl class="function">
<dt id="c.snd_ctl_new1">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_new1</code><span class="sig-paren">(</span>const struct snd_kcontrol_new *<em> ncontrol</em>, void *<em> private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_new1" title="Permalink to this definition">¶</a></dt>
<dd><p>create a control instance from the template</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">ncontrol</span></code></dt><dd><p>the initialization record</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt><dd><p>the private data to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a new struct snd_kcontrol instance and initialize from the given
template.  When the access field of ncontrol is 0, it’s assumed as
READWRITE access. When the count field is 0, it’s assumes as one.</p>
<p><strong>Return</strong></p>
<p>The pointer of the newly generated instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_free_one">
void <code class="sig-name descname">snd_ctl_free_one</code><span class="sig-paren">(</span>struct snd_kcontrol *<em> kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_free_one" title="Permalink to this definition">¶</a></dt>
<dd><p>release the control instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the control instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the control instance created via <a class="reference internal" href="../sound/kernel-api/alsa-driver-api.html#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a>
or <a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a>.
Don’t call this after the control was added to the card.</p>
<dl class="function">
<dt id="c.snd_ctl_add">
int <code class="sig-name descname">snd_ctl_add</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_kcontrol *<em> kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the control instance to the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the control instance to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the control instance created via <a class="reference internal" href="../sound/kernel-api/alsa-driver-api.html#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a> or
<a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> to the given card. Assigns also an unique
numid used for fast search.</p>
<p>It frees automatically the control which cannot be added.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_replace">
int <code class="sig-name descname">snd_ctl_replace</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_kcontrol *<em> kcontrol</em>, bool<em> add_on_replace</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the control instance of the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the control instance to replace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">add_on_replace</span></code></dt><dd><p>add the control if not already added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the given control.  If the given control does not exist
and the add_on_replace flag is set, the control is added.  If the
control exists, it is destroyed first.</p>
<p>It frees automatically the control which cannot be added or replaced.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_remove">
int <code class="sig-name descname">snd_ctl_remove</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_kcontrol *<em> kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control from the card and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the control instance to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the control from the card and then releases the instance.
You don’t need to call <a class="reference internal" href="#c.snd_ctl_free_one" title="snd_ctl_free_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_free_one()</span></code></a>. You must be in
the write lock - down_write(<code class="xref c c-type docutils literal notranslate"><span class="pre">card-&gt;controls_rwsem</span></code>).</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_remove_id">
int <code class="sig-name descname">snd_ctl_remove_id</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_ctl_elem_id *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove_id" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control of the given id and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the control id to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, removes it from the
card list and releases it.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_activate_id">
int <code class="sig-name descname">snd_ctl_activate_id</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_ctl_elem_id *<em> id</em>, int<em> active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_activate_id" title="Permalink to this definition">¶</a></dt>
<dd><p>activate/inactivate the control of the given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the control id to activate/inactivate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">active</span></code></dt><dd><p>non-zero to activate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, and activate or
inactivate the control together with notification, if changed.
The given ID data is filled with full information.</p>
<p><strong>Return</strong></p>
<p>0 if unchanged, 1 if changed, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_rename_id">
int <code class="sig-name descname">snd_ctl_rename_id</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_ctl_elem_id *<em> src_id</em>, struct snd_ctl_elem_id *<em> dst_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_rename_id" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the id of a control on the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">src_id</span></code></dt><dd><p>the old id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">dst_id</span></code></dt><dd><p>the new id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control with the old id from the card, and replaces the
id with the new one.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_find_numid">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_find_numid</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, unsigned int<em> numid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_numid" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given number-id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">numid</span></code></dt><dd><p>the number-id to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given number-id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
<dl class="function">
<dt id="c.snd_ctl_find_id">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_find_id</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, struct snd_ctl_elem_id *<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the id to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl">
int <code class="sig-name descname">snd_ctl_register_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called from each device manager like pcm.c, hwdep.c, etc.</p>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl_compat">
int <code class="sig-name descname">snd_ctl_register_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific 32bit compat control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl">
int <code class="sig-name descname">snd_ctl_unregister_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function to unregister</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl_compat">
int <code class="sig-name descname">snd_ctl_unregister_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific compat 32bit control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function to unregister</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_boolean_mono_info">
int <code class="sig-name descname">snd_ctl_boolean_mono_info</code><span class="sig-paren">(</span>struct snd_kcontrol *<em> kcontrol</em>, struct snd_ctl_elem_info *<em> uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_mono_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with a mono channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the kcontrol instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>info to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with a single mono channel.</p>
<dl class="function">
<dt id="c.snd_ctl_boolean_stereo_info">
int <code class="sig-name descname">snd_ctl_boolean_stereo_info</code><span class="sig-paren">(</span>struct snd_kcontrol *<em> kcontrol</em>, struct snd_ctl_elem_info *<em> uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_stereo_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with stereo two channels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt><dd><p>the kcontrol instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>info to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with stereo two channels.</p>
<dl class="function">
<dt id="c.snd_ctl_enum_info">
int <code class="sig-name descname">snd_ctl_enum_info</code><span class="sig-paren">(</span>struct snd_ctl_elem_info *<em> info</em>, unsigned int<em> channels</em>, unsigned int<em> items</em>, const char *const<em> names</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_enum_info" title="Permalink to this definition">¶</a></dt>
<dd><p>fills the info structure for an enumerated control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>the structure to be filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">channels</span></code></dt><dd><p>the number of the control’s channels; often one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">items</span></code></dt><dd><p>the number of control values; also the size of <strong>names</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">names</span></code></dt><dd><p>an array containing the names of all control values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets all required fields in <strong>info</strong> to their appropriate values.
If the control’s accessibility is not the default (readable and writable),
the caller has to fill <strong>info-&gt;access</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
<dl class="function">
<dt id="c.snd_pcm_set_ops">
void <code class="sig-name descname">snd_pcm_set_ops</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em>, int<em> direction</em>, const struct snd_pcm_ops *<em> ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM operators</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">direction</span></code></dt><dd><p>stream direction, SNDRV_PCM_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the given PCM operators to the pcm instance.</p>
<dl class="function">
<dt id="c.snd_pcm_set_sync">
void <code class="sig-name descname">snd_pcm_set_sync</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM sync id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCM sync identifier for the card.</p>
<dl class="function">
<dt id="c.snd_interval_refine">
int <code class="sig-name descname">snd_interval_refine</code><span class="sig-paren">(</span>struct snd_interval *<em> i</em>, const struct snd_interval *<em> v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_refine" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value of configurator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">v</span></code></dt><dd><p>the interval value to refer to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_ratnum">
int <code class="sig-name descname">snd_interval_ratnum</code><span class="sig-paren">(</span>struct snd_interval *<em> i</em>, unsigned int<em> rats_count</em>, const struct snd_ratnum *<em> rats</em>, unsigned int *<em> nump</em>, unsigned int *<em> denp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ratnum" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt><dd><p>interval to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rats_count</span></code></dt><dd><p>number of ratnum_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ratnum</span> <span class="pre">*</span> <span class="pre">rats</span></code></dt><dd><p>ratnum_t array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">nump</span></code></dt><dd><p>pointer to store the resultant numerator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">denp</span></code></dt><dd><p>pointer to store the resultant denominator</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_list">
int <code class="sig-name descname">snd_interval_list</code><span class="sig-paren">(</span>struct snd_interval *<em> i</em>, unsigned int<em> count</em>, const unsigned int *<em> list</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_list" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of elements in the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">list</span></code></dt><dd><p>the value list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the bit-mask to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_ranges">
int <code class="sig-name descname">snd_interval_ranges</code><span class="sig-paren">(</span>struct snd_interval *<em> i</em>, unsigned int<em> count</em>, const struct snd_interval *<em> ranges</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list of ranges</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of elements in the list of ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">ranges</span></code></dt><dd><p>the ranges list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the bit-mask to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list of ranges.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_add">
int <code class="sig-name descname">snd_pcm_hw_rule_add</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, int<em> var</em>, snd_pcm_hw_rule_func_t<em> func</em>, void *<em> private</em>, int<em> dep</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the hw-constraint rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>the pcm runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">var</span></code></dt><dd><p>the variable to evaluate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_rule_func_t</span> <span class="pre">func</span></code></dt><dd><p>the evaluation function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt><dd><p>the private data pointer passed to function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dep</span></code></dt><dd><p>the dependent variables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_mask64">
int <code class="sig-name descname">snd_pcm_hw_constraint_mask64</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, snd_pcm_hw_param_t<em> var</em>, u_int64_t<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_mask64" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the given bitmap mask constraint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_int64_t</span> <span class="pre">mask</span></code></dt><dd><p>the 64bit bitmap mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of the given bitmap mask to a 64-bit mask parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_integer">
int <code class="sig-name descname">snd_pcm_hw_constraint_integer</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, snd_pcm_hw_param_t<em> var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an integer constraint to an interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the integer constraint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of integer to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_minmax">
int <code class="sig-name descname">snd_pcm_hw_constraint_minmax</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, snd_pcm_hw_param_t<em> var</em>, unsigned int<em> min</em>, unsigned int<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a min/max range constraint to an interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>the minimal value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>the maximal value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the min/max range constraint to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_list">
int <code class="sig-name descname">snd_pcm_hw_constraint_list</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_list" title="snd_pcm_hw_constraint_list">snd_pcm_hw_constraint_list</a> *<em> l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_list" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a list of constraints to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the list constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_list</span> <span class="pre">*</span> <span class="pre">l</span></code></dt><dd><p>list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ranges">
int <code class="sig-name descname">snd_pcm_hw_constraint_ranges</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ranges" title="snd_pcm_hw_constraint_ranges">snd_pcm_hw_constraint_ranges</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>apply list of range constraints to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the list of range constraints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ranges</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>ranges</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of range constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratnums">
int <code class="sig-name descname">snd_pcm_hw_constraint_ratnums</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratnums" title="snd_pcm_hw_constraint_ratnums">snd_pcm_hw_constraint_ratnums</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratnums" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratnums constraint to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the ratnums constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratnums</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>struct snd_ratnums constriants</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratdens">
int <code class="sig-name descname">snd_pcm_hw_constraint_ratdens</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratdens" title="snd_pcm_hw_constraint_ratdens">snd_pcm_hw_constraint_ratdens</a> *<em> r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratdens" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratdens constraint to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the ratdens constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratdens</span> <span class="pre">*</span> <span class="pre">r</span></code></dt><dd><p>struct snd_ratdens constriants</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_msbits">
int <code class="sig-name descname">snd_pcm_hw_constraint_msbits</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, unsigned int<em> width</em>, unsigned int<em> msbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_msbits" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint msbits rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>sample bits width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msbits</span></code></dt><dd><p>msbits width</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This constraint will set the number of most significant bits (msbits) if a
sample format with the specified width has been select. If width is set to 0
the msbits will be set for any sample format with a width larger than the
specified msbits.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_step">
int <code class="sig-name descname">snd_pcm_hw_constraint_step</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, unsigned long<em> step</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_step" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint step rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the step constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">step</span></code></dt><dd><p>step size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_pow2">
int <code class="sig-name descname">snd_pcm_hw_constraint_pow2</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_pow2" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint power-of-2 rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the power-of-2 constraint</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_noresample">
int <code class="sig-name descname">snd_pcm_hw_rule_noresample</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em> runtime</em>, unsigned int<em> base_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_noresample" title="Permalink to this definition">¶</a></dt>
<dd><p>add a rule to allow disabling hw resampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base_rate</span></code></dt><dd><p>the rate at which the hardware does not resample</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_value">
int <code class="sig-name descname">snd_pcm_hw_param_value</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em> params</em>, snd_pcm_hw_param_t<em> var</em>, int *<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return <strong>params</strong> field <strong>var</strong> value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The value for field <strong>var</strong> if it’s fixed in configuration space
defined by <strong>params</strong>. -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_first">
int <code class="sig-name descname">snd_pcm_hw_param_first</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> pcm</em>, struct snd_pcm_hw_params *<em> params</em>, snd_pcm_hw_param_t<em> var</em>, int *<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_first" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return minimum value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &gt; minimum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The minimum, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_last">
int <code class="sig-name descname">snd_pcm_hw_param_last</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> pcm</em>, struct snd_pcm_hw_params *<em> params</em>, snd_pcm_hw_param_t<em> var</em>, int *<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_last" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return maximum value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &lt; maximum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The maximum, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_ioctl">
int <code class="sig-name descname">snd_pcm_lib_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned int<em> cmd</em>, void *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>a generic PCM ioctl callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>ioctl argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_period_elapsed">
void <code class="sig-name descname">snd_pcm_period_elapsed</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_period_elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the pcm status for the next period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the interrupt handler when the
PCM has processed the period size.  It will update the current
pointer, wake up sleepers, etc.</p>
<p>Even if more than one periods have elapsed since the last call, you
have to call this only once.</p>
<dl class="function">
<dt id="c.snd_pcm_add_chmap_ctls">
int <code class="sig-name descname">snd_pcm_add_chmap_ctls</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em>, int<em> stream</em>, const struct snd_pcm_chmap_elem *<em> chmap</em>, int<em> max_channels</em>, unsigned long<em> private_value</em>, struct snd_pcm_chmap **<em> info_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_add_chmap_ctls" title="Permalink to this definition">¶</a></dt>
<dd><p>create channel-mapping control elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the assigned PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>stream direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_chmap_elem</span> <span class="pre">*</span> <span class="pre">chmap</span></code></dt><dd><p>channel map elements (for query)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_channels</span></code></dt><dd><p>the max number of channels for the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">private_value</span></code></dt><dd><p>the value passed to each kcontrol’s private_value field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">**</span> <span class="pre">info_ret</span></code></dt><dd><p>store struct snd_pcm_chmap instance if non-NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create channel-mapping control elements assigned to the given PCM stream(s).</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error value.</p>
<dl class="function">
<dt id="c.snd_hwdep_new">
int <code class="sig-name descname">snd_hwdep_new</code><span class="sig-paren">(</span>struct snd_card *<em> card</em>, char *<em> id</em>, int<em> device</em>, struct snd_hwdep **<em> rhwdep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_hwdep_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new hwdep instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_hwdep</span> <span class="pre">**</span> <span class="pre">rhwdep</span></code></dt><dd><p>the pointer to store the new hwdep instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-&gt;ops) must be set on the returned instance
after this call manually by the caller.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock">
void <code class="sig-name descname">snd_pcm_stream_lock</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream’s spinlock or mutex depending on the nonatomic
flag of the given substream.  This also takes the global link rw lock
(or rw sem), too, for avoiding the race with linked streams.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock">
void <code class="sig-name descname">snd_pcm_stream_unlock</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unlocks the PCM stream that has been locked via <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irq">
void <code class="sig-name descname">snd_pcm_stream_lock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> and disables the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irq">
void <code class="sig-name descname">snd_pcm_stream_unlock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irq" title="snd_pcm_stream_lock_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irq()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irqrestore">
void <code class="sig-name descname">snd_pcm_stream_unlock_irqrestore</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irqrestore" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>irq flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irqsave" title="snd_pcm_stream_lock_irqsave"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irqsave()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stop">
int <code class="sig-name descname">snd_pcm_stop</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, snd_pcm_state_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>try to stop all running streams in the substream group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_state_t</span> <span class="pre">state</span></code></dt><dd><p>PCM state after stopping the stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state of each stream is then changed to the given state unconditionally.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_stop_xrun">
int <code class="sig-name descname">snd_pcm_stop_xrun</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop_xrun" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the running streams as XRUN</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This stops the given running substream (and all linked substreams) as XRUN.
Unlike <a class="reference internal" href="#c.snd_pcm_stop" title="snd_pcm_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stop()</span></code></a>, this function takes the substream lock by itself.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_suspend_all">
int <code class="sig-name descname">snd_pcm_suspend_all</code><span class="sig-paren">(</span>struct snd_pcm *<em> pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_suspend_all" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger SUSPEND to all substreams in the given pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt><dd><p>the PCM instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, all streams are changed to SUSPENDED state.</p>
<p><strong>Return</strong></p>
<p>Zero if successful (or <strong>pcm</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>), or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_kernel_ioctl">
int <code class="sig-name descname">snd_pcm_kernel_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, unsigned int<em> cmd</em>, void *<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_kernel_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute PCM ioctl in the kernel-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>IOCTL cmd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt><dd><p>IOCTL argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function is provided primarily for OSS layer and USB gadget drivers,
and it allows only the limited set of ioctls (hw_params, sw_params,
prepare, start, drain, drop, forward).</p>
<dl class="function">
<dt id="c.snd_pcm_lib_default_mmap">
int <code class="sig-name descname">snd_pcm_lib_default_mmap</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, struct vm_area_struct *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_default_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default mmap handler for PCM data.  When mmap pcm_ops is NULL,
this function is invoked implicitly.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_mmap_iomem">
int <code class="sig-name descname">snd_pcm_lib_mmap_iomem</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em> substream</em>, struct vm_area_struct *<em> area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_mmap_iomem" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function for I/O mem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When your hardware uses the iomapped pages as the hardware buffer and
wants to mmap it, pass this function as mmap pcm_ops.  Note that this
is supposed to work only on limited architectures.</p>
<dl class="function">
<dt id="c.snd_dma_alloc_pages">
int <code class="sig-name descname">snd_dma_alloc_pages</code><span class="sig-paren">(</span>int<em> type</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> device</em>, size_t<em> size</em>, struct snd_dma_buffer *<em> dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the DMA buffer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt><dd><p>buffer allocation record to store the allocated data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
<dl class="function">
<dt id="c.snd_dma_alloc_pages_fallback">
int <code class="sig-name descname">snd_dma_alloc_pages_fallback</code><span class="sig-paren">(</span>int<em> type</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em> device</em>, size_t<em> size</em>, struct snd_dma_buffer *<em> dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_pages_fallback" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type with fallback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the DMA buffer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt><dd><p>buffer allocation record to store the allocated data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res_size argument.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
<dl class="function">
<dt id="c.snd_dma_free_pages">
void <code class="sig-name descname">snd_dma_free_pages</code><span class="sig-paren">(</span>struct snd_dma_buffer *<em> dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt><dd><p>the buffer allocation record to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the allocated buffer via <a class="reference internal" href="#c.snd_dma_alloc_pages" title="snd_dma_alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_dma_alloc_pages()</span></code></a>.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="frame-buffer.html" class="btn btn-neutral float-right" title="Frame Buffer Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="infiniband.html" class="btn btn-neutral float-left" title="InfiniBand and Remote DMA (RDMA) Interfaces" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>