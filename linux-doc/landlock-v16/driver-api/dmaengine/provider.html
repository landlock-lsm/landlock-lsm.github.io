

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DMAengine controller documentation &mdash; The Linux Kernel 5.7.0-rc1+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="DMA Engine API Guide" href="client.html" />
    <link rel="prev" title="DMAEngine documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">DMAEngine documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html#dmaengine-development-documentation">DMAEngine development documentation</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">DMAengine controller documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dmaengine-client-documentation">DMAEngine client documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dma-test-documentation">DMA Test documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#pxa-dma-documentation">PXA DMA documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">DMAEngine documentation</a> &raquo;</li>
        
      <li>DMAengine controller documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/dmaengine/provider.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dmaengine-controller-documentation">
<h1>DMAengine controller documentation<a class="headerlink" href="#dmaengine-controller-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="hardware-introduction">
<h2>Hardware Introduction<a class="headerlink" href="#hardware-introduction" title="Permalink to this headline">¶</a></h2>
<p>Most of the Slave DMA controllers have the same general principles of
operations.</p>
<p>They have a given number of channels to use for the DMA transfers, and
a given number of requests lines.</p>
<p>Requests and channels are pretty much orthogonal. Channels can be used
to serve several to any requests. To simplify, channels are the
entities that will be doing the copy, and requests what endpoints are
involved.</p>
<p>The request lines actually correspond to physical lines going from the
DMA-eligible devices to the controller itself. Whenever the device
will want to start a transfer, it will assert a DMA request (DRQ) by
asserting that request line.</p>
<p>A very simple DMA controller would only take into account a single
parameter: the transfer size. At each clock cycle, it would transfer a
byte of data from one buffer to another, until the transfer size has
been reached.</p>
<p>That wouldn’t work well in the real world, since slave devices might
require a specific number of bits to be transferred in a single
cycle. For example, we may want to transfer as much data as the
physical bus allows to maximize performances when doing a simple
memory copy operation, but our audio device could have a narrower FIFO
that requires data to be written exactly 16 or 24 bits at a time. This
is why most if not all of the DMA controllers can adjust this, using a
parameter called the transfer width.</p>
<p>Moreover, some DMA controllers, whenever the RAM is used as a source
or destination, can group the reads or writes in memory into a buffer,
so instead of having a lot of small memory accesses, which is not
really efficient, you’ll get several bigger transfers. This is done
using a parameter called the burst size, that defines how many single
reads/writes it’s allowed to do without the controller splitting the
transfer into smaller sub-transfers.</p>
<p>Our theoretical DMA controller would then only be able to do transfers
that involve a single contiguous block of data. However, some of the
transfers we usually have are not, and want to copy data from
non-contiguous buffers to a contiguous buffer, which is called
scatter-gather.</p>
<p>DMAEngine, at least for mem2dev transfers, require support for
scatter-gather. So we’re left with two cases here: either we have a
quite simple DMA controller that doesn’t support it, and we’ll have to
implement it in software, or we have a more advanced DMA controller,
that implements in hardware scatter-gather.</p>
<p>The latter are usually programmed using a collection of chunks to
transfer, and whenever the transfer is started, the controller will go
over that collection, doing whatever we programmed there.</p>
<p>This collection is usually either a table or a linked list. You will
then push either the address of the table and its number of elements,
or the first item of the list to one channel of the DMA controller,
and whenever a DRQ will be asserted, it will go through the collection
to know where to fetch the data from.</p>
<p>Either way, the format of this collection is completely dependent on
your hardware. Each DMA controller will require a different structure,
but all of them will require, for every chunk, at least the source and
destination addresses, whether it should increment these addresses or
not and the three parameters we saw earlier: the burst size, the
transfer width and the transfer size.</p>
<p>The one last thing is that usually, slave devices won’t issue DRQ by
default, and you have to enable this in your slave device driver first
whenever you’re willing to use DMA.</p>
<p>These were just the general memory-to-memory (also called mem2mem) or
memory-to-device (mem2dev) kind of transfers. Most devices often
support other kind of transfers or memory operations that dmaengine
support and will be detailed later in this document.</p>
</div>
<div class="section" id="dma-support-in-linux">
<h2>DMA Support in Linux<a class="headerlink" href="#dma-support-in-linux" title="Permalink to this headline">¶</a></h2>
<p>Historically, DMA controller drivers have been implemented using the
async TX API, to offload operations such as memory copy, XOR,
cryptography, etc., basically any memory to memory operation.</p>
<p>Over time, the need for memory to device transfers arose, and
dmaengine was extended. Nowadays, the async TX API is written as a
layer on top of dmaengine, and acts as a client. Still, dmaengine
accommodates that API in some cases, and made some design choices to
ensure that it stayed compatible.</p>
<p>For more information on the Async TX API, please look the relevant
documentation file in Documentation/crypto/async-tx-api.txt.</p>
</div>
<div class="section" id="dmaengine-apis">
<h2>DMAEngine APIs<a class="headerlink" href="#dmaengine-apis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="struct-dma-device-initialization">
<h3><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_device</span></code> Initialization<a class="headerlink" href="#struct-dma-device-initialization" title="Permalink to this headline">¶</a></h3>
<p>Just like any other kernel framework, the whole DMAEngine registration
relies on the driver filling a structure and registering against the
framework. In our case, that structure is dma_device.</p>
<p>The first thing you need to do in your driver is to allocate this
structure. Any of the usual memory allocators will do, but you’ll also
need to initialize a few fields in there:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">channels</span></code>: should be initialized as a list using the
INIT_LIST_HEAD macro for example</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src_addr_widths</span></code>:
should contain a bitmask of the supported source transfer width</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dst_addr_widths</span></code>:
should contain a bitmask of the supported destination transfer width</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">directions</span></code>:
should contain a bitmask of the supported slave directions
(i.e. excluding mem2mem transfers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">residue_granularity</span></code>:
granularity of the transfer residue reported to dma_set_residue.
This can be either:</p>
<ul>
<li><p>Descriptor:
your device doesn’t support any kind of residue
reporting. The framework will only know that a particular
transaction descriptor is done.</p></li>
<li><p>Segment:
your device is able to report which chunks have been transferred</p></li>
<li><p>Burst:
your device is able to report which burst have been transferred</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dev</span></code>: should hold the pointer to the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code> associated
to your current driver instance.</p></li>
</ul>
</div>
<div class="section" id="supported-transaction-types">
<h3>Supported transaction types<a class="headerlink" href="#supported-transaction-types" title="Permalink to this headline">¶</a></h3>
<p>The next thing you need is to set which transaction types your device
(and driver) supports.</p>
<p>Our <code class="docutils literal notranslate"><span class="pre">dma_device</span> <span class="pre">structure</span></code> has a field called cap_mask that holds the
various types of transaction supported, and you need to modify this
mask using the dma_cap_set function, with various flags depending on
transaction types you support as an argument.</p>
<p>All those capabilities are defined in the <code class="docutils literal notranslate"><span class="pre">dma_transaction_type</span> <span class="pre">enum</span></code>,
in <code class="docutils literal notranslate"><span class="pre">include/linux/dmaengine.h</span></code></p>
<p>Currently, the types available are:</p>
<ul class="simple">
<li><p>DMA_MEMCPY</p>
<ul>
<li><p>The device is able to do memory to memory copies</p></li>
</ul>
</li>
<li><p>DMA_XOR</p>
<ul>
<li><p>The device is able to perform XOR operations on memory areas</p></li>
<li><p>Used to accelerate XOR intensive tasks, such as RAID5</p></li>
</ul>
</li>
<li><p>DMA_XOR_VAL</p>
<ul>
<li><p>The device is able to perform parity check using the XOR
algorithm against a memory buffer.</p></li>
</ul>
</li>
<li><p>DMA_PQ</p>
<ul>
<li><p>The device is able to perform RAID6 P+Q computations, P being a
simple XOR, and Q being a Reed-Solomon algorithm.</p></li>
</ul>
</li>
<li><p>DMA_PQ_VAL</p>
<ul>
<li><p>The device is able to perform parity check using RAID6 P+Q
algorithm against a memory buffer.</p></li>
</ul>
</li>
<li><p>DMA_INTERRUPT</p>
<ul>
<li><p>The device is able to trigger a dummy transfer that will
generate periodic interrupts</p></li>
<li><p>Used by the client drivers to register a callback that will be
called on a regular basis through the DMA controller interrupt</p></li>
</ul>
</li>
<li><p>DMA_PRIVATE</p>
<ul>
<li><p>The devices only supports slave transfers, and as such isn’t
available for async transfers.</p></li>
</ul>
</li>
<li><p>DMA_ASYNC_TX</p>
<ul>
<li><p>Must not be set by the device, and will be set by the framework
if needed</p></li>
<li><p>TODO: What is it about?</p></li>
</ul>
</li>
<li><p>DMA_SLAVE</p>
<ul>
<li><p>The device can handle device to memory transfers, including
scatter-gather transfers.</p></li>
<li><p>While in the mem2mem case we were having two distinct types to
deal with a single chunk to copy or a collection of them, here,
we just have a single transaction type that is supposed to
handle both.</p></li>
<li><p>If you want to transfer a single contiguous memory buffer,
simply build a scatter list with only one item.</p></li>
</ul>
</li>
<li><p>DMA_CYCLIC</p>
<ul>
<li><p>The device can handle cyclic transfers.</p></li>
<li><p>A cyclic transfer is a transfer where the chunk collection will
loop over itself, with the last item pointing to the first.</p></li>
<li><p>It’s usually used for audio transfers, where you want to operate
on a single ring buffer that you will fill with your audio data.</p></li>
</ul>
</li>
<li><p>DMA_INTERLEAVE</p>
<ul>
<li><p>The device supports interleaved transfer.</p></li>
<li><p>These transfers can transfer data from a non-contiguous buffer
to a non-contiguous buffer, opposed to DMA_SLAVE that can
transfer data from a non-contiguous data set to a continuous
destination buffer.</p></li>
<li><p>It’s usually used for 2d content transfers, in which case you
want to transfer a portion of uncompressed data directly to the
display to print it</p></li>
</ul>
</li>
</ul>
<p>These various types will also affect how the source and destination
addresses change over time.</p>
<p>Addresses pointing to RAM are typically incremented (or decremented)
after each transfer. In case of a ring buffer, they may loop
(DMA_CYCLIC). Addresses pointing to a device’s register (e.g. a FIFO)
are typically fixed.</p>
</div>
<div class="section" id="per-descriptor-metadata-support">
<h3>Per descriptor metadata support<a class="headerlink" href="#per-descriptor-metadata-support" title="Permalink to this headline">¶</a></h3>
<p>Some data movement architecture (DMA controller and peripherals) uses metadata
associated with a transaction. The DMA controller role is to transfer the
payload and the metadata alongside.
The metadata itself is not used by the DMA engine itself, but it contains
parameters, keys, vectors, etc for peripheral or from the peripheral.</p>
<p>The DMAengine framework provides a generic ways to facilitate the metadata for
descriptors. Depending on the architecture the DMA driver can implement either
or both of the methods and it is up to the client driver to choose which one
to use.</p>
<ul>
<li><p>DESC_METADATA_CLIENT</p>
<p>The metadata buffer is allocated/provided by the client driver and it is
attached (via the dmaengine_desc_attach_metadata() helper to the descriptor.</p>
<p>From the DMA driver the following is expected for this mode:</p>
<ul>
<li><p>DMA_MEM_TO_DEV / DEV_MEM_TO_MEM</p>
<p>The data from the provided metadata buffer should be prepared for the DMA
controller to be sent alongside of the payload data. Either by copying to a
hardware descriptor, or highly coupled packet.</p>
</li>
<li><p>DMA_DEV_TO_MEM</p>
<p>On transfer completion the DMA driver must copy the metadata to the client
provided metadata buffer before notifying the client about the completion.
After the transfer completion, DMA drivers must not touch the metadata
buffer provided by the client.</p>
</li>
</ul>
</li>
<li><p>DESC_METADATA_ENGINE</p>
<p>The metadata buffer is allocated/managed by the DMA driver. The client driver
can ask for the pointer, maximum size and the currently used size of the
metadata and can directly update or read it. dmaengine_desc_get_metadata_ptr()
and dmaengine_desc_set_metadata_len() is provided as helper functions.</p>
<p>From the DMA driver the following is expected for this mode:</p>
<ul>
<li><p>get_metadata_ptr()</p>
<p>Should return a pointer for the metadata buffer, the maximum size of the
metadata buffer and the currently used / valid (if any) bytes in the buffer.</p>
</li>
<li><p>set_metadata_len()</p>
<p>It is called by the clients after it have placed the metadata to the buffer
to let the DMA driver know the number of valid bytes provided.</p>
</li>
</ul>
<p>Note: since the client will ask for the metadata pointer in the completion
callback (in DMA_DEV_TO_MEM case) the DMA driver must ensure that the
descriptor is not freed up prior the callback is called.</p>
</li>
</ul>
</div>
<div class="section" id="device-operations">
<h3>Device operations<a class="headerlink" href="#device-operations" title="Permalink to this headline">¶</a></h3>
<p>Our dma_device structure also requires a few function pointers in
order to implement the actual logic, now that we described what
operations we were able to perform.</p>
<p>The functions that we have to fill in there, and hence have to
implement, obviously depend on the transaction types you reported as
supported.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device_alloc_chan_resources</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_free_chan_resources</span></code></p>
<ul>
<li><p>These functions will be called whenever a driver will call
<code class="docutils literal notranslate"><span class="pre">dma_request_channel</span></code> or <code class="docutils literal notranslate"><span class="pre">dma_release_channel</span></code> for the first/last
time on the channel associated to that driver.</p></li>
<li><p>They are in charge of allocating/freeing all the needed
resources in order for that channel to be useful for your driver.</p></li>
<li><p>These functions can sleep.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_prep_dma_*</span></code></p>
<ul>
<li><p>These functions are matching the capabilities you registered
previously.</p></li>
<li><p>These functions all take the buffer or the scatterlist relevant
for the transfer being prepared, and should create a hardware
descriptor or a list of hardware descriptors from it</p></li>
<li><p>These functions can be called from an interrupt context</p></li>
<li><p>Any allocation you might do should be using the GFP_NOWAIT
flag, in order not to potentially sleep, but without depleting
the emergency pool either.</p></li>
<li><p>Drivers should try to pre-allocate any memory they might need
during the transfer setup at probe time to avoid putting to
much pressure on the nowait allocator.</p></li>
<li><p>It should return a unique instance of the
<code class="docutils literal notranslate"><span class="pre">dma_async_tx_descriptor</span> <span class="pre">structure</span></code>, that further represents this
particular transfer.</p></li>
<li><p>This structure can be initialized using the function
<code class="docutils literal notranslate"><span class="pre">dma_async_tx_descriptor_init</span></code>.</p></li>
<li><p>You’ll also need to set two fields in this structure:</p>
<ul>
<li><p>flags:
TODO: Can it be modified by the driver itself, or
should it be always the flags passed in the arguments</p></li>
<li><p>tx_submit: A pointer to a function you have to implement,
that is supposed to push the current transaction descriptor to a
pending queue, waiting for issue_pending to be called.</p></li>
</ul>
</li>
<li><p>In this structure the function pointer callback_result can be
initialized in order for the submitter to be notified that a
transaction has completed. In the earlier code the function pointer
callback has been used. However it does not provide any status to the
transaction and will be deprecated. The result structure defined as
<code class="docutils literal notranslate"><span class="pre">dmaengine_result</span></code> that is passed in to callback_result
has two fields:</p>
<ul>
<li><p>result: This provides the transfer result defined by
<code class="docutils literal notranslate"><span class="pre">dmaengine_tx_result</span></code>. Either success or some error condition.</p></li>
<li><p>residue: Provides the residue bytes of the transfer for those that
support residue.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_issue_pending</span></code></p>
<ul>
<li><p>Takes the first transaction descriptor in the pending queue,
and starts the transfer. Whenever that transfer is done, it
should move to the next transaction in the list.</p></li>
<li><p>This function can be called in an interrupt context</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_tx_status</span></code></p>
<ul>
<li><p>Should report the bytes left to go over on the given channel</p></li>
<li><p>Should only care about the transaction descriptor passed as
argument, not the currently active one on a given channel</p></li>
<li><p>The tx_state argument might be NULL</p></li>
<li><p>Should use dma_set_residue to report it</p></li>
<li><p>In the case of a cyclic transfer, it should only take into
account the current period.</p></li>
<li><p>This function can be called in an interrupt context.</p></li>
</ul>
</li>
<li><p>device_config</p>
<ul>
<li><p>Reconfigures the channel with the configuration given as argument</p></li>
<li><p>This command should NOT perform synchronously, or on any
currently queued transfers, but only on subsequent ones</p></li>
<li><p>In this case, the function will receive a <code class="docutils literal notranslate"><span class="pre">dma_slave_config</span></code>
structure pointer as an argument, that will detail which
configuration to use.</p></li>
<li><p>Even though that structure contains a direction field, this
field is deprecated in favor of the direction argument given to
the prep_* functions</p></li>
<li><p>This call is mandatory for slave operations only. This should NOT be
set or expected to be set for memcpy operations.
If a driver support both, it should use this call for slave
operations only and not for memcpy ones.</p></li>
</ul>
</li>
<li><p>device_pause</p>
<ul>
<li><p>Pauses a transfer on the channel</p></li>
<li><p>This command should operate synchronously on the channel,
pausing right away the work of the given channel</p></li>
</ul>
</li>
<li><p>device_resume</p>
<ul>
<li><p>Resumes a transfer on the channel</p></li>
<li><p>This command should operate synchronously on the channel,
resuming right away the work of the given channel</p></li>
</ul>
</li>
<li><p>device_terminate_all</p>
<ul>
<li><p>Aborts all the pending and ongoing transfers on the channel</p></li>
<li><p>For aborted transfers the complete callback should not be called</p></li>
<li><p>Can be called from atomic context or from within a complete
callback of a descriptor. Must not sleep. Drivers must be able
to handle this correctly.</p></li>
<li><p>Termination may be asynchronous. The driver does not have to
wait until the currently active transfer has completely stopped.
See device_synchronize.</p></li>
</ul>
</li>
<li><p>device_synchronize</p>
<ul>
<li><p>Must synchronize the termination of a channel to the current
context.</p></li>
<li><p>Must make sure that memory for previously submitted
descriptors is no longer accessed by the DMA controller.</p></li>
<li><p>Must make sure that all complete callbacks for previously
submitted descriptors have finished running and none are
scheduled to run.</p></li>
<li><p>May sleep.</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="misc-notes">
<h2>Misc notes<a class="headerlink" href="#misc-notes" title="Permalink to this headline">¶</a></h2>
<p>(stuff that should be documented, but don’t really know
where to put them)</p>
<p><code class="docutils literal notranslate"><span class="pre">dma_run_dependencies</span></code></p>
<ul class="simple">
<li><p>Should be called at the end of an async TX transfer, and can be
ignored in the slave transfers case.</p></li>
<li><p>Makes sure that dependent operations are run before marking it
as complete.</p></li>
</ul>
<p>dma_cookie_t</p>
<ul class="simple">
<li><p>it’s a DMA transaction ID that will increment over time.</p></li>
<li><p>Not really relevant any more since the introduction of <code class="docutils literal notranslate"><span class="pre">virt-dma</span></code>
that abstracts it away.</p></li>
</ul>
<p>DMA_CTRL_ACK</p>
<ul class="simple">
<li><p>If clear, the descriptor cannot be reused by provider until the
client acknowledges receipt, i.e. has has a chance to establish any
dependency chains</p></li>
<li><p>This can be acked by invoking async_tx_ack()</p></li>
<li><p>If set, does not mean descriptor can be reused</p></li>
</ul>
<p>DMA_CTRL_REUSE</p>
<ul class="simple">
<li><p>If set, the descriptor can be reused after being completed. It should
not be freed by provider if this flag is set.</p></li>
<li><p>The descriptor should be prepared for reuse by invoking
<code class="docutils literal notranslate"><span class="pre">dmaengine_desc_set_reuse()</span></code> which will set DMA_CTRL_REUSE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dmaengine_desc_set_reuse()</span></code> will succeed only when channel support
reusable descriptor as exhibited by capabilities</p></li>
<li><p>As a consequence, if a device driver wants to skip the
<code class="docutils literal notranslate"><span class="pre">dma_map_sg()</span></code> and <code class="docutils literal notranslate"><span class="pre">dma_unmap_sg()</span></code> in between 2 transfers,
because the DMA’d data wasn’t used, it can resubmit the transfer right after
its completion.</p></li>
<li><p>Descriptor can be freed in few ways</p>
<ul>
<li><p>Clearing DMA_CTRL_REUSE by invoking
<code class="docutils literal notranslate"><span class="pre">dmaengine_desc_clear_reuse()</span></code> and submitting for last txn</p></li>
<li><p>Explicitly invoking <code class="docutils literal notranslate"><span class="pre">dmaengine_desc_free()</span></code>, this can succeed only
when DMA_CTRL_REUSE is already set</p></li>
<li><p>Terminating the channel</p></li>
</ul>
</li>
<li><p>DMA_PREP_CMD</p>
<ul>
<li><p>If set, the client driver tells DMA controller that passed data in DMA
API is command data.</p></li>
<li><p>Interpretation of command data is DMA controller specific. It can be
used for issuing commands to other peripherals/register reads/register
writes for which the descriptor should be in different format from
normal data descriptors.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-design-notes">
<h2>General Design Notes<a class="headerlink" href="#general-design-notes" title="Permalink to this headline">¶</a></h2>
<p>Most of the DMAEngine drivers you’ll see are based on a similar design
that handles the end of transfer interrupts in the handler, but defer
most work to a tasklet, including the start of a new transfer whenever
the previous transfer ended.</p>
<p>This is a rather inefficient design though, because the inter-transfer
latency will be not only the interrupt latency, but also the
scheduling latency of the tasklet, which will leave the channel idle
in between, which will slow down the global transfer rate.</p>
<p>You should avoid this kind of practice, and instead of electing a new
transfer in your tasklet, move that part to the interrupt handler in
order to have a shorter idle window (that we can’t really avoid
anyway).</p>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Burst: A number of consecutive read or write operations that
can be queued to buffers before being flushed to memory.</p></li>
<li><p>Chunk: A contiguous collection of bursts</p></li>
<li><p>Transfer: A collection of chunks (be it contiguous or not)</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="client.html" class="btn btn-neutral float-right" title="DMA Engine API Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="DMAEngine documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>