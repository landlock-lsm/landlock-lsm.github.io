

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>NAND Error-correction Code &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SPI NOR framework" href="spi-nor.html" />
    <link rel="prev" title="Upgrading BIOS using intel-spi" href="intel-spi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Memory Technology Device (MTD)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="intel-spi.html">Upgrading BIOS using intel-spi</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">NAND Error-correction Code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-problem">The problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-0">Attempt 0</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-0">Analysis 0</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-1">Attempt 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-1">Analysis 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-2">Attempt 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-2">Analysis 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-3">Attempt 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-3">Analysis 3</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-4">Attempt 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-4">Analysis 4</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-5">Attempt 5</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-5">Analysis 5</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-6">Attempt 6</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-6">Analysis 6</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-7">Attempt 7</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-7">Analysis 7</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-8">Attempt 8</a></li>
<li class="toctree-l4"><a class="reference internal" href="#analysis-8">Analysis 8</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attempt-9">Attempt 9</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correcting-errors">Correcting errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="spi-nor.html">SPI NOR framework</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Memory Technology Device (MTD)</a> &raquo;</li>
        
      <li>NAND Error-correction Code</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/mtd/nand_ecc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nand-error-correction-code">
<h1>NAND Error-correction Code<a class="headerlink" href="#nand-error-correction-code" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Having looked at the linux mtd/nand driver and more specific at nand_ecc.c
I felt there was room for optimisation. I bashed the code for a few hours
performing tricks like table lookup removing superfluous code etc.
After that the speed was increased by 35-40%.
Still I was not too happy as I felt there was additional room for improvement.</p>
<p>Bad! I was hooked.
I decided to annotate my steps in this file. Perhaps it is useful to someone
or someone learns something from it.</p>
</div>
<div class="section" id="the-problem">
<h2>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h2>
<p>NAND flash (at least SLC one) typically has sectors of 256 bytes.
However NAND flash is not extremely reliable so some error detection
(and sometimes correction) is needed.</p>
<p>This is done by means of a Hamming code. I’ll try to explain it in
laymans terms (and apologies to all the pro’s in the field in case I do
not use the right terminology, my coding theory class was almost 30
years ago, and I must admit it was not one of my favourites).</p>
<p>As I said before the ecc calculation is performed on sectors of 256
bytes. This is done by calculating several parity bits over the rows and
columns. The parity used is even parity which means that the parity bit = 1
if the data over which the parity is calculated is 1 and the parity bit = 0
if the data over which the parity is calculated is 0. So the total
number of bits over the data over which the parity is calculated + the
parity bit is even. (see wikipedia if you can’t follow this).
Parity is often calculated by means of an exclusive or operation,
sometimes also referred to as xor. In C the operator for xor is ^</p>
<p>Back to ecc.
Let’s give a small figure:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>byte   0:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>…</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>byte   1:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>…</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-odd"><td><p>byte   2:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>…</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>byte   3:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>…</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-odd"><td><p>byte   4:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp5</p></td>
<td><p>…</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>byte 254:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>…</p></td>
<td><p>rp15</p></td>
</tr>
<tr class="row-even"><td><p>byte 255:</p></td>
<td><p>bit7
cp1
cp3
cp5</p></td>
<td><p>bit6
cp0
cp3
cp5</p></td>
<td><p>bit5
cp1
cp2
cp5</p></td>
<td><p>bit4
cp0
cp2
cp5</p></td>
<td><p>bit3
cp1
cp3
cp4</p></td>
<td><p>bit2
cp0
cp3
cp4</p></td>
<td><p>bit1
cp1
cp2
cp4</p></td>
<td><p>bit0
cp0
cp2
cp4</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>…</p></td>
<td><p>rp15</p></td>
</tr>
</tbody>
</table>
<p>This figure represents a sector of 256 bytes.
cp is my abbreviation for column parity, rp for row parity.</p>
<p>Let’s start to explain column parity.</p>
<ul>
<li><p>cp0 is the parity that belongs to all bit0, bit2, bit4, bit6.</p>
<p>so the sum of all bit0, bit2, bit4 and bit6 values + cp0 itself is even.</p>
</li>
</ul>
<p>Similarly cp1 is the sum of all bit1, bit3, bit5 and bit7.</p>
<ul class="simple">
<li><p>cp2 is the parity over bit0, bit1, bit4 and bit5</p></li>
<li><p>cp3 is the parity over bit2, bit3, bit6 and bit7.</p></li>
<li><p>cp4 is the parity over bit0, bit1, bit2 and bit3.</p></li>
<li><p>cp5 is the parity over bit4, bit5, bit6 and bit7.</p></li>
</ul>
<p>Note that each of cp0 .. cp5 is exactly one bit.</p>
<p>Row parity actually works almost the same.</p>
<ul>
<li><p>rp0 is the parity of all even bytes (0, 2, 4, 6, … 252, 254)</p></li>
<li><p>rp1 is the parity of all odd bytes (1, 3, 5, 7, …, 253, 255)</p></li>
<li><p>rp2 is the parity of all bytes 0, 1, 4, 5, 8, 9, …
(so handle two bytes, then skip 2 bytes).</p></li>
<li><p>rp3 is covers the half rp2 does not cover (bytes 2, 3, 6, 7, 10, 11, …)</p></li>
<li><p>for rp4 the rule is cover 4 bytes, skip 4 bytes, cover 4 bytes, skip 4 etc.</p>
<p>so rp4 calculates parity over bytes 0, 1, 2, 3, 8, 9, 10, 11, 16, …)</p>
</li>
<li><p>and rp5 covers the other half, so bytes 4, 5, 6, 7, 12, 13, 14, 15, 20, ..</p></li>
</ul>
<p>The story now becomes quite boring. I guess you get the idea.</p>
<ul class="simple">
<li><p>rp6 covers 8 bytes then skips 8 etc</p></li>
<li><p>rp7 skips 8 bytes then covers 8 etc</p></li>
<li><p>rp8 covers 16 bytes then skips 16 etc</p></li>
<li><p>rp9 skips 16 bytes then covers 16 etc</p></li>
<li><p>rp10 covers 32 bytes then skips 32 etc</p></li>
<li><p>rp11 skips 32 bytes then covers 32 etc</p></li>
<li><p>rp12 covers 64 bytes then skips 64 etc</p></li>
<li><p>rp13 skips 64 bytes then covers 64 etc</p></li>
<li><p>rp14 covers 128 bytes then skips 128</p></li>
<li><p>rp15 skips 128 bytes then covers 128</p></li>
</ul>
<p>In the end the parity bits are grouped together in three bytes as
follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ECC</p></th>
<th class="head"><p>Bit 7</p></th>
<th class="head"><p>Bit 6</p></th>
<th class="head"><p>Bit 5</p></th>
<th class="head"><p>Bit 4</p></th>
<th class="head"><p>Bit 3</p></th>
<th class="head"><p>Bit 2</p></th>
<th class="head"><p>Bit 1</p></th>
<th class="head"><p>Bit 0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ECC 0</p></td>
<td><p>rp07</p></td>
<td><p>rp06</p></td>
<td><p>rp05</p></td>
<td><p>rp04</p></td>
<td><p>rp03</p></td>
<td><p>rp02</p></td>
<td><p>rp01</p></td>
<td><p>rp00</p></td>
</tr>
<tr class="row-odd"><td><p>ECC 1</p></td>
<td><p>rp15</p></td>
<td><p>rp14</p></td>
<td><p>rp13</p></td>
<td><p>rp12</p></td>
<td><p>rp11</p></td>
<td><p>rp10</p></td>
<td><p>rp09</p></td>
<td><p>rp08</p></td>
</tr>
<tr class="row-even"><td><p>ECC 2</p></td>
<td><p>cp5</p></td>
<td><p>cp4</p></td>
<td><p>cp3</p></td>
<td><p>cp2</p></td>
<td><p>cp1</p></td>
<td><p>cp0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>I detected after writing this that ST application note AN1823
(<a class="reference external" href="http://www.st.com/stonline/">http://www.st.com/stonline/</a>) gives a much
nicer picture.(but they use line parity as term where I use row parity)
Oh well, I’m graphically challenged, so suffer with me for a moment :-)</p>
<p>And I could not reuse the ST picture anyway for copyright reasons.</p>
</div>
<div class="section" id="attempt-0">
<h2>Attempt 0<a class="headerlink" href="#attempt-0" title="Permalink to this headline">¶</a></h2>
<p>Implementing the parity calculation is pretty simple.
In C pseudocode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 256; i++)
{
  if (i &amp; 0x01)
     rp1 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp1;
  else
     rp0 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp0;
  if (i &amp; 0x02)
     rp3 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp3;
  else
     rp2 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp2;
  if (i &amp; 0x04)
    rp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp5;
  else
    rp4 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp4;
  if (i &amp; 0x08)
    rp7 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp7;
  else
    rp6 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp6;
  if (i &amp; 0x10)
    rp9 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp9;
  else
    rp8 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp8;
  if (i &amp; 0x20)
    rp11 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp11;
  else
    rp10 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp10;
  if (i &amp; 0x40)
    rp13 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp13;
  else
    rp12 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp12;
  if (i &amp; 0x80)
    rp15 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp15;
  else
    rp14 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp14;
  cp0 = bit6 ^ bit4 ^ bit2 ^ bit0 ^ cp0;
  cp1 = bit7 ^ bit5 ^ bit3 ^ bit1 ^ cp1;
  cp2 = bit5 ^ bit4 ^ bit1 ^ bit0 ^ cp2;
  cp3 = bit7 ^ bit6 ^ bit3 ^ bit2 ^ cp3
  cp4 = bit3 ^ bit2 ^ bit1 ^ bit0 ^ cp4
  cp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ cp5
}
</pre></div>
</div>
</div>
<div class="section" id="analysis-0">
<h2>Analysis 0<a class="headerlink" href="#analysis-0" title="Permalink to this headline">¶</a></h2>
<p>C does have bitwise operators but not really operators to do the above
efficiently (and most hardware has no such instructions either).
Therefore without implementing this it was clear that the code above was
not going to bring me a Nobel prize :-)</p>
<p>Fortunately the exclusive or operation is commutative, so we can combine
the values in any order. So instead of calculating all the bits
individually, let us try to rearrange things.
For the column parity this is easy. We can just xor the bytes and in the
end filter out the relevant bits. This is pretty nice as it will bring
all cp calculation out of the for loop.</p>
<p>Similarly we can first xor the bytes for the various rows.
This leads to:</p>
</div>
<div class="section" id="attempt-1">
<h2>Attempt 1<a class="headerlink" href="#attempt-1" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char parity[256] = {
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0
};

void ecc1(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned char *bp = buf;
    unsigned char cur;
    unsigned char rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned char rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned char par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 256; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp1 ^= cur; else rp0 ^= cur;
        if (i &amp; 0x02) rp3 ^= cur; else rp2 ^= cur;
        if (i &amp; 0x04) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x08) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x10) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x20) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x40) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x80) rp15 ^= cur; else rp14 ^= cur;
    }
    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>Still pretty straightforward. The last three invert statements are there to
give a checksum of 0xff 0xff 0xff for an empty flash. In an empty flash
all data is 0xff, so the checksum then matches.</p>
<p>I also introduced the parity lookup. I expected this to be the fastest
way to calculate the parity, but I will investigate alternatives later
on.</p>
</div>
<div class="section" id="analysis-1">
<h2>Analysis 1<a class="headerlink" href="#analysis-1" title="Permalink to this headline">¶</a></h2>
<p>The code works, but is not terribly efficient. On my system it took
almost 4 times as much time as the linux driver code. But hey, if it was
<em>that</em> easy this would have been done long before.
No pain. no gain.</p>
<p>Fortunately there is plenty of room for improvement.</p>
<p>In step 1 we moved from bit-wise calculation to byte-wise calculation.
However in C we can also use the unsigned long data type and virtually
every modern microprocessor supports 32 bit operations, so why not try
to write our code in such a way that we process data in 32 bit chunks.</p>
<p>Of course this means some modification as the row parity is byte by
byte. A quick analysis:
for the column parity we use the par variable. When extending to 32 bits
we can in the end easily calculate rp0 and rp1 from it.
(because par now consists of 4 bytes, contributing to rp1, rp0, rp1, rp0
respectively, from MSB to LSB)
also rp2 and rp3 can be easily retrieved from par as rp3 covers the
first two MSBs and rp2 covers the last two LSBs.</p>
<p>Note that of course now the loop is executed only 64 times (256/4).
And note that care must taken wrt byte ordering. The way bytes are
ordered in a long is machine dependent, and might affect us.
Anyway, if there is an issue: this code is developed on x86 (to be
precise: a DELL PC with a D920 Intel CPU)</p>
<p>And of course the performance might depend on alignment, but I expect
that the I/O buffers in the nand driver are aligned properly (and
otherwise that should be fixed to get maximum performance).</p>
<p>Let’s give it a try…</p>
</div>
<div class="section" id="attempt-2">
<h2>Attempt 2<a class="headerlink" href="#attempt-2" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern const char parity[256];

void ecc2(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned long *bp = (unsigned long *)buf;
    unsigned long cur;
    unsigned long rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned long rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned long par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 64; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
    }
    /*
       we need to adapt the code generation for the fact that rp vars are now
       long; also the column parity calculation needs to be changed.
       we&#39;ll bring rp4 to 15 back to single byte entities by shifting and
       xoring
    */
    rp4 ^= (rp4 &gt;&gt; 16); rp4 ^= (rp4 &gt;&gt; 8); rp4 &amp;= 0xff;
    rp5 ^= (rp5 &gt;&gt; 16); rp5 ^= (rp5 &gt;&gt; 8); rp5 &amp;= 0xff;
    rp6 ^= (rp6 &gt;&gt; 16); rp6 ^= (rp6 &gt;&gt; 8); rp6 &amp;= 0xff;
    rp7 ^= (rp7 &gt;&gt; 16); rp7 ^= (rp7 &gt;&gt; 8); rp7 &amp;= 0xff;
    rp8 ^= (rp8 &gt;&gt; 16); rp8 ^= (rp8 &gt;&gt; 8); rp8 &amp;= 0xff;
    rp9 ^= (rp9 &gt;&gt; 16); rp9 ^= (rp9 &gt;&gt; 8); rp9 &amp;= 0xff;
    rp10 ^= (rp10 &gt;&gt; 16); rp10 ^= (rp10 &gt;&gt; 8); rp10 &amp;= 0xff;
    rp11 ^= (rp11 &gt;&gt; 16); rp11 ^= (rp11 &gt;&gt; 8); rp11 &amp;= 0xff;
    rp12 ^= (rp12 &gt;&gt; 16); rp12 ^= (rp12 &gt;&gt; 8); rp12 &amp;= 0xff;
    rp13 ^= (rp13 &gt;&gt; 16); rp13 ^= (rp13 &gt;&gt; 8); rp13 &amp;= 0xff;
    rp14 ^= (rp14 &gt;&gt; 16); rp14 ^= (rp14 &gt;&gt; 8); rp14 &amp;= 0xff;
    rp15 ^= (rp15 &gt;&gt; 16); rp15 ^= (rp15 &gt;&gt; 8); rp15 &amp;= 0xff;
    rp3 = (par &gt;&gt; 16); rp3 ^= (rp3 &gt;&gt; 8); rp3 &amp;= 0xff;
    rp2 = par &amp; 0xffff; rp2 ^= (rp2 &gt;&gt; 8); rp2 &amp;= 0xff;
    par ^= (par &gt;&gt; 16);
    rp1 = (par &gt;&gt; 8); rp1 &amp;= 0xff;
    rp0 = (par &amp; 0xff);
    par ^= (par &gt;&gt; 8); par &amp;= 0xff;

    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>The parity array is not shown any more. Note also that for these
examples I kinda deviated from my regular programming style by allowing
multiple statements on a line, not using { } in then and else blocks
with only a single statement and by using operators like ^=</p>
</div>
<div class="section" id="analysis-2">
<h2>Analysis 2<a class="headerlink" href="#analysis-2" title="Permalink to this headline">¶</a></h2>
<p>The code (of course) works, and hurray: we are a little bit faster than
the linux driver code (about 15%). But wait, don’t cheer too quickly.
There is more to be gained.
If we look at e.g. rp14 and rp15 we see that we either xor our data with
rp14 or with rp15. However we also have par which goes over all data.
This means there is no need to calculate rp14 as it can be calculated from
rp15 through rp14 = par ^ rp15, because par = rp14 ^ rp15;
(or if desired we can avoid calculating rp15 and calculate it from
rp14).  That is why some places refer to inverse parity.
Of course the same thing holds for rp4/5, rp6/7, rp8/9, rp10/11 and rp12/13.
Effectively this means we can eliminate the else clause from the if
statements. Also we can optimise the calculation in the end a little bit
by going from long to byte first. Actually we can even avoid the table
lookups</p>
</div>
<div class="section" id="attempt-3">
<h2>Attempt 3<a class="headerlink" href="#attempt-3" title="Permalink to this headline">¶</a></h2>
<p>Odd replaced:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
</pre></div>
</div>
<p>with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (i &amp; 0x01) rp5 ^= cur;
if (i &amp; 0x02) rp7 ^= cur;
if (i &amp; 0x04) rp9 ^= cur;
if (i &amp; 0x08) rp11 ^= cur;
if (i &amp; 0x10) rp13 ^= cur;
if (i &amp; 0x20) rp15 ^= cur;
</pre></div>
</div>
<p>and outside the loop added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4  = par ^ rp5;
rp6  = par ^ rp7;
rp8  = par ^ rp9;
rp10  = par ^ rp11;
rp12  = par ^ rp13;
rp14  = par ^ rp15;
</pre></div>
</div>
<p>And after that the code takes about 30% more time, although the number of
statements is reduced. This is also reflected in the assembly code.</p>
</div>
<div class="section" id="analysis-3">
<h2>Analysis 3<a class="headerlink" href="#analysis-3" title="Permalink to this headline">¶</a></h2>
<p>Very weird. Guess it has to do with caching or instruction parallellism
or so. I also tried on an eeePC (Celeron, clocked at 900 Mhz). Interesting
observation was that this one is only 30% slower (according to time)
executing the code as my 3Ghz D920 processor.</p>
<p>Well, it was expected not to be easy so maybe instead move to a
different track: let’s move back to the code from attempt2 and do some
loop unrolling. This will eliminate a few if statements. I’ll try
different amounts of unrolling to see what works best.</p>
</div>
<div class="section" id="attempt-4">
<h2>Attempt 4<a class="headerlink" href="#attempt-4" title="Permalink to this headline">¶</a></h2>
<p>Unrolled the loop 1, 2, 3 and 4 times.
For 4 the code starts with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++;
    par ^= cur;
    rp4 ^= cur;
    rp6 ^= cur;
    rp8 ^= cur;
    rp10 ^= cur;
    if (i &amp; 0x1) rp13 ^= cur; else rp12 ^= cur;
    if (i &amp; 0x2) rp15 ^= cur; else rp14 ^= cur;
    cur = *bp++;
    par ^= cur;
    rp5 ^= cur;
    rp6 ^= cur;
    ...
</pre></div>
</div>
</div>
<div class="section" id="analysis-4">
<h2>Analysis 4<a class="headerlink" href="#analysis-4" title="Permalink to this headline">¶</a></h2>
<p>Unrolling once gains about 15%</p>
<p>Unrolling twice keeps the gain at about 15%</p>
<p>Unrolling three times gives a gain of 30% compared to attempt 2.</p>
<p>Unrolling four times gives a marginal improvement compared to unrolling
three times.</p>
<p>I decided to proceed with a four time unrolled loop anyway. It was my gut
feeling that in the next steps I would obtain additional gain from it.</p>
<p>The next step was triggered by the fact that par contains the xor of all
bytes and rp4 and rp5 each contain the xor of half of the bytes.
So in effect par = rp4 ^ rp5. But as xor is commutative we can also say
that rp5 = par ^ rp4. So no need to keep both rp4 and rp5 around. We can
eliminate rp5 (or rp4, but I already foresaw another optimisation).
The same holds for rp6/7, rp8/9, rp10/11 rp12/13 and rp14/15.</p>
</div>
<div class="section" id="attempt-5">
<h2>Attempt 5<a class="headerlink" href="#attempt-5" title="Permalink to this headline">¶</a></h2>
<p>Effectively so all odd digit rp assignments in the loop were removed.
This included the else clause of the if statements.
Of course after the loop we need to correct things by adding code like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp5 = par ^ rp4;
</pre></div>
</div>
<p>Also the initial assignments (rp5 = 0; etc) could be removed.
Along the line I also removed the initialisation of rp0/1/2/3.</p>
</div>
<div class="section" id="analysis-5">
<h2>Analysis 5<a class="headerlink" href="#analysis-5" title="Permalink to this headline">¶</a></h2>
<p>Measurements showed this was a good move. The run-time roughly halved
compared with attempt 4 with 4 times unrolled, and we only require 1/3rd
of the processor time compared to the current code in the linux kernel.</p>
<p>However, still I thought there was more. I didn’t like all the if
statements. Why not keep a running parity and only keep the last if
statement. Time for yet another version!</p>
</div>
<div class="section" id="attempt-6">
<h2>Attempt 6<a class="headerlink" href="#attempt-6" title="Permalink to this headline">¶</a></h2>
<p>THe code within the for loop was changed to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= cur;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
</pre></div>
</div>
<p>As you can see tmppar is used to accumulate the parity within a for
iteration. In the last 3 statements is added to par and, if needed,
to rp12 and rp14.</p>
<p>While making the changes I also found that I could exploit that tmppar
contains the running parity for this iteration. So instead of having:
rp4 ^= cur; rp6 ^= cur;
I removed the rp6 ^= cur; statement and did rp6 ^= tmppar; on next
statement. A similar change was done for rp8 and rp10</p>
</div>
<div class="section" id="analysis-6">
<h2>Analysis 6<a class="headerlink" href="#analysis-6" title="Permalink to this headline">¶</a></h2>
<p>Measuring this code again showed big gain. When executing the original
linux code 1 million times, this took about 1 second on my system.
(using time to measure the performance). After this iteration I was back
to 0.075 sec. Actually I had to decide to start measuring over 10
million iterations in order not to lose too much accuracy. This one
definitely seemed to be the jackpot!</p>
<p>There is a little bit more room for improvement though. There are three
places with statements:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4 ^= cur; rp6 ^= cur;
</pre></div>
</div>
<p>It seems more efficient to also maintain a variable rp4_6 in the while
loop; This eliminates 3 statements per loop. Of course after the loop we
need to correct by adding:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4 ^= rp4_6;
rp6 ^= rp4_6
</pre></div>
</div>
<p>Furthermore there are 4 sequential assignments to rp8. This can be
encoded slightly more efficiently by saving tmppar before those 4 lines
and later do rp8 = rp8 ^ tmppar ^ notrp8;
(where notrp8 is the value of rp8 before those 4 lines).
Again a use of the commutative property of xor.
Time for a new test!</p>
</div>
<div class="section" id="attempt-7">
<h2>Attempt 7<a class="headerlink" href="#attempt-7" title="Permalink to this headline">¶</a></h2>
<p>The new code now looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    notrp8 = tmppar;
    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;
    rp8 = rp8 ^ tmppar ^ notrp8;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
rp4 ^= rp4_6;
rp6 ^= rp4_6;
</pre></div>
</div>
<p>Not a big change, but every penny counts :-)</p>
</div>
<div class="section" id="analysis-7">
<h2>Analysis 7<a class="headerlink" href="#analysis-7" title="Permalink to this headline">¶</a></h2>
<p>Actually this made things worse. Not very much, but I don’t want to move
into the wrong direction. Maybe something to investigate later. Could
have to do with caching again.</p>
<p>Guess that is what there is to win within the loop. Maybe unrolling one
more time will help. I’ll keep the optimisations from 7 for now.</p>
</div>
<div class="section" id="attempt-8">
<h2>Attempt 8<a class="headerlink" href="#attempt-8" title="Permalink to this headline">¶</a></h2>
<p>Unrolled the loop one more time.</p>
</div>
<div class="section" id="analysis-8">
<h2>Analysis 8<a class="headerlink" href="#analysis-8" title="Permalink to this headline">¶</a></h2>
<p>This makes things worse. Let’s stick with attempt 6 and continue from there.
Although it seems that the code within the loop cannot be optimised
further there is still room to optimize the generation of the ecc codes.
We can simply calculate the total parity. If this is 0 then rp4 = rp5
etc. If the parity is 1, then rp4 = !rp5;</p>
<p>But if rp4 = rp5 we do not need rp5 etc. We can just write the even bits
in the result byte and then do something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>code[0] |= (code[0] &lt;&lt; 1);
</pre></div>
</div>
<p>Lets test this.</p>
</div>
<div class="section" id="attempt-9">
<h2>Attempt 9<a class="headerlink" href="#attempt-9" title="Permalink to this headline">¶</a></h2>
<p>Changed the code but again this slightly degrades performance. Tried all
kind of other things, like having dedicated parity arrays to avoid the
shift after parity[rp7] &lt;&lt; 7; No gain.
Change the lookup using the parity array by using shift operators (e.g.
replace parity[rp7] &lt;&lt; 7 with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp7 ^= (rp7 &lt;&lt; 4);
rp7 ^= (rp7 &lt;&lt; 2);
rp7 ^= (rp7 &lt;&lt; 1);
rp7 &amp;= 0x80;
</pre></div>
</div>
<p>No gain.</p>
<p>The only marginal change was inverting the parity bits, so we can remove
the last three invert statements.</p>
<p>Ah well, pity this does not deliver more. Then again 10 million
iterations using the linux driver code takes between 13 and 13.5
seconds, whereas my code now takes about 0.73 seconds for those 10
million iterations. So basically I’ve improved the performance by a
factor 18 on my system. Not that bad. Of course on different hardware
you will get different results. No warranties!</p>
<p>But of course there is no such thing as a free lunch. The codesize almost
tripled (from 562 bytes to 1434 bytes). Then again, it is not that much.</p>
</div>
<div class="section" id="correcting-errors">
<h2>Correcting errors<a class="headerlink" href="#correcting-errors" title="Permalink to this headline">¶</a></h2>
<p>For correcting errors I again used the ST application note as a starter,
but I also peeked at the existing code.</p>
<p>The algorithm itself is pretty straightforward. Just xor the given and
the calculated ecc. If all bytes are 0 there is no problem. If 11 bits
are 1 we have one correctable bit error. If there is 1 bit 1, we have an
error in the given ecc code.</p>
<p>It proved to be fastest to do some table lookups. Performance gain
introduced by this is about a factor 2 on my system when a repair had to
be done, and 1% or so if no repair had to be done.</p>
<p>Code size increased from 330 bytes to 686 bytes for this function.
(gcc 4.2, -O3)</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>The gain when calculating the ecc is tremendous. Om my development hardware
a speedup of a factor of 18 for ecc calculation was achieved. On a test on an
embedded system with a MIPS core a factor 7 was obtained.</p>
<p>On a test with a Linksys NSLU2 (ARMv5TE processor) the speedup was a factor
5 (big endian mode, gcc 4.1.2, -O3)</p>
<p>For correction not much gain could be obtained (as bitflips are rare). Then
again there are also much less cycles spent there.</p>
<p>It seems there is not much more gain possible in this, at least when
programmed in C. Of course it might be possible to squeeze something more
out of it with an assembler program, but due to pipeline behaviour etc
this is very tricky (at least for intel hw).</p>
<p>Author: Frans Meulenbroeks</p>
<p>Copyright (C) 2008 Koninklijke Philips Electronics NV.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="spi-nor.html" class="btn btn-neutral float-right" title="SPI NOR framework" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="intel-spi.html" class="btn btn-neutral float-left" title="Upgrading BIOS using intel-spi" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>