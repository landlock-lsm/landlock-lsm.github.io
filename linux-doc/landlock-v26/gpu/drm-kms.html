

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Mode Setting (KMS) &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Mode Setting Helper Functions" href="drm-kms-helpers.html" />
    <link rel="prev" title="DRM Memory Management" href="drm-mm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel Mode Setting (KMS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-core-structures-and-functions">KMS Core Structures and Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeset-base-object-abstraction">Modeset Base Object Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-mode-setting">Atomic Mode Setting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handling-driver-private-state">Handling Driver Private State</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-mode-setting-function-reference">Atomic Mode Setting Function Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-mode-setting-ioctl-and-uapi-functions">Atomic Mode Setting IOCTL and UAPI Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtc-functions-reference">CRTC Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frame-buffer-functions-reference">Frame Buffer Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-format-handling">DRM Format Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#format-modifiers">Format Modifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#format-functions-reference">Format Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dumb-buffer-objects">Dumb Buffer Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-abstraction">Plane Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plane-functions-reference">Plane Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#display-modes-function-reference">Display Modes Function Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connector-abstraction">Connector Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connector-functions-reference">Connector Functions Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writeback-connectors">Writeback Connectors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#encoder-functions-reference">Encoder Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-locking">KMS Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-properties">KMS Properties</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#property-types-and-blob-property-support">Property Types and Blob Property Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-connector-properties">Standard Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hdmi-specific-connector-properties">HDMI Specific Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-crtc-properties">Standard CRTC Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#color-management-properties">Color Management Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tile-group-property">Tile Group Property</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-fencing-properties">Explicit Fencing Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variable-refresh-properties">Variable Refresh Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existing-kms-properties">Existing KMS Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-blanking">Vertical Blanking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vertical-blanking-and-interrupt-handling-functions-reference">Vertical Blanking and Interrupt Handling Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-blank-work">Vertical Blank Work</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vertical-blank-work-functions-reference">Vertical Blank Work Functions Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight.html">Backlight support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>Kernel Mode Setting (KMS)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-kms.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-mode-setting-kms">
<h1>Kernel Mode Setting (KMS)<a class="headerlink" href="#kernel-mode-setting-kms" title="Permalink to this headline">¶</a></h1>
<p>Drivers must initialize the mode setting core by calling
<a class="reference internal" href="#c.drmm_mode_config_init" title="drmm_mode_config_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_mode_config_init()</span></code></a> on the DRM device. The function
initializes the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span></code></a>
mode_config field and never fails. Once done, mode configuration must
be setup by initializing the following fields.</p>
<ul class="simple">
<li><p>int min_width, min_height; int max_width, max_height;
Minimum and maximum width and height of the frame buffers in pixel
units.</p></li>
<li><p><a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_config_funcs</span></code></a> *funcs;
Mode setting functions.</p></li>
</ul>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id1">
<img alt="KMS Display Pipeline" src="../_images/DOT-dade12aa9127c64406e41cdf8d7f80694c134db2.svg" /><p class="caption"><span class="caption-text">KMS Display Pipeline Overview</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>The basic object structure KMS presents to userspace is fairly simple.
Framebuffers (represented by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>,
see <a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a>) feed into planes. Planes are represented by
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a>, see <a class="reference internal" href="#plane-abstraction">Plane Abstraction</a> for more
details. One or more (or even no) planes feed their pixel data into a CRTC
(represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>, see <a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a>)
for blending. The precise blending step is explained in more detail in <a class="reference internal" href="#plane-composition-properties">Plane
Composition Properties</a> and related chapters.</p>
<p>For the output routing the first step is encoders (represented by
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a>, see <a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a>). Those
are really just internal artifacts of the helper libraries used to implement KMS
drivers. Besides that they make it unecessarily more complicated for userspace
to figure out which connections between a CRTC and a connector are possible, and
what kind of cloning is supported, they serve no purpose in the userspace API.
Unfortunately encoders have been exposed to userspace, hence can’t remove them
at this point.  Futhermore the exposed restrictions are often wrongly set by
drivers, and in many cases not powerful enough to express the real restrictions.
A CRTC can be connected to multiple encoders, and for an active CRTC there must
be at least one encoder.</p>
<p>The final, and real, endpoint in the display chain is the connector (represented
by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>, see <a class="reference internal" href="#connector-abstraction">Connector
Abstraction</a>). Connectors can have different possible encoders, but the kernel
driver selects which encoder to use for each connector. The use case is DVI,
which could switch between an analog and a digital encoder. Encoders can also
drive multiple different connectors. There is exactly one active connector for
every active encoder.</p>
<p>Internally the output pipeline is a bit more complex and matches today’s
hardware more closely:</p>
<div class="figure align-default" id="id2">
<img alt="KMS Output Pipeline" src="../_images/DOT-6445c75fc4859992454fd377127d4d309e82f09a.svg" /><p class="caption"><span class="caption-text">KMS Output Pipeline</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>Internally two additional helper objects come into play. First, to be able to
share code for encoders (sometimes on the same SoC, sometimes off-chip) one or
more <a class="reference internal" href="drm-kms-helpers.html#drm-bridges"><span class="std std-ref">Bridges</span></a> (represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>) can be linked to an encoder. This link is static and cannot be
changed, which means the cross-bar (if there is any) needs to be mapped between
the CRTC and any encoders. Often for drivers with bridges there’s no code left
at the encoder level. Atomic drivers can leave out all the encoder callbacks to
essentially only leave a dummy routing object behind, which is needed for
backwards compatibility since encoders are exposed to userspace.</p>
<p>The second object is for panels, represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span></code></a>, see <a class="reference internal" href="drm-kms-helpers.html#drm-panel-helper"><span class="std std-ref">Panel Helper Reference</span></a>. Panels do not have a fixed binding
point, but are generally linked to the driver private structure that embeds
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>.</p>
<p>Note that currently the bridge chaining and interactions with connectors and
panels are still in-flux and not really fully sorted out yet.</p>
</div>
<div class="section" id="kms-core-structures-and-functions">
<h2>KMS Core Structures and Functions<a class="headerlink" href="#kms-core-structures-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.drm_mode_config_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_mode_config_funcs</code><a class="headerlink" href="#c.drm_mode_config_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>basic driver provided mode setting functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_config_funcs {
  struct drm_framebuffer *(*fb_create)(struct drm_device *dev,struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd);
  const struct drm_format_info *(*get_format_info)(const struct drm_mode_fb_cmd2 *mode_cmd);
  void (*output_poll_changed)(struct drm_device *dev);
  enum drm_mode_status (*mode_valid)(struct drm_device *dev, const struct drm_display_mode *mode);
  int (*atomic_check)(struct drm_device *dev, struct drm_atomic_state *state);
  int (*atomic_commit)(struct drm_device *dev,struct drm_atomic_state *state, bool nonblock);
  struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
  void (*atomic_state_clear)(struct drm_atomic_state *state);
  void (*atomic_state_free)(struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">fb_create</span></code></dt><dd><p>Create a new framebuffer object. The core does basic checks on the
requested metadata, but most of that is left to the driver. See
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> for details.</p>
<p>To validate the pixel format and modifier drivers can use
<a class="reference internal" href="#c.drm_any_plane_has_format" title="drm_any_plane_has_format"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_any_plane_has_format()</span></code></a> to make sure at least one plane supports
the requested values. Note that the driver must first determine the
actual modifier used if the request doesn’t have it specified,
ie. when (<strong>mode_cmd-&gt;flags</strong> &amp; DRM_MODE_FB_MODIFIERS) == 0.</p>
<p>If the parameters are deemed valid and the backing storage objects in
the underlying memory manager all exist, then the driver allocates
a new <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> structure, subclassed to contain
driver-specific information (like the internal native buffer object
references). It also needs to fill out all relevant metadata, which
should be done by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a>.</p>
<p>The initialization is finalized by calling <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_init()</span></code></a>,
which registers the framebuffer and makes it accessible to other
threads.</p>
<p>RETURNS:</p>
<p>A new framebuffer with an initial reference count of 1 or a negative
error code encoded with ERR_PTR().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_format_info</span></code></dt><dd><p>Allows a driver to return custom format information for special
fb layouts (eg. ones with auxiliary compression control planes).</p>
<p>RETURNS:</p>
<p>The format information specific to the given fb metadata, or
NULL if none is found.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">output_poll_changed</span></code></dt><dd><p>Callback used by helpers to inform the driver of output configuration
changes.</p>
<p>Drivers implementing fbdev emulation with the helpers can call
drm_fb_helper_hotplug_changed from this hook to inform the fbdev
helper of output changes.</p>
<p>FIXME:</p>
<p>Except that there’s no vtable for device-level helper callbacks
there’s no reason this is a core function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>Device specific validation of display modes. Can be used to reject
modes that can never be supported. Only device wide constraints can
be checked here. crtc/encoder/bridge/connector specific constraints
should be checked in the .mode_valid() hook for each specific object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This is the only hook to validate an atomic modeset update. This
function must reject any modeset and state changes which the hardware
or driver doesn’t support. This includes but is of course not limited
to:</p>
<blockquote>
<div><ul class="simple">
<li><p>Checking that the modes, framebuffers, scaling and placement
requirements and so on are within the limits of the hardware.</p></li>
<li><p>Checking that any hidden shared resources are not oversubscribed.
This can be shared PLLs, shared lanes, overall memory bandwidth,
display fifo space (where shared between planes or maybe even
CRTCs).</p></li>
<li><p>Checking that virtualized resources exported to userspace are not
oversubscribed. For various reasons it can make sense to expose
more planes, crtcs or encoders than which are physically there. One
example is dual-pipe operations (which generally should be hidden
from userspace if when lockstepped in hardware, exposed otherwise),
where a plane might need 1 hardware plane (if it’s just on one
pipe), 2 hardware planes (when it spans both pipes) or maybe even
shared a hardware plane with a 2nd plane (if there’s a compatible
plane requested on the area handled by the other pipe).</p></li>
<li><p>Check that any transitional state is possible and that if
requested, the update can indeed be done in the vblank period
without temporarily disabling some functions.</p></li>
<li><p>Check any other constraints the driver or hardware might have.</p></li>
<li><p>This callback also needs to correctly fill out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a>
in this update to make sure that <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>
reflects the nature of the possible update and returns true if and
only if the update cannot be applied without tearing within one
vblank on that CRTC. The core uses that information to reject
updates which require a full modeset (i.e. blanking the screen, or
at least pausing updates for a substantial amount of time) if
userspace has disallowed that in its request.</p></li>
<li><p>The driver also does not need to repeat basic input validation
like done for the corresponding legacy entry points. The core does
that before calling this hook.</p></li>
</ul>
</div></blockquote>
<p>See the documentation of <strong>atomic_commit</strong> for an exhaustive list of
error conditions which don’t have to be checked at the in this
callback.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote>
<div><ul class="simple">
<li><p>-EINVAL, if any of the above constraints are violated.</p></li>
<li><p>-EDEADLK, when returned from an attempt to acquire an additional
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> through <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a>.</p></li>
<li><p>-ENOMEM, if allocating additional state sub-structures failed due
to lack of memory.</p></li>
<li><p>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point all errors are
treated equally.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit</span></code></dt><dd><p>This is the only hook to commit an atomic modeset update. The core
guarantees that <strong>atomic_check</strong> has been called successfully before
calling this function, and that nothing has been changed in the
interim.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>Nonblocking commits (as indicated with the nonblock parameter) must
do any preparatory work which might result in an unsuccessful commit
in the context of this callback. The only exceptions are hardware
errors resulting in -EIO. But even in that case the driver must
ensure that the display pipe is at least running, to avoid
compositors crashing when pageflips don’t work. Anything else,
specifically committing the update to the hardware, should be done
without blocking the caller. For updates which do not require a
modeset this must be guaranteed.</p>
<p>The driver must wait for any pending rendering to the new
framebuffers to complete before executing the flip. It should also
wait for any pending rendering from other drivers if the underlying
buffer is a shared dma-buf. Nonblocking commits must not wait for
rendering in the context of this callback.</p>
<p>An application can request to be notified when the atomic commit has
completed. These events are per-CRTC and can be distinguished by the
CRTC index supplied in <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_event</span></code> to userspace.</p>
<p>The drm core will supply a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in each CRTC’s
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a>. See the documentation for
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a> for more details about the precise semantics of
this event.</p>
<p>NOTE:</p>
<p>Drivers are not allowed to shut down any display pipe successfully
enabled through an atomic commit on their own. Doing so can result in
compositors crashing if a page flip is suddenly rejected because the
pipe is off.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote>
<div><ul class="simple">
<li><p>-EBUSY, if a nonblocking updated is requested and there is
an earlier updated pending. Drivers are allowed to support a queue
of outstanding updates, but currently no driver supports that.
Note that drivers must wait for preceding updates to complete if a
synchronous update is requested, they are not allowed to fail the
commit in that case.</p></li>
<li><p>-ENOMEM, if the driver failed to allocate memory. Specifically
this can happen when trying to pin framebuffers, which must only
be done when committing the state.</p></li>
<li><p>-ENOSPC, as a refinement of the more generic -ENOMEM to indicate
that the driver has run out of vram, iommu space or similar GPU
address space needed for framebuffer.</p></li>
<li><p>-EIO, if the hardware completely died.</p></li>
<li><p>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point of view all errors are
treated equally.</p></li>
</ul>
</div></blockquote>
<p>This list is exhaustive. Specifically this hook is not allowed to
return -EINVAL (any invalid requests should be caught in
<strong>atomic_check</strong>) or -EDEADLK (this function must not acquire
additional modeset locks).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_state_alloc</span></code></dt><dd><p>This optional hook can be used by drivers that want to subclass struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> to be able to track their own driver-private global
state easily. If this hook is implemented, drivers must also
implement <strong>atomic_state_clear</strong> and <strong>atomic_state_free</strong>.</p>
<p>Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a>.</p>
<p>RETURNS:</p>
<p>A new <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> on success or NULL on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_state_clear</span></code></dt><dd><p>This hook must clear any driver private state duplicated into the
passed-in <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>. This hook is called when the caller
encountered a <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> deadlock and needs to drop all
already acquired locks as part of the deadlock avoidance dance
implemented in <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>Any duplicated state must be invalidated since a concurrent atomic
update might change it, and the drm atomic interfaces always apply
updates as relative changes to the current state.</p>
<p>Drivers that implement this must call <a class="reference internal" href="#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_default_clear()</span></code></a>
to clear common state.</p>
<p>Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_state_free</span></code></dt><dd><p>This hook needs driver private resources and the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
itself. Note that the core first calls <a class="reference internal" href="#c.drm_atomic_state_clear" title="drm_atomic_state_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_clear()</span></code></a> to
avoid code duplicate between the clear and free hooks.</p>
<p>Drivers that implement this must call
<a class="reference internal" href="#c.drm_atomic_state_default_release" title="drm_atomic_state_default_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_default_release()</span></code></a> to release common resources.</p>
<p>Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
involve drivers.</p>
<dl class="c struct">
<dt id="c.drm_mode_config">
<em class="property">struct </em><code class="sig-name descname">drm_mode_config</code><a class="headerlink" href="#c.drm_mode_config" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mode configuration control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_config {
  struct mutex mutex;
  struct drm_modeset_lock connection_mutex;
  struct drm_modeset_acquire_ctx *acquire_ctx;
  struct mutex idr_mutex;
  struct idr object_idr;
  struct idr tile_idr;
  struct mutex fb_lock;
  int num_fb;
  struct list_head fb_list;
  spinlock_t connector_list_lock;
  int num_connector;
  struct ida connector_ida;
  struct list_head connector_list;
  struct llist_head connector_free_list;
  struct work_struct connector_free_work;
  int num_encoder;
  struct list_head encoder_list;
  int num_total_plane;
  struct list_head plane_list;
  int num_crtc;
  struct list_head crtc_list;
  struct list_head property_list;
  struct list_head privobj_list;
  int min_width, min_height;
  int max_width, max_height;
  const struct drm_mode_config_funcs *funcs;
  resource_size_t fb_base;
  bool poll_enabled;
  bool poll_running;
  bool delayed_event;
  struct delayed_work output_poll_work;
  struct mutex blob_lock;
  struct list_head property_blob_list;
  struct drm_property *edid_property;
  struct drm_property *dpms_property;
  struct drm_property *path_property;
  struct drm_property *tile_property;
  struct drm_property *link_status_property;
  struct drm_property *plane_type_property;
  struct drm_property *prop_src_x;
  struct drm_property *prop_src_y;
  struct drm_property *prop_src_w;
  struct drm_property *prop_src_h;
  struct drm_property *prop_crtc_x;
  struct drm_property *prop_crtc_y;
  struct drm_property *prop_crtc_w;
  struct drm_property *prop_crtc_h;
  struct drm_property *prop_fb_id;
  struct drm_property *prop_in_fence_fd;
  struct drm_property *prop_out_fence_ptr;
  struct drm_property *prop_crtc_id;
  struct drm_property *prop_fb_damage_clips;
  struct drm_property *prop_active;
  struct drm_property *prop_mode_id;
  struct drm_property *prop_vrr_enabled;
  struct drm_property *dvi_i_subconnector_property;
  struct drm_property *dvi_i_select_subconnector_property;
  struct drm_property *dp_subconnector_property;
  struct drm_property *tv_subconnector_property;
  struct drm_property *tv_select_subconnector_property;
  struct drm_property *tv_mode_property;
  struct drm_property *tv_left_margin_property;
  struct drm_property *tv_right_margin_property;
  struct drm_property *tv_top_margin_property;
  struct drm_property *tv_bottom_margin_property;
  struct drm_property *tv_brightness_property;
  struct drm_property *tv_contrast_property;
  struct drm_property *tv_flicker_reduction_property;
  struct drm_property *tv_overscan_property;
  struct drm_property *tv_saturation_property;
  struct drm_property *tv_hue_property;
  struct drm_property *scaling_mode_property;
  struct drm_property *aspect_ratio_property;
  struct drm_property *content_type_property;
  struct drm_property *degamma_lut_property;
  struct drm_property *degamma_lut_size_property;
  struct drm_property *ctm_property;
  struct drm_property *gamma_lut_property;
  struct drm_property *gamma_lut_size_property;
  struct drm_property *suggested_x_property;
  struct drm_property *suggested_y_property;
  struct drm_property *non_desktop_property;
  struct drm_property *panel_orientation_property;
  struct drm_property *writeback_fb_id_property;
  struct drm_property *writeback_pixel_formats_property;
  struct drm_property *writeback_out_fence_ptr_property;
  struct drm_property *hdr_output_metadata_property;
  struct drm_property *content_protection_property;
  struct drm_property *hdcp_content_type_property;
  uint32_t preferred_depth, prefer_shadow;
  bool prefer_shadow_fbdev;
  bool fbdev_use_iomem;
  bool quirk_addfb_prefer_xbgr_30bpp;
  bool quirk_addfb_prefer_host_byte_order;
  bool async_page_flip;
  bool allow_fb_modifiers;
  bool normalize_zpos;
  struct drm_property *modifiers_property;
  uint32_t cursor_width, cursor_height;
  struct drm_atomic_state *suspend_state;
  const struct drm_mode_config_helper_funcs *helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>This is the big scary modeset BKL which protects everything that
isn’t protect otherwise. Scope is unclear and fuzzy, try to remove
anything from under its protection and move it into more well-scoped
locks.</p>
<p>The one important thing this protects is the use of <strong>acquire_ctx</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connection_mutex</span></code></dt><dd><p>This protects connector state and the connector to encoder to CRTC
routing chain.</p>
<p>For atomic drivers specifically this protects <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acquire_ctx</span></code></dt><dd><p>Global implicit acquire context used by atomic drivers for legacy
IOCTLs. Deprecated, since implicit locking contexts make it
impossible to use driver-private <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a>. Users of
this must hold <strong>mutex</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idr_mutex</span></code></dt><dd><p>Mutex for KMS ID allocation and management. Protects both <strong>object_idr</strong>
and <strong>tile_idr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object_idr</span></code></dt><dd><p>Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
connector, modes - just makes life easier to have only one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_idr</span></code></dt><dd><p>Use this idr for allocating new IDs for tiled sinks like use in some
high-res DP MST screens.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_lock</span></code></dt><dd><p>Mutex to protect fb the global <strong>fb_list</strong> and <strong>num_fb</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_fb</span></code></dt><dd><p>Number of entries on <strong>fb_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_list</span></code></dt><dd><p>List of all <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_list_lock</span></code></dt><dd><p>Protects <strong>num_connector</strong> and
<strong>connector_list</strong> and <strong>connector_free_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_connector</span></code></dt><dd><p>Number of connectors on this device. Protected by
<strong>connector_list_lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_ida</span></code></dt><dd><p>ID allocator for connector indices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_list</span></code></dt><dd><p>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.head</span></code></a>. Protected
by <strong>connector_list_lock</strong>. Only use <a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_free_list</span></code></dt><dd><p>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.free_head</span></code></a>.
Protected by <strong>connector_list_lock</strong>. Used by
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to savely free connectors using
<strong>connector_free_work</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_free_work</span></code></dt><dd><p>Work to clean up <strong>connector_free_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_encoder</span></code></dt><dd><p>Number of encoders on this device. This is invariant over the
lifetime of a device and hence doesn’t need any locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_list</span></code></dt><dd><p>List of encoder objects linked with <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn’t need any
locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_total_plane</span></code></dt><dd><p>Number of universal (i.e. with primary/curso) planes on this device.
This is invariant over the lifetime of a device and hence doesn’t
need any locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_list</span></code></dt><dd><p>List of plane objects linked with <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn’t need any locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_crtc</span></code></dt><dd><p>Number of CRTCs on this device linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.head</span></code></a>. This is invariant over the lifetime
of a device and hence doesn’t need any locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_list</span></code></dt><dd><p>List of CRTC objects linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn’t need any locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">property_list</span></code></dt><dd><p>List of property type objects linked with <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn’t need any
locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">privobj_list</span></code></dt><dd><p>List of private objects linked with <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn’t need any
locks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_width</span></code></dt><dd><p>minimum fb pixel width on this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_height</span></code></dt><dd><p>minimum fb pixel height on this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_width</span></code></dt><dd><p>maximum fb pixel width on this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_height</span></code></dt><dd><p>maximum fb pixel height on this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>core driver provided mode setting functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_base</span></code></dt><dd><p>base address of the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_enabled</span></code></dt><dd><p>track polling support for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_running</span></code></dt><dd><p>track polling status for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_event</span></code></dt><dd><p>track delayed poll uevent deliver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">output_poll_work</span></code></dt><dd><p>delayed work for polling in process context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blob_lock</span></code></dt><dd><p>Mutex for blob property allocation and management, protects
<strong>property_blob_list</strong> and <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.blobs</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">property_blob_list</span></code></dt><dd><p>List of all the blob property objects linked with
<a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property_blob.head</span></code></a>. Protected by <strong>blob_lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edid_property</span></code></dt><dd><p>Default connector property to hold the EDID of the
currently connected sink, if any.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpms_property</span></code></dt><dd><p>Default connector property to control the
connector’s DPMS state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_property</span></code></dt><dd><p>Default connector property to hold the DP MST path
for the port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_property</span></code></dt><dd><p>Default connector property to store the tile
position of a tiled screen, for sinks which need to be driven with
multiple CRTCs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_status_property</span></code></dt><dd><p>Default connector property for link status
of a connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_type_property</span></code></dt><dd><p>Default plane property to differentiate
CURSOR, PRIMARY and OVERLAY legacy uses of planes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_src_x</span></code></dt><dd><p>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_src_y</span></code></dt><dd><p>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_src_w</span></code></dt><dd><p>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_src_h</span></code></dt><dd><p>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_crtc_x</span></code></dt><dd><p>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> is being shown on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_crtc_y</span></code></dt><dd><p>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> is being shown on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_crtc_w</span></code></dt><dd><p>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> is being shown on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_crtc_h</span></code></dt><dd><p>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> is being shown on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_fb_id</span></code></dt><dd><p>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_in_fence_fd</span></code></dt><dd><p>Sync File fd representing the incoming fences
for a Plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_out_fence_ptr</span></code></dt><dd><p>Sync File fd pointer representing the
outgoing fences for a CRTC. Userspace should provide a pointer to a
value of type s32, and then cast that pointer to u64.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_crtc_id</span></code></dt><dd><p>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_fb_damage_clips</span></code></dt><dd><p>Optional plane property to mark damaged
regions on the plane in framebuffer coordinates of the framebuffer
attached to the plane.</p>
<p>The layout of blob data is simply an array of <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a>. Unlike
plane src coordinates, damage clips are not in 16.16 fixed point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_active</span></code></dt><dd><p>Default atomic CRTC property to control the active
state, which is the simplified implementation for DPMS in atomic
drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_mode_id</span></code></dt><dd><p>Default atomic CRTC property to set the mode for a
CRTC. A 0 mode implies that the CRTC is entirely disabled - all
connectors must be of and active must be set to disabled, too.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_vrr_enabled</span></code></dt><dd><p>Default atomic CRTC property to indicate
whether variable refresh rate should be enabled on the CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dvi_i_subconnector_property</span></code></dt><dd><p>Optional DVI-I property to
differentiate between analog or digital mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dvi_i_select_subconnector_property</span></code></dt><dd><p>Optional DVI-I property to
select between analog or digital mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dp_subconnector_property</span></code></dt><dd><p>Optional DP property to differentiate
between different DP downstream port types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_subconnector_property</span></code></dt><dd><p>Optional TV property to differentiate
between different TV connector types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_select_subconnector_property</span></code></dt><dd><p>Optional TV property to select
between different TV connector types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_mode_property</span></code></dt><dd><p>Optional TV property to select
the output TV mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_left_margin_property</span></code></dt><dd><p>Optional TV property to set the left
margin (expressed in pixels).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_right_margin_property</span></code></dt><dd><p>Optional TV property to set the right
margin (expressed in pixels).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_top_margin_property</span></code></dt><dd><p>Optional TV property to set the right
margin (expressed in pixels).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_bottom_margin_property</span></code></dt><dd><p>Optional TV property to set the right
margin (expressed in pixels).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_brightness_property</span></code></dt><dd><p>Optional TV property to set the
brightness.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_contrast_property</span></code></dt><dd><p>Optional TV property to set the
contrast.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_flicker_reduction_property</span></code></dt><dd><p>Optional TV property to control the
flicker reduction mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_overscan_property</span></code></dt><dd><p>Optional TV property to control the overscan
setting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_saturation_property</span></code></dt><dd><p>Optional TV property to set the
saturation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_hue_property</span></code></dt><dd><p>Optional TV property to set the hue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_mode_property</span></code></dt><dd><p>Optional connector property to control the
upscaling, mostly used for built-in panels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aspect_ratio_property</span></code></dt><dd><p>Optional connector property to control the
HDMI infoframe aspect ratio setting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">content_type_property</span></code></dt><dd><p>Optional connector property to control the
HDMI infoframe content type setting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">degamma_lut_property</span></code></dt><dd><p>Optional CRTC property to set the LUT used to
convert the framebuffer’s colors to linear gamma.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">degamma_lut_size_property</span></code></dt><dd><p>Optional CRTC property for the size of
the degamma LUT as supported by the driver (read-only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctm_property</span></code></dt><dd><p>Optional CRTC property to set the
matrix used to convert colors after the lookup in the
degamma LUT.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_lut_property</span></code></dt><dd><p>Optional CRTC property to set the LUT used to
convert the colors, after the CTM matrix, to the gamma space of the
connected screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_lut_size_property</span></code></dt><dd><p>Optional CRTC property for the size of the
gamma LUT as supported by the driver (read-only).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suggested_x_property</span></code></dt><dd><p>Optional connector property with a hint for
the position of the output on the host’s screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suggested_y_property</span></code></dt><dd><p>Optional connector property with a hint for
the position of the output on the host’s screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_desktop_property</span></code></dt><dd><p>Optional connector property with a hint
that device isn’t a standard display, and the console/desktop,
should not be displayed on it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">panel_orientation_property</span></code></dt><dd><p>Optional connector property indicating
how the lcd-panel is mounted inside the casing (e.g. normal or
upside-down).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_fb_id_property</span></code></dt><dd><p>Property for writeback connectors, storing
the ID of the output framebuffer.
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_connector_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_pixel_formats_property</span></code></dt><dd><p>Property for writeback connectors,
storing an array of the supported pixel formats for the writeback
engine (read-only).
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_connector_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_out_fence_ptr_property</span></code></dt><dd><p>Property for writeback connectors,
fd pointer representing the outgoing fences for a writeback
connector. Userspace should provide a pointer to a value of type s32,
and then cast that pointer to u64.
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_connector_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdr_output_metadata_property</span></code></dt><dd><p>Connector property containing hdr
metatada. This will be provided by userspace compositors based
on HDR content</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">content_protection_property</span></code></dt><dd><p>DRM ENUM property for content
protection. See <a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdcp_content_type_property</span></code></dt><dd><p>DRM ENUM property for type of
Protected Content.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preferred_depth</span></code></dt><dd><p>preferred RBG pixel depth, used by fb helpers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefer_shadow</span></code></dt><dd><p>hint to userspace to prefer shadow-fb rendering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefer_shadow_fbdev</span></code></dt><dd><p>Hint to framebuffer emulation to prefer shadow-fb rendering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fbdev_use_iomem</span></code></dt><dd><p>Set to true if framebuffer reside in iomem.
When set to true memcpy_toio() is used when copying the framebuffer in
drm_fb_helper.drm_fb_helper_dirty_blit_real().</p>
<p>FIXME: This should be replaced with a per-mapping is_iomem
flag (like ttm does), and then used everywhere in fbdev code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_addfb_prefer_xbgr_30bpp</span></code></dt><dd><p>Special hack for legacy ADDFB to keep nouveau userspace happy. Should
only ever be set by the nouveau kernel driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_addfb_prefer_host_byte_order</span></code></dt><dd><p>When set to true drm_mode_addfb() will pick host byte order
pixel_format when calling drm_mode_addfb2().  This is how
drm_mode_addfb() should have worked from day one.  It
didn’t though, so we ended up with quirks in both kernel
and userspace drivers to deal with the broken behavior.
Simply fixing drm_mode_addfb() unconditionally would break
these drivers, so add a quirk bit here to allow drivers
opt-in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">async_page_flip</span></code></dt><dd><p>Does this device support async flips on the primary
plane?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allow_fb_modifiers</span></code></dt><dd><p>Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">normalize_zpos</span></code></dt><dd><p>If true the drm core will call <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> as part of
atomic mode checking from <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modifiers_property</span></code></dt><dd><p>Plane property to list support modifier/format
combination.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_width</span></code></dt><dd><p>hint to userspace for max cursor width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_height</span></code></dt><dd><p>hint to userspace for max cursor height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend_state</span></code></dt><dd><p>Atomic state when suspended.
Set by <a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_suspend()</span></code></a> and cleared by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_resume" title="drm_mode_config_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_resume()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">helper_private</span></code></dt><dd><p>mid-layer private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core mode resource tracking structure.  All CRTC, encoders, and connectors
enumerated by the driver are added here, as are global properties.  Some
global restrictions are also here, e.g. dimension restrictions.</p>
<dl class="c function">
<dt id="c.drm_mode_config_init">
int <code class="sig-name descname">drm_mode_config_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM mode_configuration structure initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the unmanaged version of <a class="reference internal" href="#c.drmm_mode_config_init" title="drmm_mode_config_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_mode_config_init()</span></code></a> for drivers which
still explicitly call <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>FIXME: This function is deprecated and drivers should be converted over to
<a class="reference internal" href="#c.drmm_mode_config_init" title="drmm_mode_config_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_mode_config_init()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_mode_config_reset">
void <code class="sig-name descname">drm_mode_config_reset</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>call -&gt;reset callbacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions calls all the crtc’s, encoder’s and connector’s -&gt;reset
callback. Drivers can use this in e.g. their driver load or resume code to
reset hardware and software state.</p>
<dl class="c function">
<dt id="c.drmm_mode_config_init">
int <code class="sig-name descname">drmm_mode_config_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drmm_mode_config_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>managed DRM mode_configuration structure initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>dev</strong>’s mode_config structure, used for tracking the graphics
configuration of <strong>dev</strong>.</p>
<p>Since this initializes the modeset locks, no locking is possible. Which is no
problem, since this should happen single threaded at init time. It is the
driver’s problem to ensure this guarantee.</p>
<p>Cleanup is automatically handled through registering drm_mode_config_cleanup
with <a class="reference internal" href="drm-internals.html#c.drmm_add_action" title="drmm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_add_action()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error value on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_config_cleanup">
void <code class="sig-name descname">drm_mode_config_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free up DRM mode_config info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free up all the connectors and CRTCs associated with this DRM device, then
free up the framebuffers and associated buffer objects.</p>
<p>Note that since this /should/ happen single-threaded at driver/device
teardown time, no locking is required. It’s the driver’s job to ensure that
this guarantee actually holds true.</p>
<p>FIXME: With the managed <a class="reference internal" href="#c.drmm_mode_config_init" title="drmm_mode_config_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_mode_config_init()</span></code></a> it is no longer necessary for
drivers to explicitly call this function.</p>
</div>
<div class="section" id="modeset-base-object-abstraction">
<h2>Modeset Base Object Abstraction<a class="headerlink" href="#modeset-base-object-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id3">
<img alt="Mode Objects and Properties" src="../_images/DOT-1eee3f74bb2de20b2b68c4aa6c9c1cabe5078857.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>The base structure for all KMS objects is <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span></code></a>. One of the base services it provides is tracking properties,
which are especially important for the atomic IOCTL (see <a class="reference internal" href="#atomic-mode-setting">Atomic Mode
Setting</a>). The somewhat surprising part here is that properties are not
directly instantiated on each object, but free-standing mode objects themselves,
represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a>, which only specify
the type and value range of a property. Any given property can be attached
multiple times to different objects using <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<dl class="c struct">
<dt id="c.drm_mode_object">
<em class="property">struct </em><code class="sig-name descname">drm_mode_object</code><a class="headerlink" href="#c.drm_mode_object" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>base structure for modeset objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_object {
  uint32_t id;
  uint32_t type;
  struct drm_object_properties *properties;
  struct kref refcount;
  void (*free_cb)(struct kref *kref);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>userspace visible identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the object, one of DRM_MODE_OBJECT_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt><dd><p>properties attached to this object, including values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>reference count for objects which with dynamic lifetime</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_cb</span></code></dt><dd><p>free function callback, only set for objects with dynamic lifetime</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Base structure for modeset objects visible to userspace. Objects can be
looked up using <a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_find()</span></code></a>. Besides basic uapi interface
properties like <strong>id</strong> and <strong>type</strong> it provides two services:</p>
<ul class="simple">
<li><p>It tracks attached properties and their values. This is used by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>,
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>. Properties are attached by calling
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a> before the object is visible to userspace.</p></li>
<li><p>For objects with dynamic lifetimes (as indicated by a non-NULL <strong>free_cb</strong>) it
provides reference counting through <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_get()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_put()</span></code></a>. This is used by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>, <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>
and <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property_blob</span></code></a>. These objects provide specialized reference
counting wrappers.</p></li>
</ul>
<dl class="c struct">
<dt id="c.drm_object_properties">
<em class="property">struct </em><code class="sig-name descname">drm_object_properties</code><a class="headerlink" href="#c.drm_object_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>property tracking for <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_object_properties {
  int count;
  struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
  uint64_t values[DRM_OBJECT_MAX_PROPERTY];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>number of valid properties, must be less than or equal to
DRM_OBJECT_MAX_PROPERTY.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt><dd><p>Array of pointers to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a>.</p>
<p>NOTE: if we ever start dynamically destroying properties (ie.
not at <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> time), then we’d have to do
a better job of detaching property from mode objects to avoid
dangling property pointers:</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">values</span></code></dt><dd><p>Array to store the property values, matching <strong>properties</strong>. Do
not read/write values directly, but use
<a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_property_get_value()</span></code></a> and <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_property_set_value()</span></code></a>.</p>
<p>Note that atomic drivers do not store mutable properties in this
array, but only the decoded values in the corresponding state
structure. The decoding is done using the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.atomic_set_property</span></code></a> hooks for <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. For
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> the hooks are <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a>. And for <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>
the hooks are <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> .</p>
<p>Hence atomic drivers should not use <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_property_set_value()</span></code></a>
and <a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_property_get_value()</span></code></a> on mutable objects, i.e. those
without the DRM_MODE_PROP_IMMUTABLE flag set.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_mode_object_find">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<code class="sig-name descname">drm_mode_object_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em>, uint32_t <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up a drm object with static lifetime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>id of the mode object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt><dd><p>type of the mode object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to look up a modeset object. It will acquire a
reference for reference counted objects. This reference must be dropped again
by callind <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_mode_object_put">
void <code class="sig-name descname">drm_mode_object_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj</span></code></dt><dd><p>DRM mode object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the object’s refcount if it is a refcounted modeset
object. It is a no-op on any other object. This is used to drop references
acquired with <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_get()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_mode_object_get">
void <code class="sig-name descname">drm_mode_object_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj</span></code></dt><dd><p>DRM mode object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the object’s refcount if it is a refcounted modeset
object. It is a no-op on any other object. References should be dropped again
by calling <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_object_attach_property">
void <code class="sig-name descname">drm_object_attach_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint64_t <em>init_val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_attach_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach a property to a modeset object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm modeset object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">init_val</span></code></dt><dd><p>initial value of the property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This attaches the given property to the modeset object with the given initial
value. Currently this function cannot fail since the properties are stored in
a statically sized array.</p>
<p>Note that all properties must be attached before the object itself is
registered and accessible from userspace.</p>
<dl class="c function">
<dt id="c.drm_object_property_set_value">
int <code class="sig-name descname">drm_object_property_set_value</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint64_t <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_set_value" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm mode object to set property value for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt><dd><p>value the property should be set to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets a given property on a given object. This function only
changes the software state of the property, it does not call into the
driver’s -&gt;set_property callback.</p>
<p>Note that atomic drivers should not have any need to call this, the core will
ensure consistency of values reported back to userspace through the
appropriate -&gt;atomic_get_property callback. Only legacy drivers should call
this function to update the tracked value (after clamping and other
restrictions have been applied).</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_object_property_get_value">
int <code class="sig-name descname">drm_object_property_get_value</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint64_t *<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_get_value" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm mode object to get property value from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*val</span></code></dt><dd><p>storage for the property value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves the softare state of the given property for the given
property. Since there is no driver callback to retrieve the current property
value this might be out of sync with the hardware, depending upon the driver
and property.</p>
<p>Atomic drivers should never call this function directly, the core will read
out property values through the various -&gt;atomic_get_property callbacks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<div class="section" id="atomic-mode-setting">
<h2>Atomic Mode Setting<a class="headerlink" href="#atomic-mode-setting" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id4">
<img alt="Mode Objects and Properties" src="../_images/DOT-69c6997054dbfdfb0892fa0cab076cfd8074c7ed.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Atomic provides transactional modeset (including planes) updates, but a
bit differently from the usual transactional approach of try-commit and
rollback:</p>
<ul class="simple">
<li><p>Firstly, no hardware changes are allowed when the commit would fail. This
allows us to implement the DRM_MODE_ATOMIC_TEST_ONLY mode, which allows
userspace to explore whether certain configurations would work or not.</p></li>
<li><p>This would still allow setting and rollback of just the software state,
simplifying conversion of existing drivers. But auditing drivers for
correctness of the atomic_check code becomes really hard with that: Rolling
back changes in data structures all over the place is hard to get right.</p></li>
<li><p>Lastly, for backwards compatibility and to support all use-cases, atomic
updates need to be incremental and be able to execute in parallel. Hardware
doesn’t always allow it, but where possible plane updates on different CRTCs
should not interfere, and not get stalled due to output routing changing on
different CRTCs.</p></li>
</ul>
<p>Taken all together there’s two consequences for the atomic design:</p>
<ul class="simple">
<li><p>The overall state is split up into per-object state structures:
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> for planes, <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_crtc_state</span></code></a> for CRTCs and <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_connector_state</span></code></a> for connectors. These are the only
objects with userspace-visible and settable state. For internal state drivers
can subclass these structures through embeddeding, or add entirely new state
structures for their globally shared hardware functions, see <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_private_state</span></code></a>.</p></li>
<li><p>An atomic update is assembled and validated as an entirely free-standing pile
of structures within the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
container. Driver private state structures are also tracked in the same
structure; see the next chapter.  Only when a state is committed is it applied
to the driver and modeset objects. This way rolling back an update boils down
to releasing memory and unreferencing objects like framebuffers.</p></li>
</ul>
<p>Locking of atomic state structures is internally using <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_modeset_lock</span></code></a>. As a general rule the locking shouldn’t be
exposed to drivers, instead the right locks should be automatically acquired by
any function that duplicates or peeks into a state, like e.g.
<a class="reference internal" href="#c.drm_atomic_get_crtc_state" title="drm_atomic_get_crtc_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_crtc_state()</span></code></a>.  Locking only protects the software data
structure, ordering of committing state changes to hardware is sequenced using
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
<p>Read on in this chapter, and also in <a class="reference internal" href="drm-kms-helpers.html#drm-atomic-helper"><span class="std std-ref">Atomic Modeset Helper Functions Reference</span></a> for more detailed
coverage of specific topics.</p>
<div class="section" id="handling-driver-private-state">
<h3>Handling Driver Private State<a class="headerlink" href="#handling-driver-private-state" title="Permalink to this headline">¶</a></h3>
<p>Very often the DRM objects exposed to userspace in the atomic modeset api
(<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>) do not map neatly to the
underlying hardware. Especially for any kind of shared resources (e.g. shared
clocks, scaler units, bandwidth and fifo limits shared among a group of
planes or CRTCs, and so on) it makes sense to model these as independent
objects. Drivers then need to do similar state tracking and commit ordering for
such private (since not exposed to userpace) objects as the atomic core and
helpers already provide for connectors, planes and CRTCs.</p>
<p>To make this easier on drivers the atomic core provides some support to track
driver private state objects using struct <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a>, with the
associated state struct <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a>.</p>
<p>Similar to userspace-exposed objects, private state structures can be
acquired by calling <a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>. This also takes care
of locking, hence drivers should not have a need to call <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a>
directly. Sequence of the actual hardware state commit is not handled,
drivers might need to keep track of <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a> within subclassed
structure of <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> as necessary, e.g. similar to
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.commit</span></code></a>. See also <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state.fake_commit</span></code></a>.</p>
<p>All private state structures contained in a <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> update can be
iterated using <a class="reference internal" href="#c.for_each_oldnew_private_obj_in_state" title="for_each_oldnew_private_obj_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_private_obj_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_new_private_obj_in_state" title="for_each_new_private_obj_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_private_obj_in_state()</span></code></a> and <a class="reference internal" href="#c.for_each_old_private_obj_in_state" title="for_each_old_private_obj_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_private_obj_in_state()</span></code></a>.
Drivers are recommended to wrap these for each type of driver private state
object they have, filtering on <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj.funcs</span></code></a> using <a class="reference internal" href="drm-internals.html#c.for_each_if" title="for_each_if"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_if()</span></code></a>, at
least if they want to iterate over all objects of a given type.</p>
<p>An earlier way to handle driver private state was by subclassing struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>. But since that encourages non-standard ways to implement
the check/commit split atomic requires (by using e.g. “check and rollback or
commit instead” of “duplicate state, check, then either commit or release
duplicated state) it is deprecated in favour of using <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a>.</p>
</div>
<div class="section" id="atomic-mode-setting-function-reference">
<h3>Atomic Mode Setting Function Reference<a class="headerlink" href="#atomic-mode-setting-function-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_crtc_commit">
<em class="property">struct </em><code class="sig-name descname">drm_crtc_commit</code><a class="headerlink" href="#c.drm_crtc_commit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>track modeset commits on a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc_commit {
  struct drm_crtc *crtc;
  struct kref ref;
  struct completion flip_done;
  struct completion hw_done;
  struct completion cleanup_done;
  struct list_head commit_entry;
  struct drm_pending_vblank_event *event;
  bool abort_completion;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>DRM CRTC for this commit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ref</span></code></dt><dd><p>Reference count for this structure. Needed to allow blocking on
completions without the risk of the completion disappearing
meanwhile.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flip_done</span></code></dt><dd><p>Will be signaled when the hardware has flipped to the new set of
buffers. Signals at the same time as when the drm event for this
commit is sent to userspace, or when an out-fence is singalled. Note
that for most hardware, in most cases this happens after <strong>hw_done</strong> is
signalled.</p>
<p>Completion of this stage is signalled implicitly by calling
<a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> on <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_done</span></code></dt><dd><p>Will be signalled when all hw register changes for this commit have
been written out. Especially when disabling a pipe this can be much
later than <strong>flip_done</strong>, since that can signal already when the
screen goes black, whereas to fully shut down a pipe more register
I/O is required.</p>
<p>Note that this does not need to include separately reference-counted
resources like backing storage buffer pinning, or runtime pm
management.</p>
<p>Drivers should call <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a> to signal
completion of this stage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_done</span></code></dt><dd><p>Will be signalled after old buffers have been cleaned up by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>. Since this can only happen after
a vblank wait completed it might be a bit later. This completion is
useful to throttle updates and avoid hardware updates getting ahead
of the buffer cleanup too much.</p>
<p>Drivers should call <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit_cleanup_done" title="drm_atomic_helper_commit_cleanup_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_cleanup_done()</span></code></a> to signal
completion of this stage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit_entry</span></code></dt><dd><p>Entry on the per-CRTC <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.commit_list</span></code></a>. Protected by
$drm_crtc.commit_lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p><a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pending_vblank_event</span></code></a> pointer to clean up private events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_completion</span></code></dt><dd><p>A flag that’s set after <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> takes a
second reference for the completion of $drm_crtc_state.event. It’s
used by the free code to remove the second reference if commit fails.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used to track pending modeset changes and atomic commit on
a per-CRTC basis. Since updating the list should never block, this structure
is reference counted to allow waiters to safely wait on an event to complete,
without holding any locks.</p>
<p>It has 3 different events in total to allow a fine-grained synchronization
between outstanding updates:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>atomic commit thread                    hardware

write new state into hardware   ----&gt;   ...
signal hw_done
                                        switch to new state on next
...                                     v/hblank

wait for buffers to show up             ...

...                                     send completion irq
                                        irq handler signals flip_done
cleanup old buffers

signal cleanup_done

wait for flip_done              &lt;----
clean up atomic state
</pre></div>
</div>
<p>The important bit to know is that <code class="xref c c-type docutils literal notranslate"><span class="pre">cleanup_done</span></code> is the terminal event, but the
ordering between <code class="xref c c-type docutils literal notranslate"><span class="pre">flip_done</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">hw_done</span></code> is entirely up to the specific driver
and modeset state change.</p>
<p>For an implementation of how to use this look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> from the atomic helper library.</p>
<dl class="c struct">
<dt id="c.drm_private_state_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_private_state_funcs</code><a class="headerlink" href="#c.drm_private_state_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>atomic state functions for private objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_private_state_funcs {
  struct drm_private_state *(*atomic_duplicate_state)(struct drm_private_obj *obj);
  void (*atomic_destroy_state)(struct drm_private_obj *obj, struct drm_private_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current state of the private object and return it. It
is an error to call this before obj-&gt;state has been initialized.</p>
<p>RETURNS:</p>
<p>Duplicated atomic state or NULL when obj-&gt;state is not
initialized or allocation failed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Frees the private object state created with <strong>atomic_duplicate_state</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by atomic helpers to create, swap and destroy states of
private objects. The structure itself is used as a vtable to identify the
associated private object type. Each private object type that needs to be
added to the atomic states is expected to have an implementation of these
hooks and pass a pointer to its drm_private_state_funcs struct to
<a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>.</p>
<dl class="c struct">
<dt id="c.drm_private_obj">
<em class="property">struct </em><code class="sig-name descname">drm_private_obj</code><a class="headerlink" href="#c.drm_private_obj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>base struct for driver private atomic object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_private_obj {
  struct list_head head;
  struct drm_modeset_lock lock;
  struct drm_private_state *state;
  const struct drm_private_state_funcs *funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List entry used to attach a private object to a <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a>
(queued to <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.privobj_list</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Modeset lock to protect the state object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Current atomic state for this driver private object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Functions to manipulate the state of this driver private object, see
<a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state_funcs</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A driver private object is initialized by calling
<a class="reference internal" href="#c.drm_atomic_private_obj_init" title="drm_atomic_private_obj_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_private_obj_init()</span></code></a> and cleaned up by calling
<a class="reference internal" href="#c.drm_atomic_private_obj_fini" title="drm_atomic_private_obj_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_private_obj_fini()</span></code></a>.</p>
<p>Currently only tracks the state update functions and the opaque driver
private state itself, but in the future might also track which
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> is required to duplicate and update this object’s state.</p>
<p>All private objects must be initialized before the DRM device they are
attached to is registered to the DRM subsystem (call to <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>)
and should stay around until this DRM device is unregistered (call to
<a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>). In other words, private objects lifetime is tied
to the DRM device lifetime. This implies that:</p>
<dl class="simple">
<dt>1/ all calls to drm_atomic_private_obj_init() must be done before calling</dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a></p>
</dd>
<dt>2/ all calls to drm_atomic_private_obj_fini() must be done after calling</dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a></p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.drm_for_each_privobj">
<code class="sig-name descname">drm_for_each_privobj</code><a class="headerlink" href="#c.drm_for_each_privobj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_privobj</span> <span class="pre">(privobj,</span> <span class="pre">dev)</span></code></p>
<blockquote>
<div><p>private object iterator</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">privobj</span></code></dt><dd><p>pointer to the current private object. Updated after each
iteration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device we want get private objects from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allows one to iterate over all private objects attached to <strong>dev</strong></p>
<dl class="c struct">
<dt id="c.drm_private_state">
<em class="property">struct </em><code class="sig-name descname">drm_private_state</code><a class="headerlink" href="#c.drm_private_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>base struct for driver private object state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_private_state {
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>backpointer to global drm_atomic_state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Currently only contains a backpointer to the overall atomic update, but in
the future also might hold synchronization information similar to e.g.
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.commit</span></code></a>.</p>
<dl class="c struct">
<dt id="c.drm_atomic_state">
<em class="property">struct </em><code class="sig-name descname">drm_atomic_state</code><a class="headerlink" href="#c.drm_atomic_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>the global state object for atomic updates</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_atomic_state {
  struct kref ref;
  struct drm_device *dev;
  bool allow_modeset : 1;
  bool legacy_cursor_update : 1;
  bool async_update : 1;
  bool duplicated : 1;
  struct __drm_planes_state *planes;
  struct __drm_crtcs_state *crtcs;
  int num_connector;
  struct __drm_connnectors_state *connectors;
  int num_private_objs;
  struct __drm_private_objs_state *private_objs;
  struct drm_modeset_acquire_ctx *acquire_ctx;
  struct drm_crtc_commit *fake_commit;
  struct work_struct commit_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ref</span></code></dt><dd><p>count of all references to this state (will not be freed until zero)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>parent DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allow_modeset</span></code></dt><dd><p>Allow full modeset. This is used by the ATOMIC IOCTL handler to
implement the DRM_MODE_ATOMIC_ALLOW_MODESET flag. Drivers should
never consult this flag, instead looking at the output of
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy_cursor_update</span></code></dt><dd><p>hint to enforce legacy cursor IOCTL semantics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">async_update</span></code></dt><dd><p>hint for asynchronous plane update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplicated</span></code></dt><dd><p>Indicates whether or not this atomic state was duplicated using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a>. Drivers and atomic helpers
should use this to fixup normal  inconsistencies in duplicated
states.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">planes</span></code></dt><dd><p>pointer to array of structures with per-plane data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtcs</span></code></dt><dd><p>pointer to array of CRTC pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_connector</span></code></dt><dd><p>size of the <strong>connectors</strong> and <strong>connector_states</strong> arrays</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connectors</span></code></dt><dd><p>pointer to array of structures with per-connector data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_private_objs</span></code></dt><dd><p>size of the <strong>private_objs</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_objs</span></code></dt><dd><p>pointer to array of private object pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acquire_ctx</span></code></dt><dd><p>acquire context for this atomic modeset state update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fake_commit</span></code></dt><dd><p>Used for signaling unbound planes/connectors.
When a connector or plane is not bound to any CRTC, it’s still important
to preserve linearity to prevent the atomic states from being freed to early.</p>
<p>This commit (if set) is not bound to any CRTC, but will be completed when
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a> is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit_work</span></code></dt><dd><p>Work item which can be used by the driver or helpers to execute the
commit without blocking.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>States are added to an atomic update by calling <a class="reference internal" href="#c.drm_atomic_get_crtc_state" title="drm_atomic_get_crtc_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_crtc_state()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_get_plane_state" title="drm_atomic_get_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_plane_state()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_get_connector_state" title="drm_atomic_get_connector_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_connector_state()</span></code></a>, or for
private state structures, <a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_commit_get">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<code class="sig-name descname">drm_crtc_commit_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a reference to the CRTC commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*commit</span></code></dt><dd><p>CRTC commit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increases the reference of <strong>commit</strong>.</p>
<p><strong>Return</strong></p>
<p>The pointer to <strong>commit</strong>, with reference increased.</p>
<dl class="c function">
<dt id="c.drm_crtc_commit_put">
void <code class="sig-name descname">drm_crtc_commit_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a reference to the CRTC commmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*commit</span></code></dt><dd><p>CRTC commit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>commit</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="c function">
<dt id="c.drm_atomic_state_get">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<code class="sig-name descname">drm_atomic_state_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new reference to the <strong>state</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_state_put">
void <code class="sig-name descname">drm_atomic_state_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>state</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_existing_crtc_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<code class="sig-name descname">drm_atomic_get_existing_crtc_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_crtc_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get CRTC state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the CRTC state for the given CRTC, or NULL
if the CRTC is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_crtc_state</strong> or
<strong>drm_atomic_get_new_crtc_state</strong> should be used instead.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_crtc_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<code class="sig-name descname">drm_atomic_get_old_crtc_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_crtc_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get old CRTC state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old CRTC state for the given CRTC, or
NULL if the CRTC is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_crtc_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<code class="sig-name descname">drm_atomic_get_new_crtc_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_crtc_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get new CRTC state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new CRTC state for the given CRTC, or
NULL if the CRTC is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_existing_plane_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">drm_atomic_get_existing_plane_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, or NULL
if the plane is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_plane_state</strong> or
<strong>drm_atomic_get_new_plane_state</strong> should be used instead.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_plane_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">drm_atomic_get_old_plane_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_plane_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">drm_atomic_get_new_plane_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_existing_connector_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<code class="sig-name descname">drm_atomic_get_existing_connector_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_connector_state</strong> or
<strong>drm_atomic_get_new_connector_state</strong> should be used instead.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_connector_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<code class="sig-name descname">drm_atomic_get_old_connector_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_connector_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<code class="sig-name descname">drm_atomic_get_new_connector_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.__drm_atomic_get_current_plane_state">
<em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">__drm_atomic_get_current_plane_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_get_current_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get current plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, either from
<strong>state</strong>, or if the plane isn’t part of the atomic state update, from <strong>plane</strong>.
This is useful in atomic check callbacks, when drivers need to peek at, but
not change, state of other planes, since it avoids threading an error code
back up the call chain.</p>
<p>WARNING:</p>
<p>Note that this function is in general unsafe since it doesn’t check for the
required locking for access state structures. Drivers must ensure that it is
safe to access the returned state structure through other means. One common
example is when planes are fixed to a single CRTC, and the driver knows that
the CRTC lock is held already. In that case holding the CRTC lock gives a
read-lock on all planes connected to that CRTC. But if planes can be
reassigned things get more tricky. In that case it’s better to use
drm_atomic_get_plane_state and wire up full error handling.</p>
<p>Read-only pointer to the current plane state.</p>
<p><strong>Return</strong></p>
<dl class="c macro">
<dt id="c.for_each_oldnew_connector_in_state">
<code class="sig-name descname">for_each_oldnew_connector_in_state</code><a class="headerlink" href="#c.for_each_oldnew_connector_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_oldnew_connector_in_state</span> <span class="pre">(__state,</span> <span class="pre">connector,</span> <span class="pre">old_connector_state,</span> <span class="pre">new_connector_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all connectors in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_connector_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_connector_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="c macro">
<dt id="c.for_each_old_connector_in_state">
<code class="sig-name descname">for_each_old_connector_in_state</code><a class="headerlink" href="#c.for_each_old_connector_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_old_connector_in_state</span> <span class="pre">(__state,</span> <span class="pre">connector,</span> <span class="pre">old_connector_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all connectors in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_connector_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="c macro">
<dt id="c.for_each_new_connector_in_state">
<code class="sig-name descname">for_each_new_connector_in_state</code><a class="headerlink" href="#c.for_each_new_connector_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_new_connector_in_state</span> <span class="pre">(__state,</span> <span class="pre">connector,</span> <span class="pre">new_connector_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all connectors in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_connector_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="c macro">
<dt id="c.for_each_oldnew_crtc_in_state">
<code class="sig-name descname">for_each_oldnew_crtc_in_state</code><a class="headerlink" href="#c.for_each_oldnew_crtc_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_oldnew_crtc_in_state</span> <span class="pre">(__state,</span> <span class="pre">crtc,</span> <span class="pre">old_crtc_state,</span> <span class="pre">new_crtc_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all CRTCs in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_crtc_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_crtc_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="c macro">
<dt id="c.for_each_old_crtc_in_state">
<code class="sig-name descname">for_each_old_crtc_in_state</code><a class="headerlink" href="#c.for_each_old_crtc_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_old_crtc_in_state</span> <span class="pre">(__state,</span> <span class="pre">crtc,</span> <span class="pre">old_crtc_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all CRTCs in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_crtc_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="c macro">
<dt id="c.for_each_new_crtc_in_state">
<code class="sig-name descname">for_each_new_crtc_in_state</code><a class="headerlink" href="#c.for_each_new_crtc_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_new_crtc_in_state</span> <span class="pre">(__state,</span> <span class="pre">crtc,</span> <span class="pre">new_crtc_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all CRTCs in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_crtc_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="c macro">
<dt id="c.for_each_oldnew_plane_in_state">
<code class="sig-name descname">for_each_oldnew_plane_in_state</code><a class="headerlink" href="#c.for_each_oldnew_plane_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_oldnew_plane_in_state</span> <span class="pre">(__state,</span> <span class="pre">plane,</span> <span class="pre">old_plane_state,</span> <span class="pre">new_plane_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all planes in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="c macro">
<dt id="c.for_each_oldnew_plane_in_state_reverse">
<code class="sig-name descname">for_each_oldnew_plane_in_state_reverse</code><a class="headerlink" href="#c.for_each_oldnew_plane_in_state_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_oldnew_plane_in_state_reverse</span> <span class="pre">(__state,</span> <span class="pre">plane,</span> <span class="pre">old_plane_state,</span> <span class="pre">new_plane_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all planes in an atomic update in reverse order</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update in reverse order,
tracking both old and  new state. This is useful in places where the
state delta needs to be considered, for example in atomic check functions.</p>
<dl class="c macro">
<dt id="c.for_each_old_plane_in_state">
<code class="sig-name descname">for_each_old_plane_in_state</code><a class="headerlink" href="#c.for_each_old_plane_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_old_plane_in_state</span> <span class="pre">(__state,</span> <span class="pre">plane,</span> <span class="pre">old_plane_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all planes in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="c macro">
<dt id="c.for_each_new_plane_in_state">
<code class="sig-name descname">for_each_new_plane_in_state</code><a class="headerlink" href="#c.for_each_new_plane_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_new_plane_in_state</span> <span class="pre">(__state,</span> <span class="pre">plane,</span> <span class="pre">new_plane_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all planes in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_plane_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="c macro">
<dt id="c.for_each_oldnew_private_obj_in_state">
<code class="sig-name descname">for_each_oldnew_private_obj_in_state</code><a class="headerlink" href="#c.for_each_oldnew_private_obj_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_oldnew_private_obj_in_state</span> <span class="pre">(__state,</span> <span class="pre">obj,</span> <span class="pre">old_obj_state,</span> <span class="pre">new_obj_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all private objects in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_obj_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_obj_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking both
old and new state. This is useful in places where the state delta needs
to be considered, for example in atomic check functions.</p>
<dl class="c macro">
<dt id="c.for_each_old_private_obj_in_state">
<code class="sig-name descname">for_each_old_private_obj_in_state</code><a class="headerlink" href="#c.for_each_old_private_obj_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_old_private_obj_in_state</span> <span class="pre">(__state,</span> <span class="pre">obj,</span> <span class="pre">old_obj_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all private objects in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_obj_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the old state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the old state. This is useful in disable functions, where we need the old
state the hardware is still in.</p>
<dl class="c macro">
<dt id="c.for_each_new_private_obj_in_state">
<code class="sig-name descname">for_each_new_private_obj_in_state</code><a class="headerlink" href="#c.for_each_new_private_obj_in_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_new_private_obj_in_state</span> <span class="pre">(__state,</span> <span class="pre">obj,</span> <span class="pre">new_obj_state,</span> <span class="pre">__i)</span></code></p>
<blockquote>
<div><p>iterate over all private objects in an atomic update</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_obj_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the new state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the new state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="c function">
<dt id="c.drm_atomic_crtc_needs_modeset">
bool <code class="sig-name descname">drm_atomic_crtc_needs_modeset</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_needs_modeset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compute combined modeset need</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a> for the CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To give drivers flexibility <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> has 3 booleans to track
whether the state CRTC changed enough to need a full modeset cycle:
mode_changed, active_changed and connectors_changed. This helper simply
combines these three to compute the overall need for a modeset for <strong>state</strong>.</p>
<p>The atomic helper code sets these booleans, but drivers can and should
change them appropriately to accurately represent whether a modeset is
really needed. In general, drivers should avoid full modesets whenever
possible.</p>
<p>For example if the CRTC mode has changed, and the hardware is able to enact
the requested mode change without going through a full modeset, the driver
should clear mode_changed in its <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
implementation.</p>
<dl class="c function">
<dt id="c.drm_atomic_crtc_effectively_active">
bool <code class="sig-name descname">drm_atomic_crtc_effectively_active</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_effectively_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compute whether CRTC is actually active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a> for the CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When in self refresh mode, the crtc_state-&gt;active value will be false, since
the CRTC is off. However in some cases we’re interested in whether the CRTC
is active, or effectively active (ie: it’s connected to an active display).
In these cases, use this function instead of just checking active.</p>
<dl class="c struct">
<dt id="c.drm_bus_cfg">
<em class="property">struct </em><code class="sig-name descname">drm_bus_cfg</code><a class="headerlink" href="#c.drm_bus_cfg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>bus configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bus_cfg {
  u32 format;
  u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>format used on this bus (one of the MEDIA_BUS_FMT_* format)</p>
<p>This field should not be directly modified by drivers
(drm_atomic_bridge_chain_select_bus_fmts() takes care of the bus
format negotiation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>DRM_BUS_* flags used on this bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure stores the configuration of a physical bus between two
components in an output pipeline, usually between two bridges, an encoder
and a bridge, or a bridge and a connector.</p>
<p>The bus configuration is stored in <a class="reference internal" href="#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a> separately for the
input and output buses, as seen from the point of view of each bridge. The
bus configuration of a bridge output is usually identical to the
configuration of the next bridge’s input, but may differ if the signals are
modified between the two bridges, for instance by an inverter on the board.
The input and output configurations of a bridge may differ if the bridge
modifies the signals internally, for instance by performing format
conversion, or modifying signals polarities.</p>
<dl class="c struct">
<dt id="c.drm_bridge_state">
<em class="property">struct </em><code class="sig-name descname">drm_bridge_state</code><a class="headerlink" href="#c.drm_bridge_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomic bridge state object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge_state {
  struct drm_private_state base;
  struct drm_bridge *bridge;
  struct drm_bus_cfg input_bus_cfg;
  struct drm_bus_cfg output_bus_cfg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>inherit from <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_bus_cfg</span></code></dt><dd><p>input bus configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">output_bus_cfg</span></code></dt><dd><p>input bus configuration</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_atomic_state_default_release">
void <code class="sig-name descname">drm_atomic_state_default_release</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release memory initialized by drm_atomic_state_init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all the memory allocated by drm_atomic_state_init.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> and haven’t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="c function">
<dt id="c.drm_atomic_state_init">
int <code class="sig-name descname">drm_atomic_state_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>init new atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for filling in a new atomic state.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> and haven’t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="c function">
<dt id="c.drm_atomic_state_alloc">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<code class="sig-name descname">drm_atomic_state_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates an empty atomic state to track updates.</p>
<dl class="c function">
<dt id="c.drm_atomic_state_default_clear">
void <code class="sig-name descname">drm_atomic_state_default_clear</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_clear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear base atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for clearing atomic state.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> and haven’t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="c function">
<dt id="c.drm_atomic_state_clear">
void <code class="sig-name descname">drm_atomic_state_clear</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_clear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the w/w mutex algorithm detects a deadlock we need to back off and drop
all locks. So someone else could sneak in and change the current modeset
configuration. Which means that all the state assembled in <strong>state</strong> is no
longer an atomic update to the current state, but to some arbitrary earlier
state. Which could break assumptions the driver’s
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> likely relies on.</p>
<p>Hence we must clear all cached state and completely start over, using this
function.</p>
<dl class="c function">
<dt id="c.__drm_atomic_state_free">
void <code class="sig-name descname">__drm_atomic_state_free</code><span class="sig-paren">(</span><em class="property">struct</em> kref *<em>ref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_state_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free all memory for an atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*ref</span></code></dt><dd><p>This atomic state to deallocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This frees all memory associated with an atomic state, including all the
per-object state for planes, CRTCs and connectors.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_crtc_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<code class="sig-name descname">drm_atomic_get_crtc_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_crtc_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to get state object for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the CRTC state for the given CRTC, allocating it if
needed. It will also grab the relevant CRTC lock to make sure that the state
is consistent.</p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_get_plane_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<code class="sig-name descname">drm_atomic_get_plane_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to get state object for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, allocating it if
needed. It will also grab the relevant plane lock to make sure that the state
is consistent.</p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_private_obj_init">
void <code class="sig-name descname">drm_atomic_private_obj_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>obj</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<em>state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs">drm_private_state_funcs</a> *<em>funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_private_obj_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize private object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device this object will be attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>private object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span> <span class="pre">*state</span></code></dt><dd><p>initial private object state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>pointer to the struct of function pointers that identify the object
type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the private object, which can be embedded into any
driver private object that needs its own atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_private_obj_fini">
void <code class="sig-name descname">drm_atomic_private_obj_fini</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_private_obj_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>finalize private object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>private object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finalize the private object.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_private_obj_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<code class="sig-name descname">drm_atomic_get_private_obj_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_private_obj_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get private object state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>private object to get the state for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the private object state for the given private object,
allocating the state if needed. It will also grab the relevant private
object lock to make sure that the state is consistent.</p>
<p>Either the allocated state or the error code encoded into a pointer.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_private_obj_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<code class="sig-name descname">drm_atomic_get_old_private_obj_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_private_obj_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>private_obj to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old private object state for the given private_obj,
or NULL if the private_obj is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_private_obj_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<code class="sig-name descname">drm_atomic_get_new_private_obj_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_private_obj_state" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>private_obj to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new private object state for the given private_obj,
or NULL if the private_obj is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_connector_for_encoder">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<code class="sig-name descname">drm_atomic_get_old_connector_for_encoder</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_connector_for_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get old connector for an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>Atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>The encoder to fetch the connector state for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function finds and returns the connector that was connected to <strong>encoder</strong>
as specified by the <strong>state</strong>.</p>
<p>If there is no connector in <strong>state</strong> which previously had <strong>encoder</strong> connected to
it, this function will return NULL. While this may seem like an invalid use
case, it is sometimes useful to differentiate commits which had no prior
connectors attached to <strong>encoder</strong> vs ones that did (and to inspect their
state). This is especially true in enable hooks because the pipeline has
changed.</p>
<p><strong>Return</strong></p>
<p>The old connector connected to <strong>encoder</strong>, or NULL if the encoder is
not connected.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_connector_for_encoder">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<code class="sig-name descname">drm_atomic_get_new_connector_for_encoder</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_connector_for_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get new connector for an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>Atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>The encoder to fetch the connector state for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function finds and returns the connector that will be connected to
<strong>encoder</strong> as specified by the <strong>state</strong>.</p>
<p>If there is no connector in <strong>state</strong> which will have <strong>encoder</strong> connected to it,
this function will return NULL. While this may seem like an invalid use case,
it is sometimes useful to differentiate commits which have no connectors
attached to <strong>encoder</strong> vs ones that do (and to inspect their state). This is
especially true in disable hooks because the pipeline will change.</p>
<p><strong>Return</strong></p>
<p>The new connector connected to <strong>encoder</strong>, or NULL if the encoder is
not connected.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_connector_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<code class="sig-name descname">drm_atomic_get_connector_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to get state object for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
allocating it if needed. It will also grab the relevant connector lock to
make sure that the state is consistent.</p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_get_bridge_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<code class="sig-name descname">drm_atomic_get_bridge_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_bridge_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get bridge state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge to get state object for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the bridge state for the given bridge, allocating it
if needed. It will also grab the relevant bridge lock to make sure that the
state is consistent.</p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_atomic_get_old_bridge_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<code class="sig-name descname">drm_atomic_get_old_bridge_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_bridge_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get old bridge state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old bridge state for the given bridge, or NULL if
the bridge is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_get_new_bridge_state">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> *<code class="sig-name descname">drm_atomic_get_new_bridge_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_bridge_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get new bridge state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge to grab</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new bridge state for the given bridge, or NULL if
the bridge is not part of the global atomic state.</p>
<dl class="c function">
<dt id="c.drm_atomic_add_encoder_bridges">
int <code class="sig-name descname">drm_atomic_add_encoder_bridges</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_encoder_bridges" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add bridges attached to an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>DRM encoder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds all bridges attached to <strong>encoder</strong>. This is needed to add
bridge states to <strong>state</strong> and make them available when
<a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a>, <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_pre_enable()</span></code></a>,
<a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_enable()</span></code></a>,
<a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_disable_post_disable()</span></code></a> are called.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="c function">
<dt id="c.drm_atomic_add_affected_connectors">
int <code class="sig-name descname">drm_atomic_add_affected_connectors</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_connectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add connectors for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all connectors
currently using <strong>crtc</strong> to the atomic configuration <strong>state</strong>. Note that this
function must acquire the connection mutex. This can potentially cause
unneeded seralization if the update is just for the planes on one CRTC. Hence
drivers and helpers should only call this when really needed (e.g. when a
full modeset needs to happen due to some change).</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="c function">
<dt id="c.drm_atomic_add_affected_planes">
int <code class="sig-name descname">drm_atomic_add_affected_planes</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_planes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add planes for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all planes
currently used by <strong>crtc</strong> to the atomic configuration <strong>state</strong>. This is useful
when an atomic commit also needs to check all currently enabled plane on
<strong>crtc</strong>, e.g. when changing the mode. It’s also useful when re-enabling a CRTC
to avoid special code to force-enable all planes.</p>
<p>Since acquiring a plane state will always also acquire the w/w mutex of the
current CRTC for that plane (if there is any) adding all the plane states for
a CRTC will not reduce parallism of atomic updates.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="c function">
<dt id="c.drm_atomic_check_only">
int <code class="sig-name descname">drm_atomic_check_only</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_check_only" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check whether a given config would work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic configuration to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_atomic_commit">
int <code class="sig-name descname">drm_atomic_commit</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_commit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>commit configuration atomically</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic configuration to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_atomic_nonblocking_commit">
int <code class="sig-name descname">drm_atomic_nonblocking_commit</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_nonblocking_commit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>atomic nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic configuration to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_state_dump">
void <code class="sig-name descname">drm_state_dump</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_state_dump" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>dump entire device atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>where to print the state to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just for debugging.  Drivers might want an option to dump state
to dmesg in case of error irq’s.  (Hint, you probably want to
ratelimit this!)</p>
<p>The caller must <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_all()</span></code></a>, or if this is called
from error irq handler, it should not be enabled by default.
(Ie. if you are debugging errors you might not care that this
is racey.  But calling this without all modeset locks held is
not inherently safe.)</p>
</div>
<div class="section" id="atomic-mode-setting-ioctl-and-uapi-functions">
<h3>Atomic Mode Setting IOCTL and UAPI Functions<a class="headerlink" href="#atomic-mode-setting-ioctl-and-uapi-functions" title="Permalink to this headline">¶</a></h3>
<p>This file contains the marshalling and demarshalling glue for the atomic UAPI
in all its forms: The monster ATOMIC IOCTL itself, code for GET_PROPERTY and
SET_PROPERTY IOCTLs. Plus interface functions for compatibility helpers and
drivers which have special needs to construct their own atomic updates, e.g.
for load detect or similiar.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_mode_for_crtc">
int <code class="sig-name descname">drm_atomic_set_mode_for_crtc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_for_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p>the CRTC whose incoming state to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>kernel-internal mode to use for the CRTC, or NULL to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from the kernel) on the desired CRTC state and update
the enable property.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_mode_prop_for_crtc">
int <code class="sig-name descname">drm_atomic_set_mode_prop_for_crtc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_prop_for_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p>the CRTC whose incoming state to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*blob</span></code></dt><dd><p>pointer to blob property to use for mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from a blob property) on the desired CRTC state.
This function will take a reference on the blob property for the CRTC state,
and release the reference held on the state’s existing mode property, if any
was set.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_crtc_for_plane">
int <code class="sig-name descname">drm_atomic_set_crtc_for_plane</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>plane_state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set CRTC for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane whose incoming state to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to use for the plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned CRTC for a plane requires us to grab the lock and state
for the new CRTC, as needed. This function takes care of all these details
besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_fb_for_plane">
void <code class="sig-name descname">drm_atomic_set_fb_for_plane</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>plane_state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fb_for_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set framebuffer for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>atomic state object for the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>fb to use for the plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned framebuffer for a plane requires us to grab a reference
to the new fb and drop the reference to the old fb, if there is one. This
function takes care of all these details besides updating the pointer in the
state object itself.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_fence_for_plane">
void <code class="sig-name descname">drm_atomic_set_fence_for_plane</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>plane_state</em>, <em class="property">struct</em> <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fence_for_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set fence for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>atomic state object for the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>dma_fence to use for the plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to setup the plane_state fence in case it is not set yet.
By using this drivers doesn’t need to worry if the user choose
implicit or explicit fencing.</p>
<p>This function will not set the fence to the state if it was set
via explicit fencing interfaces on the atomic ioctl. In that case it will
drop the reference to the fence as we are not storing it anywhere.
Otherwise, if <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fence</span></code></a> is not set this function we just set it
with the received implicit fence. In both cases this function consumes a
reference for <strong>fence</strong>.</p>
<p>This way explicit fencing can be used to overrule implicit fencing, which is
important to make explicit fencing use-cases work: One example is using one
buffer for 2 screens with different refresh rates. Implicit fencing will
clamp rendering to the refresh rate of the slower screen, whereas explicit
fence allows 2 independent render and display loops on a single buffer. If a
driver allows obeys both implicit and explicit fences for plane updates, then
it will break all the benefits of explicit fencing.</p>
<dl class="c function">
<dt id="c.drm_atomic_set_crtc_for_connector">
int <code class="sig-name descname">drm_atomic_set_crtc_for_connector</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_connector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set CRTC for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>atomic state object for the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to use for the connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned CRTC for a connector requires us to grab the lock and
state for the new CRTC, as needed. This function takes care of all these
details besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
</div>
</div>
<div class="section" id="crtc-abstraction">
<h2>CRTC Abstraction<a class="headerlink" href="#crtc-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A CRTC represents the overall display pipeline. It receives pixel data from
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> and blends them together. The <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> is also attached
to the CRTC, specifying display timings. On the output side the data is fed
to one or more <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>, which are then each connected to one
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>.</p>
<p>To create a CRTC, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The CRTC is also the entry point for legacy modeset operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_config</span></code></a>, legacy plane operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.cursor_set2</span></code></a>, and other legacy
operations like <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.gamma_set</span></code></a>. For atomic drivers all these
features are controlled through <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a> and
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>.</p>
<div class="section" id="crtc-functions-reference">
<h3>CRTC Functions Reference<a class="headerlink" href="#crtc-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_crtc_state">
<em class="property">struct </em><code class="sig-name descname">drm_crtc_state</code><a class="headerlink" href="#c.drm_crtc_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mutable CRTC state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc_state {
  struct drm_crtc *crtc;
  bool enable;
  bool active;
  bool planes_changed : 1;
  bool mode_changed : 1;
  bool active_changed : 1;
  bool connectors_changed : 1;
  bool zpos_changed : 1;
  bool color_mgmt_changed : 1;
  bool no_vblank : 1;
  u32 plane_mask;
  u32 connector_mask;
  u32 encoder_mask;
  struct drm_display_mode adjusted_mode;
  struct drm_display_mode mode;
  struct drm_property_blob *mode_blob;
  struct drm_property_blob *degamma_lut;
  struct drm_property_blob *ctm;
  struct drm_property_blob *gamma_lut;
  u32 target_vblank;
  bool async_flip;
  bool vrr_enabled;
  bool self_refresh_active;
  struct drm_pending_vblank_event *event;
  struct drm_crtc_commit *commit;
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>backpointer to the CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Whether the CRTC should be enabled, gates all other state.
This controls reservations of shared resources. Actual hardware state
is controlled by <strong>active</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt><dd><p>Whether the CRTC is actively displaying (used for DPMS).
Implies that <strong>enable</strong> is set. The driver must not release any shared
resources if <strong>active</strong> is set to false but <strong>enable</strong> still true, because
userspace expects that a DPMS ON always succeeds.</p>
<p>Hence drivers must not consult <strong>active</strong> in their various
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> callback to reject an atomic
commit. They can consult it to aid in the computation of derived
hardware state, since even in the DPMS OFF state the display hardware
should be as much powered down as when the CRTC is completely
disabled through setting <strong>enable</strong> to false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">planes_changed</span></code></dt><dd><p>Planes on this crtc are updated. Used by the atomic
helpers and drivers to steer the atomic commit control flow.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_changed</span></code></dt><dd><p><strong>mode</strong> or <strong>enable</strong> has been changed. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
<p>Drivers are supposed to set this for any CRTC state changes that
require a full modeset. They can also reset it to false if e.g. a
<strong>mode</strong> change can be done without a full modeset by only changing
scaler settings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_changed</span></code></dt><dd><p><strong>active</strong> has been toggled. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connectors_changed</span></code></dt><dd><p>Connectors to this crtc have been updated,
either in their state or routing. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
<p>Drivers are supposed to set this as-needed from their own atomic
check code, e.g. from <a class="reference internal" href="drm-kms-helpers.html#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zpos_changed</span></code></dt><dd><p>zpos values of planes on this crtc have been updated.
Used by the atomic helpers and drivers to steer the atomic commit
control flow.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_mgmt_changed</span></code></dt><dd><p>Color management properties have changed
(<strong>gamma_lut</strong>, <strong>degamma_lut</strong> or <strong>ctm</strong>). Used by the atomic helpers and
drivers to steer the atomic commit control flow.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_vblank</span></code></dt><dd><p>Reflects the ability of a CRTC to send VBLANK events. This state
usually depends on the pipeline configuration. If set to true, DRM
atomic helpers will send out a fake VBLANK event during display
updates after all hardware changes have been committed. This is
implemented in <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_fake_vblank" title="drm_atomic_helper_fake_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_fake_vblank()</span></code></a>.</p>
<p>One usage is for drivers and/or hardware without support for VBLANK
interrupts. Such drivers typically do not initialize vblanking
(i.e., call <a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_init()</span></code></a> with the number of CRTCs). For CRTCs
without initialized vblanking, this field is set to true in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>, and a fake VBLANK event will be
send out on each update of the display pipeline by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_fake_vblank" title="drm_atomic_helper_fake_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_fake_vblank()</span></code></a>.</p>
<p>Another usage is CRTCs feeding a writeback connector operating in
oneshot mode. In this case the fake VBLANK event is only generated
when a job is queued to the writeback connector, and we want the
core to fake VBLANK events when this part of the pipeline hasn’t
changed but others had or when the CRTC and connectors are being
disabled.</p>
<p><a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_crtc_duplicate_state" title="__drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code></a> will not reset the value
from the current state, the CRTC driver is then responsible for
updating this field when needed.</p>
<p>Note that the combination of <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a> == NULL and
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_blank</span></code></a> == true is valid and usually used when the
writeback connector attached to the CRTC has a new job queued. In
this case the driver will send the VBLANK event on its own when the
writeback job is complete.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_mask</span></code></dt><dd><p>Bitmask of drm_plane_mask(plane) of planes attached to
this CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_mask</span></code></dt><dd><p>Bitmask of drm_connector_mask(connector) of
connectors attached to this CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_mask</span></code></dt><dd><p>Bitmask of drm_encoder_mask(encoder) of encoders
attached to this CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adjusted_mode</span></code></dt><dd><p>Internal display timings which can be used by the driver to handle
differences between the mode requested by userspace in <strong>mode</strong> and what
is actually programmed into the hardware.</p>
<p>For drivers using <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>, this stores hardware display timings
used between the CRTC and the first bridge. For other drivers, the
meaning of the adjusted_mode field is purely driver implementation
defined information, and will usually be used to store the hardware
display timings used between the CRTC and encoder blocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Display timings requested by userspace. The driver should try to
match the refresh rate as close as possible (but note that it’s
undefined what exactly is close enough, e.g. some of the HDMI modes
only differ in less than 1% of the refresh rate). The active width
and height as observed by userspace for positioning planes must match
exactly.</p>
<p>For external connectors where the sink isn’t fixed (like with a
built-in panel), this mode here should match the physical mode on the
wire to the last details (i.e. including sync polarities and
everything).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_blob</span></code></dt><dd><p><a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property_blob</span></code></a> for <strong>mode</strong>, for exposing the mode to
atomic userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">degamma_lut</span></code></dt><dd><p>Lookup table for converting framebuffer pixel data before apply the
color conversion matrix <strong>ctm</strong>. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctm</span></code></dt><dd><p>Color transformation matrix. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_color_ctm</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_lut</span></code></dt><dd><p>Lookup table for converting pixel data after the color conversion
matrix <strong>ctm</strong>.  See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The blob (if not
NULL) is an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_vblank</span></code></dt><dd><p>Target vertical blank period when a page flip
should take effect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">async_flip</span></code></dt><dd><p>This is set when DRM_MODE_PAGE_FLIP_ASYNC is set in the legacy
PAGE_FLIP IOCTL. It’s not wired up for the atomic IOCTL itself yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vrr_enabled</span></code></dt><dd><p>Indicates if variable refresh rate should be enabled for the CRTC.
Support for the requested vrr state will depend on driver and
hardware capabiltiy - lacking support is not treated as failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self_refresh_active</span></code></dt><dd><p>Used by the self refresh helpers to denote when a self refresh
transition is occurring. This will be set on enable/disable callbacks
when self refresh is being enabled or disabled. In some cases, it may
not be desirable to fully shut off the crtc during self refresh.
CRTC’s can inspect this flag and determine the best course of action.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>Optional pointer to a DRM event to signal upon completion of the
state update. The driver must send out the event when the atomic
commit operation completes. There are two cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>The event is for a CRTC which is being disabled through this
atomic commit. In that case the event can be send out any time
after the hardware has stopped scanning out the current
framebuffers. It should contain the timestamp and counter for the
last vblank before the display pipeline was shut off. The simplest
way to achieve that is calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a>
somewhen after <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> has been called.</p></li>
<li><p>For a CRTC which is enabled at the end of the commit (even when it
undergoes an full modeset) the vblank timestamp and counter must
be for the vblank right before the first frame that scans out the
new set of buffers. Again the event can only be sent out after the
hardware has stopped scanning out the old buffers.</p></li>
<li><p>Events for disabled CRTCs are not allowed, and drivers can ignore
that case.</p></li>
</ul>
</div></blockquote>
<p>For very simple hardware without VBLANK interrupt, enabling
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>.no_vblank makes DRM’s atomic commit helpers
send a fake VBLANK event at the end of the display update after all
hardware changes have been applied. See
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_fake_vblank" title="drm_atomic_helper_fake_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_fake_vblank()</span></code></a>.</p>
<p>For more complex hardware this
can be handled by the <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function,
which the driver should call on the provided event upon completion of
the atomic commit. Note that if the driver supports vblank signalling
and timestamping the vblank counters and timestamps must agree with
the ones returned from page flip events. With the current vblank
helper infrastructure this can be achieved by holding a vblank
reference while the page flip is pending, acquired through
<a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with <a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_put()</span></code></a>.
Drivers are free to implement their own vblank counter and timestamp
tracking though, e.g. if they have accurate timestamp registers in
hardware.</p>
<p>For hardware which supports some means to synchronize vblank
interrupt delivery with committing display state there’s also
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>. See the documentation of that function
for a detailed discussion of the constraints it needs to be used
safely.</p>
<p>If the device can’t notify of flip completion in a race-free way
at all, then the event should be armed just after the page flip is
committed. In the worst case the driver will send the event to
userspace one frame too late. This doesn’t allow for a real atomic
update, but it should avoid tearing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>This tracks how the commit for this update proceeds through the
various phases. This is never cleared, except when we destroy the
state, so that subsequent commits can synchronize with previous ones.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>backpointer to global drm_atomic_state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the distinction between <strong>enable</strong> and <strong>active</strong> is rather subtle:
Flipping <strong>active</strong> while <strong>enable</strong> is set without changing anything else may
never return in a failure from the <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
callback. Userspace assumes that a DPMS On will always succeed. In other
words: <strong>enable</strong> controls resource assignment, <strong>active</strong> controls the actual
hardware state.</p>
<p>The three booleans active_changed, connectors_changed and mode_changed are
intended to indicate whether a full modeset is needed, rather than strictly
describing what has changed in a commit. See also:
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<p>WARNING: Transitional helpers (like drm_helper_crtc_mode_set() or
drm_helper_crtc_mode_set_base()) do not maintain many of the derived control
state like <strong>plane_mask</strong> so drivers not converted over to atomic helpers should
not rely on these being accurate!</p>
<dl class="c struct">
<dt id="c.drm_crtc_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_crtc_funcs</code><a class="headerlink" href="#c.drm_crtc_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>control CRTCs for a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc_funcs {
  void (*reset)(struct drm_crtc *crtc);
  int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv, uint32_t handle, uint32_t width, uint32_t height);
  int (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,uint32_t handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y);
  int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
  int (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,uint32_t size, struct drm_modeset_acquire_ctx *ctx);
  void (*destroy)(struct drm_crtc *crtc);
  int (*set_config)(struct drm_mode_set *set, struct drm_modeset_acquire_ctx *ctx);
  int (*page_flip)(struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, struct drm_modeset_acquire_ctx *ctx);
  int (*page_flip_target)(struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, uint32_t target, struct drm_modeset_acquire_ctx *ctx);
  int (*set_property)(struct drm_crtc *crtc, struct drm_property *property, uint64_t val);
  struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
  void (*atomic_destroy_state)(struct drm_crtc *crtc, struct drm_crtc_state *state);
  int (*atomic_set_property)(struct drm_crtc *crtc,struct drm_crtc_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_crtc *crtc,const struct drm_crtc_state *state,struct drm_property *property, uint64_t *val);
  int (*late_register)(struct drm_crtc *crtc);
  void (*early_unregister)(struct drm_crtc *crtc);
  int (*set_crc_source)(struct drm_crtc *crtc, const char *source);
  int (*verify_crc_source)(struct drm_crtc *crtc, const char *source, size_t *values_cnt);
  const char *const *(*get_crc_sources)(struct drm_crtc *crtc, size_t *count);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_crtc_state *state);
  u32 (*get_vblank_counter)(struct drm_crtc *crtc);
  int (*enable_vblank)(struct drm_crtc *crtc);
  void (*disable_vblank)(struct drm_crtc *crtc);
  bool (*get_vblank_timestamp)(struct drm_crtc *crtc,int *max_error,ktime_t *vblank_time, bool in_vblank_irq);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Reset CRTC hardware and software state to off. This function isn’t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>.
It’s not a helper hook only for historical reasons.</p>
<p>Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_reset" title="drm_atomic_helper_crtc_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_crtc_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_set</span></code></dt><dd><p>Update the cursor image. The cursor position is relative to the CRTC
and can be partially or fully outside of the visible area.</p>
<p>Note that contrary to all other KMS functions the legacy cursor entry
points don’t take a framebuffer object, but instead take directly a
raw buffer object id from the driver’s buffer manager (which is
either GEM or TTM for current drivers).</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_set2</span></code></dt><dd><p>Update the cursor image, including hotspot information. The hotspot
must not affect the cursor position in CRTC coordinates, but is only
meant as a hint for virtualized display hardware to coordinate the
guests and hosts cursor position. The cursor hotspot is relative to
the cursor image. Otherwise this works exactly like <strong>cursor_set</strong>.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_move</span></code></dt><dd><p>Update the cursor position. The cursor does not need to be visible
when this hook is called.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_set</span></code></dt><dd><p>Set gamma on the CRTC.</p>
<p>This callback is optional.</p>
<p>Atomic drivers who want to support gamma tables should implement the
atomic color management support, enabled by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>, which then supports the legacy gamma
interface through the <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a>
compatibility implementation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Clean up CRTC resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a CRTC cannot be hotplugged
in DRM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_config</span></code></dt><dd><p>This is the main legacy entry point to change the modeset state on a
CRTC. All the details of the desired configuration are passed in a
<a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span></code></a> - see there for details.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_set_config()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_flip</span></code></dt><dd><p>Legacy entry point to schedule a flip to the given framebuffer.</p>
<p>Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing (except when requested otherwise
through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
requests a page flip the DRM core verifies that the new frame buffer
is large enough to be scanned out by the CRTC in the currently
configured mode and then calls this hook with a pointer to the new
frame buffer.</p>
<p>The driver must wait for any pending rendering to the new framebuffer
to complete before executing the flip. It should also wait for any
pending rendering from other drivers if the underlying buffer is a
shared dma-buf.</p>
<p>An application can request to be notified when the page flip has
completed. The drm core will supply a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in the event
parameter in this case. This can be handled by the
<a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function, which the driver should call on
the provided event upon completion of the flip. Note that if
the driver supports vblank signalling and timestamping the vblank
counters and timestamps must agree with the ones returned from page
flip events. With the current vblank helper infrastructure this can
be achieved by holding a vblank reference while the page flip is
pending, acquired through <a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with
<a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_put()</span></code></a>. Drivers are free to implement their own vblank
counter and timestamp tracking though, e.g. if they have accurate
timestamp registers in hardware.</p>
<p>This callback is optional.</p>
<p>NOTE:</p>
<p>Very early versions of the KMS ABI mandated that the driver must
block (but not reject) any rendering to the old framebuffer until the
flip operation has completed and the old framebuffer is no longer
visible. This requirement has been lifted, and userspace is instead
expected to request delivery of an event and wait with recycling old
buffers until such has been received.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure. Note that if a
page flip operation is already pending the callback should return
-EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
or just runtime disabled through DPMS respectively the new atomic
“ACTIVE” state) should result in an -EINVAL error code. Note that
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> checks this already for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_flip_target</span></code></dt><dd><p>Same as <strong>page_flip</strong> but with an additional parameter specifying the
absolute target vertical blank period (as reported by
<a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a>) when the flip should take effect.</p>
<p>Note that the core code calls drm_crtc_vblank_get before this entry
point, and will call drm_crtc_vblank_put if this entry point returns
any non-0 error code. It’s the driver’s responsibility to call
drm_crtc_vblank_put after this entry point returns 0, typically when
the flip completes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_property</span></code></dt><dd><p>This is the legacy entry point to update a property attached to the
CRTC.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current atomic state for this CRTC and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don’t subclass <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_duplicate_state" title="drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_crtc_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_crtc_duplicate_state" title="__drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p>Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p>This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_set_property</span></code></dt><dd><p>Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
drm_atomic_crtc_set_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace’s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p>0 if the property has been found, -EINVAL if the property isn’t
implemented by the driver (which should never happen, the core only
asks for properties attached to this CRTC). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, …) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_property</span></code></dt><dd><p>Reads out the decoded driver-private property. This is used to
implement the GETCRTC IOCTL.</p>
<p>Do not call this function directly, use
drm_atomic_crtc_get_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the property isn’t implemented by the
driver (which should never happen, the core only asks for
properties attached to this CRTC).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_register</span></code></dt><dd><p>This optional hook can be used to register additional userspace
interfaces attached to the crtc like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p>0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_unregister</span></code></dt><dd><p>This optional hook should be used to unregister the additional
userspace interfaces attached to the crtc from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_crc_source</span></code></dt><dd><p>Changes the source of CRC checksums of frames at the request of
userspace, typically for testing purposes. The sources available are
specific of each driver and a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> value indicates that CRC
generation is to be switched off.</p>
<p>When CRC generation is enabled, the driver should call
<a class="reference internal" href="drm-uapi.html#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_add_crc_entry()</span></code></a> at each frame, providing any information
that characterizes the frame contents in the crcN arguments, as
provided from the configured source. Drivers must accept an “auto”
source name that will select a default source for this CRTC.</p>
<p>This may trigger an atomic modeset commit if necessary, to enable CRC
generation.</p>
<p>Note that “auto” can depend upon the current modeset configuration,
e.g. it could pick an encoder or output specific CRC sampling point.</p>
<p>This callback is optional if the driver does not support any CRC
generation functionality.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">verify_crc_source</span></code></dt><dd><p>verifies the source of CRC checksums of frames before setting the
source for CRC and during crc open. Source parameter can be NULL
while disabling crc source.</p>
<p>This callback is optional if the driver does not support any CRC
generation functionality.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_crc_sources</span></code></dt><dd><p>Driver callback for getting a list of all the available sources for
CRC generation. This callback depends upon verify_crc_source, So
verify_crc_source callback should be implemented before implementing
this. Driver can pass full list of available crc sources, this
callback does the verification on each crc-source before passing it
to userspace.</p>
<p>This callback is optional if the driver does not support exporting of
possible CRC sources list.</p>
<p>RETURNS:</p>
<p>a constant character pointer to the list of all the available CRC
sources. On failure driver should return NULL. count should be
updated with number of sources in list. if zero we don’t process any
source from the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_print_state</span></code></dt><dd><p>If driver subclasses <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p>Do not call this directly, use drm_atomic_crtc_print_state()
instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_vblank_counter</span></code></dt><dd><p>Driver callback for fetching a raw hardware vblank counter for the
CRTC. It’s meant to be used by new drivers as the replacement of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.get_vblank_counter</span></code></a> hook.</p>
<p>This callback is optional. If a device doesn’t have a hardware
counter, the driver can simply leave the hook as NULL. The DRM core
will account for missed vblank events while interrupts where disabled
based on system timestamps.</p>
<p>Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_on()</span></code></a> when disabling or
enabling a CRTC.</p>
<p>See also <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.vblank_disable_immediate</span></code></a> and
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.max_vblank_count</span></code></a>.</p>
<p>Returns:</p>
<p>Raw vblank counter value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_vblank</span></code></dt><dd><p>Enable vblank interrupts for the CRTC. It’s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.enable_vblank</span></code></a> hook.</p>
<p>Returns:</p>
<p>Zero on success, appropriate errno if the vblank interrupt cannot
be enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_vblank</span></code></dt><dd><p>Disable vblank interrupts for the CRTC. It’s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.disable_vblank</span></code></a> hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_vblank_timestamp</span></code></dt><dd><p>Called by drm_get_last_vbltimestamp(). Should return a precise
timestamp when the most recent vblank interval ended or will end.</p>
<p>Specifically, the timestamp in <strong>vblank_time</strong> should correspond as
closely as possible to the time when the first video scanline of
the video frame after the end of vblank will start scanning out,
the time immediately after end of the vblank interval. If the
<strong>crtc</strong> is currently inside vblank, this will be a time in the future.
If the <strong>crtc</strong> is currently scanning out a frame, this will be the
past start time of the current scanout. This is meant to adhere
to the OpenML OML_sync_control extension specification.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>crtc:</dt><dd><p>CRTC for which timestamp should be returned.</p>
</dd>
<dt>max_error:</dt><dd><p>Maximum allowable timestamp error in nanoseconds.
Implementation should strive to provide timestamp
with an error of at most max_error nanoseconds.
Returns true upper bound on error for timestamp.</p>
</dd>
<dt>vblank_time:</dt><dd><p>Target location for returned vblank timestamp.</p>
</dd>
<dt>in_vblank_irq:</dt><dd><p>True when called from <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</p>
</dd>
</dl>
<p>Returns:</p>
<p>True on success, false on failure, which means the core should
fallback to a simple timestamp taken in <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The drm_crtc_funcs structure is the central CRTC management structure
in the DRM.  Each CRTC controls one or more connectors (note that the name
CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
connectors, not just CRTs).</p>
<p>Each driver is responsible for filling out this structure at startup time,
in addition to providing other modesetting features, like i2c and DDC
bus accessors.</p>
<dl class="c struct">
<dt id="c.drm_crtc">
<em class="property">struct </em><code class="sig-name descname">drm_crtc</code><a class="headerlink" href="#c.drm_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>central CRTC control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc {
  struct drm_device *dev;
  struct device_node *port;
  struct list_head head;
  char *name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  struct drm_plane *primary;
  struct drm_plane *cursor;
  unsigned index;
  int cursor_x;
  int cursor_y;
  bool enabled;
  struct drm_display_mode mode;
  struct drm_display_mode hwmode;
  int x;
  int y;
  const struct drm_crtc_funcs *funcs;
  uint32_t gamma_size;
  uint16_t *gamma_store;
  const struct drm_crtc_helper_funcs *helper_private;
  struct drm_object_properties properties;
  struct drm_crtc_state *state;
  struct list_head commit_list;
  spinlock_t commit_lock;
#ifdef CONFIG_DEBUG_FS;
  struct dentry *debugfs_entry;
#endif;
  struct drm_crtc_crc crc;
  unsigned int fence_context;
  spinlock_t fence_lock;
  unsigned long fence_seqno;
  char timeline_name[32];
  struct drm_self_refresh_data *self_refresh_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>parent DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>OF node used by <a class="reference internal" href="drm-kms-helpers.html#c.drm_of_find_possible_crtcs" title="drm_of_find_possible_crtcs"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_of_find_possible_crtcs()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List of all CRTCs on <strong>dev</strong>, linked from <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.crtc_list</span></code></a>.
Invariant over the lifetime of <strong>dev</strong> and therefore does not need
locking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>human readable name, can be overwritten by the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>This provides a read lock for the overall CRTC state (mode, dpms
state, …) and a write lock for everything which can be update
without a full modeset (fb, cursor data, CRTC properties …). A full
modeset also need to grab <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>.</p>
<p>For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base KMS object for ID tracking etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">primary</span></code></dt><dd><p>Primary plane for this CRTC. Note that this is only
relevant for legacy IOCTL, it specifies the plane implicitly used by
the SETCRTC and PAGE_FLIP IOCTLs. It does not have any significance
beyond that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>Cursor plane for this CRTC. Note that this is only relevant for
legacy IOCTL, it specifies the plane implicitly used by the SETCURSOR
and SETCURSOR2 IOCTLs. It does not have any significance
beyond that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_x</span></code></dt><dd><p>Current x position of the cursor, used for universal
cursor planes because the SETCURSOR IOCTL only can update the
framebuffer without supplying the coordinates. Drivers should not use
this directly, atomic drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.crtc_x</span></code></a>
of the cursor plane instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor_y</span></code></dt><dd><p>Current y position of the cursor, used for universal
cursor planes because the SETCURSOR IOCTL only can update the
framebuffer without supplying the coordinates. Drivers should not use
this directly, atomic drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.crtc_y</span></code></a>
of the cursor plane instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>Is this CRTC enabled? Should only be used by legacy drivers, atomic
drivers should instead consult <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.enable</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active</span></code></a>. Atomic drivers can update this by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Current mode timings. Should only be used by legacy drivers, atomic
drivers should instead consult <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode</span></code></a>. Atomic drivers
can update this by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwmode</span></code></dt><dd><p>Programmed mode in hw, after adjustments for encoders, crtc, panel
scaling etc. Should only be used by legacy drivers, for high
precision vblank timestamps in
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a>.</p>
<p>Note that atomic drivers should not use this, but instead use
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>. And for high-precision timestamps
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a> used
<a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.hwmode</span></code></a>,
which is filled out by calling <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>x position on screen. Should only be used by legacy drivers, atomic
drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.crtc_x</span></code></a> of the primary plane
instead. Updated by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>y position on screen. Should only be used by legacy drivers, atomic
drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.crtc_y</span></code></a> of the primary plane
instead. Updated by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>CRTC control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_size</span></code></dt><dd><p>Size of legacy gamma ramp reported to userspace. Set up
by calling <a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_store</span></code></dt><dd><p>Gamma ramp values used by the legacy SETGAMMA and
GETGAMMA IOCTls. Set up by calling <a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">helper_private</span></code></dt><dd><p>mid-layer private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt><dd><p>property tracking for this CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Current atomic state for this CRTC.</p>
<p>This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current CRTC state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_crtc_in_state" title="for_each_oldnew_crtc_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_crtc_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_crtc_in_state" title="for_each_old_crtc_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_crtc_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_crtc_in_state" title="for_each_new_crtc_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_crtc_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit_list</span></code></dt><dd><p>List of <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> structures tracking pending commits.
Protected by <strong>commit_lock</strong>. This list holds its own full reference,
as does the ongoing commit.</p>
<p>“Note that the commit for a state change is also tracked in
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.commit</span></code></a>. For accessing the immediately preceding
commit in an atomic update it is recommended to just use that
pointer in the old CRTC state, since accessing that doesn’t need
any locking or list-walking. <strong>commit_list</strong> should only be used to
stall for framebuffer cleanup that’s signalled through
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit.cleanup_done</span></code></a>.”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit_lock</span></code></dt><dd><p>Spinlock to protect <strong>commit_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_entry</span></code></dt><dd><p>Debugfs directory for this CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc</span></code></dt><dd><p>Configuration settings of CRC capture.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_context</span></code></dt><dd><p>timeline context used for fence operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_lock</span></code></dt><dd><p>spinlock to protect the fences in the fence_context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_seqno</span></code></dt><dd><p>Seqno variable used as monotonic counter for the fences
created on the CRTC’s timeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_name</span></code></dt><dd><p>The name of the CRTC’s fence timeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self_refresh_data</span></code></dt><dd><p>Holds the state for the self refresh helpers</p>
<p>Initialized via <a class="reference internal" href="drm-kms-helpers.html#c.drm_self_refresh_helper_init" title="drm_self_refresh_helper_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_self_refresh_helper_init()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors associated with it.  This structure
allows the CRTC to be controlled.</p>
<dl class="c struct">
<dt id="c.drm_mode_set">
<em class="property">struct </em><code class="sig-name descname">drm_mode_set</code><a class="headerlink" href="#c.drm_mode_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>new values for a CRTC config change</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_set {
  struct drm_framebuffer *fb;
  struct drm_crtc *crtc;
  struct drm_display_mode *mode;
  uint32_t x;
  uint32_t y;
  struct drm_connector **connectors;
  size_t num_connectors;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>framebuffer to use for new config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>CRTC whose configuration we’re about to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>mode timings to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>position of this CRTC relative to <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>position of this CRTC relative to <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connectors</span></code></dt><dd><p>array of connectors to drive with this CRTC if possible</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_connectors</span></code></dt><dd><p>size of <strong>connectors</strong> array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a modeset configuration for the legacy SETCRTC ioctl and is
also used internally. Atomic drivers instead use <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_index">
unsigned int <code class="sig-name descname">drm_crtc_index</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the index of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to find index for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the index of that CRTC within a DRM
device’s list of CRTCs.</p>
<dl class="c function">
<dt id="c.drm_crtc_mask">
uint32_t <code class="sig-name descname">drm_crtc_mask</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the mask of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to find mask for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the mask bit of that CRTC for the
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder.possible_crtcs</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.possible_crtcs</span></code></a> fields.</p>
<dl class="c function">
<dt id="c.drm_crtc_find">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<code class="sig-name descname">drm_crtc_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up a CRTC object from its ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a> ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to look up a CRTC from its userspace ID. Only used by
drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
userspace interface should be done using <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_for_each_crtc">
<code class="sig-name descname">drm_for_each_crtc</code><a class="headerlink" href="#c.drm_for_each_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_crtc</span> <span class="pre">(crtc,</span> <span class="pre">dev)</span></code></p>
<blockquote>
<div><p>iterate over all CRTCs</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> as the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all CRTCs of <strong>dev</strong>.</p>
<dl class="c function">
<dt id="c.drm_crtc_from_index">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<code class="sig-name descname">drm_crtc_from_index</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, int <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_from_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the registered CRTC at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of registered CRTC to find for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a CRTC index, return the registered CRTC from DRM device’s
list of CRTCs with matching index. This is the inverse of <a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_index()</span></code></a>.
It’s useful in the vblank callbacks (like <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.enable_vblank</span></code></a> or
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.disable_vblank</span></code></a>), since that still deals with indices instead
of pointers to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>.”</p>
<dl class="c function">
<dt id="c.drm_crtc_init_with_planes">
int <code class="sig-name descname">drm_crtc_init_with_planes</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>primary</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>cursor</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a> *<em>funcs</em>, <em class="property">const</em> char *<em>name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init_with_planes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise a new CRTC object with specified primary and cursor planes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*primary</span></code></dt><dd><p>Primary plane for CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*cursor</span></code></dt><dd><p>Cursor plane for CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for the new CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>printf style format string for the CRTC name, or NULL for default name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inits a new object created as base part of a driver crtc object. Drivers
should use this function instead of <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_init" title="drm_crtc_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init()</span></code></a>, which is only provided
for backwards compatibility with drivers which do not yet support universal
planes). For really simple hardware which has only 1 plane look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_crtc_cleanup">
void <code class="sig-name descname">drm_crtc_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean up the core crtc usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>crtc</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the crtc structure itself,
this is the responsibility of the caller.</p>
<dl class="c function">
<dt id="c.drm_mode_set_config_internal">
int <code class="sig-name descname">drm_mode_set_config_internal</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em>set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_config_internal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper to call <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.set_config</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*set</span></code></dt><dd><p>modeset config to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a little helper to wrap internal calls to the
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> driver interface. The only thing it adds is
correct refcounting dance.</p>
<p>This should only be used by non-atomic legacy drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_crtc_check_viewport">
int <code class="sig-name descname">drm_crtc_check_viewport</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, int <em>x</em>, int <em>y</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_check_viewport" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks that a framebuffer is big enough for the CRTC viewport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC that framebuffer will be displayed on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>x panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>y panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode that framebuffer will be displayed under</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer to check size of</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="frame-buffer-abstraction">
<h2>Frame Buffer Abstraction<a class="headerlink" href="#frame-buffer-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Frame buffers are abstract memory objects that provide a source of pixels to
scanout to a CRTC. Applications explicitly request the creation of frame
buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque
handle that can be passed to the KMS CRTC control, plane configuration and
page flip functions.</p>
<p>Frame buffers rely on the underlying memory manager for allocating backing
storage. When creating a frame buffer applications pass a memory handle
(or a list of memory handles for multi-planar formats) through the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> argument. For drivers using GEM as their userspace
buffer management interface this would be a GEM handle.  Drivers are however
free to use their own backing storage object handles, e.g. vmwgfx directly
exposes special TTM handles to userspace and so expects TTM handles in the
create ioctl and not GEM handles.</p>
<p>Framebuffers are tracked with <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>. They are published
using <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_init()</span></code></a> - after calling that function userspace can use
and access the framebuffer object. The helper function
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a> can be used to pre-fill the required
metadata fields.</p>
<p>The lifetime of a drm framebuffer is controlled with a reference count,
drivers can grab additional references with <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_get()</span></code></a> and drop
them again with <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_put()</span></code></a>. For driver-private framebuffers for
which the last reference is never dropped (e.g. for the fbdev framebuffer
when the struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a> is embedded into the fbdev helper
struct) drivers can manually clean up a framebuffer at module unload time
with <a class="reference internal" href="#c.drm_framebuffer_unregister_private" title="drm_framebuffer_unregister_private"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_unregister_private()</span></code></a>. But doing this is not
recommended, and it’s better to have a normal free-standing <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_framebuffer</span></code></a>.</p>
<div class="section" id="frame-buffer-functions-reference">
<h3>Frame Buffer Functions Reference<a class="headerlink" href="#frame-buffer-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_framebuffer_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_framebuffer_funcs</code><a class="headerlink" href="#c.drm_framebuffer_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>framebuffer hooks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_framebuffer_funcs {
  void (*destroy)(struct drm_framebuffer *framebuffer);
  int (*create_handle)(struct drm_framebuffer *fb,struct drm_file *file_priv, unsigned int *handle);
  int (*dirty)(struct drm_framebuffer *framebuffer,struct drm_file *file_priv, unsigned flags,unsigned color, struct drm_clip_rect *clips, unsigned num_clips);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Clean up framebuffer resources, specifically also unreference the
backing storage. The core guarantees to call this function for every
framebuffer successfully created by calling
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>. Drivers must also call
<a class="reference internal" href="#c.drm_framebuffer_cleanup" title="drm_framebuffer_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_cleanup()</span></code></a> to release DRM core resources for this
framebuffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">create_handle</span></code></dt><dd><p>Create a buffer handle in the driver-specific buffer manager (either
GEM or TTM) valid for the passed-in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a>. This is used by
the core to implement the GETFB IOCTL, which returns (for
sufficiently priviledged user) also a native buffer handle. This can
be used for seamless transitions between modesetting clients by
copying the current screen contents to a private buffer and blending
between that and the new contents.</p>
<p>GEM based drivers should call <a class="reference internal" href="drm-mm.html#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_handle_create()</span></code></a> to create the
handle.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dirty</span></code></dt><dd><p>Optional callback for the dirty fb IOCTL.</p>
<p>Userspace can notify the driver via this callback that an area of the
framebuffer has changed and should be flushed to the display
hardware. This can also be used internally, e.g. by the fbdev
emulation, though that’s not the case currently.</p>
<p>See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
for more information as all the semantics and arguments have a one to
one mapping on this function.</p>
<p>Atomic drivers should use <a class="reference internal" href="#c.drm_atomic_helper_dirtyfb" title="drm_atomic_helper_dirtyfb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_dirtyfb()</span></code></a> to implement
this hook.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_framebuffer">
<em class="property">struct </em><code class="sig-name descname">drm_framebuffer</code><a class="headerlink" href="#c.drm_framebuffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>frame buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_framebuffer {
  struct drm_device *dev;
  struct list_head head;
  struct drm_mode_object base;
  char comm[TASK_COMM_LEN];
  const struct drm_format_info *format;
  const struct drm_framebuffer_funcs *funcs;
  unsigned int pitches[4];
  unsigned int offsets[4];
  uint64_t modifier;
  unsigned int width;
  unsigned int height;
  int flags;
  int hot_x;
  int hot_y;
  struct list_head filp_head;
  struct drm_gem_object *obj[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device this framebuffer belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>Place on the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.fb_list</span></code></a>, access protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.fb_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base modeset object structure, contains the reference count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comm</span></code></dt><dd><p>Name of the process allocating the fb, used for fb dumping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>framebuffer format information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>framebuffer vfunc table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pitches</span></code></dt><dd><p>Line stride per buffer. For userspace created object this
is copied from drm_mode_fb_cmd2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offsets</span></code></dt><dd><p>Offset from buffer start to the actual pixel data in bytes,
per buffer. For userspace created object this is copied from
drm_mode_fb_cmd2.</p>
<p>Note that this is a linear offset and does not take into account
tiling or buffer laytou per <strong>modifier</strong>. It meant to be used when the
actual pixel data for this framebuffer plane starts at an offset,
e.g.  when multiple planes are allocated within the same backing
storage buffer object. For tiled layouts this generally means it
<strong>offsets</strong> must at least be tile-size aligned, but hardware often has
stricter requirements.</p>
<p>This should not be used to specifiy x/y pixel offsets into the buffer
data (even for linear buffers). Specifying an x/y pixel offset is
instead done through the source rectangle in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modifier</span></code></dt><dd><p>Data layout modifier. This is used to describe
tiling, or also special layouts (like compression) of auxiliary
buffers. For userspace created object this is copied from
drm_mode_fb_cmd2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>Logical width of the visible area of the framebuffer, in
pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>Logical height of the visible area of the framebuffer, in
pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Framebuffer flags like DRM_MODE_FB_INTERLACED or
DRM_MODE_FB_MODIFIERS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hot_x</span></code></dt><dd><p>X coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hot_y</span></code></dt><dd><p>Y coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filp_head</span></code></dt><dd><p>Placed on <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.fbs</span></code></a>, protected by <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.fbs_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>GEM objects backing the framebuffer, one per plane (optional).</p>
<p>This is used by the GEM framebuffer helpers, see e.g.
<a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the fb is refcounted for the benefit of driver internals,
for example some hw, disabling a CRTC/plane is asynchronous, and
scanout does not actually complete until the next vblank.  So some
cleanup (like releasing the reference(s) on the backing GEM bo(s))
should be deferred.  In cases like this, the driver would like to
hold a ref to the fb even though it has already been removed from
userspace perspective. See <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_get()</span></code></a> and
<a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<p>The refcount is stored inside the mode object <strong>base</strong>.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_get">
void <code class="sig-name descname">drm_framebuffer_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the framebuffer’s reference count.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_put">
void <code class="sig-name descname">drm_framebuffer_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the framebuffer’s reference count and frees the
framebuffer if the reference count drops to zero.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_read_refcount">
uint32_t <code class="sig-name descname">drm_framebuffer_read_refcount</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_read_refcount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>read the framebuffer reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns the framebuffer’s reference count.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_assign">
void <code class="sig-name descname">drm_framebuffer_assign</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> **<em>p</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_assign" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>store a reference to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">**p</span></code></dt><dd><p>location to store framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>new framebuffer (maybe NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets the location to store a reference to the framebuffer,
unreferencing the framebuffer that was previously stored in that location.</p>
<dl class="c struct">
<dt id="c.drm_afbc_framebuffer">
<em class="property">struct </em><code class="sig-name descname">drm_afbc_framebuffer</code><a class="headerlink" href="#c.drm_afbc_framebuffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>a special afbc frame buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_afbc_framebuffer {
  struct drm_framebuffer base;
  u32 block_width;
  u32 block_height;
  u32 aligned_width;
  u32 aligned_height;
  u32 offset;
  u32 afbc_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base framebuffer structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_width</span></code></dt><dd><p>width of a single afbc block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_height</span></code></dt><dd><p>height of a single afbc block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aligned_width</span></code></dt><dd><p>aligned frame buffer width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aligned_height</span></code></dt><dd><p>aligned frame buffer height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of the first afbc header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">afbc_size</span></code></dt><dd><p>minimum size of afbc buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A derived class of <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>, dedicated for afbc use cases.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_init">
int <code class="sig-name descname">drm_framebuffer_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em>funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>… with these functions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an ID for the framebuffer’s parent mode object, sets its mode
functions &amp; device file and adds it to the master fd list.</p>
<p>IMPORTANT:
This functions publishes the fb and makes it available for concurrent access
by other users. Which means by this point the fb _must_ be fully set up -
since all the fb attributes are invariant over its lifetime, no further
locking but only correct reference counting is required.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_lookup">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<code class="sig-name descname">drm_framebuffer_lookup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_lookup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up a drm framebuffer and grab a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>id of the fb object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this grabs an additional reference to the framebuffer -
callers need to make sure to eventually unreference the returned framebuffer
again, using <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_unregister_private">
void <code class="sig-name descname">drm_framebuffer_unregister_private</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unregister_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a private fb from the lookup idr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>fb to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers need to call this when cleaning up driver-private framebuffers, e.g.
those used for fbdev. Note that the caller must hold a reference of its own,
i.e. the object may not be destroyed through this call (since it’ll lead to a
locking inversion).</p>
<p><strong>NOTE</strong></p>
<p>This function is deprecated. For driver-private framebuffers it is not
recommended to embed a framebuffer struct info fbdev struct, instead, a
framebuffer pointer is preferred and <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_framebuffer_put()</span></code></a> should be called
when the framebuffer is to be cleaned up.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_cleanup">
void <code class="sig-name descname">drm_framebuffer_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup framebuffer. This function is intended to be used from the drivers
<a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs.destroy</span></code></a> callback. It can also be used to clean up
driver private framebuffers embedded into a larger structure.</p>
<p>Note that this function does not remove the fb from active usage - if it is
still used anywhere, hilarity can ensue since userspace could call getfb on
the id and get back -EINVAL. Obviously no concern at driver unload time.</p>
<p>Also, the framebuffer will not be removed from the lookup idr - for
user-created framebuffers this will happen in in the rmfb ioctl. For
driver-private objects (e.g. for fbdev) drivers need to explicitly call
drm_framebuffer_unregister_private.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_remove">
void <code class="sig-name descname">drm_framebuffer_remove</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove and unreference a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans all the CRTCs and planes in <strong>dev</strong>’s mode_config.  If they’re
using <strong>fb</strong>, removes it, setting it to NULL. Then drops the reference to the
passed-in framebuffer. Might take the modeset locks.</p>
<p>Note that this function optimizes the cleanup away if the caller holds the
last reference to the framebuffer. It is also guaranteed to not take the
modeset locks in this case.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_plane_width">
int <code class="sig-name descname">drm_framebuffer_plane_width</code><span class="sig-paren">(</span>int <em>width</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_width" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width of the first plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="c function">
<dt id="c.drm_framebuffer_plane_height">
int <code class="sig-name descname">drm_framebuffer_plane_height</code><span class="sig-paren">(</span>int <em>height</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_height" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height of the first plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
</div>
</div>
<div class="section" id="drm-format-handling">
<h2>DRM Format Handling<a class="headerlink" href="#drm-format-handling" title="Permalink to this headline">¶</a></h2>
<p>In the DRM subsystem, framebuffer pixel formats are described using the
fourcc codes defined in <cite>include/uapi/drm/drm_fourcc.h</cite>. In addition to the
fourcc code, a Format Modifier may optionally be provided, in order to
further describe the buffer’s format - for example tiling or compression.</p>
<div class="section" id="format-modifiers">
<h3>Format Modifiers<a class="headerlink" href="#format-modifiers" title="Permalink to this headline">¶</a></h3>
<p>Format modifiers are used in conjunction with a fourcc code, forming a
unique fourcc:modifier pair. This format:modifier pair must fully define the
format and data layout of the buffer, and should be the only way to describe
that particular buffer.</p>
<p>Having multiple fourcc:modifier pairs which describe the same layout should
be avoided, as such aliases run the risk of different drivers exposing
different names for the same data format, forcing userspace to understand
that they are aliases.</p>
<p>Format modifiers may change any property of the buffer, including the number
of planes and/or the required allocation size. Format modifiers are
vendor-namespaced, and as such the relationship between a fourcc code and a
modifier is specific to the modifer being used. For example, some modifiers
may preserve meaning - such as number of planes - from the fourcc code,
whereas others may not.</p>
<p>Vendors should document their modifier usage in as much detail as
possible, to ensure maximum compatibility across devices, drivers and
applications.</p>
<p>The authoritative list of format modifier codes is found in
<cite>include/uapi/drm/drm_fourcc.h</cite></p>
</div>
<div class="section" id="format-functions-reference">
<h3>Format Functions Reference<a class="headerlink" href="#format-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_format_info">
<em class="property">struct </em><code class="sig-name descname">drm_format_info</code><a class="headerlink" href="#c.drm_format_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>information about a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_format_info {
  u32 format;
  u8 depth;
  u8 num_planes;
  union {
    u8 cpp[4];
    u8 char_per_block[4];
  };
  u8 block_w[4];
  u8 block_h[4];
  u8 hsub;
  u8 vsub;
  bool has_alpha;
  bool is_yuv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>4CC format identifier (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">depth</span></code></dt><dd><p>Color depth (number of bits per pixel excluding padding bits),
valid for a subset of RGB formats only. This is a legacy field, do
not use in new code and set to 0 for new formats.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_planes</span></code></dt><dd><p>Number of color planes (1 to 3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpp</span></code></dt><dd><p>Number of bytes per pixel (per plane), this is aliased with
<strong>char_per_block</strong>. It is deprecated in favour of using the
triplet <strong>char_per_block</strong>, <strong>block_w</strong>, <strong>block_h</strong> for better
describing the pixel format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char_per_block</span></code></dt><dd><p>Number of bytes per block (per plane), where blocks are
defined as a rectangle of pixels which are stored next to
each other in a byte aligned memory region. Together with
<strong>block_w</strong> and <strong>block_h</strong> this is used to properly describe tiles
in tiled formats or to describe groups of pixels in packed
formats for which the memory needed for a single pixel is not
byte aligned.</p>
<p><strong>cpp</strong> has been kept for historical reasons because there are
a lot of places in drivers where it’s used. In drm core for
generic code paths the preferred way is to use
<strong>char_per_block</strong>, <a class="reference internal" href="#c.drm_format_info_block_width" title="drm_format_info_block_width"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_format_info_block_width()</span></code></a> and
<a class="reference internal" href="#c.drm_format_info_block_height" title="drm_format_info_block_height"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_format_info_block_height()</span></code></a> which allows handling both
block and non-block formats in the same way.</p>
<p>For formats that are intended to be used only with non-linear
modifiers both <strong>cpp</strong> and <strong>char_per_block</strong> must be 0 in the
generic format table. Drivers could supply accurate
information from their drm_mode_config.get_format_info hook
if they want the core to be validating the pitch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_w</span></code></dt><dd><p>Block width in pixels, this is intended to be accessed through
<a class="reference internal" href="#c.drm_format_info_block_width" title="drm_format_info_block_width"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_format_info_block_width()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_h</span></code></dt><dd><p>Block height in pixels, this is intended to be accessed through
<a class="reference internal" href="#c.drm_format_info_block_height" title="drm_format_info_block_height"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_format_info_block_height()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hsub</span></code></dt><dd><p>Horizontal chroma subsampling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsub</span></code></dt><dd><p>Vertical chroma subsampling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_alpha</span></code></dt><dd><p>Does the format embeds an alpha component?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_yuv</span></code></dt><dd><p>Is it a YUV format?</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_format_name_buf">
<em class="property">struct </em><code class="sig-name descname">drm_format_name_buf</code><a class="headerlink" href="#c.drm_format_name_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>name of a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_format_name_buf {
  char str[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">str</span></code></dt><dd><p>string buffer containing the format name</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_packed">
bool <code class="sig-name descname">drm_format_info_is_yuv_packed</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_packed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with data laid in a single plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a packed YUV format.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_semiplanar">
bool <code class="sig-name descname">drm_format_info_is_yuv_semiplanar</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_semiplanar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with data laid in two planes (luminance and chrominance)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a semiplanar YUV format.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_planar">
bool <code class="sig-name descname">drm_format_info_is_yuv_planar</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_planar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with data laid in three planes (one for each YUV component)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a planar YUV format.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_sampling_410">
bool <code class="sig-name descname">drm_format_info_is_yuv_sampling_410</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_sampling_410" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with 4:1:0 sub-sampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a YUV format with 4:1:0
sub-sampling.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_sampling_411">
bool <code class="sig-name descname">drm_format_info_is_yuv_sampling_411</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_sampling_411" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with 4:1:1 sub-sampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a YUV format with 4:1:1
sub-sampling.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_sampling_420">
bool <code class="sig-name descname">drm_format_info_is_yuv_sampling_420</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_sampling_420" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with 4:2:0 sub-sampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a YUV format with 4:2:0
sub-sampling.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_sampling_422">
bool <code class="sig-name descname">drm_format_info_is_yuv_sampling_422</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_sampling_422" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with 4:2:2 sub-sampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a YUV format with 4:2:2
sub-sampling.</p>
<dl class="c function">
<dt id="c.drm_format_info_is_yuv_sampling_444">
bool <code class="sig-name descname">drm_format_info_is_yuv_sampling_444</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_is_yuv_sampling_444" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that the format info matches a YUV format with 4:4:4 sub-sampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>format info</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the format info matches a YUV format with 4:4:4
sub-sampling.</p>
<dl class="c function">
<dt id="c.drm_format_info_plane_width">
int <code class="sig-name descname">drm_format_info_plane_width</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em>, int <em>width</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_plane_width" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>pixel format info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width of the first plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="c function">
<dt id="c.drm_format_info_plane_height">
int <code class="sig-name descname">drm_format_info_plane_height</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em>, int <em>height</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_plane_height" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>pixel format info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height of the first plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
<dl class="c function">
<dt id="c.drm_mode_legacy_fb_format">
uint32_t <code class="sig-name descname">drm_mode_legacy_fb_format</code><span class="sig-paren">(</span>uint32_t <em>bpp</em>, uint32_t <em>depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_legacy_fb_format" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compute drm fourcc code from legacy description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">bpp</span></code></dt><dd><p>bits per pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">depth</span></code></dt><dd><p>bit depth per pixel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes a drm fourcc pixel format code for the given <strong>bpp</strong>/<strong>depth</strong> values.
Useful in fbdev emulation code, since that deals in those values.</p>
<dl class="c function">
<dt id="c.drm_driver_legacy_fb_format">
uint32_t <code class="sig-name descname">drm_driver_legacy_fb_format</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, uint32_t <em>bpp</em>, uint32_t <em>depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_driver_legacy_fb_format" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compute drm fourcc code from legacy description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">bpp</span></code></dt><dd><p>bits per pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">depth</span></code></dt><dd><p>bit depth per pixel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes a drm fourcc pixel format code for the given <strong>bpp</strong>/<strong>depth</strong> values.
Unlike <a class="reference internal" href="#c.drm_mode_legacy_fb_format" title="drm_mode_legacy_fb_format"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_legacy_fb_format()</span></code></a> this looks at the drivers mode_config,
and depending on the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.quirk_addfb_prefer_host_byte_order</span></code></a> flag
it returns little endian byte order or host byte order framebuffer formats.</p>
<dl class="c function">
<dt id="c.drm_get_format_name">
<em class="property">const</em> char *<code class="sig-name descname">drm_get_format_name</code><span class="sig-paren">(</span>uint32_t <em>format</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_name_buf" title="drm_format_name_buf">drm_format_name_buf</a> *<em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill a string with a drm fourcc format’s name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt><dd><p>format to compute name of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_format_name_buf</span> <span class="pre">*buf</span></code></dt><dd><p>caller-supplied buffer</p>
</dd>
</dl>
<dl class="c function">
<dt>
<em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<code class="sig-name descname">drm_format_info</code><span class="sig-paren">(</span>u32 <em>format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>query information for a given format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">format</span></code></dt><dd><p>pixel format (DRM_FORMAT_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller should only pass a supported pixel format to this function.
Unsupported pixel formats will generate a warning in the kernel log.</p>
<p><strong>Return</strong></p>
<p>The instance of <a class="reference internal" href="#c.drm_format_info" title="drm_format_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_format_info</span></code></a> that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="c function">
<dt id="c.drm_get_format_info">
<em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<code class="sig-name descname">drm_get_format_info</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> drm_mode_fb_cmd2 *<em>mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>query information for a given framebuffer configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>metadata from the userspace fb creation request</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The instance of <a class="reference internal" href="#c.drm_format_info" title="drm_format_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_format_info</span></code></a> that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="c function">
<dt id="c.drm_format_info_block_width">
unsigned int <code class="sig-name descname">drm_format_info_block_width</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_block_width" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>width in pixels of block.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>pixel format info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width in pixels of a block, depending on the plane index.</p>
<dl class="c function">
<dt id="c.drm_format_info_block_height">
unsigned int <code class="sig-name descname">drm_format_info_block_height</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em>, int <em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_block_height" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>height in pixels of a block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>pixel format info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height in pixels of a block, depending on the plane index.</p>
<dl class="c function">
<dt id="c.drm_format_info_min_pitch">
uint64_t <code class="sig-name descname">drm_format_info_min_pitch</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>info</em>, int <em>plane</em>, unsigned int <em>buffer_width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_info_min_pitch" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes the minimum required pitch in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*info</span></code></dt><dd><p>pixel format info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>plane index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buffer_width</span></code></dt><dd><p>buffer width in pixels</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The minimum required pitch in bytes for a buffer by taking into consideration
the pixel format information and the buffer width.</p>
</div>
</div>
<div class="section" id="dumb-buffer-objects">
<h2>Dumb Buffer Objects<a class="headerlink" href="#dumb-buffer-objects" title="Permalink to this headline">¶</a></h2>
<p>The KMS API doesn’t standardize backing storage object creation and leaves it
to driver-specific ioctls. Furthermore actually creating a buffer object even
for GEM-based drivers is done through a driver-specific ioctl - GEM only has
a common userspace interface for sharing and destroying objects. While not an
issue for full-fledged graphics stacks that include device-specific userspace
components (in libdrm for instance), this limit makes DRM-based early boot
graphics unnecessarily complex.</p>
<p>Dumb objects partly alleviate the problem by providing a standard API to
create dumb buffers suitable for scanout, which can then be used to create
KMS frame buffers.</p>
<p>To support dumb objects drivers must implement the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_create</span></code></a>
operation. <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_destroy</span></code></a> defaults to <a class="reference internal" href="drm-mm.html#c.drm_gem_dumb_destroy" title="drm_gem_dumb_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dumb_destroy()</span></code></a> if
not set and <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_map_offset</span></code></a> defaults to
<a class="reference internal" href="drm-mm.html#c.drm_gem_dumb_map_offset" title="drm_gem_dumb_map_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dumb_map_offset()</span></code></a>. See the callbacks for further details.</p>
<p>Note that dumb objects may not be used for gpu acceleration, as has been
attempted on some ARM embedded platforms. Such drivers really must have
a hardware-specific ioctl to allocate suitable buffer objects.</p>
</div>
<div class="section" id="plane-abstraction">
<h2>Plane Abstraction<a class="headerlink" href="#plane-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A plane represents an image source that can be blended with or overlayed on
top of a CRTC during the scanout process. Planes take their input data from a
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> object. The plane itself specifies the cropping and scaling
of that image, and where it is placed on the visible are of a display
pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>. A plane can also have additional
properties that specify how the pixels are positioned and blended, like
rotation or Z-position. All these properties are stored in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>To create a plane, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_universal_plane_init()</span></code></a>.</p>
<p>Cursor and overlay planes are optional. All drivers should provide one
primary plane per CRTC to avoid surprising userspace too much. See <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">drm_plane_type</span></code></a> for a more in-depth discussion of these special uapi-relevant
plane types. Special planes are associated with their CRTC by calling
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The type of a plane is exposed in the immutable “type” enumeration property,
which has one of the following values: “Overlay”, “Primary”, “Cursor”.</p>
<div class="section" id="plane-functions-reference">
<h3>Plane Functions Reference<a class="headerlink" href="#plane-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_plane_state">
<em class="property">struct </em><code class="sig-name descname">drm_plane_state</code><a class="headerlink" href="#c.drm_plane_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mutable plane state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_plane_state {
  struct drm_plane *plane;
  struct drm_crtc *crtc;
  struct drm_framebuffer *fb;
  struct dma_fence *fence;
  int32_t crtc_x;
  int32_t crtc_y;
  uint32_t crtc_w, crtc_h;
  uint32_t src_x;
  uint32_t src_y;
  uint32_t src_h, src_w;
  u16 alpha;
  uint16_t pixel_blend_mode;
  unsigned int rotation;
  unsigned int zpos;
  unsigned int normalized_zpos;
  enum drm_color_encoding color_encoding;
  enum drm_color_range color_range;
  struct drm_property_blob *fb_damage_clips;
  struct drm_rect src, dst;
  bool visible;
  struct drm_crtc_commit *commit;
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>backpointer to the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>Currently bound CRTC, NULL if disabled. Do not this write directly,
use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_plane" title="drm_atomic_set_crtc_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_crtc_for_plane()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>Currently bound framebuffer. Do not write this directly, use
<a class="reference internal" href="#c.drm_atomic_set_fb_for_plane" title="drm_atomic_set_fb_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_fb_for_plane()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>Optional fence to wait for before scanning out <strong>fb</strong>. The core atomic
code will set this when userspace is using explicit fencing. Do not
write this field directly for a driver’s implicit fence, use
<a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a> to ensure that an explicit fence is
preserved.</p>
<p>Drivers should store any implicit fence in this from their
<a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> callback. See <a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_prepare_fb" title="drm_gem_fb_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_prepare_fb()</span></code></a>
and <a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_simple_display_pipe_prepare_fb" title="drm_gem_fb_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_simple_display_pipe_prepare_fb()</span></code></a> for suitable helpers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_x</span></code></dt><dd><p>Left position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_y</span></code></dt><dd><p>Upper position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_w</span></code></dt><dd><p>width of visible portion of plane on crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_h</span></code></dt><dd><p>height of visible portion of plane on crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_x</span></code></dt><dd><p>left position of visible portion of plane within plane (in
16.16 fixed point).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_y</span></code></dt><dd><p>upper position of visible portion of plane within plane (in
16.16 fixed point).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_h</span></code></dt><dd><p>height of visible portion of plane (in 16.16)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_w</span></code></dt><dd><p>width of visible portion of plane (in 16.16)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alpha</span></code></dt><dd><p>Opacity of the plane with 0 as completely transparent and 0xffff as
completely opaque. See <a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_alpha_property()</span></code></a> for more
details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixel_blend_mode</span></code></dt><dd><p>The alpha blending equation selection, describing how the pixels from
the current plane are composited with the background. Value can be
one of DRM_MODE_BLEND_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rotation</span></code></dt><dd><p>Rotation of the plane. See <a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_rotation_property()</span></code></a> for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zpos</span></code></dt><dd><p>Priority of the given plane on crtc (optional).</p>
<p>User-space may set mutable zpos properties so that multiple active
planes on the same CRTC have identical zpos values. This is a
user-space bug, but drivers can solve the conflict by comparing the
plane object IDs; the plane with a higher ID is stacked on top of a
plane with a lower ID.</p>
<p>See <a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_property()</span></code></a> and
<a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">normalized_zpos</span></code></dt><dd><p>Normalized value of zpos: unique, range from 0 to N-1 where N is the
number of active planes for given crtc. Note that the driver must set
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.normalize_zpos</span></code></a> or call <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> to
update this before it can be trusted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_encoding</span></code></dt><dd><p>Color encoding for non RGB formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_range</span></code></dt><dd><p>Color range for non RGB formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_damage_clips</span></code></dt><dd><p>Blob representing damage (area in plane framebuffer that changed
since last plane update) as an array of <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a> in framebuffer
coodinates of the attached framebuffer. Note that unlike plane src,
damage clips are not in 16.16 fixed point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>source coordinates of the plane (in 16.16).</p>
<p>When using <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a>,
the coordinates are clipped, but the driver may choose
to use unclipped coordinates instead when the hardware
performs the clipping automatically.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst</span></code></dt><dd><p>clipped destination coordinates of the plane.</p>
<p>When using <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a>,
the coordinates are clipped, but the driver may choose
to use unclipped coordinates instead when the hardware
performs the clipping automatically.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">visible</span></code></dt><dd><p>Visibility of the plane. This can be false even if fb!=NULL and
crtc!=NULL, due to clipping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>Tracks the pending commit to prevent use-after-free conditions,
and for async plane updates.</p>
<p>May be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>backpointer to global drm_atomic_state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Please not that the destination coordinates <strong>crtc_x</strong>, <strong>crtc_y</strong>, <strong>crtc_h</strong> and
<strong>crtc_w</strong> and the source coordinates <strong>src_x</strong>, <strong>src_y</strong>, <strong>src_h</strong> and <strong>src_w</strong> are the
raw coordinates provided by userspace. Drivers should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a> and only use the derived rectangles in
<strong>src</strong> and <strong>dst</strong> to program the hardware.</p>
<dl class="c struct">
<dt id="c.drm_plane_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_plane_funcs</code><a class="headerlink" href="#c.drm_plane_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>driver plane control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_plane_funcs {
  int (*update_plane)(struct drm_plane *plane,struct drm_crtc *crtc, struct drm_framebuffer *fb,int crtc_x, int crtc_y,unsigned int crtc_w, unsigned int crtc_h,uint32_t src_x, uint32_t src_y,uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx *ctx);
  int (*disable_plane)(struct drm_plane *plane, struct drm_modeset_acquire_ctx *ctx);
  void (*destroy)(struct drm_plane *plane);
  void (*reset)(struct drm_plane *plane);
  int (*set_property)(struct drm_plane *plane, struct drm_property *property, uint64_t val);
  struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
  void (*atomic_destroy_state)(struct drm_plane *plane, struct drm_plane_state *state);
  int (*atomic_set_property)(struct drm_plane *plane,struct drm_plane_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_plane *plane,const struct drm_plane_state *state,struct drm_property *property, uint64_t *val);
  int (*late_register)(struct drm_plane *plane);
  void (*early_unregister)(struct drm_plane *plane);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_plane_state *state);
  bool (*format_mod_supported)(struct drm_plane *plane, uint32_t format, uint64_t modifier);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">update_plane</span></code></dt><dd><p>This is the legacy entry point to enable and configure the plane for
the given CRTC and framebuffer. It is never called to disable the
plane, i.e. the passed-in crtc and fb paramters are never NULL.</p>
<p>The source rectangle in frame buffer memory coordinates is given by
the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
values). Devices that don’t support subpixel plane coordinates can
ignore the fractional part.</p>
<p>The destination rectangle in CRTC coordinates is given by the
crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
Devices scale the source rectangle to the destination rectangle. If
scaling is not supported, and the source rectangle size doesn’t match
the destination rectangle size, the driver must return a
-&lt;errorname&gt;EINVAL&lt;/errorname&gt; error.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_plane" title="drm_atomic_helper_update_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_plane</span></code></dt><dd><p>This is the legacy entry point to disable the plane. The DRM core
calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
with the frame buffer ID set to 0.  Disabled planes must not be
processed by the CRTC.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Clean up plane resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a plane cannot be hotplugged
in DRM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Reset plane hardware and software state to off. This function isn’t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>.
It’s not a helper hook only for historical reasons.</p>
<p>Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_reset" title="drm_atomic_helper_plane_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_plane_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_property</span></code></dt><dd><p>This is the legacy entry point to update a property attached to the
plane.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current atomic state for this plane and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don’t subclass <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_duplicate_state" title="drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_plane_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_plane_duplicate_state" title="__drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">__drm_atomic_helper_plane_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p>Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p>This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_set_property</span></code></dt><dd><p>Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
drm_atomic_plane_set_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace’s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p>0 if the property has been found, -EINVAL if the property isn’t
implemented by the driver (which shouldn’t ever happen, the core only
asks for properties attached to this plane). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, …) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_property</span></code></dt><dd><p>Reads out the decoded driver-private property. This is used to
implement the GETPLANE IOCTL.</p>
<p>Do not call this function directly, use
drm_atomic_plane_get_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the property isn’t implemented by the
driver (which should never happen, the core only asks for
properties attached to this plane).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_register</span></code></dt><dd><p>This optional hook can be used to register additional userspace
interfaces attached to the plane like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p>0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_unregister</span></code></dt><dd><p>This optional hook should be used to unregister the additional
userspace interfaces attached to the plane from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_print_state</span></code></dt><dd><p>If driver subclasses <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p>Do not call this directly, use drm_atomic_plane_print_state()
instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_mod_supported</span></code></dt><dd><p>This optional hook is used for the DRM to determine if the given
format/modifier combination is valid for the plane. This allows the
DRM to generate the correct format bitmask (which formats apply to
which modifier), and to valdiate modifiers at atomic_check time.</p>
<p>If not present, then any modifier in the plane’s modifier
list is allowed with any of the plane’s formats.</p>
<p>Returns:</p>
<p>True if the given modifier is valid for that format on the plane.
False otherwise.</p>
</dd>
</dl>
<dl class="c enum">
<dt id="c.drm_plane_type">
<em class="property">enum </em><code class="sig-name descname">drm_plane_type</code><a class="headerlink" href="#c.drm_plane_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>uapi plane type enumeration</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PLANE_TYPE_OVERLAY</span></code></dt><dd><p>Overlay planes represent all non-primary, non-cursor planes. Some
drivers refer to these types of planes as “sprites” internally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PLANE_TYPE_PRIMARY</span></code></dt><dd><p>Primary planes represent a “main” plane for a CRTC.  Primary planes
are the planes operated upon by CRTC modesetting and flipping
operations described in the <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_config</span></code></a> hooks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PLANE_TYPE_CURSOR</span></code></dt><dd><p>Cursor planes represent a “cursor” plane for a CRTC.  Cursor planes
are the planes operated upon by the DRM_IOCTL_MODE_CURSOR and
DRM_IOCTL_MODE_CURSOR2 IOCTLs.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For historical reasons not all planes are made the same. This enumeration is
used to tell the different types of planes apart to implement the different
uapi semantics for them. For userspace which is universal plane aware and
which is using that atomic IOCTL there’s no difference between these planes
(beyong what the driver and hardware can support of course).</p>
<p>For compatibility with legacy userspace, only overlay planes are made
available to userspace by default. Userspace clients may set the
DRM_CLIENT_CAP_UNIVERSAL_PLANES client capability bit to indicate that they
wish to receive a universal plane list containing all plane types. See also
<a class="reference internal" href="#c.drm_for_each_legacy_plane" title="drm_for_each_legacy_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_for_each_legacy_plane()</span></code></a>.</p>
<p>WARNING: The values of this enum is UABI since they’re exposed in the “type”
property.</p>
<dl class="c struct">
<dt id="c.drm_plane">
<em class="property">struct </em><code class="sig-name descname">drm_plane</code><a class="headerlink" href="#c.drm_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>central DRM plane control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_plane {
  struct drm_device *dev;
  struct list_head head;
  char *name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  uint32_t possible_crtcs;
  uint32_t *format_types;
  unsigned int format_count;
  bool format_default;
  uint64_t *modifiers;
  unsigned int modifier_count;
  struct drm_crtc *crtc;
  struct drm_framebuffer *fb;
  struct drm_framebuffer *old_fb;
  const struct drm_plane_funcs *funcs;
  struct drm_object_properties properties;
  enum drm_plane_type type;
  unsigned index;
  const struct drm_plane_helper_funcs *helper_private;
  struct drm_plane_state *state;
  struct drm_property *alpha_property;
  struct drm_property *zpos_property;
  struct drm_property *rotation_property;
  struct drm_property *blend_mode_property;
  struct drm_property *color_encoding_property;
  struct drm_property *color_range_property;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device this plane belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List of all planes on <strong>dev</strong>, linked from <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.plane_list</span></code></a>.
Invariant over the lifetime of <strong>dev</strong> and therefore does not need
locking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>human readable name, can be overwritten by the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>Protects modeset plane state, together with the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.mutex</span></code></a> of
CRTC this plane is linked to (when active, getting activated or
getting disabled).</p>
<p>For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base mode object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_crtcs</span></code></dt><dd><p>pipes this plane can be bound to constructed from
<a class="reference internal" href="#c.drm_crtc_mask" title="drm_crtc_mask"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_mask()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_types</span></code></dt><dd><p>array of formats supported by this plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_count</span></code></dt><dd><p>Size of the array pointed at by <strong>format_types</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_default</span></code></dt><dd><p>driver hasn’t supplied supported formats for the
plane. Used by the drm_plane_init compatibility wrapper only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modifiers</span></code></dt><dd><p>array of modifiers supported by this plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modifier_count</span></code></dt><dd><p>Size of the array pointed at by <strong>modifier_count</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>Currently bound CRTC, only meaningful for non-atomic drivers. For
atomic drivers this is forced to be NULL, atomic drivers should
instead check <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.crtc</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>Currently bound framebuffer, only meaningful for non-atomic drivers.
For atomic drivers this is forced to be NULL, atomic drivers should
instead check <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fb</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_fb</span></code></dt><dd><p>Temporary tracking of the old fb while a modeset is ongoing. Only
used by non-atomic drivers, forced to be NULL for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>plane control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt><dd><p>property tracking for this plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of plane, see <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a> for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">helper_private</span></code></dt><dd><p>mid-layer private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Current atomic state for this plane.</p>
<p>This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current plane state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_plane_in_state" title="for_each_oldnew_plane_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_plane_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_plane_in_state" title="for_each_old_plane_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_plane_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_plane_in_state" title="for_each_new_plane_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_plane_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alpha_property</span></code></dt><dd><p>Optional alpha property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_alpha_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zpos_property</span></code></dt><dd><p>Optional zpos property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rotation_property</span></code></dt><dd><p>Optional rotation property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_rotation_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blend_mode_property</span></code></dt><dd><p>Optional “pixel blend mode” enum property for this plane.
Blend mode property represents the alpha blending equation selection,
describing how the pixels from the current plane are composited with
the background.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_encoding_property</span></code></dt><dd><p>Optional “COLOR_ENCODING” enum property for specifying
color encoding for non RGB formats.
See <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_range_property</span></code></dt><dd><p>Optional “COLOR_RANGE” enum property for specifying
color range for non RGB formats.
See <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Planes represent the scanout hardware of a display block. They receive their
input data from a <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> and feed it to a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>. Planes control
the color conversion, see <a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a> for more details,
and are also involved in the color conversion of input pixels, see <a class="reference internal" href="#color-management-properties">Color
Management Properties</a> for details on that.</p>
<dl class="c function">
<dt id="c.drm_plane_index">
unsigned int <code class="sig-name descname">drm_plane_index</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the index of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to find index for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered plane, return the index of that plane within a DRM
device’s list of planes.</p>
<dl class="c function">
<dt id="c.drm_plane_mask">
u32 <code class="sig-name descname">drm_plane_mask</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the mask of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to find mask for</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_plane_find">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<code class="sig-name descname">drm_plane_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>plane id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the plane with <strong>id</strong>, NULL if it doesn’t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_for_each_plane_mask">
<code class="sig-name descname">drm_for_each_plane_mask</code><a class="headerlink" href="#c.drm_for_each_plane_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_plane_mask</span> <span class="pre">(plane,</span> <span class="pre">dev,</span> <span class="pre">plane_mask)</span></code></p>
<blockquote>
<div><p>iterate over planes specified by bitmask</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_mask</span></code></dt><dd><p>bitmask of plane indices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes specified by bitmask.</p>
<dl class="c macro">
<dt id="c.drm_for_each_legacy_plane">
<code class="sig-name descname">drm_for_each_legacy_plane</code><a class="headerlink" href="#c.drm_for_each_legacy_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_legacy_plane</span> <span class="pre">(plane,</span> <span class="pre">dev)</span></code></p>
<blockquote>
<div><p>iterate over all planes for legacy userspace</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all legacy planes of <strong>dev</strong>, excluding primary and cursor planes.
This is useful for implementing userspace apis when userspace is not
universal plane aware. See also <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_for_each_plane">
<code class="sig-name descname">drm_for_each_plane</code><a class="headerlink" href="#c.drm_for_each_plane" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_plane</span> <span class="pre">(plane,</span> <span class="pre">dev)</span></code></p>
<blockquote>
<div><p>iterate over all planes</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes of <strong>dev</strong>, include primary and cursor planes.</p>
<dl class="c function">
<dt id="c.drm_plane_get_damage_clips_count">
unsigned int <code class="sig-name descname">drm_plane_get_damage_clips_count</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_get_damage_clips_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns damage clips count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple helper to get the number of <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a> clips set by user-space
during plane update.</p>
<p><strong>Return</strong></p>
<p>Number of clips in plane fb_damage_clips blob property.</p>
<dl class="c function">
<dt id="c.drm_plane_get_damage_clips">
<em class="property">struct</em> <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect">drm_mode_rect</a> *<code class="sig-name descname">drm_plane_get_damage_clips</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_get_damage_clips" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns damage clips.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function returns uapi type <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a>. Drivers might
instead be interested in internal <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_rect</span></code></a> which can be obtained by calling
<a class="reference internal" href="#c.drm_helper_get_plane_damage_clips" title="drm_helper_get_plane_damage_clips"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_get_plane_damage_clips()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Damage clips in plane fb_damage_clips blob property.</p>
<dl class="c function">
<dt id="c.drm_universal_plane_init">
int <code class="sig-name descname">drm_universal_plane_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, uint32_t <em>possible_crtcs</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>funcs</em>, <em class="property">const</em> uint32_t *<em>formats</em>, unsigned int <em>format_count</em>, <em class="property">const</em> uint64_t *<em>format_modifiers</em>, <em class="property">enum</em> <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type">drm_plane_type</a> <em>type</em>, <em class="property">const</em> char *<em>name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_universal_plane_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a new universal plane object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt><dd><p>bitmask of possible CRTCs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for the new plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*formats</span></code></dt><dd><p>array of supported formats (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint64_t</span> <span class="pre">*format_modifiers</span></code></dt><dd><p>array of struct drm_format modifiers terminated by
DRM_FORMAT_MOD_INVALID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_plane_type</span> <span class="pre">type</span></code></dt><dd><p>type of plane (overlay, primary, cursor)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>printf style format string for the plane name, or NULL for default name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a plane object of type <strong>type</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_plane_init">
int <code class="sig-name descname">drm_plane_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, uint32_t <em>possible_crtcs</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>funcs</em>, <em class="property">const</em> uint32_t *<em>formats</em>, unsigned int <em>format_count</em>, bool <em>is_primary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a legacy plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt><dd><p>bitmask of possible CRTCs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for the new plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*formats</span></code></dt><dd><p>array of supported formats (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_primary</span></code></dt><dd><p>plane type (primary vs overlay)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy API to initialize a DRM plane.</p>
<p>New drivers should call <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_universal_plane_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_plane_cleanup">
void <code class="sig-name descname">drm_plane_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean up the core plane usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>plane</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the plane structure itself,
this is the responsibility of the caller.</p>
<dl class="c function">
<dt id="c.drm_plane_from_index">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<code class="sig-name descname">drm_plane_from_index</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, int <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_from_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the registered plane at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of registered plane to find for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a plane index, return the registered plane from DRM device’s
list of planes with matching index. This is the inverse of <a class="reference internal" href="#c.drm_plane_index" title="drm_plane_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_index()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_plane_force_disable">
void <code class="sig-name descname">drm_plane_force_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_force_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Forcibly disable a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces the plane to be disabled.</p>
<p>Used when the plane’s current framebuffer is destroyed,
and when restoring fbdev mode.</p>
<p>Note that this function is not suitable for atomic drivers, since it doesn’t
wire through the lock acquisition context properly and hence can’t handle
retries or driver private locks. You probably want to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> instead.</p>
<dl class="c function">
<dt id="c.drm_mode_plane_set_obj_prop">
int <code class="sig-name descname">drm_mode_plane_set_obj_prop</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint64_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_plane_set_obj_prop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane object to set property value for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt><dd><p>value the property should be set to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets a given property on a given plane object. This function
calls the driver’s -&gt;set_property callback and changes the software state of
the property if the callback succeeds.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_any_plane_has_format">
bool <code class="sig-name descname">drm_any_plane_has_format</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>format</em>, u64 <em>modifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_any_plane_has_format" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check whether any plane supports this format and modifier combination</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">format</span></code></dt><dd><p>pixel format (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">modifier</span></code></dt><dd><p>data layout modifier</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Whether at least one plane supports the specified format and modifier combination.</p>
</div>
</div>
<div class="section" id="display-modes-function-reference">
<h2>Display Modes Function Reference<a class="headerlink" href="#display-modes-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="c enum">
<dt id="c.drm_mode_status">
<em class="property">enum </em><code class="sig-name descname">drm_mode_status</code><a class="headerlink" href="#c.drm_mode_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hardware support status of a mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MODE_OK</span></code></dt><dd><p>Mode OK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_HSYNC</span></code></dt><dd><p>hsync out of range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VSYNC</span></code></dt><dd><p>vsync out of range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_H_ILLEGAL</span></code></dt><dd><p>mode has illegal horizontal timings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_V_ILLEGAL</span></code></dt><dd><p>mode has illegal vertical timings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_BAD_WIDTH</span></code></dt><dd><p>requires an unsupported linepitch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NOMODE</span></code></dt><dd><p>no mode with a matching name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_INTERLACE</span></code></dt><dd><p>interlaced mode not supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_DBLESCAN</span></code></dt><dd><p>doublescan mode not supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_VSCAN</span></code></dt><dd><p>multiscan mode not supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_MEM</span></code></dt><dd><p>insufficient video memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VIRTUAL_X</span></code></dt><dd><p>mode width too large for specified virtual size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VIRTUAL_Y</span></code></dt><dd><p>mode height too large for specified virtual size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_MEM_VIRT</span></code></dt><dd><p>insufficient video memory given virtual size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NOCLOCK</span></code></dt><dd><p>no fixed clock available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_CLOCK_HIGH</span></code></dt><dd><p>clock required is too high</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_CLOCK_LOW</span></code></dt><dd><p>clock required is too low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_CLOCK_RANGE</span></code></dt><dd><p>clock/mode isn’t in a ClockRange</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_BAD_HVALUE</span></code></dt><dd><p>horizontal timing was out of range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_BAD_VVALUE</span></code></dt><dd><p>vertical timing was out of range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_BAD_VSCAN</span></code></dt><dd><p>VScan value out of range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_HSYNC_NARROW</span></code></dt><dd><p>horizontal sync too narrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_HSYNC_WIDE</span></code></dt><dd><p>horizontal sync too wide</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_HBLANK_NARROW</span></code></dt><dd><p>horizontal blanking too narrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_HBLANK_WIDE</span></code></dt><dd><p>horizontal blanking too wide</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VSYNC_NARROW</span></code></dt><dd><p>vertical sync too narrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VSYNC_WIDE</span></code></dt><dd><p>vertical sync too wide</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VBLANK_NARROW</span></code></dt><dd><p>vertical blanking too narrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_VBLANK_WIDE</span></code></dt><dd><p>vertical blanking too wide</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_PANEL</span></code></dt><dd><p>exceeds panel dimensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_INTERLACE_WIDTH</span></code></dt><dd><p>width too large for interlaced mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_ONE_WIDTH</span></code></dt><dd><p>only one width is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_ONE_HEIGHT</span></code></dt><dd><p>only one height is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_ONE_SIZE</span></code></dt><dd><p>only one resolution is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_REDUCED</span></code></dt><dd><p>monitor doesn’t accept reduced blanking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_STEREO</span></code></dt><dd><p>stereo modes not supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_NO_420</span></code></dt><dd><p>ycbcr 420 modes not supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_STALE</span></code></dt><dd><p>mode has become stale</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_BAD</span></code></dt><dd><p>unspecified reason</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MODE_ERROR</span></code></dt><dd><p>error condition</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to filter out modes not supported by the driver/hardware
combination.</p>
<dl class="c macro">
<dt id="c.DRM_SIMPLE_MODE">
<code class="sig-name descname">DRM_SIMPLE_MODE</code><a class="headerlink" href="#c.DRM_SIMPLE_MODE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_SIMPLE_MODE</span> <span class="pre">(hd,</span> <span class="pre">vd,</span> <span class="pre">hd_mm,</span> <span class="pre">vd_mm)</span></code></p>
<blockquote>
<div><p>Simple display mode</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hd</span></code></dt><dd><p>Horizontal resolution, width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vd</span></code></dt><dd><p>Vertical resolution, height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hd_mm</span></code></dt><dd><p>Display width in millimeters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vd_mm</span></code></dt><dd><p>Display height in millimeters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes a <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> that only contains info about
resolution and physical size.</p>
<dl class="c struct">
<dt id="c.drm_display_mode">
<em class="property">struct </em><code class="sig-name descname">drm_display_mode</code><a class="headerlink" href="#c.drm_display_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM kernel-internal display mode structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_display_mode {
  int clock;
  u16 hdisplay;
  u16 hsync_start;
  u16 hsync_end;
  u16 htotal;
  u16 hskew;
  u16 vdisplay;
  u16 vsync_start;
  u16 vsync_end;
  u16 vtotal;
  u16 vscan;
  u32 flags;
  int crtc_clock;
  u16 crtc_hdisplay;
  u16 crtc_hblank_start;
  u16 crtc_hblank_end;
  u16 crtc_hsync_start;
  u16 crtc_hsync_end;
  u16 crtc_htotal;
  u16 crtc_hskew;
  u16 crtc_vdisplay;
  u16 crtc_vblank_start;
  u16 crtc_vblank_end;
  u16 crtc_vsync_start;
  u16 crtc_vsync_end;
  u16 crtc_vtotal;
  u16 width_mm;
  u16 height_mm;
  u8 type;
  bool expose_to_userspace;
  struct list_head head;
  char name[DRM_DISPLAY_MODE_LEN];
  enum drm_mode_status status;
  enum hdmi_picture_aspect picture_aspect_ratio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">clock</span></code></dt><dd><p>Pixel clock in kHz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdisplay</span></code></dt><dd><p>horizontal display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hsync_start</span></code></dt><dd><p>horizontal sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hsync_end</span></code></dt><dd><p>horizontal sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">htotal</span></code></dt><dd><p>horizontal total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hskew</span></code></dt><dd><p>horizontal skew?!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vdisplay</span></code></dt><dd><p>vertical display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsync_start</span></code></dt><dd><p>vertical sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsync_end</span></code></dt><dd><p>vertical sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vtotal</span></code></dt><dd><p>vertical total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vscan</span></code></dt><dd><p>vertical scan?!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Sync and timing flags:</p>
<blockquote>
<div><ul class="simple">
<li><p>DRM_MODE_FLAG_PHSYNC: horizontal sync is active high.</p></li>
<li><p>DRM_MODE_FLAG_NHSYNC: horizontal sync is active low.</p></li>
<li><p>DRM_MODE_FLAG_PVSYNC: vertical sync is active high.</p></li>
<li><p>DRM_MODE_FLAG_NVSYNC: vertical sync is active low.</p></li>
<li><p>DRM_MODE_FLAG_INTERLACE: mode is interlaced.</p></li>
<li><p>DRM_MODE_FLAG_DBLSCAN: mode uses doublescan.</p></li>
<li><p>DRM_MODE_FLAG_CSYNC: mode uses composite sync.</p></li>
<li><p>DRM_MODE_FLAG_PCSYNC: composite sync is active high.</p></li>
<li><p>DRM_MODE_FLAG_NCSYNC: composite sync is active low.</p></li>
<li><p>DRM_MODE_FLAG_HSKEW: hskew provided (not used?).</p></li>
<li><p>DRM_MODE_FLAG_BCAST: &lt;deprecated&gt;</p></li>
<li><p>DRM_MODE_FLAG_PIXMUX: &lt;deprecated&gt;</p></li>
<li><p>DRM_MODE_FLAG_DBLCLK: double-clocked mode.</p></li>
<li><p>DRM_MODE_FLAG_CLKDIV2: half-clocked mode.</p></li>
</ul>
</div></blockquote>
<p>Additionally there’s flags to specify how 3D modes are packed:</p>
<blockquote>
<div><ul class="simple">
<li><p>DRM_MODE_FLAG_3D_NONE: normal, non-3D mode.</p></li>
<li><p>DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right.</p></li>
<li><p>DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields.</p></li>
<li><p>DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines.</p></li>
<li><p>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames.</p></li>
<li><p>DRM_MODE_FLAG_3D_L_DEPTH: ?</p></li>
<li><p>DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?</p></li>
<li><p>DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom
parts.</p></li>
<li><p>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and
right parts.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_clock</span></code></dt><dd><p>Actual pixel or dot clock in the hardware. This differs from the
logical <strong>clock</strong> when e.g. using interlacing, double-clocking, stereo
modes or other fancy stuff that changes the timings and signals
actually sent over the wire.</p>
<p>This is again in kHz.</p>
<p>Note that with digital outputs like HDMI or DP there’s usually a
massive confusion between the dot clock and the signal clock at the
bit encoding level. Especially when a 8b/10b encoding is used and the
difference is exactly a factor of 10.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hdisplay</span></code></dt><dd><p>hardware mode horizontal display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hblank_start</span></code></dt><dd><p>hardware mode horizontal blank start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hblank_end</span></code></dt><dd><p>hardware mode horizontal blank end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hsync_start</span></code></dt><dd><p>hardware mode horizontal sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hsync_end</span></code></dt><dd><p>hardware mode horizontal sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_htotal</span></code></dt><dd><p>hardware mode horizontal total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_hskew</span></code></dt><dd><p>hardware mode horizontal skew?!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vdisplay</span></code></dt><dd><p>hardware mode vertical display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vblank_start</span></code></dt><dd><p>hardware mode vertical blank start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vblank_end</span></code></dt><dd><p>hardware mode vertical blank end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vsync_start</span></code></dt><dd><p>hardware mode vertical sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vsync_end</span></code></dt><dd><p>hardware mode vertical sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_vtotal</span></code></dt><dd><p>hardware mode vertical total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width_mm</span></code></dt><dd><p>Addressable size of the output in mm, projectors should set this to
0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">height_mm</span></code></dt><dd><p>Addressable size of the output in mm, projectors should set this to
0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>A bitmask of flags, mostly about the source of a mode. Possible flags
are:</p>
<blockquote>
<div><ul class="simple">
<li><p>DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
resolution of an LCD panel. There should only be one preferred
mode per connector at any given time.</p></li>
<li><p>DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
them really. Drivers must set this bit for all modes they create
and expose to userspace.</p></li>
<li><p>DRM_MODE_TYPE_USERDEF: Mode defined or selected via the kernel
command line.</p></li>
</ul>
</div></blockquote>
<p>Plus a big list of flags which shouldn’t be used at all, but are
still around since these flags are also used in the userspace ABI.
We no longer accept modes with these types though:</p>
<blockquote>
<div><ul class="simple">
<li><p>DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, unused.
Use DRM_MODE_TYPE_DRIVER instead.</p></li>
<li><p>DRM_MODE_TYPE_DEFAULT: Again a leftover, use
DRM_MODE_TYPE_PREFERRED instead.</p></li>
<li><p>DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
which are stuck around for hysterical raisins only. No one has an
idea what they were meant for. Don’t use.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">expose_to_userspace</span></code></dt><dd><p>Indicates whether the mode is to be exposed to the userspace.
This is to maintain a set of exposed modes while preparing
user-mode’s list in drm_mode_getconnector ioctl. The purpose of
this only lies in the ioctl function, and is not to be used
outside the function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>struct list_head for mode lists.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Human-readable name of the mode, filled out with <a class="reference internal" href="#c.drm_mode_set_name" title="drm_mode_set_name"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_set_name()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Status of the mode, used to filter out modes not supported by the
hardware. See enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">picture_aspect_ratio</span></code></dt><dd><p>Field for setting the HDMI picture aspect ratio of a mode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The horizontal and vertical timings are defined per the following diagram.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          Active                 Front           Sync           Back
         Region                 Porch                          Porch
&lt;-----------------------&gt;&lt;----------------&gt;&lt;-------------&gt;&lt;--------------&gt;
  //////////////////////|
 ////////////////////// |
//////////////////////  |..................               ................
                                           _______________
&lt;----- [hv]display -----&gt;
&lt;------------- [hv]sync_start ------------&gt;
&lt;--------------------- [hv]sync_end ---------------------&gt;
&lt;-------------------------------- [hv]total -----------------------------&gt;*
</pre></div>
</div>
<p>This structure contains two copies of timings. First are the plain timings,
which specify the logical mode, as it would be for a progressive 1:1 scanout
at the refresh rate userspace can observe through vblank timestamps. Then
there’s the hardware timings, which are corrected for interlacing,
double-clocking and similar things. They are provided as a convenience, and
can be appropriately computed using <a class="reference internal" href="#c.drm_mode_set_crtcinfo" title="drm_mode_set_crtcinfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_set_crtcinfo()</span></code></a>.</p>
<p>For printing you can use <code class="docutils literal notranslate"><span class="pre">DRM_MODE_FMT</span></code> and <a class="reference internal" href="#c.DRM_MODE_ARG" title="DRM_MODE_ARG"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODE_ARG()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.DRM_MODE_FMT">
<code class="sig-name descname">DRM_MODE_FMT</code><a class="headerlink" href="#c.DRM_MODE_FMT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_MODE_FMT</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>printf string for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="c macro">
<dt id="c.DRM_MODE_ARG">
<code class="sig-name descname">DRM_MODE_ARG</code><a class="headerlink" href="#c.DRM_MODE_ARG" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_MODE_ARG</span> <span class="pre">(m)</span></code></p>
<blockquote>
<div><p>printf arguments for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">m</span></code></dt><dd><p>display mode</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_mode_is_stereo">
bool <code class="sig-name descname">drm_mode_is_stereo</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_stereo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check for stereo mode flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>drm_display_mode to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the mode is one of the stereo modes (like side-by-side), false if
not.</p>
<dl class="c function">
<dt id="c.drm_mode_debug_printmodeline">
void <code class="sig-name descname">drm_mode_debug_printmodeline</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_debug_printmodeline" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>print a mode to dmesg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to print</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describe <strong>mode</strong> using DRM_DEBUG.</p>
<dl class="c function">
<dt id="c.drm_mode_create">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_mode_create</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it
and return it.</p>
<p><strong>Return</strong></p>
<p>Pointer to new mode on success, NULL on error.</p>
<dl class="c function">
<dt id="c.drm_mode_destroy">
void <code class="sig-name descname">drm_mode_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release <strong>mode</strong>’s unique ID, then free it <strong>mode</strong> structure itself using kfree.</p>
<dl class="c function">
<dt id="c.drm_mode_probed_add">
void <code class="sig-name descname">drm_mode_probed_add</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_probed_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a mode to a connector’s probed_mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector the new mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>mode</strong> to <strong>connector</strong>’s probed_mode list for later use. This list should
then in a second step get filtered and all the modes actually supported by
the hardware moved to the <strong>connector</strong>’s modes list.</p>
<dl class="c function">
<dt id="c.drm_cvt_mode">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_cvt_mode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, int <em>hdisplay</em>, int <em>vdisplay</em>, int <em>vrefresh</em>, bool <em>reduced</em>, bool <em>interlaced</em>, bool <em>margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_cvt_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a modeline based on the CVT algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt><dd><p>hdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt><dd><p>vdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt><dd><p>vrefresh rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">reduced</span></code></dt><dd><p>whether to use reduced blanking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt><dd><p>whether to compute an interlaced mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">margins</span></code></dt><dd><p>whether to add margins (borders)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called to generate the modeline based on CVT algorithm
according to the hdisplay, vdisplay, vrefresh.
It is based from the VESA(TM) Coordinated Video Timing Generator by
Graham Loveridge April 9, 2003 available at
<a class="reference external" href="http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls">http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls</a></p>
<p>And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
What I have done is to translate it by using integer calculation.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the CVT algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="c function">
<dt id="c.drm_gtf_mode_complex">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_gtf_mode_complex</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, int <em>hdisplay</em>, int <em>vdisplay</em>, int <em>vrefresh</em>, bool <em>interlaced</em>, int <em>margins</em>, int <em>GTF_M</em>, int <em>GTF_2C</em>, int <em>GTF_K</em>, int <em>GTF_2J</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode_complex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create the modeline based on the full GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt><dd><p>hdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt><dd><p>vdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt><dd><p>vrefresh rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt><dd><p>whether to compute an interlaced mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">margins</span></code></dt><dd><p>desired margin (borders) size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GTF_M</span></code></dt><dd><p>extended GTF formula parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GTF_2C</span></code></dt><dd><p>extended GTF formula parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GTF_K</span></code></dt><dd><p>extended GTF formula parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">GTF_2J</span></code></dt><dd><p>extended GTF formula parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GTF feature blocks specify C and J in multiples of 0.5, so we pass them
in here multiplied by two.  For a C of 40, pass in 80.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the full GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="c function">
<dt id="c.drm_gtf_mode">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_gtf_mode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, int <em>hdisplay</em>, int <em>vdisplay</em>, int <em>vrefresh</em>, bool <em>interlaced</em>, int <em>margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create the modeline based on the GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt><dd><p>hdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt><dd><p>vdisplay size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt><dd><p>vrefresh rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt><dd><p>whether to compute an interlaced mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">margins</span></code></dt><dd><p>desired margin (borders) size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the modeline based on GTF algorithm</p>
<p>This function is to create the modeline based on the GTF algorithm.
Generalized Timing Formula is derived from:</p>
<blockquote>
<div><p>GTF Spreadsheet by Andy Morrish (1/5/97)
available at <a class="reference external" href="https://www.vesa.org">https://www.vesa.org</a></p>
</div></blockquote>
<p>And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
What I have done is to translate it by using integer calculation.
I also refer to the function of fb_get_mode in the file of
drivers/video/fbmon.c</p>
<p>Standard GTF parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>M = 600
C = 40
K = 128
J = 20
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The modeline based on the GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="c function">
<dt id="c.drm_display_mode_from_videomode">
void <code class="sig-name descname">drm_display_mode_from_videomode</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> videomode *<em>vm</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>dmode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_from_videomode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill in <strong>dmode</strong> using <strong>vm</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*vm</span></code></dt><dd><p>videomode structure to use as source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*dmode</span></code></dt><dd><p>drm_display_mode structure to use as destination</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>dmode</strong> using the display mode specified in <strong>vm</strong>.</p>
<dl class="c function">
<dt id="c.drm_display_mode_to_videomode">
void <code class="sig-name descname">drm_display_mode_to_videomode</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>dmode</em>, <em class="property">struct</em> videomode *<em>vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_to_videomode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill in <strong>vm</strong> using <strong>dmode</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*dmode</span></code></dt><dd><p>drm_display_mode structure to use as source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*vm</span></code></dt><dd><p>videomode structure to use as destination</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>vm</strong> using the display mode specified in <strong>dmode</strong>.</p>
<dl class="c function">
<dt id="c.drm_bus_flags_from_videomode">
void <code class="sig-name descname">drm_bus_flags_from_videomode</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> videomode *<em>vm</em>, u32 *<em>bus_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bus_flags_from_videomode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>extract information about pixelclk and DE polarity from videomode and store it in a separate variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*vm</span></code></dt><dd><p>videomode structure to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*bus_flags</span></code></dt><dd><p>information about pixelclk, sync and DE polarity will be stored
here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets DRM_BUS_FLAG_DE_(LOW|HIGH),  DRM_BUS_FLAG_PIXDATA_DRIVE_(POS|NEG)EDGE
and DISPLAY_FLAGS_SYNC_(POS|NEG)EDGE in <strong>bus_flags</strong> according to DISPLAY_FLAGS
found in <strong>vm</strong></p>
<dl class="c function">
<dt id="c.of_get_drm_display_mode">
int <code class="sig-name descname">of_get_drm_display_mode</code><span class="sig-paren">(</span><em class="property">struct</em> device_node *<em>np</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>dmode</em>, u32 *<em>bus_flags</em>, int <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_drm_display_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a drm_display_mode from devicetree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device_node with the timing specification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*dmode</span></code></dt><dd><p>will be set to the return value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*bus_flags</span></code></dt><dd><p>information about pixelclk, sync and DE polarity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index into the list of display timings in devicetree</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is expensive and should only be used, if only one mode is to be
read from DT. To get multiple modes start with of_get_display_timings and
work with that instead.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative errno code when no of videomode node was found.</p>
<dl class="c function">
<dt id="c.drm_mode_set_name">
void <code class="sig-name descname">drm_mode_set_name</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the name on a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>name will be set in this mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the name of <strong>mode</strong> to a standard format which is &lt;hdisplay&gt;x&lt;vdisplay&gt;
with an optional ‘i’ suffix for interlaced modes.</p>
<dl class="c function">
<dt id="c.drm_mode_vrefresh">
int <code class="sig-name descname">drm_mode_vrefresh</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_vrefresh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the vrefresh of a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>modes</strong>’s vrefresh rate in Hz, rounded to the nearest integer. Calculates the
value first if it is not yet set.</p>
<dl class="c function">
<dt id="c.drm_mode_get_hv_timing">
void <code class="sig-name descname">drm_mode_get_hv_timing</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em>, int *<em>hdisplay</em>, int *<em>vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_hv_timing" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fetches hdisplay/vdisplay for given mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*hdisplay</span></code></dt><dd><p>hdisplay value to fill in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*vdisplay</span></code></dt><dd><p>vdisplay value to fill in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vdisplay value will be doubled if the specified mode is a stereo mode of
the appropriate layout.</p>
<dl class="c function">
<dt id="c.drm_mode_set_crtcinfo">
void <code class="sig-name descname">drm_mode_set_crtcinfo</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>p</em>, int <em>adjust_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_crtcinfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set CRTC modesetting timing parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*p</span></code></dt><dd><p>mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">adjust_flags</span></code></dt><dd><p>a combination of adjustment flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the CRTC modesetting timing parameters for <strong>p</strong>, adjusting if necessary.</p>
<ul class="simple">
<li><p>The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
interlaced modes.</p></li>
<li><p>The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
buffers containing two eyes (only adjust the timings when needed, eg. for
“frame packing” or “side by side full”).</p></li>
<li><p>The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment <em>not</em>
be performed for doublescan and vscan &gt; 1 modes respectively.</p></li>
</ul>
<dl class="c function">
<dt id="c.drm_mode_copy">
void <code class="sig-name descname">drm_mode_copy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>dst</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_copy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy the mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*dst</span></code></dt><dd><p>mode to overwrite</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*src</span></code></dt><dd><p>mode to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy an existing mode into another mode, preserving the object id and
list head of the destination mode.</p>
<dl class="c function">
<dt id="c.drm_mode_duplicate">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_mode_duplicate</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_duplicate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate and duplicate an existing mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device to allocate the duplicated mode for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to duplicate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just allocate a new mode, copy the existing mode into it, and return
a pointer to it.  Used to create new instances of established modes.</p>
<p><strong>Return</strong></p>
<p>Pointer to duplicated mode on success, NULL on error.</p>
<dl class="c function">
<dt id="c.drm_mode_match">
bool <code class="sig-name descname">drm_mode_match</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode1</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode2</em>, unsigned int <em>match_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_match" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test modes for (partial) equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode1</span></code></dt><dd><p>first mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode2</span></code></dt><dd><p>second mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_flags</span></code></dt><dd><p>which parts need to match (DRM_MODE_MATCH_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent.</p>
<p><strong>Return</strong></p>
<p>True if the modes are (partially) equal, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_mode_equal">
bool <code class="sig-name descname">drm_mode_equal</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode1</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode1</span></code></dt><dd><p>first mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode2</span></code></dt><dd><p>second mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_mode_equal_no_clocks">
bool <code class="sig-name descname">drm_mode_equal_no_clocks</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode1</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode1</span></code></dt><dd><p>first mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode2</span></code></dt><dd><p>second mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don’t check the pixel clocks.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_mode_equal_no_clocks_no_stereo">
bool <code class="sig-name descname">drm_mode_equal_no_clocks_no_stereo</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode1</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks_no_stereo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode1</span></code></dt><dd><p>first mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode2</span></code></dt><dd><p>second mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don’t check the pixel clocks nor the stereo layout.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_mode_validate_driver">
<em class="property">enum</em> <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_mode_validate_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>make sure the mode is somewhat sane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>First do basic validation on the mode, and then allow the driver
to check for device/driver specific limitations via the optional
<a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.mode_valid</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="c function">
<dt id="c.drm_mode_validate_size">
<em class="property">enum</em> <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_mode_validate_size</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em>, int <em>maxX</em>, int <em>maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>make sure modes adhere to size constraints</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxX</span></code></dt><dd><p>maximum width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxY</span></code></dt><dd><p>maximum height</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a helper which can be used to validate modes against size
limitations of the DRM device/connector. If a mode is too big its status
member is updated with the appropriate validation failure code. The list
itself is not changed.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="c function">
<dt id="c.drm_mode_validate_ycbcr420">
<em class="property">enum</em> <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_mode_validate_ycbcr420</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_ycbcr420" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add ‘ycbcr420-only’ modes only when allowed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector under action</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a helper which can be used to filter out any YCBCR420
only mode, when the source doesn’t support it.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="c function">
<dt id="c.drm_mode_prune_invalid">
void <code class="sig-name descname">drm_mode_prune_invalid</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> list_head *<em>mode_list</em>, bool <em>verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_prune_invalid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove invalid modes from mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*mode_list</span></code></dt><dd><p>list of modes to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">verbose</span></code></dt><dd><p>be verbose about it</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function can be used to prune a display mode list after
validation has been completed. All modes whose status is not MODE_OK will be
removed from the list, and if <strong>verbose</strong> the status code and mode name is also
printed to dmesg.</p>
<dl class="c function">
<dt id="c.drm_mode_sort">
void <code class="sig-name descname">drm_mode_sort</code><span class="sig-paren">(</span><em class="property">struct</em> list_head *<em>mode_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_sort" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sort mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*mode_list</span></code></dt><dd><p>list of drm_display_mode structures to sort</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sort <strong>mode_list</strong> by favorability, moving good modes to the head of the list.</p>
<dl class="c function">
<dt id="c.drm_connector_list_update">
void <code class="sig-name descname">drm_connector_list_update</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_update" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the mode list for the connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This moves the modes from the <strong>connector</strong> probed_modes list
to the actual mode list. It compares the probed mode against the current
list and only adds different/new modes.</p>
<p>This is just a helper functions doesn’t validate any modes itself and also
doesn’t prune any invalid modes. Callers need to do that themselves.</p>
<dl class="c function">
<dt id="c.drm_mode_parse_command_line_for_connector">
bool <code class="sig-name descname">drm_mode_parse_command_line_for_connector</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>mode_option</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_cmdline_mode" title="drm_cmdline_mode">drm_cmdline_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_parse_command_line_for_connector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>parse command line modeline for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mode_option</span></code></dt><dd><p>optional per connector mode option</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to parse modeline for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*mode</span></code></dt><dd><p>preallocated drm_cmdline_mode structure to fill out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This parses <strong>mode_option</strong> command line modeline for modes and options to
configure the connector. If <strong>mode_option</strong> is NULL the default command line
modeline in fb_mode_option will be parsed instead.</p>
<p>This uses the same parameters as the fb modedb.c, except for an extra
force-enable, force-enable-digital and force-disable bit at the end:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]
</pre></div>
</div>
<p>Additionals options can be provided following the mode, using a comma to
separate each option. Valid options can be found in
<a class="reference internal" href="../fb/modedb.html"><span class="doc">modedb default video mode support</span></a>.</p>
<p>The intermediate drm_cmdline_mode structure is required to store additional
options from the command line modline like the force-enable/disable flag.</p>
<p><strong>Return</strong></p>
<p>True if a valid modeline has been parsed, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_mode_create_from_cmdline_mode">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<code class="sig-name descname">drm_mode_create_from_cmdline_mode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_cmdline_mode" title="drm_cmdline_mode">drm_cmdline_mode</a> *<em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_from_cmdline_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a command line modeline into a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device to create the new mode for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*cmd</span></code></dt><dd><p>input command line modeline</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to converted mode on success, NULL on error.</p>
<dl class="c function">
<dt id="c.drm_mode_is_420_only">
bool <code class="sig-name descname">drm_mode_is_420_only</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>display</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420_only" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if a given videomode can be only supported in YCBCR420 output format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*display</span></code></dt><dd><p>display under action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>video mode to be tested.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be supported in YCBCR420 format
false if not.</p>
<dl class="c function">
<dt id="c.drm_mode_is_420_also">
bool <code class="sig-name descname">drm_mode_is_420_also</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>display</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420_also" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if a given videomode can be supported in YCBCR420 output format also (along with RGB/YCBCR444/422)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*display</span></code></dt><dd><p>display under action.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>video mode to be tested.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be support YCBCR420 format
false if not.</p>
<dl class="c function">
<dt id="c.drm_mode_is_420">
bool <code class="sig-name descname">drm_mode_is_420</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>display</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>if a given videomode can be supported in YCBCR420 output format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*display</span></code></dt><dd><p>display under action.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>video mode to be tested.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be supported in YCBCR420 format
false if not.</p>
</div>
<div class="section" id="connector-abstraction">
<h2>Connector Abstraction<a class="headerlink" href="#connector-abstraction" title="Permalink to this headline">¶</a></h2>
<p>In DRM connectors are the general abstraction for display sinks, and include
also fixed panels or anything else that can display pixels in some form. As
opposed to all other KMS objects representing hardware (like CRTC, encoder or
plane abstractions) connectors can be hotplugged and unplugged at runtime.
Hence they are reference-counted using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_get()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_put()</span></code></a>.</p>
<p>KMS driver must create, initialize, register and attach at a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_connector</span></code></a> for each such sink. The instance is created as other KMS
objects and initialized by setting the following fields. The connector is
initialized with a call to <a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_init()</span></code></a> with a pointer to the
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_funcs</span></code></a> and a connector type, and then exposed to
userspace with a call to <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_register()</span></code></a>.</p>
<p>Connectors must be attached to an encoder to be used. For devices that map
connectors to encoders 1:1, the connector should be attached at
initialization time with a call to <a class="reference internal" href="#c.drm_connector_attach_encoder" title="drm_connector_attach_encoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_encoder()</span></code></a>. The
driver must also set the <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.encoder</span></code></a> field to point to the
attached encoder.</p>
<p>For connectors which are not fixed (like built-in panels) the driver needs to
support hotplug notifications. The simplest way to do that is by using the
probe helpers, see <a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_init()</span></code></a> for connectors which don’t have
hardware support for hotplug interrupts. Connectors with hardware hotplug
support can instead use e.g. <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_hpd_irq_event()</span></code></a>.</p>
<div class="section" id="connector-functions-reference">
<h3>Connector Functions Reference<a class="headerlink" href="#connector-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c enum">
<dt id="c.drm_connector_status">
<em class="property">enum </em><code class="sig-name descname">drm_connector_status</code><a class="headerlink" href="#c.drm_connector_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>status for a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">connector_status_connected</span></code></dt><dd><p>The connector is definitely connected to
a sink device, and can be enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_status_disconnected</span></code></dt><dd><p>The connector isn’t connected to a
sink device which can be autodetect. For digital outputs like DP or
HDMI (which can be realiable probed) this means there’s really
nothing there. It is driver-dependent whether a connector with this
status can be lit up or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_status_unknown</span></code></dt><dd><p>The connector’s status could not be
reliably detected. This happens when probing would either cause
flicker (like load-detection when the connector is in use), or when a
hardware resource isn’t available (like when load-detection needs a
free CRTC). It should be possible to light up the connector with one
of the listed fallback modes. For default configuration userspace
should only try to light up connectors with unknown status when
there’s not connector with <strong>connector_status_connected</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the connector status. There are no separate
#defines for the uapi!</p>
<dl class="c enum">
<dt id="c.drm_connector_registration_state">
<em class="property">enum </em><code class="sig-name descname">drm_connector_registration_state</code><a class="headerlink" href="#c.drm_connector_registration_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>userspace registration status for a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_CONNECTOR_INITIALIZING</span></code></dt><dd><p>The connector has just been created,
but has yet to be exposed to userspace. There should be no
additional restrictions to how the state of this connector may be
modified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_CONNECTOR_REGISTERED</span></code></dt><dd><p>The connector has been fully initialized
and registered with sysfs, as such it has been exposed to
userspace. There should be no additional restrictions to how the
state of this connector may be modified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_CONNECTOR_UNREGISTERED</span></code></dt><dd><p>The connector has either been exposed
to userspace and has since been unregistered and removed from
userspace, or the connector was unregistered before it had a chance
to be exposed to userspace (e.g. still in the
<strong>DRM_CONNECTOR_INITIALIZING</strong> state). When a connector is
unregistered, there are additional restrictions to how its state
may be modified:</p>
<ul class="simple">
<li><p>An unregistered connector may only have its DPMS changed from
On-&gt;Off. Once DPMS is changed to Off, it may not be switched back
to On.</p></li>
<li><p>Modesets are not allowed on unregistered connectors, unless they
would result in disabling its assigned CRTCs. This means
disabling a CRTC on an unregistered connector is OK, but enabling
one is not.</p></li>
<li><p>Removing a CRTC from an unregistered connector is OK, but new
CRTCs may never be assigned to an unregistered connector.</p></li>
</ul>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the status of initializing a connector and
registering it with userspace, so that DRM can prevent bogus modesets on
connectors that no longer exist.</p>
<dl class="c struct">
<dt id="c.drm_scrambling">
<em class="property">struct </em><code class="sig-name descname">drm_scrambling</code><a class="headerlink" href="#c.drm_scrambling" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_scrambling {
  bool supported;
  bool low_rates;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supported</span></code></dt><dd><p>scrambling supported for rates &gt; 340 Mhz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">low_rates</span></code></dt><dd><p>scrambling supported for rates &lt;= 340 Mhz.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_hdmi_info">
<em class="property">struct </em><code class="sig-name descname">drm_hdmi_info</code><a class="headerlink" href="#c.drm_hdmi_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runtime information about the connected HDMI sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_hdmi_info {
  struct drm_scdc scdc;
  unsigned long y420_vdb_modes[BITS_TO_LONGS(256)];
  unsigned long y420_cmdb_modes[BITS_TO_LONGS(256)];
  u64 y420_cmdb_map;
  u8 y420_dc_modes;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scdc</span></code></dt><dd><p>sink’s scdc support and capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y420_vdb_modes</span></code></dt><dd><p>bitmap of modes which can support ycbcr420
output only (not normal RGB/YCBCR444/422 outputs). The max VIC
defined by the CEA-861-G spec is 219, so the size is 256 bits to map
up to 256 VICs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y420_cmdb_modes</span></code></dt><dd><p>bitmap of modes which can support ycbcr420
output also, along with normal HDMI outputs. The max VIC defined by
the CEA-861-G spec is 219, so the size is 256 bits to map up to 256
VICs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y420_cmdb_map</span></code></dt><dd><p>bitmap of SVD index, to extraxt vcb modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y420_dc_modes</span></code></dt><dd><p>bitmap of deep color support index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes if a given display supports advanced HDMI 2.0 features.
This information is available in CEA-861-F extension blocks (like HF-VSDB).</p>
<dl class="c enum">
<dt id="c.drm_link_status">
<em class="property">enum </em><code class="sig-name descname">drm_link_status</code><a class="headerlink" href="#c.drm_link_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>connector’s link_status property value</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LINK_STATUS_GOOD</span></code></dt><dd><p>DP Link is Good as a result of successful
link training</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LINK_STATUS_BAD</span></code></dt><dd><p>DP Link is BAD as a result of link training
failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used as the connector’s link status property value.
It is set to the values defined in uapi.</p>
<dl class="c enum">
<dt id="c.drm_panel_orientation">
<em class="property">enum </em><code class="sig-name descname">drm_panel_orientation</code><a class="headerlink" href="#c.drm_panel_orientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>panel_orientation info for <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PANEL_ORIENTATION_UNKNOWN</span></code></dt><dd><p>The drm driver has not provided any
panel orientation information (normal
for non panels) in this case the “panel
orientation” connector prop will not be
attached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PANEL_ORIENTATION_NORMAL</span></code></dt><dd><p>The top side of the panel matches the
top side of the device’s casing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP</span></code></dt><dd><p>The top side of the panel matches the
bottom side of the device’s casing, iow
the panel is mounted upside-down.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PANEL_ORIENTATION_LEFT_UP</span></code></dt><dd><p>The left side of the panel matches the
top side of the device’s casing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PANEL_ORIENTATION_RIGHT_UP</span></code></dt><dd><p>The right side of the panel matches the
top side of the device’s casing.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the (LCD) panel orientation. There are no
separate #defines for the uapi!</p>
<dl class="c struct">
<dt id="c.drm_monitor_range_info">
<em class="property">struct </em><code class="sig-name descname">drm_monitor_range_info</code><a class="headerlink" href="#c.drm_monitor_range_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Panel’s Monitor range in EDID for <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_monitor_range_info {
  u8 min_vfreq;
  u8 max_vfreq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">min_vfreq</span></code></dt><dd><p>This is the min supported refresh rate in Hz from
EDID’s detailed monitor range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_vfreq</span></code></dt><dd><p>This is the max supported refresh rate in Hz from
EDID’s detailed monitor range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct is used to store a frequency range supported by panel
as parsed from EDID’s detailed monitor range descriptor block.</p>
<dl class="c enum">
<dt id="c.drm_bus_flags">
<em class="property">enum </em><code class="sig-name descname">drm_bus_flags</code><a class="headerlink" href="#c.drm_bus_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>bus_flags info for <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_DE_LOW</span></code></dt><dd><p>The Data Enable signal is active low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_DE_HIGH</span></code></dt><dd><p>The Data Enable signal is active high</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE</span></code></dt><dd><p>Data is driven on the rising edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE</span></code></dt><dd><p>Data is driven on the falling edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE</span></code></dt><dd><p>Data is sampled on the rising edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE</span></code></dt><dd><p>Data is sampled on the falling edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_DATA_MSB_TO_LSB</span></code></dt><dd><p>Data is transmitted MSB to LSB on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_DATA_LSB_TO_MSB</span></code></dt><dd><p>Data is transmitted LSB to MSB on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE</span></code></dt><dd><p>Sync signals are driven on the rising edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE</span></code></dt><dd><p>Sync signals are driven on the falling edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE</span></code></dt><dd><p>Sync signals are sampled on the rising edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE</span></code></dt><dd><p>Sync signals are sampled on the falling edge of the pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BUS_FLAG_SHARP_SIGNALS</span></code></dt><dd><p>Set if the Sharp-specific signals (SPL, CLS, PS, REV) must be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum defines signal polarities and clock edge information for signals on
a bus as bitmask flags.</p>
<p>The clock edge information is conveyed by two sets of symbols,
DRM_BUS_FLAGS_*_DRIVE_* and DRM_BUS_FLAGS_*_SAMPLE_*. When this enum is
used to describe a bus from the point of view of the transmitter, the
*_DRIVE_* flags should be used. When used from the point of view of the
receiver, the *_SAMPLE_* flags should be used. The *_DRIVE_* and
*_SAMPLE_* flags alias each other, with the *_SAMPLE_POSEDGE and
*_SAMPLE_NEGEDGE flags being equal to *_DRIVE_NEGEDGE and *_DRIVE_POSEDGE
respectively. This simplifies code as signals are usually sampled on the
opposite edge of the driving edge. Transmitters and receivers may however
need to take other signal timings into account to convert between driving
and sample edges.</p>
<dl class="c struct">
<dt id="c.drm_display_info">
<em class="property">struct </em><code class="sig-name descname">drm_display_info</code><a class="headerlink" href="#c.drm_display_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>runtime data about the connected sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_display_info {
  unsigned int width_mm;
  unsigned int height_mm;
  unsigned int bpc;
  enum subpixel_order subpixel_order;
#define DRM_COLOR_FORMAT_RGB444         (1&lt;&lt;0);
#define DRM_COLOR_FORMAT_YCRCB444       (1&lt;&lt;1);
#define DRM_COLOR_FORMAT_YCRCB422       (1&lt;&lt;2);
#define DRM_COLOR_FORMAT_YCRCB420       (1&lt;&lt;3);
  int panel_orientation;
  u32 color_formats;
  const u32 *bus_formats;
  unsigned int num_bus_formats;
  u32 bus_flags;
  int max_tmds_clock;
  bool dvi_dual;
  bool is_hdmi;
  bool has_hdmi_infoframe;
  bool rgb_quant_range_selectable;
  u8 edid_hdmi_dc_modes;
  u8 cea_rev;
  struct drm_hdmi_info hdmi;
  bool non_desktop;
  struct drm_monitor_range_info monitor_range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">width_mm</span></code></dt><dd><p>Physical width in mm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">height_mm</span></code></dt><dd><p>Physical height in mm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpc</span></code></dt><dd><p>Maximum bits per color channel. Used by HDMI and DP outputs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subpixel_order</span></code></dt><dd><p>Subpixel order of LCD panels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">panel_orientation</span></code></dt><dd><p>Read only connector property for built-in panels,
indicating the orientation of the panel vs the device’s casing.
<a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_init()</span></code></a> sets this to DRM_MODE_PANEL_ORIENTATION_UNKNOWN.
When not UNKNOWN this gets used by the drm_fb_helpers to rotate the
fb to compensate and gets exported as prop to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">color_formats</span></code></dt><dd><p>HDMI Color formats, selects between RGB and YCrCb
modes. Used DRM_COLOR_FORMAT_ defines, which are _not_ the same ones
as used to describe the pixel format in framebuffers, and also don’t
match the formats in <strong>bus_formats</strong> which are shared with v4l.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_formats</span></code></dt><dd><p>Pixel data format on the wire, somewhat redundant with
<strong>color_formats</strong>. Array of size <strong>num_bus_formats</strong> encoded using
MEDIA_BUS_FMT_ defines shared with v4l and media drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_bus_formats</span></code></dt><dd><p>Size of <strong>bus_formats</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_flags</span></code></dt><dd><p>Additional information (like pixel signal polarity) for
the pixel data on the bus, using <a class="reference internal" href="#c.drm_bus_flags" title="drm_bus_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_bus_flags</span></code></a> values
DRM_BUS_FLAGS_.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_tmds_clock</span></code></dt><dd><p>Maximum TMDS clock rate supported by the
sink in kHz. 0 means undefined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dvi_dual</span></code></dt><dd><p>Dual-link DVI sink?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_hdmi</span></code></dt><dd><p>True if the sink is an HDMI device.</p>
<p>This field shall be used instead of calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_detect_hdmi_monitor" title="drm_detect_hdmi_monitor"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_detect_hdmi_monitor()</span></code></a> when possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_hdmi_infoframe</span></code></dt><dd><p>Does the sink support the HDMI infoframe?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rgb_quant_range_selectable</span></code></dt><dd><p>Does the sink support selecting
the RGB quantization range?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edid_hdmi_dc_modes</span></code></dt><dd><p>Mask of supported hdmi deep color modes. Even
more stuff redundant with <strong>bus_formats</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cea_rev</span></code></dt><dd><p>CEA revision of the HDMI sink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdmi</span></code></dt><dd><p>advance features of a HDMI sink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_desktop</span></code></dt><dd><p>Non desktop display (HMD).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">monitor_range</span></code></dt><dd><p>Frequency range supported by monitor range descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes a given display (e.g. CRT or flat panel) and its limitations. For
fixed display sinks like built-in panels there’s not much difference between
this and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>. But for sinks with a real cable this
structure is meant to describe all the things at the other end of the cable.</p>
<p>For sinks which provide an EDID this can be filled out by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_edid_modes()</span></code></a>.</p>
<dl class="c struct">
<dt id="c.drm_connector_tv_margins">
<em class="property">struct </em><code class="sig-name descname">drm_connector_tv_margins</code><a class="headerlink" href="#c.drm_connector_tv_margins" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TV connector related margins</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_tv_margins {
  unsigned int bottom;
  unsigned int left;
  unsigned int right;
  unsigned int top;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bottom</span></code></dt><dd><p>Bottom margin in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">left</span></code></dt><dd><p>Left margin in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">right</span></code></dt><dd><p>Right margin in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top</span></code></dt><dd><p>Top margin in pixels.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes the margins in pixels to put around the image on TV
connectors to deal with overscan.</p>
<dl class="c struct">
<dt id="c.drm_tv_connector_state">
<em class="property">struct </em><code class="sig-name descname">drm_tv_connector_state</code><a class="headerlink" href="#c.drm_tv_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>TV connector related states</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_tv_connector_state {
  enum drm_mode_subconnector subconnector;
  struct drm_connector_tv_margins margins;
  unsigned int mode;
  unsigned int brightness;
  unsigned int contrast;
  unsigned int flicker_reduction;
  unsigned int overscan;
  unsigned int saturation;
  unsigned int hue;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">subconnector</span></code></dt><dd><p>selected subconnector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">margins</span></code></dt><dd><p>TV margins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>TV mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">brightness</span></code></dt><dd><p>brightness in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">contrast</span></code></dt><dd><p>contrast in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flicker_reduction</span></code></dt><dd><p>flicker reduction in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">overscan</span></code></dt><dd><p>overscan in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">saturation</span></code></dt><dd><p>saturation in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hue</span></code></dt><dd><p>hue in percent</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_connector_state">
<em class="property">struct </em><code class="sig-name descname">drm_connector_state</code><a class="headerlink" href="#c.drm_connector_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mutable connector state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_state {
  struct drm_connector *connector;
  struct drm_crtc *crtc;
  struct drm_encoder *best_encoder;
  enum drm_link_status link_status;
  struct drm_atomic_state *state;
  struct drm_crtc_commit *commit;
  struct drm_tv_connector_state tv;
  bool self_refresh_aware;
  enum hdmi_picture_aspect picture_aspect_ratio;
  unsigned int content_type;
  unsigned int hdcp_content_type;
  unsigned int scaling_mode;
  unsigned int content_protection;
  u32 colorspace;
  struct drm_writeback_job *writeback_job;
  u8 max_requested_bpc;
  u8 max_bpc;
  struct drm_property_blob *hdr_output_metadata;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>backpointer to the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>CRTC to connect connector to, NULL if disabled.</p>
<p>Do not change this directly, use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_connector" title="drm_atomic_set_crtc_for_connector"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_crtc_for_connector()</span></code></a>
instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best_encoder</span></code></dt><dd><p>Used by the atomic helpers to select the encoder, through the
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_best_encoder</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.best_encoder</span></code></a> callbacks.</p>
<p>This is also used in the atomic helpers to map encoders to their
current and previous connectors, see
<a class="reference internal" href="#c.drm_atomic_get_old_connector_for_encoder" title="drm_atomic_get_old_connector_for_encoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_old_connector_for_encoder()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_get_new_connector_for_encoder" title="drm_atomic_get_new_connector_for_encoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_get_new_connector_for_encoder()</span></code></a>.</p>
<p>NOTE: Atomic drivers must fill this out (either themselves or through
helpers), for otherwise the GETCONNECTOR and GETENCODER IOCTLs will
not return correct data to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_status</span></code></dt><dd><p>Connector link_status to keep track of whether link is
GOOD or BAD to notify userspace if retraining is necessary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>backpointer to global drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>Tracks the pending commit to prevent use-after-free conditions.</p>
<p>Is only set when <strong>crtc</strong> is NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv</span></code></dt><dd><p>TV connector state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self_refresh_aware</span></code></dt><dd><p>This tracks whether a connector is aware of the self refresh state.
It should be set to true for those connector implementations which
understand the self refresh state. This is needed since the crtc
registers the self refresh helpers and it doesn’t know if the
connectors downstream have implemented self refresh entry/exit.</p>
<p>Drivers should set this to true in atomic_check if they know how to
handle self_refresh requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">picture_aspect_ratio</span></code></dt><dd><p>Connector property to control the
HDMI infoframe aspect ratio setting.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DRM_MODE_PICTURE_ASPECT_</span></code>* values much match the
values for <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hdmi_picture_aspect</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">content_type</span></code></dt><dd><p>Connector property to control the
HDMI infoframe content type setting.
The <code class="docutils literal notranslate"><span class="pre">DRM_MODE_CONTENT_TYPE_</span></code>* values much
match the values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdcp_content_type</span></code></dt><dd><p>Connector property to pass the type of
protected content. This is most commonly used for HDCP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_mode</span></code></dt><dd><p>Connector property to control the
upscaling, mostly used for built-in panels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">content_protection</span></code></dt><dd><p>Connector property to request content
protection. This is most commonly used for HDCP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">colorspace</span></code></dt><dd><p>State variable for Connector property to request
colorspace change on Sink. This is most commonly used to switch
to wider color gamuts like BT2020.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_job</span></code></dt><dd><p>Writeback job for writeback connectors</p>
<p>Holds the framebuffer and out-fence for a writeback connector. As
the writeback completion may be asynchronous to the normal commit
cycle, the writeback job lifetime is managed separately from the
normal atomic state by this object.</p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_queue_job()</span></code></a> and
<a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_requested_bpc</span></code></dt><dd><p>Connector property to limit the maximum bit
depth of the pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_bpc</span></code></dt><dd><p>Connector max_bpc based on the requested max_bpc property
and the connector bpc limitations obtained from edid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdr_output_metadata</span></code></dt><dd><p>DRM blob property for HDR output metadata</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_connector_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_connector_funcs</code><a class="headerlink" href="#c.drm_connector_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>control connectors on a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_funcs {
  int (*dpms)(struct drm_connector *connector, int mode);
  void (*reset)(struct drm_connector *connector);
  enum drm_connector_status (*detect)(struct drm_connector *connector, bool force);
  void (*force)(struct drm_connector *connector);
  int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
  int (*set_property)(struct drm_connector *connector, struct drm_property *property, uint64_t val);
  int (*late_register)(struct drm_connector *connector);
  void (*early_unregister)(struct drm_connector *connector);
  void (*destroy)(struct drm_connector *connector);
  struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
  void (*atomic_destroy_state)(struct drm_connector *connector, struct drm_connector_state *state);
  int (*atomic_set_property)(struct drm_connector *connector,struct drm_connector_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_connector *connector,const struct drm_connector_state *state,struct drm_property *property, uint64_t *val);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Legacy entry point to set the per-connector DPMS state. Legacy DPMS
is exposed as a standard property on the connector, but diverted to
this callback in the drm core. Note that atomic drivers don’t
implement the 4 level DPMS support on the connector any more, but
instead only have an on/off “ACTIVE” property on the CRTC object.</p>
<p>This hook is not used by atomic drivers, remapping of the legacy DPMS
property is entirely handled in the DRM core.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Reset connector hardware and software state to off. This function isn’t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>.
It’s not a helper hook only for historical reasons.</p>
<p>Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_reset" title="drm_atomic_helper_connector_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_connector_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>FIXME:</p>
<p>Note that this hook is only called by the probe helper. It’s not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is <strong>fill_modes</strong>.</p>
<p>Note that the helper library will already hold
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Drivers which need to grab additional
locks to avoid races with concurrent modeset changes need to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.detect_ctx</span></code></a> instead.</p>
<p>RETURNS:</p>
<p>drm_connector_status indicating the connector’s status.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force</span></code></dt><dd><p>This function is called to update internal encoder state when the
connector is forced to a certain state by userspace, either through
the sysfs interfaces or on the kernel cmdline. In that case the
<strong>detect</strong> callback isn’t called.</p>
<p>FIXME:</p>
<p>Note that this hook is only called by the probe helper. It’s not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is <strong>fill_modes</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fill_modes</span></code></dt><dd><p>Entry point for output detection and basic mode validation. The
driver should reprobe the output if needed (e.g. when hotplug
handling is unreliable), add all detected modes to <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>
and filter out any the device can’t support in any configuration. It
also needs to filter out any modes wider or higher than the
parameters max_width and max_height indicate.</p>
<p>The drivers must also prune any modes no longer valid from
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. Furthermore it must update
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.status</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.edid</span></code></a>.  If no EDID has been
received for this output connector-&gt;edid must be NULL.</p>
<p>Drivers using the probe helpers should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> to implement this
function.</p>
<p>RETURNS:</p>
<p>The number of modes detected and filled into <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_property</span></code></dt><dd><p>This is the legacy entry point to update a property attached to the
connector.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_register</span></code></dt><dd><p>This optional hook can be used to register additional userspace
interfaces attached to the connector, light backlight control, i2c,
DP aux or similar interfaces. It is called late in the driver load
sequence from <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_register()</span></code></a> when registering all the
core drm connector interfaces. Everything added from this callback
should be unregistered in the early_unregister callback.</p>
<p>This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.mutex</span></code></a>.</p>
<p>Returns:</p>
<p>0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_unregister</span></code></dt><dd><p>This optional hook should be used to unregister the additional
userspace interfaces attached to the connector from
late_register(). It is called from <a class="reference internal" href="#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
<p>This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Clean up connector resources. This is called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>. It can also be called at runtime
when a connector is being hot-unplugged for drivers that support
connector hotplugging (e.g. DisplayPort MST).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current atomic state for this connector and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don’t subclass <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_duplicate_state" title="drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_connector_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_connector_duplicate_state" title="__drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">__drm_atomic_helper_connector_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p>Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p>This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_set_property</span></code></dt><dd><p>Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
drm_atomic_connector_set_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace’s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p>0 if the property has been found, -EINVAL if the property isn’t
implemented by the driver (which shouldn’t ever happen, the core only
asks for properties attached to this connector). No other validation
is allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, …) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_property</span></code></dt><dd><p>Reads out the decoded driver-private property. This is used to
implement the GETCONNECTOR IOCTL.</p>
<p>Do not call this function directly, use
drm_atomic_connector_get_property() instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the property isn’t implemented by the
driver (which shouldn’t ever happen, the core only asks for
properties attached to this connector).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_print_state</span></code></dt><dd><p>If driver subclasses <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p>Do not call this directly, use drm_atomic_connector_print_state()
instead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors attached to it.  The functions
below allow the core DRM code to control connectors, enumerate available modes,
etc.</p>
<dl class="c struct">
<dt id="c.drm_cmdline_mode">
<em class="property">struct </em><code class="sig-name descname">drm_cmdline_mode</code><a class="headerlink" href="#c.drm_cmdline_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM Mode passed through the kernel command-line</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_cmdline_mode {
  char name[DRM_DISPLAY_MODE_LEN];
  bool specified;
  bool refresh_specified;
  bool bpp_specified;
  int xres;
  int yres;
  int bpp;
  int refresh;
  bool rb;
  bool interlace;
  bool cvt;
  bool margins;
  enum drm_connector_force force;
  unsigned int rotation_reflection;
  enum drm_panel_orientation panel_orientation;
  struct drm_connector_tv_margins tv_margins;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">specified</span></code></dt><dd><p>Has a mode been read from the command-line?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refresh_specified</span></code></dt><dd><p>Did the mode have a preferred refresh rate?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpp_specified</span></code></dt><dd><p>Did the mode have a preferred BPP?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xres</span></code></dt><dd><p>Active resolution on the X axis, in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yres</span></code></dt><dd><p>Active resolution on the Y axis, in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpp</span></code></dt><dd><p>Bits per pixels for the mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refresh</span></code></dt><dd><p>Refresh rate, in Hertz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb</span></code></dt><dd><p>Do we need to use reduced blanking?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interlace</span></code></dt><dd><p>The mode is interlaced.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cvt</span></code></dt><dd><p>The timings will be calculated using the VESA Coordinated
Video Timings instead of looking up the mode from a table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">margins</span></code></dt><dd><p>Add margins to the mode calculation (1.8% of xres rounded
down to 8 pixels and 1.8% of yres).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force</span></code></dt><dd><p>Ignore the hotplug state of the connector, and force its
state to one of the DRM_FORCE_* values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rotation_reflection</span></code></dt><dd><p>Initial rotation and reflection of the mode setup from the
command line. See DRM_MODE_ROTATE_* and
DRM_MODE_REFLECT_*. The only rotations supported are
DRM_MODE_ROTATE_0 and DRM_MODE_ROTATE_180.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">panel_orientation</span></code></dt><dd><p>drm-connector “panel orientation” property override value,
DRM_MODE_PANEL_ORIENTATION_UNKNOWN if not set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_margins</span></code></dt><dd><p>TV margins to apply to the mode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each connector can have an initial mode with additional options
passed through the kernel command line. This structure allows to
express those parameters and will be filled by the command-line
parser.</p>
<dl class="c struct">
<dt id="c.drm_connector">
<em class="property">struct </em><code class="sig-name descname">drm_connector</code><a class="headerlink" href="#c.drm_connector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>central DRM connector control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector {
  struct drm_device *dev;
  struct device *kdev;
  struct device_attribute *attr;
  struct list_head head;
  struct drm_mode_object base;
  char *name;
  struct mutex mutex;
  unsigned index;
  int connector_type;
  int connector_type_id;
  bool interlace_allowed;
  bool doublescan_allowed;
  bool stereo_allowed;
  bool ycbcr_420_allowed;
  enum drm_connector_registration_state registration_state;
  struct list_head modes;
  enum drm_connector_status status;
  struct list_head probed_modes;
  struct drm_display_info display_info;
  const struct drm_connector_funcs *funcs;
  struct drm_property_blob *edid_blob_ptr;
  struct drm_object_properties properties;
  struct drm_property *scaling_mode_property;
  struct drm_property *vrr_capable_property;
  struct drm_property *colorspace_property;
  struct drm_property_blob *path_blob_ptr;
  struct drm_property *max_bpc_property;
#define DRM_CONNECTOR_POLL_HPD (1 &lt;&lt; 0);
#define DRM_CONNECTOR_POLL_CONNECT (1 &lt;&lt; 1);
#define DRM_CONNECTOR_POLL_DISCONNECT (1 &lt;&lt; 2);
  uint8_t polled;
  int dpms;
  const struct drm_connector_helper_funcs *helper_private;
  struct drm_cmdline_mode cmdline_mode;
  enum drm_connector_force force;
  bool override_edid;
  u64 epoch_counter;
  u32 possible_encoders;
  struct drm_encoder *encoder;
#define MAX_ELD_BYTES   128;
  uint8_t eld[MAX_ELD_BYTES];
  bool latency_present[2];
  int video_latency[2];
  int audio_latency[2];
  struct i2c_adapter *ddc;
  int null_edid_counter;
  unsigned bad_edid_counter;
  bool edid_corrupt;
  u8 real_edid_checksum;
  struct dentry *debugfs_entry;
  struct drm_connector_state *state;
  struct drm_property_blob *tile_blob_ptr;
  bool has_tile;
  struct drm_tile_group *tile_group;
  bool tile_is_single_monitor;
  uint8_t num_h_tile, num_v_tile;
  uint8_t tile_h_loc, tile_v_loc;
  uint16_t tile_h_size, tile_v_size;
  struct llist_node free_node;
  struct hdr_sink_metadata hdr_sink_metadata;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>parent DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kdev</span></code></dt><dd><p>kernel device for sysfs attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attr</span></code></dt><dd><p>sysfs attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List of all connectors on a <strong>dev</strong>, linked from
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connector_list</span></code></a>. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connector_list_lock</span></code></a>, but please only use
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base KMS object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>human readable name, can be overwritten by the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>Lock for general connector state, but currently only protects
<strong>registered</strong>. Most of the connector state is still protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Compacted connector index, which matches the position inside
the mode_config.list for drivers not supporting hot-add/removing. Can
be used as an array index. It is invariant over the lifetime of the
connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type</span></code></dt><dd><p>one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type_id</span></code></dt><dd><p>index into connector type enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interlace_allowed</span></code></dt><dd><p>Can this connector handle interlaced modes? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">doublescan_allowed</span></code></dt><dd><p>Can this connector handle doublescan? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stereo_allowed</span></code></dt><dd><p>Can this connector handle stereo modes? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ycbcr_420_allowed</span></code></dt><dd><p>This bool indicates if this connector is
capable of handling YCBCR 420 output. While parsing the EDID
blocks it’s very helpful to know if the source is capable of
handling YCBCR 420 outputs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">registration_state</span></code></dt><dd><p>Is this connector initializing, exposed
(registered) with userspace, or unregistered?</p>
<p>Protected by <strong>mutex</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modes</span></code></dt><dd><p>Modes available on this connector (from fill_modes() + user).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>One of the drm_connector_status enums (connected, not, or unknown).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_modes</span></code></dt><dd><p>These are modes added by probing with DDC or the BIOS, before
filtering is applied. Used by the probe helpers. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">display_info</span></code></dt><dd><p>Display information is filled from EDID information
when a display is detected. For non hot-pluggable displays such as
flat panels in embedded systems, the driver should initialize the
<a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info.width_mm</span></code></a> and <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info.height_mm</span></code></a> fields
with the physical size of the display.</p>
<p>Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>connector control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edid_blob_ptr</span></code></dt><dd><p>DRM property containing EDID if present. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>. This should be updated only by calling
<a class="reference internal" href="#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_update_edid_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">properties</span></code></dt><dd><p>property tracking for this connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaling_mode_property</span></code></dt><dd><p>Optional atomic property to control the
upscaling. See <a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vrr_capable_property</span></code></dt><dd><p>Optional property to help userspace
query hardware support for variable refresh rate on a connector.
connector. Drivers can add the property to a connector by
calling <a class="reference internal" href="#c.drm_connector_attach_vrr_capable_property" title="drm_connector_attach_vrr_capable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_vrr_capable_property()</span></code></a>.</p>
<p>This should be updated only by calling
<a class="reference internal" href="#c.drm_connector_set_vrr_capable_property" title="drm_connector_set_vrr_capable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_vrr_capable_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">colorspace_property</span></code></dt><dd><p>Connector property to set the suitable
colorspace supported by the sink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_blob_ptr</span></code></dt><dd><p>DRM blob property data for the DP MST path property. This should only
be updated by calling <a class="reference internal" href="#c.drm_connector_set_path_property" title="drm_connector_set_path_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_path_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_bpc_property</span></code></dt><dd><p>Default connector property for the max bpc to be
driven out of the connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polled</span></code></dt><dd><p>Connector polling mode, a combination of</p>
<dl class="simple">
<dt>DRM_CONNECTOR_POLL_HPD</dt><dd><p>The connector generates hotplug events and doesn’t need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.</p>
</dd>
<dt>DRM_CONNECTOR_POLL_CONNECT</dt><dd><p>Periodically poll the connector for connection.</p>
</dd>
<dt>DRM_CONNECTOR_POLL_DISCONNECT</dt><dd><p>Periodically poll the connector for disconnection, without
causing flickering even when the connector is in use. DACs should
rarely do this without a lot of testing.</p>
</dd>
</dl>
<p>Set to 0 for connectors that don’t support connection status
discovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Current dpms state. For legacy drivers the
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.dpms</span></code></a> callback must update this. For atomic
drivers, this is handled by the core atomic code, and drivers must
only take <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active</span></code></a> into account.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">helper_private</span></code></dt><dd><p>mid-layer private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmdline_mode</span></code></dt><dd><p>mode line parsed from the kernel cmdline for this connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force</span></code></dt><dd><p>a DRM_FORCE_&lt;foo&gt; state for forced mode sets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">override_edid</span></code></dt><dd><p>has the EDID been overwritten through debugfs for testing?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">epoch_counter</span></code></dt><dd><p>used to detect any other changes in connector, besides status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_encoders</span></code></dt><dd><p>Bit mask of encoders that can drive this
connector, <a class="reference internal" href="#c.drm_encoder_index" title="drm_encoder_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_index()</span></code></a> determines the index into the bitfield
and the bits are set with <a class="reference internal" href="#c.drm_connector_attach_encoder" title="drm_connector_attach_encoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_encoder()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>Currently bound encoder driving this connector, if any.
Only really meaningful for non-atomic drivers. Atomic drivers should
instead look at <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.best_encoder</span></code></a>, and in case they
need the CRTC driving this output, <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.crtc</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eld</span></code></dt><dd><p>EDID-like data, if present</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">latency_present</span></code></dt><dd><p>AV delay info from ELD, if found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">video_latency</span></code></dt><dd><p>Video latency info from ELD, if found.
[0]: progressive, [1]: interlaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_latency</span></code></dt><dd><p>audio latency info from ELD, if found
[0]: progressive, [1]: interlaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddc</span></code></dt><dd><p>associated ddc adapter.
A connector usually has its associated ddc adapter. If a driver uses
this field, then an appropriate symbolic link is created in connector
sysfs directory to make it easy for the user to tell which i2c
adapter is for a particular display.</p>
<p>The field should be set by calling <a class="reference internal" href="#c.drm_connector_init_with_ddc" title="drm_connector_init_with_ddc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_init_with_ddc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">null_edid_counter</span></code></dt><dd><p>track sinks that give us all zeros for the EDID.
Needed to workaround some HW bugs where we get all 0s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bad_edid_counter</span></code></dt><dd><p>track sinks that give us an EDID with invalid checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">edid_corrupt</span></code></dt><dd><p>Indicates whether the last read EDID was corrupt. Used
in Displayport compliance testing - Displayport Link CTS Core 1.2
rev1.1 4.2.2.6</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">real_edid_checksum</span></code></dt><dd><p>real edid checksum for corrupted edid block.
Required in Displayport 1.4 compliance testing
rev1.1 4.2.2.6</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_entry</span></code></dt><dd><p>debugfs directory for this connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Current atomic state for this connector.</p>
<p>This is protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Note that
nonblocking atomic commits access the current connector state without
taking locks. Either by going through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a>
pointers, see <a class="reference internal" href="#c.for_each_oldnew_connector_in_state" title="for_each_oldnew_connector_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_connector_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_connector_in_state" title="for_each_old_connector_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_connector_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_connector_in_state" title="for_each_new_connector_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_connector_in_state()</span></code></a>. Or through careful ordering of
atomic commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_blob_ptr</span></code></dt><dd><p>DRM blob property data for the tile property (used mostly by DP MST).
This is meant for screens which are driven through separate display
pipelines represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>, which might not be running with
genlocked clocks. For tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose
the tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> if needed.</p>
<p>This should only be updated by calling
<a class="reference internal" href="#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_tile_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_tile</span></code></dt><dd><p>is this connector connected to a tiled monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_group</span></code></dt><dd><p>tile group for the connected monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_is_single_monitor</span></code></dt><dd><p>whether the tile is one monitor housing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_h_tile</span></code></dt><dd><p>number of horizontal tiles in the tile group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_v_tile</span></code></dt><dd><p>number of vertical tiles in the tile group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_h_loc</span></code></dt><dd><p>horizontal location of this tile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_v_loc</span></code></dt><dd><p>vertical location of this tile</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_h_size</span></code></dt><dd><p>horizontal size of this tile.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_v_size</span></code></dt><dd><p>vertical size of this tile.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_node</span></code></dt><dd><p>List used only by <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_list_iter</span></code></a> to be able to clean up a
connector from any context, in conjunction with
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connector_free_work</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdr_sink_metadata</span></code></dt><dd><p>HDR Metadata Information read from sink</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each connector may be connected to one or more CRTCs, or may be clonable by
another connector if they can share a CRTC.  Each connector also has a specific
position in the broader display (referred to as a ‘screen’ though it could
span multiple monitors).</p>
<dl class="c function">
<dt id="c.drm_connector_lookup">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<code class="sig-name descname">drm_connector_lookup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_lookup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup connector object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>connector object id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the connector object specified by id
add takes a reference to it.</p>
<dl class="c function">
<dt id="c.drm_connector_get">
void <code class="sig-name descname">drm_connector_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the connector’s refcount.</p>
<dl class="c function">
<dt id="c.drm_connector_put">
void <code class="sig-name descname">drm_connector_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the connector’s reference count and frees the
object if the reference count drops to zero.</p>
<dl class="c function">
<dt id="c.drm_connector_is_unregistered">
bool <code class="sig-name descname">drm_connector_is_unregistered</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_is_unregistered" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>has the connector been unregistered from userspace?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether or not <strong>connector</strong> has been unregistered from userspace.</p>
<p><strong>Return</strong></p>
<p>True if the connector was unregistered, false if the connector is
registered or has not yet been registered with userspace.</p>
<dl class="c struct">
<dt id="c.drm_tile_group">
<em class="property">struct </em><code class="sig-name descname">drm_tile_group</code><a class="headerlink" href="#c.drm_tile_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tile group metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_tile_group {
  struct kref refcount;
  struct drm_device *dev;
  int id;
  u8 group_data[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>reference count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>tile group id exposed to userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group_data</span></code></dt><dd><p>Sink-private data identifying this group</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>group_data</strong> corresponds to displayid vend/prod/serial for external screens
with an EDID.</p>
<dl class="c struct">
<dt id="c.drm_connector_list_iter">
<em class="property">struct </em><code class="sig-name descname">drm_connector_list_iter</code><a class="headerlink" href="#c.drm_connector_list_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>connector_list iterator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_list_iter {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This iterator tracks state needed to be able to walk the connector_list
within <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_config</span></code></a>. Only use together with
<a class="reference internal" href="#c.drm_connector_list_iter_begin" title="drm_connector_list_iter_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_begin()</span></code></a>, <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_end()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_next()</span></code></a> respectively the convenience macro
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_for_each_connector_iter">
<code class="sig-name descname">drm_for_each_connector_iter</code><a class="headerlink" href="#c.drm_for_each_connector_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_connector_iter</span> <span class="pre">(connector,</span> <span class="pre">iter)</span></code></p>
<blockquote>
<div><p>connector_list iterator macro</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer used as cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iter</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>connector</strong> is only valid within the list body, if you want to use
<strong>connector</strong> after calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_end()</span></code></a> then you need to grab
your own reference first using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_get()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_connector_for_each_possible_encoder">
<code class="sig-name descname">drm_connector_for_each_possible_encoder</code><a class="headerlink" href="#c.drm_connector_for_each_possible_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_connector_for_each_possible_encoder</span> <span class="pre">(connector,</span> <span class="pre">encoder)</span></code></p>
<blockquote>
<div><p>iterate connector’s possible encoders</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p><a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a> pointer used as cursor</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_get_connector_type_name">
<em class="property">const</em> char *<code class="sig-name descname">drm_get_connector_type_name</code><span class="sig-paren">(</span>unsigned int <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_connector_type_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a string for connector type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>The connector type (DRM_MODE_CONNECTOR_*)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the name of the connector type, or NULL if the type is not valid.</p>
<dl class="c function">
<dt id="c.drm_connector_init">
int <code class="sig-name descname">drm_connector_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>funcs</em>, int <em>connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init a preallocated connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for this connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt><dd><p>user visible type of the connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated connector. Connectors should be
subclassed as part of driver connector objects.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_init_with_ddc">
int <code class="sig-name descname">drm_connector_init_with_ddc</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>funcs</em>, int <em>connector_type</em>, <em class="property">struct</em> i2c_adapter *<em>ddc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_init_with_ddc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init a preallocated connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for this connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt><dd><p>user visible type of the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*ddc</span></code></dt><dd><p>pointer to the associated ddc adapter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated connector. Connectors should be
subclassed as part of driver connector objects.</p>
<p>Ensures that the ddc field of the connector is correctly set.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_edid_property">
void <code class="sig-name descname">drm_connector_attach_edid_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_edid_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach edid property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some connector types like DRM_MODE_CONNECTOR_VIRTUAL do not get a
edid property attached by default.  This function can be used to
explicitly enable the edid property in these cases.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_encoder">
int <code class="sig-name descname">drm_connector_attach_encoder</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach a connector to an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to attach <strong>connector</strong> to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function links up a connector to an encoder. Note that the routing
restrictions between encoders and crtcs are exposed to userspace through the
possible_clones and possible_crtcs bitmasks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_has_possible_encoder">
bool <code class="sig-name descname">drm_connector_has_possible_encoder</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_has_possible_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if the connector and encoder are associated with each other</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>the encoder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if <strong>encoder</strong> is one of the possible encoders for <strong>connector</strong>.</p>
<dl class="c function">
<dt id="c.drm_connector_cleanup">
void <code class="sig-name descname">drm_connector_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleans up an initialised connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the connector but doesn’t free the object.</p>
<dl class="c function">
<dt id="c.drm_connector_register">
int <code class="sig-name descname">drm_connector_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register userspace interfaces for a connector. Only call this for connectors
which can be hotplugged after <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a> has been called already,
e.g. DP MST connectors. All other connectors will be registered automatically
when calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_unregister">
void <code class="sig-name descname">drm_connector_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister userspace interfaces for a connector. Only call this for
connectors which have registered explicitly by calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>,
since connectors are unregistered automatically when <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a> is
called.</p>
<dl class="c function">
<dt id="c.drm_get_connector_status_name">
<em class="property">const</em> char *<code class="sig-name descname">drm_get_connector_status_name</code><span class="sig-paren">(</span><em class="property">enum</em> <a class="reference internal" href="#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> <em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_connector_status_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a string for connector status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt><dd><p>connector status to compute name of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In contrast to the other drm_get_*_name functions this one here returns a
const pointer and hence is threadsafe.</p>
<dl class="c function">
<dt id="c.drm_connector_list_iter_begin">
void <code class="sig-name descname">drm_connector_list_iter_begin</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_begin" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*iter</span></code></dt><dd><p>connector_list iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <strong>iter</strong> up to walk the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connector_list</span></code></a> of <strong>dev</strong>. <strong>iter</strong>
must always be cleaned up again by calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_end()</span></code></a>.
Iteration itself happens using <a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_iter_next()</span></code></a> or
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_connector_list_iter_next">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<code class="sig-name descname">drm_connector_list_iter_next</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return next connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*iter</span></code></dt><dd><p>connector_list iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next connector for <strong>iter</strong>, or NULL when the list walk has
completed.</p>
<dl class="c function">
<dt id="c.drm_connector_list_iter_end">
void <code class="sig-name descname">drm_connector_list_iter_end</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_end" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tear down a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*iter</span></code></dt><dd><p>connector_list iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down <strong>iter</strong> and releases any resources (like <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> references)
acquired while walking the list. This must always be called, both when the
iteration completes fully or when it was aborted without walking the entire
list.</p>
<dl class="c function">
<dt id="c.drm_get_subpixel_order_name">
<em class="property">const</em> char *<code class="sig-name descname">drm_get_subpixel_order_name</code><span class="sig-paren">(</span><em class="property">enum</em> subpixel_order <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_subpixel_order_name" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return a string for a given subpixel enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">subpixel_order</span> <span class="pre">order</span></code></dt><dd><p>enum of subpixel_order</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note you could abuse this and return something out of bounds, but that
would be a caller error.  No unscrubbed user data should make it here.</p>
<dl class="c function">
<dt id="c.drm_display_info_set_bus_formats">
int <code class="sig-name descname">drm_display_info_set_bus_formats</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>info</em>, <em class="property">const</em> u32 *<em>formats</em>, unsigned int <em>num_formats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_info_set_bus_formats" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the supported bus formats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*info</span></code></dt><dd><p>display info to store bus formats in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*formats</span></code></dt><dd><p>array containing the supported bus formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_formats</span></code></dt><dd><p>the number of entries in the fmts array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Store the supported bus formats in display info structure.
See MEDIA_BUS_FMT_* definitions in include/uapi/linux/media-bus-format.h for
a full list of available formats.</p>
<dl class="c function">
<dt id="c.drm_mode_create_dvi_i_properties">
int <code class="sig-name descname">drm_mode_create_dvi_i_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_dvi_i_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create DVI-I specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time a DVI-I connector is made.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_dp_subconnector_property">
void <code class="sig-name descname">drm_connector_attach_dp_subconnector_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_dp_subconnector_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create subconnector property for DP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm_connector to attach property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver when DP connector is created.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_content_type_property">
int <code class="sig-name descname">drm_connector_attach_content_type_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_content_type_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach content-type property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach content type property on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time a HDMI connector is made.</p>
<dl class="c function">
<dt id="c.drm_hdmi_avi_infoframe_content_type">
void <code class="sig-name descname">drm_hdmi_avi_infoframe_content_type</code><span class="sig-paren">(</span><em class="property">struct</em> hdmi_avi_infoframe *<em>frame</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_content_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill the HDMI AVI infoframe content type information, based on correspondent DRM property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>DRM display connector state</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_connector_attach_tv_margin_properties">
void <code class="sig-name descname">drm_connector_attach_tv_margin_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_tv_margin_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach TV connector margin properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver when it needs to attach TV margin props to a connector.
Typically used on SDTV and HDMI connectors.</p>
<dl class="c function">
<dt id="c.drm_mode_create_tv_margin_properties">
int <code class="sig-name descname">drm_mode_create_tv_margin_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tv_margin_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create TV connector margin properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver’s HDMI connector initialization routine, this function
creates the TV margin properties for a given device. No need to call this
function for an SDTV connector, it’s already called from
<a class="reference internal" href="#c.drm_mode_create_tv_properties" title="drm_mode_create_tv_properties"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create_tv_properties()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_mode_create_tv_properties">
int <code class="sig-name descname">drm_mode_create_tv_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, unsigned int <em>num_modes</em>, <em class="property">const</em> char *<em class="property">const</em> <em>modes</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tv_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create TV specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_modes</span></code></dt><dd><p>number of different TV formats (modes) supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">modes[]</span></code></dt><dd><p>array of pointers to strings containing name of each format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver’s TV initialization routine, this function creates
the TV specific connector properties for a given device.  Caller is
responsible for allocating a list of format names and passing them to
this routine.</p>
<dl class="c function">
<dt id="c.drm_mode_create_scaling_mode_property">
int <code class="sig-name descname">drm_mode_create_scaling_mode_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_scaling_mode_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it’s needed, must be attached to desired
connectors.</p>
<p>Atomic drivers should use <a class="reference internal" href="#c.drm_connector_attach_scaling_mode_property" title="drm_connector_attach_scaling_mode_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_scaling_mode_property()</span></code></a>
instead to correctly assign <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
in the atomic state.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_vrr_capable_property">
int <code class="sig-name descname">drm_connector_attach_vrr_capable_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_vrr_capable_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates the vrr_capable property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to create the vrr_capable property on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used by atomic drivers to add support for querying
variable refresh rate capability for a connector.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_scaling_mode_property">
int <code class="sig-name descname">drm_connector_attach_scaling_mode_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, u32 <em>scaling_mode_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_scaling_mode_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach atomic scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach scaling mode property on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">scaling_mode_mask</span></code></dt><dd><p>or’ed mask of BIT(<code class="docutils literal notranslate"><span class="pre">DRM_MODE_SCALE_</span></code>*).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for scaling mode to atomic drivers.
The scaling mode will be set to <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
and can be used from <a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs-&gt;atomic_check</span></code></a> for validation.</p>
<p>This is the atomic version of <a class="reference internal" href="#c.drm_mode_create_scaling_mode_property" title="drm_mode_create_scaling_mode_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create_scaling_mode_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_create_aspect_ratio_property">
int <code class="sig-name descname">drm_mode_create_aspect_ratio_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_aspect_ratio_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create aspect ratio property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it’s needed, must be attached to desired
connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_create_hdmi_colorspace_property">
int <code class="sig-name descname">drm_mode_create_hdmi_colorspace_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_hdmi_colorspace_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create hdmi colorspace property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to create the Colorspace property on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it’s needed, must be attached to desired
HDMI connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_create_dp_colorspace_property">
int <code class="sig-name descname">drm_mode_create_dp_colorspace_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_dp_colorspace_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create dp colorspace property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to create the Colorspace property on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it’s needed, must be attached to desired
DP connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_create_content_type_property">
int <code class="sig-name descname">drm_mode_create_content_type_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_content_type_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create content type property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it’s needed, must be attached to desired
connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_create_suggested_offset_properties">
int <code class="sig-name descname">drm_mode_create_suggested_offset_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_suggested_offset_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create suggests offset properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create the suggested x/y offset property for connectors.</p>
<dl class="c function">
<dt id="c.drm_connector_set_path_property">
int <code class="sig-name descname">drm_connector_set_path_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">const</em> char *<em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_path_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to set property on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>path to use for property; must not be NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a property to expose to userspace to specify a
connector path. This is mainly used for DisplayPort MST where
connectors have a topology and we want to allow userspace to give
them more meaningful names.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_set_tile_property">
int <code class="sig-name descname">drm_connector_set_tile_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_tile_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to set property on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This looks up the tile information for a connector, and creates a
property for userspace to parse if it exists. The property is of
the form of 8 integers using ‘:’ as a separator.
This is used for dual port tiled displays with DisplayPort SST
or DisplayPort MST connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_update_edid_property">
int <code class="sig-name descname">drm_connector_update_edid_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_update_edid_property" title="edid">edid</a> *<em>edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_update_edid_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the edid property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>new value of the edid property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new blob modeset object and assigns its id to the
connector’s edid property.
Since we also parse tile information from EDID’s displayID block, we also
set the connector’s tile property here. See <a class="reference internal" href="#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_tile_property()</span></code></a>
for more details.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_set_link_status_property">
void <code class="sig-name descname">drm_connector_set_link_status_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, uint64_t <em>link_status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_link_status_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set link status property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">link_status</span></code></dt><dd><p>new value of link status property (0: Good, 1: Bad)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In usual working scenario, this link status property will always be set to
“GOOD”. If something fails during or after a mode set, the kernel driver
may set this link status property to “BAD”. The caller then needs to send a
hotplug uevent for userspace to re-check the valid modes through
GET_CONNECTOR_IOCTL and retry modeset.</p>
<p>The reason for adding this property is to handle link training failures, but
it is not limited to DP or link training. For example, if we implement
asynchronous setcrtc, this property can be used to report any failures in that.</p>
<p><strong>Note</strong></p>
<p>Drivers cannot rely on userspace to support this property and
issue a modeset. As such, they may choose to handle issues (like
re-training a link) without userspace’s intervention.</p>
<dl class="c function">
<dt id="c.drm_connector_attach_max_bpc_property">
int <code class="sig-name descname">drm_connector_attach_max_bpc_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, int <em>min</em>, int <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_max_bpc_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attach “max bpc” property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach max bpc property on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>The minimum bit depth supported by the connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>The maximum bit depth supported by the connector.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for limiting the bit depth on a connector.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_set_vrr_capable_property">
void <code class="sig-name descname">drm_connector_set_vrr_capable_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, bool <em>capable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_vrr_capable_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sets the variable refresh rate capable property for a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">capable</span></code></dt><dd><p>True if the connector is variable refresh rate capable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be used by atomic drivers to update the indicated support for
variable refresh rate over a connector.</p>
<dl class="c function">
<dt id="c.drm_connector_set_panel_orientation">
int <code class="sig-name descname">drm_connector_set_panel_orientation</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">enum</em> <a class="reference internal" href="#c.drm_panel_orientation" title="drm_panel_orientation">drm_panel_orientation</a> <em>panel_orientation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_panel_orientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sets the connector’s panel_orientation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector for which to set the panel-orientation property.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panel_orientation</span> <span class="pre">panel_orientation</span></code></dt><dd><p>drm_panel_orientation value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the connector’s panel_orientation and attaches
a “panel orientation” property to the connector.</p>
<p>Calling this function on a connector where the panel_orientation has
already been set is a no-op (e.g. the orientation has been overridden with
a kernel commandline option).</p>
<p>It is allowed to call this function with a panel_orientation of
DRM_MODE_PANEL_ORIENTATION_UNKNOWN, in which case it is a no-op.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_connector_set_panel_orientation_with_quirk">
int <code class="sig-name descname">drm_connector_set_panel_orientation_with_quirk</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">enum</em> <a class="reference internal" href="#c.drm_panel_orientation" title="drm_panel_orientation">drm_panel_orientation</a> <em>panel_orientation</em>, int <em>width</em>, int <em>height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_panel_orientation_with_quirk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the connector’s panel_orientation after checking for quirks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector for which to init the panel-orientation property.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panel_orientation</span> <span class="pre">panel_orientation</span></code></dt><dd><p>drm_panel_orientation value to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width in pixels of the panel, used for panel quirk detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height in pixels of the panel, used for panel quirk detection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.drm_connector_set_panel_orientation" title="drm_connector_set_panel_orientation"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_panel_orientation()</span></code></a>, but with a check for platform
specific (e.g. DMI based) quirks overriding the passed in panel_orientation.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_mode_put_tile_group">
void <code class="sig-name descname">drm_mode_put_tile_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> *<em>tg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_put_tile_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>drop a reference to a tile group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_tile_group</span> <span class="pre">*tg</span></code></dt><dd><p>tile group to drop reference to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>drop reference to tile group and free if 0.</p>
<dl class="c function">
<dt id="c.drm_mode_get_tile_group">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> *<code class="sig-name descname">drm_mode_get_tile_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">const</em> char <em>topology</em>[8]<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_tile_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a reference to an existing tile group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">topology[8]</span></code></dt><dd><p>8-bytes unique per monitor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the unique bytes to get a reference to an existing tile group.</p>
<p><strong>Return</strong></p>
<p>tile group or NULL if not found.</p>
<dl class="c function">
<dt id="c.drm_mode_create_tile_group">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> *<code class="sig-name descname">drm_mode_create_tile_group</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">const</em> char <em>topology</em>[8]<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tile_group" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a tile group from a displayid description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">topology[8]</span></code></dt><dd><p>8-bytes unique per monitor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a tile group for the unique monitor, and get a unique
identifier for the tile group.</p>
<p><strong>Return</strong></p>
<p>new tile group or NULL.</p>
</div>
<div class="section" id="writeback-connectors">
<h3>Writeback Connectors<a class="headerlink" href="#writeback-connectors" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_writeback_connector">
<em class="property">struct </em><code class="sig-name descname">drm_writeback_connector</code><a class="headerlink" href="#c.drm_writeback_connector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM writeback connector</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_writeback_connector {
  struct drm_connector base;
  struct drm_encoder encoder;
  struct drm_property_blob *pixel_formats_blob_ptr;
  spinlock_t job_lock;
  struct list_head job_queue;
  unsigned int fence_context;
  spinlock_t fence_lock;
  unsigned long fence_seqno;
  char timeline_name[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base drm_connector object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>Internal encoder used by the connector to fulfill
the DRM framework requirements. The users of the
<strong>drm_writeback_connector</strong> control the behaviour of the <strong>encoder</strong>
by passing the <strong>enc_funcs</strong> parameter to <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_connector_init()</span></code></a>
function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixel_formats_blob_ptr</span></code></dt><dd><p>DRM blob property data for the pixel formats list on writeback
connectors
See also <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_connector_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_lock</span></code></dt><dd><p>Protects job_queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_queue</span></code></dt><dd><p>Holds a list of a connector’s writeback jobs; the last item is the
most recent. The first item may be either waiting for the hardware
to begin writing, or currently being written.</p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_queue_job()</span></code></a> and
<a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_context</span></code></dt><dd><p>timeline context used for fence operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_lock</span></code></dt><dd><p>spinlock to protect the fences in the fence_context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_seqno</span></code></dt><dd><p>Seqno variable used as monotonic counter for the fences
created on the connector’s timeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_name</span></code></dt><dd><p>The name of the connector’s fence timeline.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_writeback_job">
<em class="property">struct </em><code class="sig-name descname">drm_writeback_job</code><a class="headerlink" href="#c.drm_writeback_job" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM writeback job</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_writeback_job {
  struct drm_writeback_connector *connector;
  bool prepared;
  struct work_struct cleanup_work;
  struct list_head list_entry;
  struct drm_framebuffer *fb;
  struct dma_fence *out_fence;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>Back-pointer to the writeback connector associated with the job</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepared</span></code></dt><dd><p>Set when the job has been prepared with drm_writeback_prepare_job()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_work</span></code></dt><dd><p>Used to allow drm_writeback_signal_completion to defer dropping the
framebuffer reference to a workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_entry</span></code></dt><dd><p>List item for the writeback connector’s <strong>job_queue</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>Framebuffer to be written to by the writeback connector. Do not set
directly, use drm_writeback_set_fb()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_fence</span></code></dt><dd><p>Fence which will signal once the writeback has completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Driver-private data</p>
</dd>
</dl>
<p>Writeback connectors are used to expose hardware which can write the output
from a CRTC to a memory buffer. They are used and act similarly to other
types of connectors, with some important differences:</p>
<ul class="simple">
<li><p>Writeback connectors don’t provide a way to output visually to the user.</p></li>
<li><p>Writeback connectors are visible to userspace only when the client sets
DRM_CLIENT_CAP_WRITEBACK_CONNECTORS.</p></li>
<li><p>Writeback connectors don’t have EDID.</p></li>
</ul>
<p>A framebuffer may only be attached to a writeback connector when the
connector is attached to a CRTC. The WRITEBACK_FB_ID property which sets the
framebuffer applies only to a single commit (see below). A framebuffer may
not be attached while the CRTC is off.</p>
<p>Unlike with planes, when a writeback framebuffer is removed by userspace DRM
makes no attempt to remove it from active use by the connector. This is
because no method is provided to abort a writeback operation, and in any
case making a new commit whilst a writeback is ongoing is undefined (see
WRITEBACK_OUT_FENCE_PTR below). As soon as the current writeback is finished,
the framebuffer will automatically no longer be in active use. As it will
also have already been removed from the framebuffer list, there will be no
way for any userspace application to retrieve a reference to it in the
intervening period.</p>
<p>Writeback connectors have some additional properties, which userspace
can use to query and control them:</p>
<blockquote>
<div><dl class="simple">
<dt>“WRITEBACK_FB_ID”:</dt><dd><p>Write-only object property storing a DRM_MODE_OBJECT_FB: it stores the
framebuffer to be written by the writeback connector. This property is
similar to the FB_ID property on planes, but will always read as zero
and is not preserved across commits.
Userspace must set this property to an output buffer every time it
wishes the buffer to get filled.</p>
</dd>
<dt>“WRITEBACK_PIXEL_FORMATS”:</dt><dd><p>Immutable blob property to store the supported pixel formats table. The
data is an array of u32 DRM_FORMAT_* fourcc values.
Userspace can use this blob to find out what pixel formats are supported
by the connector’s writeback engine.</p>
</dd>
<dt>“WRITEBACK_OUT_FENCE_PTR”:</dt><dd><p>Userspace can use this property to provide a pointer for the kernel to
fill with a sync_file file descriptor, which will signal once the
writeback is finished. The value should be the address of a 32-bit
signed integer, cast to a u64.
Userspace should wait for this fence to signal before making another
commit affecting any of the same CRTCs, Planes or Connectors.
<strong>Failure to do so will result in undefined behaviour.</strong>
For this reason it is strongly recommended that all userspace
applications making use of writeback connectors <em>always</em> retrieve an
out-fence for the commit and use it appropriately.
From userspace, this property will always read as zero.</p>
</dd>
</dl>
</div></blockquote>
<dl class="c function">
<dt id="c.drm_writeback_connector_init">
int <code class="sig-name descname">drm_writeback_connector_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_writeback_connector" title="drm_writeback_connector">drm_writeback_connector</a> *<em>wb_connector</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>con_funcs</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a> *<em>enc_helper_funcs</em>, <em class="property">const</em> u32 *<em>formats</em>, int <em>n_formats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_connector_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a writeback connector and its properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*wb_connector</span></code></dt><dd><p>Writeback connector to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*con_funcs</span></code></dt><dd><p>Connector funcs vtable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*enc_helper_funcs</span></code></dt><dd><p>Encoder helper funcs vtable to be used by the internal encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*formats</span></code></dt><dd><p>Array of supported pixel formats for the writeback engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n_formats</span></code></dt><dd><p>Length of the formats array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates the writeback-connector-specific properties if they
have not been already created, initializes the connector as
type DRM_MODE_CONNECTOR_WRITEBACK, and correctly initializes the property
values. It will also create an internal encoder associated with the
drm_writeback_connector and set it to use the <strong>enc_helper_funcs</strong> vtable for
the encoder helper.</p>
<p>Drivers should always use this function instead of <a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_init()</span></code></a> to
set up writeback connectors.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error code</p>
<dl class="c function">
<dt id="c.drm_writeback_queue_job">
void <code class="sig-name descname">drm_writeback_queue_job</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_writeback_connector" title="drm_writeback_connector">drm_writeback_connector</a> *<em>wb_connector</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_queue_job" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue a writeback job for later signalling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*wb_connector</span></code></dt><dd><p>The writeback connector to queue a job on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>The connector state containing the job to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds the job contained in <strong>conn_state</strong> to the job_queue for a
writeback connector. It takes ownership of the writeback job and sets the
<strong>conn_state-&gt;writeback_job</strong> to NULL, and so no access to the job may be
performed by the caller after this function returns.</p>
<p>Drivers must ensure that for a given writeback connector, jobs are queued in
exactly the same order as they will be completed by the hardware (and
signaled via drm_writeback_signal_completion).</p>
<p>For every call to <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_queue_job()</span></code></a> there must be exactly one call to
<a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
<dl class="c function">
<dt id="c.drm_writeback_signal_completion">
void <code class="sig-name descname">drm_writeback_signal_completion</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_writeback_connector" title="drm_writeback_connector">drm_writeback_connector</a> *<em>wb_connector</em>, int <em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_signal_completion" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Signal the completion of a writeback job</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*wb_connector</span></code></dt><dd><p>The writeback connector whose job is complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>Status code to set in the writeback out_fence (0 for success)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this to signal the completion of a previously queued
writeback job. It should be called as soon as possible after the hardware
has finished writing, and may be called from interrupt context.
It is the driver’s responsibility to ensure that for a given connector, the
hardware completes writeback jobs in the same order as they are queued.</p>
<p>Unless the driver is holding its own reference to the framebuffer, it must
not be accessed after calling this function.</p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_writeback_queue_job()</span></code></a></p>
</div>
</div>
<div class="section" id="encoder-abstraction">
<h2>Encoder Abstraction<a class="headerlink" href="#encoder-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Encoders represent the connecting element between the CRTC (as the overall
pixel pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>) and the connectors (as the
generic sink entity, represented by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>). An encoder takes
pixel data from a CRTC and converts it to a format suitable for any attached
connector. Encoders are objects exposed to userspace, originally to allow
userspace to infer cloning and connector/CRTC restrictions. Unfortunately
almost all drivers get this wrong, making the uabi pretty much useless. On
top of that the exposed restrictions are too simple for today’s hardware, and
the recommended way to infer restrictions is by using the
DRM_MODE_ATOMIC_TEST_ONLY flag for the atomic IOCTL.</p>
<p>Otherwise encoders aren’t used in the uapi at all (any modeset request from
userspace directly connects a connector with a CRTC), drivers are therefore
free to use them however they wish. Modeset helper libraries make strong use
of encoders to facilitate code sharing. But for more complex settings it is
usually better to move shared code into a separate <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>. Compared to
encoders, bridges also have the benefit of being purely an internal
abstraction since they are not exposed to userspace at all.</p>
<p>Encoders are initialized with <a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_init()</span></code></a> and cleaned up using
<a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_cleanup()</span></code></a>.</p>
<div class="section" id="encoder-functions-reference">
<h3>Encoder Functions Reference<a class="headerlink" href="#encoder-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_encoder_funcs">
<em class="property">struct </em><code class="sig-name descname">drm_encoder_funcs</code><a class="headerlink" href="#c.drm_encoder_funcs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>encoder controls</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_encoder_funcs {
  void (*reset)(struct drm_encoder *encoder);
  void (*destroy)(struct drm_encoder *encoder);
  int (*late_register)(struct drm_encoder *encoder);
  void (*early_unregister)(struct drm_encoder *encoder);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Reset encoder hardware and software state to off. This function isn’t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>.
It’s not a helper hook only for historical reasons.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>Clean up encoder resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> since an encoder cannot be
hotplugged in DRM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_register</span></code></dt><dd><p>This optional hook can be used to register additional userspace
interfaces attached to the encoder like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p>0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_unregister</span></code></dt><dd><p>This optional hook should be used to unregister the additional
userspace interfaces attached to the encoder from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encoders sit between CRTCs and connectors.</p>
<dl class="c struct">
<dt id="c.drm_encoder">
<em class="property">struct </em><code class="sig-name descname">drm_encoder</code><a class="headerlink" href="#c.drm_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>central DRM encoder structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_encoder {
  struct drm_device *dev;
  struct list_head head;
  struct drm_mode_object base;
  char *name;
  int encoder_type;
  unsigned index;
  uint32_t possible_crtcs;
  uint32_t possible_clones;
  struct drm_crtc *crtc;
  struct list_head bridge_chain;
  const struct drm_encoder_funcs *funcs;
  const struct drm_encoder_helper_funcs *helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>parent DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>list management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base KMS object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>human readable name, can be overwritten by the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_type</span></code></dt><dd><p>One of the DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h. The following
encoder types are defined thus far:</p>
<ul class="simple">
<li><p>DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A.</p></li>
<li><p>DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort.</p></li>
<li><p>DRM_MODE_ENCODER_LVDS for display panels, or in general any panel
with a proprietary parallel connector.</p></li>
<li><p>DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video,
Component, SCART).</p></li>
<li><p>DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</p></li>
<li><p>DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus.</p></li>
<li><p>DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel
bus.</p></li>
<li><p>DRM_MODE_ENCODER_DPMST for special fake encoders used to allow
mutliple DP MST streams to share one physical encoder.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the encoder.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_crtcs</span></code></dt><dd><p>Bitmask of potential CRTC bindings, using
<a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_index()</span></code></a> as the index into the bitfield. The driver must set
the bits for all <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> objects this encoder can be connected to
before calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.</p>
<p>You will get a WARN if you get this wrong in the driver.</p>
<p>Note that since CRTC objects can’t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_clones</span></code></dt><dd><p>Bitmask of potential sibling encoders for cloning,
using <a class="reference internal" href="#c.drm_encoder_index" title="drm_encoder_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_index()</span></code></a> as the index into the bitfield. The driver
must set the bits for all <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> objects which can clone a
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> together with this encoder before calling
<a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>. Drivers should set the bit representing the
encoder itself, too. Cloning bits should be set such that when two
encoders can be used in a cloned configuration, they both should have
each another bits set.</p>
<p>As an exception to the above rule if the driver doesn’t implement
any cloning it can leave <strong>possible_clones</strong> set to 0. The core will
automagically fix this up by setting the bit for the encoder itself.</p>
<p>You will get a WARN if you get this wrong in the driver.</p>
<p>Note that since encoder objects can’t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>Currently bound CRTC, only really meaningful for non-atomic
drivers.  Atomic drivers should instead check
<a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.crtc</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge_chain</span></code></dt><dd><p>Bridges attached to this encoder. Drivers shall not
access this field directly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">helper_private</span></code></dt><dd><p>mid-layer private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>CRTCs drive pixels to encoders, which convert them into signals
appropriate for a given connector or set of connectors.</p>
<dl class="c function">
<dt id="c.drm_encoder_index">
unsigned int <code class="sig-name descname">drm_encoder_index</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_index" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the index of a registered encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to find index for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the index of that encoder within a DRM
device’s list of encoders.</p>
<dl class="c function">
<dt id="c.drm_encoder_mask">
u32 <code class="sig-name descname">drm_encoder_mask</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the mask of a registered encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to find mask for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the mask bit of that encoder for an
encoder’s possible_clones field.</p>
<dl class="c function">
<dt id="c.drm_encoder_crtc_ok">
bool <code class="sig-name descname">drm_encoder_crtc_ok</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_crtc_ok" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>can a given crtc drive a given encoder?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>crtc to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns false if <strong>encoder</strong> can’t be driven by <strong>crtc</strong>, true otherwise.</p>
<dl class="c function">
<dt id="c.drm_encoder_find">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<code class="sig-name descname">drm_encoder_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>encoder id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the encoder with <strong>id</strong>, NULL if it doesn’t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.drm_for_each_encoder_mask">
<code class="sig-name descname">drm_for_each_encoder_mask</code><a class="headerlink" href="#c.drm_for_each_encoder_mask" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_encoder_mask</span> <span class="pre">(encoder,</span> <span class="pre">dev,</span> <span class="pre">encoder_mask)</span></code></p>
<blockquote>
<div><p>iterate over encoders specified by bitmask</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_mask</span></code></dt><dd><p>bitmask of encoder indices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders specified by bitmask.</p>
<dl class="c macro">
<dt id="c.drm_for_each_encoder">
<code class="sig-name descname">drm_for_each_encoder</code><a class="headerlink" href="#c.drm_for_each_encoder" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_for_each_encoder</span> <span class="pre">(encoder,</span> <span class="pre">dev)</span></code></p>
<blockquote>
<div><p>iterate over all encoders</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders of <strong>dev</strong>.</p>
<dl class="c function">
<dt id="c.drm_encoder_init">
int <code class="sig-name descname">drm_encoder_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs">drm_encoder_funcs</a> *<em>funcs</em>, int <em>encoder_type</em>, <em class="property">const</em> char *<em>name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init a preallocated encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>the encoder to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for this encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">encoder_type</span></code></dt><dd><p>user visible type of the encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>printf style format string for the encoder name, or NULL for default name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated encoder. Encoder should be subclassed as part of
driver encoder objects. At driver unload time <a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_cleanup()</span></code></a> should be
called from the driver’s <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_funcs.destroy</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_encoder_cleanup">
void <code class="sig-name descname">drm_encoder_cleanup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleans up an initialised encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the encoder but doesn’t free the object.</p>
</div>
</div>
<div class="section" id="kms-locking">
<h2>KMS Locking<a class="headerlink" href="#kms-locking" title="Permalink to this headline">¶</a></h2>
<p>As KMS moves toward more fine grained locking, and atomic ioctl where
userspace can indirectly control locking order, it becomes necessary
to use <code class="xref c c-type docutils literal notranslate"><span class="pre">ww_mutex</span></code> and acquire-contexts to avoid deadlocks.  But because
the locking is more distributed around the driver code, we want a bit
of extra utility/tracking out of our acquire-ctx.  This is provided
by <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a> and <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span></code></a>.</p>
<p>For basic principles of <code class="xref c c-type docutils literal notranslate"><span class="pre">ww_mutex</span></code>, see: <a class="reference internal" href="../locking/ww-mutex-design.html"><span class="doc">Wound/Wait Deadlock-Proof Mutex Design</span></a></p>
<p>The basic usage pattern is to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>drm_modeset_acquire_init(ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE)
retry:
foreach (lock in random_ordered_set_of_locks) {
    ret = drm_modeset_lock(lock, ctx)
    if (ret == -EDEADLK) {
        ret = drm_modeset_backoff(ctx);
        if (!ret)
            goto retry;
    }
    if (ret)
        goto out;
}
... do stuff ...
out:
drm_modeset_drop_locks(ctx);
drm_modeset_acquire_fini(ctx);
</pre></div>
</div>
<p>For convenience this control flow is implemented in
<a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_BEGIN" title="DRM_MODESET_LOCK_ALL_BEGIN"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_BEGIN()</span></code></a> and <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_END" title="DRM_MODESET_LOCK_ALL_END"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_END()</span></code></a> for the case
where all modeset locks need to be taken through <a class="reference internal" href="#c.drm_modeset_lock_all_ctx" title="drm_modeset_lock_all_ctx"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_all_ctx()</span></code></a>.</p>
<p>If all that is needed is a single modeset lock, then the <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_modeset_acquire_ctx</span></code></a> is not needed and the locking can be simplified
by passing a NULL instead of ctx in the <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a> call or
calling  <a class="reference internal" href="#c.drm_modeset_lock_single_interruptible" title="drm_modeset_lock_single_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_single_interruptible()</span></code></a>. To unlock afterwards
call <a class="reference internal" href="#c.drm_modeset_unlock" title="drm_modeset_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_unlock()</span></code></a>.</p>
<p>On top of these per-object locks using <code class="xref c c-type docutils literal notranslate"><span class="pre">ww_mutex</span></code> there’s also an overall
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>, for protecting everything else. Mostly this means
probe state of connectors, and preventing hotplug add/removal of connectors.</p>
<p>Finally there’s a bunch of dedicated locks to protect drm core internal
lists and lookup data structures.</p>
<dl class="c struct">
<dt id="c.drm_modeset_acquire_ctx">
<em class="property">struct </em><code class="sig-name descname">drm_modeset_acquire_ctx</code><a class="headerlink" href="#c.drm_modeset_acquire_ctx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>locking context (see ww_acquire_ctx)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_modeset_acquire_ctx {
  struct ww_acquire_ctx ww_ctx;
  struct drm_modeset_lock *contended;
  struct list_head locked;
  bool trylock_only;
  bool interruptible;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ww_ctx</span></code></dt><dd><p>base acquire ctx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">contended</span></code></dt><dd><p>used internally for -EDEADLK handling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">locked</span></code></dt><dd><p>list of held locks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trylock_only</span></code></dt><dd><p>trylock mode used in atomic contexts/panic notifiers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interruptible</span></code></dt><dd><p>whether interruptible locking should be used.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each thread competing for a set of locks must use one acquire
ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
retry.</p>
<dl class="c struct">
<dt id="c.drm_modeset_lock">
<em class="property">struct </em><code class="sig-name descname">drm_modeset_lock</code><a class="headerlink" href="#c.drm_modeset_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>used for locking modeset resources.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_modeset_lock {
  struct ww_mutex mutex;
  struct list_head head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>resource locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>used to hold its place on <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomi_state.locked</span></code> list when
part of an atomic update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for locking CRTCs and other modeset resources.</p>
<dl class="c function">
<dt id="c.drm_modeset_lock_fini">
void <code class="sig-name descname">drm_modeset_lock_fini</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to cleanup</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_modeset_is_locked">
bool <code class="sig-name descname">drm_modeset_is_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_is_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>equivalent to <a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_is_locked" title="mutex_is_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_is_locked()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to check</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_modeset_lock_assert_held">
void <code class="sig-name descname">drm_modeset_lock_assert_held</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_assert_held" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>equivalent to lockdep_assert_held()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to check</p>
</dd>
</dl>
<dl class="c macro">
<dt id="c.DRM_MODESET_LOCK_ALL_BEGIN">
<code class="sig-name descname">DRM_MODESET_LOCK_ALL_BEGIN</code><a class="headerlink" href="#c.DRM_MODESET_LOCK_ALL_BEGIN" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_BEGIN</span> <span class="pre">(dev,</span> <span class="pre">ctx,</span> <span class="pre">flags,</span> <span class="pre">ret)</span></code></p>
<blockquote>
<div><p>Helper to acquire modeset locks</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt><dd><p>local modeset acquire context, will be dereferenced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>DRM_MODESET_ACQUIRE_* flags to pass to <a class="reference internal" href="#c.drm_modeset_acquire_init" title="drm_modeset_acquire_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_acquire_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ret</span></code></dt><dd><p>local ret/err/etc variable to track error status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use these macros to simplify grabbing all modeset locks using a local
context. This has the advantage of reducing boilerplate, but also properly
checking return values where appropriate.</p>
<p>Any code run between BEGIN and END will be holding the modeset locks.</p>
<p>This must be paired with <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_END" title="DRM_MODESET_LOCK_ALL_END"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_END()</span></code></a>. We will jump back and
forth between the labels on deadlock and error conditions.</p>
<p>Drivers can acquire additional modeset locks. If any lock acquisition
fails, the control flow needs to jump to <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_END" title="DRM_MODESET_LOCK_ALL_END"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_END()</span></code></a> with
the <strong>ret</strong> parameter containing the return value of <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The only possible value of ret immediately after <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_BEGIN" title="DRM_MODESET_LOCK_ALL_BEGIN"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_BEGIN()</span></code></a>
is 0, so no error checking is necessary</p>
<dl class="c macro">
<dt id="c.DRM_MODESET_LOCK_ALL_END">
<code class="sig-name descname">DRM_MODESET_LOCK_ALL_END</code><a class="headerlink" href="#c.DRM_MODESET_LOCK_ALL_END" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_END</span> <span class="pre">(dev,</span> <span class="pre">ctx,</span> <span class="pre">ret)</span></code></p>
<blockquote>
<div><p>Helper to release and cleanup modeset locks</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt><dd><p>local modeset acquire context, will be dereferenced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ret</span></code></dt><dd><p>local ret/err/etc variable to track error status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The other side of <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_BEGIN" title="DRM_MODESET_LOCK_ALL_BEGIN"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_BEGIN()</span></code></a>. It will bounce back to BEGIN
if ret is -EDEADLK.</p>
<p>It’s important that you use the same ret variable for begin and end so
deadlock conditions are properly handled.</p>
<p><strong>Return</strong></p>
<p>ret will be untouched unless it is -EDEADLK on entry. That means that if you
successfully acquire the locks, ret will be whatever your code sets it to. If
there is a deadlock or other failure with acquire or backoff, ret will be set
to that failure. In both of these cases the code between BEGIN/END will not
be run, so the failure will reflect the inability to grab the locks.</p>
<dl class="c function">
<dt id="c.drm_modeset_lock_all">
void <code class="sig-name descname">drm_modeset_lock_all</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn’t (yet) implemented. Locks must be dropped by calling the
<a class="reference internal" href="#c.drm_modeset_unlock_all" title="drm_modeset_unlock_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_unlock_all()</span></code></a> function.</p>
<p>This function is deprecated. It allocates a lock acquisition context and
stores it in <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>. This facilitate conversion of
existing code because it removes the need to manually deal with the
acquisition context, but it is also brittle because the context is global
and care must be taken not to nest calls. New code should use the
<a class="reference internal" href="#c.drm_modeset_lock_all_ctx" title="drm_modeset_lock_all_ctx"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_all_ctx()</span></code></a> function and pass in the context explicitly.</p>
<dl class="c function">
<dt id="c.drm_modeset_unlock_all">
void <code class="sig-name descname">drm_modeset_unlock_all</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>drop all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops all modeset locks taken by a previous call to the
<a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_all()</span></code></a> function.</p>
<p>This function is deprecated. It uses the lock acquisition context stored
in <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>. This facilitates conversion of existing
code because it removes the need to manually deal with the acquisition
context, but it is also brittle because the context is global and care must
be taken not to nest calls. New code should pass the acquisition context
directly to the <a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_drop_locks()</span></code></a> function.</p>
<dl class="c function">
<dt id="c.drm_warn_on_modeset_not_all_locked">
void <code class="sig-name descname">drm_warn_on_modeset_not_all_locked</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_warn_on_modeset_not_all_locked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check that all modeset locks are locked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful as a debug assert.</p>
<dl class="c function">
<dt id="c.drm_modeset_acquire_init">
void <code class="sig-name descname">drm_modeset_acquire_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em>, uint32_t <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the acquire context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>0 or <code class="docutils literal notranslate"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When passing <code class="docutils literal notranslate"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code> to <strong>flags</strong>,
all calls to <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a> will perform an interruptible
wait.</p>
<dl class="c function">
<dt id="c.drm_modeset_acquire_fini">
void <code class="sig-name descname">drm_modeset_acquire_fini</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_fini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cleanup acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the acquire context</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_modeset_drop_locks">
void <code class="sig-name descname">drm_modeset_drop_locks</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_drop_locks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>drop all locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop all locks currently held against this acquire context.</p>
<dl class="c function">
<dt id="c.drm_modeset_backoff">
int <code class="sig-name descname">drm_modeset_backoff</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_backoff" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deadlock avoidance backoff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If deadlock is detected (ie. <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a> returns -EDEADLK),
you must call this function to drop all currently held locks and
block until the contended lock becomes available.</p>
<p>This function returns 0 on success, or -ERESTARTSYS if this context
is initialized with <code class="docutils literal notranslate"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code> and the
wait has been interrupted.</p>
<dl class="c function">
<dt id="c.drm_modeset_lock_init">
void <code class="sig-name descname">drm_modeset_lock_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to init</p>
</dd>
</dl>
<dl class="c function">
<dt>
int <code class="sig-name descname">drm_modeset_lock</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><br /></dt>
<dd><p>take modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to take</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>acquire ctx</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>ctx</strong> is not NULL, then its ww acquire context is used and the
lock will be tracked by the context and can be released by calling
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_drop_locks()</span></code></a>.  If -EDEADLK is returned, this means a
deadlock scenario has been detected and it is an error to attempt
to take any more locks without first calling <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>If the <strong>ctx</strong> is not NULL and initialized with
<code class="docutils literal notranslate"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code>, this function will fail with
-ERESTARTSYS when interrupted.</p>
<p>If <strong>ctx</strong> is NULL then the function call behaves like a normal,
uninterruptible non-nesting <a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a> call.</p>
<dl class="c function">
<dt id="c.drm_modeset_lock_single_interruptible">
int <code class="sig-name descname">drm_modeset_lock_single_interruptible</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_single_interruptible" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>take a single modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to take</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function behaves as <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a> with a NULL context,
but performs interruptible waits.</p>
<p>This function returns 0 on success, or -ERESTARTSYS when interrupted.</p>
<dl class="c function">
<dt id="c.drm_modeset_unlock">
void <code class="sig-name descname">drm_modeset_unlock</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>drop modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*lock</span></code></dt><dd><p>lock to release</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_modeset_lock_all_ctx">
int <code class="sig-name descname">drm_modeset_lock_all_ctx</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all_ctx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn’t (yet) implemented.</p>
<p>Unlike <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock_all()</span></code></a>, it doesn’t take the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.mutex</span></code></a>
since that lock isn’t required for modeset state changes. Callers which
need to grab that lock too need to do so outside of the acquire context
<strong>ctx</strong>.</p>
<p>Locks acquired with this function should be released by calling the
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_drop_locks()</span></code></a> function on <strong>ctx</strong>.</p>
<p>See also: <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_BEGIN" title="DRM_MODESET_LOCK_ALL_BEGIN"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_BEGIN()</span></code></a> and <a class="reference internal" href="#c.DRM_MODESET_LOCK_ALL_END" title="DRM_MODESET_LOCK_ALL_END"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_MODESET_LOCK_ALL_END()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error-code on failure.</p>
</div>
<div class="section" id="kms-properties">
<h2>KMS Properties<a class="headerlink" href="#kms-properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="property-types-and-blob-property-support">
<h3>Property Types and Blob Property Support<a class="headerlink" href="#property-types-and-blob-property-support" title="Permalink to this headline">¶</a></h3>
<p>Properties as represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a> are used to extend the modeset
interface exposed to userspace. For the atomic modeset IOCTL properties are
even the only way to transport metadata about the desired new modeset
configuration from userspace to the kernel. Properties have a well-defined
value range, which is enforced by the drm core. See the documentation of the
flags member of <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a> for an overview of the different
property types and ranges.</p>
<p>Properties don’t store the current value directly, but need to be
instatiated by attaching them to a <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a> with
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<p>Property values are only 64bit. To support bigger piles of data (like gamma
tables, color correction matrices or large structures) a property can instead
point at a <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property_blob</span></code></a> with that additional data.</p>
<p>Properties are defined by their symbolic name, userspace must keep a
per-object mapping from those names to the property ID used in the atomic
IOCTL and in the get/set property IOCTL.</p>
<dl class="c struct">
<dt id="c.drm_property_enum">
<em class="property">struct </em><code class="sig-name descname">drm_property_enum</code><a class="headerlink" href="#c.drm_property_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>symbolic values for enumerations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_property_enum {
  uint64_t value;
  struct list_head head;
  char name[DRM_PROP_NAME_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>numeric property value for this enum entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>list of enum values, linked to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property.enum_list</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>symbolic name for the enum</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For enumeration and bitmask properties this structure stores the symbolic
decoding for each value. This is used for example for the rotation property.</p>
<dl class="c struct">
<dt id="c.drm_property">
<em class="property">struct </em><code class="sig-name descname">drm_property</code><a class="headerlink" href="#c.drm_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>modeset object property</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_property {
  struct list_head head;
  struct drm_mode_object base;
  uint32_t flags;
  char name[DRM_PROP_NAME_LEN];
  uint32_t num_values;
  uint64_t *values;
  struct drm_device *dev;
  struct list_head enum_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>per-device list of properties, for cleanup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base KMS object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Property flags and type. A property needs to be one of the following
types:</p>
<dl>
<dt>DRM_MODE_PROP_RANGE</dt><dd><p>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is unsigned. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_range" title="drm_property_create_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_range()</span></code></a>.</p>
</dd>
<dt>DRM_MODE_PROP_SIGNED_RANGE</dt><dd><p>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is signed. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_signed_range" title="drm_property_create_signed_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_signed_range()</span></code></a>.</p>
</dd>
<dt>DRM_MODE_PROP_ENUM</dt><dd><p>Enumerated properties take a numerical value that ranges from 0 to
the number of enumerated values defined by the property minus one,
and associate a free-formed string name to each value. Applications
can retrieve the list of defined value-name pairs and use the
numerical value to get and set property instance values. Enum
properties are created using <a class="reference internal" href="#c.drm_property_create_enum" title="drm_property_create_enum"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_enum()</span></code></a>.</p>
</dd>
<dt>DRM_MODE_PROP_BITMASK</dt><dd><p>Bitmask properties are enumeration properties that additionally
restrict all enumerated values to the 0..63 range. Bitmask property
instance values combine one or more of the enumerated bits defined
by the property. Bitmask properties are created using
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_bitmask()</span></code></a>.</p>
</dd>
<dt>DRM_MODE_PROB_OBJECT</dt><dd><p>Object properties are used to link modeset objects. This is used
extensively in the atomic support to create the display pipeline,
by linking <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> to <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> to
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>. An object property can
only link to a specific type of <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a>, this limit is
enforced by the core. Object properties are created using
<a class="reference internal" href="#c.drm_property_create_object" title="drm_property_create_object"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_object()</span></code></a>.</p>
<p>Object properties work like blob properties, but in a more
general fashion. They are limited to atomic drivers and must have
the DRM_MODE_PROP_ATOMIC flag set.</p>
</dd>
<dt>DRM_MODE_PROP_BLOB</dt><dd><p>Blob properties store a binary blob without any format restriction.
The binary blobs are created as KMS standalone objects, and blob
property instance values store the ID of their associated blob
object. Blob properties are created by calling
<a class="reference internal" href="#c.drm_property_create" title="drm_property_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create()</span></code></a> with DRM_MODE_PROP_BLOB as the type.</p>
<p>Actual blob objects to contain blob data are created using
<a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_blob()</span></code></a>, or through the corresponding IOCTL.</p>
<p>Besides the built-in limit to only accept blob objects blob
properties work exactly like object properties. The only reasons
blob properties exist is backwards compatibility with existing
userspace.</p>
</dd>
</dl>
<p>In addition a property can have any combination of the below flags:</p>
<dl class="simple">
<dt>DRM_MODE_PROP_ATOMIC</dt><dd><p>Set for properties which encode atomic modeset state. Such
properties are not exposed to legacy userspace.</p>
</dd>
<dt>DRM_MODE_PROP_IMMUTABLE</dt><dd><p>Set for properties whose values cannot be changed by
userspace. The kernel is allowed to update the value of these
properties. This is generally used to expose probe state to
userspace, e.g. the EDID, or the connector path property on DP
MST sinks. Kernel can update the value of an immutable property
by calling <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_property_set_value()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>symbolic name of the properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_values</span></code></dt><dd><p>size of the <strong>values</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">values</span></code></dt><dd><p>Array with limits and values for the property. The
interpretation of these limits is dependent upon the type per <strong>flags</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_list</span></code></dt><dd><p>List of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_prop_enum_list</span></code> structures with the symbolic names for
enum and bitmask values.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represent a modeset object property. It combines both the name
of the property with the set of permissible values. This means that when a
driver wants to use a property with the same name on different objects, but
with different value ranges, then it must create property for each one. An
example would be rotation of <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>, when e.g. the primary plane cannot
be rotated. But if both the name and the value range match, then the same
property structure can be instantiated multiple times for the same object.
Userspace must be able to cope with this and cannot assume that the same
symbolic property will have the same modeset object ID on all modeset
objects.</p>
<p>Properties are created by one of the special functions, as explained in
detail in the <strong>flags</strong> structure member.</p>
<p>To actually expose a property it must be attached to each object using
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. Currently properties can only be attached to
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>.</p>
<p>Properties are also used as the generic metadatatransport for the atomic
IOCTL. Everything that was set directly in structures in the legacy modeset
IOCTLs (like the plane source or destination windows, or e.g. the links to
the CRTC) is exposed as a property with the DRM_MODE_PROP_ATOMIC flag set.</p>
<dl class="c struct">
<dt id="c.drm_property_blob">
<em class="property">struct </em><code class="sig-name descname">drm_property_blob</code><a class="headerlink" href="#c.drm_property_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Blob data for <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_property_blob {
  struct drm_mode_object base;
  struct drm_device *dev;
  struct list_head head_global;
  struct list_head head_file;
  size_t length;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base KMS object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_global</span></code></dt><dd><p>entry on the global blob list in
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.property_blob_list</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_file</span></code></dt><dd><p>entry on the per-file blob list in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.blobs</span></code></a> list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>size of the blob in bytes, invariant over the lifetime of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>actual data, embedded at the end of this structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blobs are used to store bigger values than what fits directly into the 64
bits available for a <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property</span></code></a>.</p>
<p>Blobs are reference counted using <a class="reference internal" href="#c.drm_property_blob_get" title="drm_property_blob_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_blob_get()</span></code></a> and
<a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_blob_put()</span></code></a>. They are created using <a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_blob()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_property_type_is">
bool <code class="sig-name descname">drm_property_type_is</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint32_t <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_type_is" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check the type of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt><dd><p>property type to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function becauase the uapi encoding of property types is
a bit special for historical reasons.</p>
<dl class="c function">
<dt id="c.drm_property_find">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_find</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find property object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file to check for lease against.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>property object id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the property object specified by id and returns it.</p>
<dl class="c function">
<dt id="c.drm_property_create">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, int <em>num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_values</span></code></dt><dd><p>number of pre-defined values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_enum">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_enum</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">const</em> <em class="property">struct</em> drm_prop_enum_list *<em>props</em>, int <em>num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new enumeration property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*props</span></code></dt><dd><p>enumeration lists with property values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_values</span></code></dt><dd><p>number of pre-defined values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set one of the predefined values for enumeration
properties.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_bitmask">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_bitmask</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, <em class="property">const</em> <em class="property">struct</em> drm_prop_enum_list *<em>props</em>, int <em>num_props</em>, uint64_t <em>supported_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bitmask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new bitmask property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*props</span></code></dt><dd><p>enumeration lists with property bitflags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_props</span></code></dt><dd><p>size of the <strong>props</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">supported_bits</span></code></dt><dd><p>bitmask of all supported enumeration values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new bitmask drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Compared to plain enumeration properties userspace is allowed to set any
or’ed together combination of the predefined property bitflag values</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_range">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_range</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, uint64_t <em>min</em>, uint64_t <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new unsigned ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">min</span></code></dt><dd><p>minimum value of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">max</span></code></dt><dd><p>maximum value of the property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any unsigned integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_signed_range">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_signed_range</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, int64_t <em>min</em>, int64_t <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_signed_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new signed ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">min</span></code></dt><dd><p>minimum value of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">max</span></code></dt><dd><p>maximum value of the property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any signed integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_object">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_object</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em>, uint32_t <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_object" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new object property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt><dd><p>object type from DRM_MODE_OBJECT_* defines</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set this to any property value of the given
<strong>type</strong>. Only useful for atomic properties, which is enforced.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_create_bool">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<code class="sig-name descname">drm_property_create_bool</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, u32 <em>flags</em>, <em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new boolean property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>flags specifying the property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>This is implemented as a ranged property with only {0, 1} as valid values.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="c function">
<dt id="c.drm_property_add_enum">
int <code class="sig-name descname">drm_property_add_enum</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em>, uint64_t <em>value</em>, <em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_add_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a possible value to an enumeration property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>enumeration property to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt><dd><p>value of the new enumeration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>symbolic name of the new enumeration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions adds enumerations to a property.</p>
<p>It’s use is deprecated, drivers should use one of the more specific helpers
to directly create the property with all enumerations already attached.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="c function">
<dt id="c.drm_property_destroy">
void <code class="sig-name descname">drm_property_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>property</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy a drm property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>property to destry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees a property including any attached resources like
enumeration values.</p>
<dl class="c function">
<dt id="c.drm_property_create_blob">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<code class="sig-name descname">drm_property_create_blob</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, size_t <em>length</em>, <em class="property">const</em> void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create new blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device to create property for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>Length to allocate for blob data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>If specified, copies data into blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new blob property for a specified DRM device, optionally
copying data. Note that blob properties are meant to be invariant, hence the
data must be filled out before the blob is used as the value of any property.</p>
<p><strong>Return</strong></p>
<p>New blob property with a single reference on success, or an ERR_PTR
value on failure.</p>
<dl class="c function">
<dt id="c.drm_property_blob_put">
void <code class="sig-name descname">drm_property_blob_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*blob</span></code></dt><dd><p>DRM blob property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference to a blob property. May free the object.</p>
<dl class="c function">
<dt id="c.drm_property_blob_get">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<code class="sig-name descname">drm_property_blob_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>acquire blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*blob</span></code></dt><dd><p>DRM blob property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a reference to an existing blob property. Returns <strong>blob</strong>, which
allows this to be used as a shorthand in assignments.</p>
<dl class="c function">
<dt id="c.drm_property_lookup_blob">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<code class="sig-name descname">drm_property_lookup_blob</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, uint32_t <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_lookup_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>look up a blob property and take a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt><dd><p>id of the blob property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this takes an additional reference to the blob property.
callers need to make sure to eventually unreference the returned property
again, using <a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_blob_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>NULL on failure, pointer to the blob on success.</p>
<dl class="c function">
<dt id="c.drm_property_replace_global_blob">
int <code class="sig-name descname">drm_property_replace_global_blob</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>replace</em>, size_t <em>length</em>, <em class="property">const</em> void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>obj_holds_id</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>prop_holds_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_replace_global_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace existing blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**replace</span></code></dt><dd><p>location of blob property pointer to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of data for new blob, or 0 for no data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>content for new blob, or NULL for no data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*obj_holds_id</span></code></dt><dd><p>optional object for property holding blob ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*prop_holds_id</span></code></dt><dd><p>optional property holding blob ID
<strong>return</strong> 0 on success or error on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will replace a global property in the blob list, optionally
updating a property which holds the ID of that property.</p>
<p>If length is 0 or data is NULL, no new blob will be created, and the holding
property, if specified, will be set to 0.</p>
<p>Access to the replace pointer is assumed to be protected by the caller, e.g.
by holding the relevant modesetting object lock for its parent.</p>
<p>For example, a drm_connector has a ‘PATH’ property, which contains the ID
of a blob property with the value of the MST path information. Calling this
function with replace pointing to the connector’s path_blob_ptr, length and
data set for the new path information, obj_holds_id set to the connector’s
base object, and prop_holds_id set to the path property name, will perform
a completely atomic update. The access to path_blob_ptr is protected by the
caller holding a lock on the connector.</p>
<dl class="c function">
<dt id="c.drm_property_replace_blob">
bool <code class="sig-name descname">drm_property_replace_blob</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>blob</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>new_blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_replace_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace a blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**blob</span></code></dt><dd><p>a pointer to the member blob to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*new_blob</span></code></dt><dd><p>the new blob to replace with</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the blob was in fact replaced.</p>
</div>
<div class="section" id="standard-connector-properties">
<h3>Standard Connector Properties<a class="headerlink" href="#standard-connector-properties" title="Permalink to this headline">¶</a></h3>
<p>DRM connectors have a few standardized properties:</p>
<dl>
<dt>EDID:</dt><dd><p>Blob property which contains the current EDID read from the sink. This
is useful to parse sink identification information like vendor, model
and serial. Drivers should update this property by calling
<a class="reference internal" href="#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_update_edid_property()</span></code></a>, usually after having parsed
the EDID using <a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_edid_modes()</span></code></a>. Userspace cannot change this
property.</p>
</dd>
<dt>DPMS:</dt><dd><p>Legacy property for setting the power state of the connector. For atomic
drivers this is only provided for backwards compatibility with existing
drivers, it remaps to controlling the “ACTIVE” property on the CRTC the
connector is linked to. Drivers should never set this property directly,
it is handled by the DRM core by calling the <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.dpms</span></code></a>
callback. For atomic drivers the remapping to the “ACTIVE” property is
implemented in the DRM core.</p>
<p>Note that this property cannot be set through the MODE_ATOMIC ioctl,
userspace must use “ACTIVE” on the CRTC instead.</p>
<p>WARNING:</p>
<p>For userspace also running on legacy drivers the “DPMS” semantics are a
lot more complicated. First, userspace cannot rely on the “DPMS” value
returned by the GETCONNECTOR actually reflecting reality, because many
drivers fail to update it. For atomic drivers this is taken care of in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
<p>The second issue is that the DPMS state is only well-defined when the
connector is connected to a CRTC. In atomic the DRM core enforces that
“ACTIVE” is off in such a case, no such checks exists for “DPMS”.</p>
<p>Finally, when enabling an output using the legacy SETCONFIG ioctl then
“DPMS” is forced to ON. But see above, that might not be reflected in
the software value on legacy drivers.</p>
<p>Summarizing: Only set “DPMS” when the connector is known to be enabled,
assume that a successful SETCONFIG call also sets “DPMS” to on, and
never read back the value of “DPMS” because it can be incorrect.</p>
</dd>
<dt>PATH:</dt><dd><p>Connector path property to identify how this sink is physically
connected. Used by DP MST. This should be set by calling
<a class="reference internal" href="#c.drm_connector_set_path_property" title="drm_connector_set_path_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_path_property()</span></code></a>, in the case of DP MST with the
path property the MST manager created. Userspace cannot change this
property.</p>
</dd>
<dt>TILE:</dt><dd><p>Connector tile group property to indicate how a set of DRM connector
compose together into one logical screen. This is used by both high-res
external screens (often only using a single cable, but exposing multiple
DP MST sinks), or high-res integrated panels (like dual-link DSI) which
are not gen-locked. Note that for tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose the
tiling and virtualise both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> if needed. Drivers
should update this value using <a class="reference internal" href="#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_tile_property()</span></code></a>.
Userspace cannot change this property.</p>
</dd>
<dt>link-status:</dt><dd><p>Connector link-status property to indicate the status of link. The
default value of link-status is “GOOD”. If something fails during or
after modeset, the kernel driver may set this to “BAD” and issue a
hotplug uevent. Drivers should update this value using
<a class="reference internal" href="#c.drm_connector_set_link_status_property" title="drm_connector_set_link_status_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_link_status_property()</span></code></a>.</p>
<p>When user-space receives the hotplug uevent and detects a “BAD”
link-status, the sink doesn’t receive pixels anymore (e.g. the screen
becomes completely black). The list of available modes may have
changed. User-space is expected to pick a new mode if the current one
has disappeared and perform a new modeset with link-status set to
“GOOD” to re-enable the connector.</p>
<p>If multiple connectors share the same CRTC and one of them gets a “BAD”
link-status, the other are unaffected (ie. the sinks still continue to
receive pixels).</p>
<p>When user-space performs an atomic commit on a connector with a “BAD”
link-status without resetting the property to “GOOD”, the sink may
still not receive pixels. When user-space performs an atomic commit
which resets the link-status property to “GOOD” without the
ALLOW_MODESET flag set, it might fail because a modeset is required.</p>
<p>User-space can only change link-status to “GOOD”, changing it to “BAD”
is a no-op.</p>
<p>For backwards compatibility with non-atomic userspace the kernel
tries to automatically set the link-status back to “GOOD” in the
SETCRTC IOCTL. This might fail if the mode is no longer valid, similar
to how it might fail if a different screen has been connected in the
interim.</p>
</dd>
<dt>non_desktop:</dt><dd><p>Indicates the output should be ignored for purposes of displaying a
standard desktop environment or console. This is most likely because
the output device is not rectilinear.</p>
</dd>
<dt>Content Protection:</dt><dd><p>This property is used by userspace to request the kernel protect future
content communicated over the link. When requested, kernel will apply
the appropriate means of protection (most often HDCP), and use the
property to tell userspace the protection is active.</p>
<p>Drivers can set this up by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a> on initialization.</p>
<p>The value of this property can be one of the following:</p>
<dl class="simple">
<dt>DRM_MODE_CONTENT_PROTECTION_UNDESIRED = 0</dt><dd><p>The link is not protected, content is transmitted in the clear.</p>
</dd>
<dt>DRM_MODE_CONTENT_PROTECTION_DESIRED = 1</dt><dd><p>Userspace has requested content protection, but the link is not
currently protected. When in this state, kernel should enable
Content Protection as soon as possible.</p>
</dd>
<dt>DRM_MODE_CONTENT_PROTECTION_ENABLED = 2</dt><dd><p>Userspace has requested content protection, and the link is
protected. Only the driver can set the property to this value.
If userspace attempts to set to ENABLED, kernel will return
-EINVAL.</p>
</dd>
</dl>
<p>A few guidelines:</p>
<ul>
<li><p>DESIRED state should be preserved until userspace de-asserts it by
setting the property to UNDESIRED. This means ENABLED should only
transition to UNDESIRED when the user explicitly requests it.</p></li>
<li><p>If the state is DESIRED, kernel should attempt to re-authenticate the
link whenever possible. This includes across disable/enable, dpms,
hotplug, downstream device changes, link status failures, etc..</p></li>
<li><p>Kernel sends uevent with the connector id and property id through
<strong>drm_hdcp_update_content_protection</strong>, upon below kernel triggered
scenarios:</p>
<blockquote>
<div><ul class="simple">
<li><p>DESIRED -&gt; ENABLED (authentication success)</p></li>
<li><p>ENABLED -&gt; DESIRED (termination of authentication)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Please note no uevents for userspace triggered property state changes,
which can’t fail such as</p>
<blockquote>
<div><ul class="simple">
<li><p>DESIRED/ENABLED -&gt; UNDESIRED</p></li>
<li><p>UNDESIRED -&gt; DESIRED</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Userspace is responsible for polling the property or listen to uevents
to determine when the value transitions from ENABLED to DESIRED.
This signifies the link is no longer protected and userspace should
take appropriate action (whatever that might be).</p></li>
</ul>
</dd>
<dt>HDCP Content Type:</dt><dd><p>This Enum property is used by the userspace to declare the content type
of the display stream, to kernel. Here display stream stands for any
display content that userspace intended to display through HDCP
encryption.</p>
<p>Content Type of a stream is decided by the owner of the stream, as
“HDCP Type0” or “HDCP Type1”.</p>
<dl class="simple">
<dt>The value of the property can be one of the below:</dt><dd><ul class="simple">
<li><p>“HDCP Type0”: DRM_MODE_HDCP_CONTENT_TYPE0 = 0</p></li>
<li><p>“HDCP Type1”: DRM_MODE_HDCP_CONTENT_TYPE1 = 1</p></li>
</ul>
</dd>
</dl>
<p>When kernel starts the HDCP authentication (see “Content Protection”
for details), it uses the content type in “HDCP Content Type”
for performing the HDCP authentication with the display sink.</p>
<p>Please note in HDCP spec versions, a link can be authenticated with
HDCP 2.2 for Content Type 0/Content Type 1. Where as a link can be
authenticated with HDCP1.4 only for Content Type 0(though it is implicit
in nature. As there is no reference for Content Type in HDCP1.4).</p>
<p>HDCP2.2 authentication protocol itself takes the “Content Type” as a
parameter, which is a input for the DP HDCP2.2 encryption algo.</p>
<p>In case of Type 0 content protection request, kernel driver can choose
either of HDCP spec versions 1.4 and 2.2. When HDCP2.2 is used for
“HDCP Type 0”, a HDCP 2.2 capable repeater in the downstream can send
that content to a HDCP 1.4 authenticated HDCP sink (Type0 link).
But if the content is classified as “HDCP Type 1”, above mentioned
HDCP 2.2 repeater wont send the content to the HDCP sink as it can’t
authenticate the HDCP1.4 capable sink for “HDCP Type 1”.</p>
<p>Please note userspace can be ignorant of the HDCP versions used by the
kernel driver to achieve the “HDCP Content Type”.</p>
<p>At current scenario, classifying a content as Type 1 ensures that the
content will be displayed only through the HDCP2.2 encrypted link.</p>
<p>Note that the HDCP Content Type property is introduced at HDCP 2.2, and
defaults to type 0. It is only exposed by drivers supporting HDCP 2.2
(hence supporting Type 0 and Type 1). Based on how next versions of
HDCP specs are defined content Type could be used for higher versions
too.</p>
<p>If content type is changed when “Content Protection” is not UNDESIRED,
then kernel will disable the HDCP and re-enable with new type in the
same atomic commit. And when “Content Protection” is ENABLED, it means
that link is HDCP authenticated and encrypted, for the transmission of
the Type of stream mentioned at “HDCP Content Type”.</p>
</dd>
<dt>HDR_OUTPUT_METADATA:</dt><dd><p>Connector property to enable userspace to send HDR Metadata to
driver. This metadata is based on the composition and blending
policies decided by user, taking into account the hardware and
sink capabilities. The driver gets this metadata and creates a
Dynamic Range and Mastering Infoframe (DRM) in case of HDMI,
SDP packet (Non-audio INFOFRAME SDP v1.3) for DP. This is then
sent to sink. This notifies the sink of the upcoming frame’s Color
Encoding and Luminance parameters.</p>
<p>Userspace first need to detect the HDR capabilities of sink by
reading and parsing the EDID. Details of HDR metadata for HDMI
are added in CTA 861.G spec. For DP , its defined in VESA DP
Standard v1.4. It needs to then get the metadata information
of the video/game/app content which are encoded in HDR (basically
using HDR transfer functions). With this information it needs to
decide on a blending policy and compose the relevant
layers/overlays into a common format. Once this blending is done,
userspace will be aware of the metadata of the composed frame to
be send to sink. It then uses this property to communicate this
metadata to driver which then make a Infoframe packet and sends
to sink based on the type of encoder connected.</p>
<dl class="simple">
<dt>Userspace will be responsible to do Tone mapping operation in case:</dt><dd><ul class="simple">
<li><p>Some layers are HDR and others are SDR</p></li>
<li><p>HDR layers luminance is not same as sink</p></li>
</ul>
</dd>
</dl>
<p>It will even need to do colorspace conversion and get all layers
to one common colorspace for blending. It can use either GL, Media
or display engine to get this done based on the capabilities of the
associated hardware.</p>
<p>Driver expects metadata to be put in <a class="reference internal" href="drm-uapi.html#c.hdr_output_metadata" title="hdr_output_metadata"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdr_output_metadata</span></code></a>
structure from userspace. This is received as blob and stored in
<a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.hdr_output_metadata</span></code></a>. It parses EDID and saves the
sink metadata in <a class="reference internal" href="drm-kms-helpers.html#c.hdr_sink_metadata" title="hdr_sink_metadata"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdr_sink_metadata</span></code></a>, as
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.hdr_sink_metadata</span></code></a>.  Driver uses
<a class="reference internal" href="drm-kms-helpers.html#c.drm_hdmi_infoframe_set_hdr_metadata" title="drm_hdmi_infoframe_set_hdr_metadata"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_hdmi_infoframe_set_hdr_metadata()</span></code></a> helper to set the HDR metadata,
<a class="reference internal" href="drm-kms-helpers.html#c.hdmi_drm_infoframe_pack" title="hdmi_drm_infoframe_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">hdmi_drm_infoframe_pack()</span></code></a> to pack the infoframe as per spec, in case of
HDMI encoder.</p>
</dd>
<dt>max bpc:</dt><dd><p>This range property is used by userspace to limit the bit depth. When
used the driver would limit the bpc in accordance with the valid range
supported by the hardware and sink. Drivers to use the function
<a class="reference internal" href="#c.drm_connector_attach_max_bpc_property" title="drm_connector_attach_max_bpc_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_max_bpc_property()</span></code></a> to create and attach the
property to the connector during initialization.</p>
</dd>
</dl>
<p>Connectors also have one standardized atomic property:</p>
<dl class="simple">
<dt>CRTC_ID:</dt><dd><p>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> this connector should be connected to.</p>
</dd>
</dl>
<p>Connectors for LCD panels may also have one standardized property:</p>
<dl>
<dt>panel orientation:</dt><dd><p>On some devices the LCD panel is mounted in the casing in such a way
that the up/top side of the panel does not match with the top side of
the device. Userspace can use this property to check for this.
Note that input coordinates from touchscreens (input devices with
INPUT_PROP_DIRECT) will still map 1:1 to the actual LCD panel
coordinates, so if userspace rotates the picture to adjust for
the orientation it must also apply the same transformation to the
touchscreen input coordinates. This property is initialized by calling
<a class="reference internal" href="#c.drm_connector_set_panel_orientation" title="drm_connector_set_panel_orientation"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_panel_orientation()</span></code></a> or
<a class="reference internal" href="#c.drm_connector_set_panel_orientation_with_quirk" title="drm_connector_set_panel_orientation_with_quirk"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_panel_orientation_with_quirk()</span></code></a></p>
</dd>
<dt>scaling mode:</dt><dd><p>This property defines how a non-native mode is upscaled to the native
mode of an LCD panel:</p>
<dl class="simple">
<dt>None:</dt><dd><p>No upscaling happens, scaling is left to the panel. Not all
drivers expose this mode.</p>
</dd>
<dt>Full:</dt><dd><p>The output is upscaled to the full resolution of the panel,
ignoring the aspect ratio.</p>
</dd>
<dt>Center:</dt><dd><p>No upscaling happens, the output is centered within the native
resolution the panel.</p>
</dd>
<dt>Full aspect:</dt><dd><p>The output is upscaled to maximize either the width or height
while retaining the aspect ratio.</p>
</dd>
</dl>
<p>This property should be set up by calling
<a class="reference internal" href="#c.drm_connector_attach_scaling_mode_property" title="drm_connector_attach_scaling_mode_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_scaling_mode_property()</span></code></a>. Note that drivers
can also expose this property to external outputs, in which case they
must support “None”, which should be the default (since external screens
have a built-in scaler).</p>
</dd>
<dt>subconnector:</dt><dd><p>This property is used by DVI-I, TVout and DisplayPort to indicate different
connector subtypes. Enum values more or less match with those from main
connector types.
For DVI-I and TVout there is also a matching property “select subconnector”
allowing to switch between signal types.
DP subconnector corresponds to a downstream port.</p>
</dd>
<dt>Colorspace:</dt><dd><p>This property helps select a suitable colorspace based on the sink
capability. Modern sink devices support wider gamut like BT2020.
This helps switch to BT2020 mode if the BT2020 encoded video stream
is being played by the user, same for any other colorspace. Thereby
giving a good visual experience to users.</p>
<p>The expectation from userspace is that it should parse the EDID
and get supported colorspaces. Use this property and switch to the
one supported. Sink supported colorspaces should be retrieved by
userspace from EDID and driver will not explicitly expose them.</p>
<dl class="simple">
<dt>Basically the expectation from userspace is:</dt><dd><ul class="simple">
<li><p>Set up CRTC DEGAMMA/CTM/GAMMA to convert to some sink
colorspace</p></li>
<li><p>Set this new property to let the sink know what it
converted the CRTC output to.</p></li>
<li><p>This property is just to inform sink what colorspace
source is trying to drive.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>Because between HDMI and DP have different colorspaces,
<a class="reference internal" href="#c.drm_mode_create_hdmi_colorspace_property" title="drm_mode_create_hdmi_colorspace_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create_hdmi_colorspace_property()</span></code></a> is used for HDMI connector and
<a class="reference internal" href="#c.drm_mode_create_dp_colorspace_property" title="drm_mode_create_dp_colorspace_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create_dp_colorspace_property()</span></code></a> is used for DP connector.</p>
</div>
<div class="section" id="hdmi-specific-connector-properties">
<h3>HDMI Specific Connector Properties<a class="headerlink" href="#hdmi-specific-connector-properties" title="Permalink to this headline">¶</a></h3>
<dl>
<dt>content type (HDMI specific):</dt><dd><p>Indicates content type setting to be used in HDMI infoframes to indicate
content type for the external device, so that it adjusts its display
settings accordingly.</p>
<p>The value of this property can be one of the following:</p>
<dl class="simple">
<dt>No Data:</dt><dd><p>Content type is unknown</p>
</dd>
<dt>Graphics:</dt><dd><p>Content type is graphics</p>
</dd>
<dt>Photo:</dt><dd><p>Content type is photo</p>
</dd>
<dt>Cinema:</dt><dd><p>Content type is cinema</p>
</dd>
<dt>Game:</dt><dd><p>Content type is game</p>
</dd>
</dl>
<p>Drivers can set up this property by calling
<a class="reference internal" href="#c.drm_connector_attach_content_type_property" title="drm_connector_attach_content_type_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_content_type_property()</span></code></a>. Decoding to
infoframe values is done through <a class="reference internal" href="#c.drm_hdmi_avi_infoframe_content_type" title="drm_hdmi_avi_infoframe_content_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_hdmi_avi_infoframe_content_type()</span></code></a>.</p>
</dd>
</dl>
</div>
<div class="section" id="standard-crtc-properties">
<h3>Standard CRTC Properties<a class="headerlink" href="#standard-crtc-properties" title="Permalink to this headline">¶</a></h3>
<p>DRM CRTCs have a few standardized properties:</p>
<dl>
<dt>ACTIVE:</dt><dd><p>Atomic property for setting the power state of the CRTC. When set to 1
the CRTC will actively display content. When set to 0 the CRTC will be
powered off. There is no expectation that user-space will reset CRTC
resources like the mode and planes when setting ACTIVE to 0.</p>
<p>User-space can rely on an ACTIVE change to 1 to never fail an atomic
test as long as no other property has changed. If a change to ACTIVE
fails an atomic test, this is a driver bug. For this reason setting
ACTIVE to 0 must not release internal resources (like reserved memory
bandwidth or clock generators).</p>
<p>Note that the legacy DPMS property on connectors is internally routed
to control this property for atomic drivers.</p>
</dd>
<dt>MODE_ID:</dt><dd><p>Atomic property for setting the CRTC display timings. The value is the
ID of a blob containing the DRM mode info. To disable the CRTC,
user-space must set this property to 0.</p>
<p>Setting MODE_ID to 0 will release reserved resources for the CRTC.</p>
</dd>
</dl>
</div>
<div class="section" id="plane-composition-properties">
<h3>Plane Composition Properties<a class="headerlink" href="#plane-composition-properties" title="Permalink to this headline">¶</a></h3>
<p>The basic plane composition model supported by standard plane properties only
has a source rectangle (in logical pixels within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>), with
sub-pixel accuracy, which is scaled up to a pixel-aligned destination
rectangle in the visible area of a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>. The visible area of a CRTC is
defined by the horizontal and vertical visible pixels (stored in <strong>hdisplay</strong>
and <strong>vdisplay</strong>) of the requested mode (stored in <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode</span></code></a>). These
two rectangles are both stored in the <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>For the atomic ioctl the following standard (atomic) properties on the plane object
encode the basic plane composition model:</p>
<dl class="simple">
<dt>SRC_X:</dt><dd><p>X coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</p>
</dd>
<dt>SRC_Y:</dt><dd><p>Y coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</p>
</dd>
<dt>SRC_W:</dt><dd><p>Width for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_X plus SRC_W must be within the width of the source
framebuffer. Must be positive.</p>
</dd>
<dt>SRC_H:</dt><dd><p>Height for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_Y plus SRC_H must be within the height of the source
framebuffer. Must be positive.</p>
</dd>
<dt>CRTC_X:</dt><dd><p>X coordinate offset for the destination rectangle. Can be negative.</p>
</dd>
<dt>CRTC_Y:</dt><dd><p>Y coordinate offset for the destination rectangle. Can be negative.</p>
</dd>
<dt>CRTC_W:</dt><dd><p>Width for the destination rectangle. CRTC_X plus CRTC_W can extend past
the currently visible horizontal area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>.</p>
</dd>
<dt>CRTC_H:</dt><dd><p>Height for the destination rectangle. CRTC_Y plus CRTC_H can extend past
the currently visible vertical area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a>.</p>
</dd>
<dt>FB_ID:</dt><dd><p>Mode object ID of the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> this plane should scan out.</p>
</dd>
<dt>CRTC_ID:</dt><dd><p>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> this plane should be connected to.</p>
</dd>
</dl>
<p>Note that the source rectangle must fully lie within the bounds of the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a>. The destination rectangle can lie outside of the visible
area of the current mode of the CRTC. It must be apprpriately clipped by the
driver, which can be done by calling drm_plane_helper_check_update(). Drivers
are also allowed to round the subpixel sampling positions appropriately, but
only to the next full pixel. No pixel outside of the source rectangle may
ever be sampled, which is important when applying more sophisticated
filtering than just a bilinear one when scaling. The filtering mode when
scaling is unspecified.</p>
<p>On top of this basic transformation additional properties can be exposed by
the driver:</p>
<dl>
<dt>alpha:</dt><dd><p>Alpha is setup with <a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_alpha_property()</span></code></a>. It controls the
plane-wide opacity, from transparent (0) to opaque (0xffff). It can be
combined with pixel alpha.
The pixel values in the framebuffers are expected to not be
pre-multiplied by the global alpha associated to the plane.</p>
</dd>
<dt>rotation:</dt><dd><p>Rotation is set up with <a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_rotation_property()</span></code></a>. It adds a
rotation and reflection step between the source and destination rectangles.
Without this property the rectangle is only scaled, but not rotated or
reflected.</p>
<p>Possbile values:</p>
<dl class="simple">
<dt>“rotate-&lt;degrees&gt;”:</dt><dd><p>Signals that a drm plane is rotated &lt;degrees&gt; degrees in counter
clockwise direction.</p>
</dd>
<dt>“reflect-&lt;axis&gt;”:</dt><dd><p>Signals that the contents of a drm plane is reflected along the
&lt;axis&gt; axis, in the same way as mirroring.</p>
</dd>
</dl>
<p>reflect-x:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|o |    | o|
|  | -&gt; |  |
| v|    |v |
</pre></div>
</div>
<p>reflect-y:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|o |    | ^|
|  | -&gt; |  |
| v|    |o |
</pre></div>
</div>
</dd>
<dt>zpos:</dt><dd><p>Z position is set up with <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> and
<a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_property()</span></code></a>. It controls the visibility of overlapping
planes. Without this property the primary plane is always below the cursor
plane, and ordering between all other planes is undefined. The positive
Z axis points towards the user, i.e. planes with lower Z position values
are underneath planes with higher Z position values. Two planes with the
same Z position value have undefined ordering. Note that the Z position
value can also be immutable, to inform userspace about the hard-coded
stacking of planes, see <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a>. If
any plane has a zpos property (either mutable or immutable), then all
planes shall have a zpos property.</p>
</dd>
<dt>pixel blend mode:</dt><dd><p>Pixel blend mode is set up with <a class="reference internal" href="#c.drm_plane_create_blend_mode_property" title="drm_plane_create_blend_mode_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_blend_mode_property()</span></code></a>.
It adds a blend mode for alpha blending equation selection, describing
how the pixels from the current plane are composited with the
background.</p>
<blockquote>
<div><p>Three alpha blending equations are defined:</p>
<dl>
<dt>“None”:</dt><dd><p>Blend formula that ignores the pixel alpha:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>out.rgb = plane_alpha * fg.rgb +
        (1 - plane_alpha) * bg.rgb
</pre></div>
</div>
</dd>
<dt>“Pre-multiplied”:</dt><dd><p>Blend formula that assumes the pixel color values
have been already pre-multiplied with the alpha
channel values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>out.rgb = plane_alpha * fg.rgb +
        (1 - (plane_alpha * fg.alpha)) * bg.rgb
</pre></div>
</div>
</dd>
<dt>“Coverage”:</dt><dd><p>Blend formula that assumes the pixel color values have not
been pre-multiplied and will do so when blending them to the
background color values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>out.rgb = plane_alpha * fg.alpha * fg.rgb +
        (1 - (plane_alpha * fg.alpha)) * bg.rgb
</pre></div>
</div>
</dd>
</dl>
<p>Using the following symbols:</p>
<dl class="simple">
<dt>“fg.rgb”:</dt><dd><p>Each of the RGB component values from the plane’s pixel</p>
</dd>
<dt>“fg.alpha”:</dt><dd><p>Alpha component value from the plane’s pixel. If the plane’s
pixel format has no alpha component, then this is assumed to be
1.0. In these cases, this property has no effect, as all three
equations become equivalent.</p>
</dd>
<dt>“bg.rgb”:</dt><dd><p>Each of the RGB component values from the background</p>
</dd>
<dt>“plane_alpha”:</dt><dd><p>Plane alpha value set by the plane “alpha” property. If the
plane does not expose the “alpha” property, then this is
assumed to be 1.0</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>IN_FORMATS:</dt><dd><p>Blob property which contains the set of buffer format and modifier
pairs supported by this plane. The blob is a drm_format_modifier_blob
struct. Without this property the plane doesn’t support buffers with
modifiers. Userspace cannot change this property.</p>
</dd>
</dl>
<p>Note that all the property extensions described here apply either to the
plane or the CRTC (e.g. for the background color, which currently is not
exposed and assumed to be black).</p>
<dl class="c function">
<dt id="c.drm_plane_create_alpha_property">
int <code class="sig-name descname">drm_plane_create_alpha_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_alpha_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new alpha property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a generic, mutable, alpha property and enables support
for it in the DRM core. It is attached to <strong>plane</strong>.</p>
<p>The alpha property will be allowed to be within the bounds of 0
(transparent) to 0xffff (opaque).</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_plane_create_rotation_property">
int <code class="sig-name descname">drm_plane_create_rotation_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, unsigned int <em>rotation</em>, unsigned int <em>supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_rotation_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new rotation property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>initial value of the rotation property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt><dd><p>bitmask of supported rotations and reflections</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new property with the selected support for transformations.</p>
<p>Since a rotation by 180° degress is the same as reflecting both along the x
and the y axis the rotation property is somewhat redundant. Drivers can use
<a class="reference internal" href="#c.drm_rotation_simplify" title="drm_rotation_simplify"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_rotation_simplify()</span></code></a> to normalize values of this property.</p>
<p>The property exposed to userspace is a bitmask property (see
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_bitmask()</span></code></a>) called “rotation” and has the following
bitmask enumaration values:</p>
<dl class="simple">
<dt>DRM_MODE_ROTATE_0:</dt><dd><p>“rotate-0”</p>
</dd>
<dt>DRM_MODE_ROTATE_90:</dt><dd><p>“rotate-90”</p>
</dd>
<dt>DRM_MODE_ROTATE_180:</dt><dd><p>“rotate-180”</p>
</dd>
<dt>DRM_MODE_ROTATE_270:</dt><dd><p>“rotate-270”</p>
</dd>
<dt>DRM_MODE_REFLECT_X:</dt><dd><p>“reflect-x”</p>
</dd>
<dt>DRM_MODE_REFLECT_Y:</dt><dd><p>“reflect-y”</p>
</dd>
</dl>
<p>Rotation is the specified amount in degrees in counter clockwise direction,
the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
rotation. After reflection, the rotation is applied to the image sampled from
the source rectangle, before scaling it to fit the destination rectangle.</p>
<dl class="c function">
<dt id="c.drm_rotation_simplify">
unsigned int <code class="sig-name descname">drm_rotation_simplify</code><span class="sig-paren">(</span>unsigned int <em>rotation</em>, unsigned int <em>supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rotation_simplify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Try to simplify the rotation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Rotation to be simplified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt><dd><p>Supported rotations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to simplify the rotation to a form that is supported.
Eg. if the hardware supports everything except DRM_MODE_REFLECT_X
one could call this function like this:</p>
<dl class="simple">
<dt>drm_rotation_simplify(rotation, DRM_MODE_ROTATE_0 |</dt><dd><p>DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |
DRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_Y);</p>
</dd>
</dl>
<p>to eliminate the DRM_MODE_ROTATE_X flag. Depending on what kind of
transforms the hardware supports, this function may not
be able to produce a supported transform, so the caller should
check the result afterwards.</p>
<dl class="c function">
<dt id="c.drm_plane_create_zpos_property">
int <code class="sig-name descname">drm_plane_create_zpos_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, unsigned int <em>zpos</em>, unsigned int <em>min</em>, unsigned int <em>max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create mutable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt><dd><p>initial value of zpos property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>minimal possible value of zpos property</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>maximal possible value of zpos property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic mutable zpos property and enables support
for it in drm core. Drivers can then attach this property to planes to enable
support for configurable planes arrangement during blending operation.
Drivers that attach a mutable zpos property to any plane should call the
<a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> helper during their implementation of
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check()</span></code></a>, which will update the normalized zpos
values and store them in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.normalized_zpos</span></code></a>. Usually min
should be set to 0 and max to maximal number of planes for given crtc - 1.</p>
<p>If zpos of some planes cannot be changed (like fixed background or
cursor/topmost planes), drivers shall adjust the min/max values and assign
those planes immutable zpos properties with lower or higher values (for more
information, see <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> function). In such
case drivers shall also assign proper initial zpos values for all planes in
its plane_reset() callback, so the planes will be always sorted properly.</p>
<p>See also <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_normalize_zpos()</span></code></a>.</p>
<p>The property exposed to userspace is called “zpos”.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_plane_create_zpos_immutable_property">
int <code class="sig-name descname">drm_plane_create_zpos_immutable_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, unsigned int <em>zpos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_immutable_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create immuttable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt><dd><p>value of zpos property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic immutable zpos property and enables
support for it in drm core. Using this property driver lets userspace
to get the arrangement of the planes for blending operation and notifies
it that the hardware (or driver) doesn’t support changing of the planes’
order. For mutable zpos see <a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_zpos_property()</span></code></a>.</p>
<p>The property exposed to userspace is called “zpos”.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_atomic_normalize_zpos">
int <code class="sig-name descname">drm_atomic_normalize_zpos</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_normalize_zpos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate normalized zpos values for all crtcs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state of DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calculates normalized zpos value for all modified planes in
the provided atomic state of DRM device.</p>
<p>For every CRTC this function checks new states of all planes assigned to
it and calculates normalized zpos value for these planes. Planes are compared
first by their zpos values, then by plane id (if zpos is equal). The plane
with lowest zpos value is at the bottom. The <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.normalized_zpos</span></code></a>
is then filled with unique values from 0 to number of active planes in crtc
minus one.</p>
<p>RETURNS
Zero for success or -errno</p>
<dl class="c function">
<dt id="c.drm_plane_create_blend_mode_property">
int <code class="sig-name descname">drm_plane_create_blend_mode_property</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, unsigned int <em>supported_modes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_blend_mode_property" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new blend mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_modes</span></code></dt><dd><p>bitmask of supported modes, must include
BIT(DRM_MODE_BLEND_PREMULTI). Current DRM assumption is
that alpha is premultiplied, and old userspace can break if
the property defaults to anything else.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new property describing the blend mode.</p>
<p>The property exposed to userspace is an enumeration property (see
<a class="reference internal" href="#c.drm_property_create_enum" title="drm_property_create_enum"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_property_create_enum()</span></code></a>) called “pixel blend mode” and has the
following enumeration values:</p>
<dl class="simple">
<dt>“None”:</dt><dd><p>Blend formula that ignores the pixel alpha.</p>
</dd>
<dt>“Pre-multiplied”:</dt><dd><p>Blend formula that assumes the pixel color values have been already
pre-multiplied with the alpha channel values.</p>
</dd>
<dt>“Coverage”:</dt><dd><p>Blend formula that assumes the pixel color values have not been
pre-multiplied and will do so when blending them to the background color
values.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<div class="section" id="fb-damage-clips">
<h4>FB_DAMAGE_CLIPS<a class="headerlink" href="#fb-damage-clips" title="Permalink to this headline">¶</a></h4>
<p>FB_DAMAGE_CLIPS is an optional plane property which provides a means to
specify a list of damage rectangles on a plane in framebuffer coordinates of
the framebuffer attached to the plane. In current context damage is the area
of plane framebuffer that has changed since last plane update (also called
page-flip), irrespective of whether currently attached framebuffer is same as
framebuffer attached during last plane update or not.</p>
<p>FB_DAMAGE_CLIPS is a hint to kernel which could be helpful for some drivers
to optimize internally especially for virtual devices where each framebuffer
change needs to be transmitted over network, usb, etc.</p>
<p>Since FB_DAMAGE_CLIPS is a hint so it is an optional property. User-space can
ignore damage clips property and in that case driver will do a full plane
update. In case damage clips are provided then it is guaranteed that the area
inside damage clips will be updated to plane. For efficiency driver can do
full update or can update more than specified in damage clips. Since driver
is free to read more, user-space must always render the entire visible
framebuffer. Otherwise there can be corruptions. Also, if a user-space
provides damage clips which doesn’t encompass the actual damage to
framebuffer (since last plane update) can result in incorrect rendering.</p>
<p>FB_DAMAGE_CLIPS is a blob property with the layout of blob data is simply an
array of <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a>. Unlike plane <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.src</span></code></a> coordinates,
damage clips are not in 16.16 fixed point. Similar to plane src in
framebuffer, damage clips cannot be negative. In damage clip, x1/y1 are
inclusive and x2/y2 are exclusive. While kernel does not error for overlapped
damage clips, it is strongly discouraged.</p>
<p>Drivers that are interested in damage interface for plane should enable
FB_DAMAGE_CLIPS property by calling <a class="reference internal" href="#c.drm_plane_enable_fb_damage_clips" title="drm_plane_enable_fb_damage_clips"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_enable_fb_damage_clips()</span></code></a>.
Drivers implementing damage can use <a class="reference internal" href="#c.drm_atomic_helper_damage_iter_init" title="drm_atomic_helper_damage_iter_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_damage_iter_init()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_damage_iter_next" title="drm_atomic_helper_damage_iter_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_damage_iter_next()</span></code></a> helper iterator function to get damage
rectangles clipped to <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.src</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_plane_enable_fb_damage_clips">
void <code class="sig-name descname">drm_plane_enable_fb_damage_clips</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_enable_fb_damage_clips" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables plane fb damage clips property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>Plane on which to enable damage clips property.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function lets driver to enable the damage clips property on a plane.</p>
<dl class="c function">
<dt id="c.drm_atomic_helper_check_plane_damage">
void <code class="sig-name descname">drm_atomic_helper_check_plane_damage</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_plane_damage" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Verify plane damage on atomic_check.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The driver state object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>Plane state for which to verify damage.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function makes sure that damage from plane state is discarded
for full modeset. If there are more reasons a driver would want to do a full
plane update rather than processing individual damage regions, then those
cases should be taken care of here.</p>
<p>Note that <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fb_damage_clips</span></code></a> == NULL in plane state means that
full plane update should happen. It also ensure helper iterator will return
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.src</span></code></a> as damage.</p>
<dl class="c function">
<dt id="c.drm_atomic_helper_dirtyfb">
int <code class="sig-name descname">drm_atomic_helper_dirtyfb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>fb</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em>, unsigned int <em>flags</em>, unsigned int <em>color</em>, <em class="property">struct</em> drm_clip_rect *<em>clips</em>, unsigned int <em>num_clips</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_dirtyfb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Helper for dirtyfb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>Drm file for the ioctl call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Dirty fb annotate flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">color</span></code></dt><dd><p>Color for annotate fill.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_clip_rect</span> <span class="pre">*clips</span></code></dt><dd><p>Dirty region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_clips</span></code></dt><dd><p>Count of clip in clips.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to implement <a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> using damage interface
during plane update. If num_clips is 0 then this helper will do a full plane
update. This is the same behaviour expected by DIRTFB IOCTL.</p>
<p>Note that this helper is blocking implementation. This is what current
drivers and userspace expect in their DIRTYFB IOCTL implementation, as a way
to rate-limit userspace and make sure its rendering doesn’t get ahead of
uploading new data too much.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_atomic_helper_damage_iter_init">
void <code class="sig-name descname">drm_atomic_helper_damage_iter_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_helper_damage_iter" title="drm_atomic_helper_damage_iter">drm_atomic_helper_damage_iter</a> *<em>iter</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>old_state</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_damage_iter_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the damage iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_helper_damage_iter</span> <span class="pre">*iter</span></code></dt><dd><p>The iterator to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>Old plane state for validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state from which to iterate the damage clips.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an iterator, which clips plane damage
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fb_damage_clips</span></code></a> to plane <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.src</span></code></a>. This iterator
returns full plane src in case damage is not present because either
user-space didn’t sent or driver discarded it (it want to do full plane
update). Currently this iterator returns full plane src in case plane src
changed but that can be changed in future to return damage.</p>
<p>For the case when plane is not visible or plane update should not happen the
first call to iter_next will return false. Note that this helper use clipped
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.src</span></code></a>, so driver calling this helper should have called
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a> earlier.</p>
<dl class="c function">
<dt id="c.drm_atomic_helper_damage_iter_next">
bool <code class="sig-name descname">drm_atomic_helper_damage_iter_next</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_atomic_helper_damage_iter" title="drm_atomic_helper_damage_iter">drm_atomic_helper_damage_iter</a> *<em>iter</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect">drm_rect</a> *<em>rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_damage_iter_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Advance the damage iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_helper_damage_iter</span> <span class="pre">*iter</span></code></dt><dd><p>The iterator to advance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*rect</span></code></dt><dd><p>Return a rectangle in fb coordinate clipped to plane src.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since plane src is in 16.16 fixed point and damage clips are whole number,
this iterator round off clips that intersect with plane src. Round down for
x1/y1 and round up for x2/y2 for the intersected coordinate. Similar rounding
off for full plane src, in case it’s returned as damage. This iterator will
skip damage clips outside of plane src.</p>
<p>If the first call to iterator next returns false then it means no need to
update the plane.</p>
<p><strong>Return</strong></p>
<p>True if the output is valid, false if reached the end.</p>
<dl class="c function">
<dt id="c.drm_atomic_helper_damage_merged">
bool <code class="sig-name descname">drm_atomic_helper_damage_merged</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>old_state</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect">drm_rect</a> *<em>rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_damage_merged" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merged plane damage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>Old plane state for validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state from which to iterate the damage clips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*rect</span></code></dt><dd><p>Returns the merged damage rectangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function merges any valid plane damage clips into one rectangle and
returns it in <strong>rect</strong>.</p>
<p>For details see: <a class="reference internal" href="#c.drm_atomic_helper_damage_iter_init" title="drm_atomic_helper_damage_iter_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_damage_iter_init()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_damage_iter_next" title="drm_atomic_helper_damage_iter_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_damage_iter_next()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if there is valid plane damage otherwise false.</p>
<dl class="c macro">
<dt id="c.drm_atomic_for_each_plane_damage">
<code class="sig-name descname">drm_atomic_for_each_plane_damage</code><a class="headerlink" href="#c.drm_atomic_for_each_plane_damage" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_atomic_for_each_plane_damage</span> <span class="pre">(iter,</span> <span class="pre">rect)</span></code></p>
<blockquote>
<div><p>Iterator macro for plane damage.</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">iter</span></code></dt><dd><p>The iterator to advance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rect</span></code></dt><dd><p>Return a rectangle in fb coordinate clipped to plane src.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the first call to iterator macro return false then no need to do
plane update. Iterator will return full plane src when damage is not passed
by user-space.</p>
<dl class="c struct">
<dt id="c.drm_atomic_helper_damage_iter">
<em class="property">struct </em><code class="sig-name descname">drm_atomic_helper_damage_iter</code><a class="headerlink" href="#c.drm_atomic_helper_damage_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Closure structure for damage iterator.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_atomic_helper_damage_iter {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This structure tracks state needed to walk the list of plane damage clips.</p>
<dl class="c function">
<dt id="c.drm_helper_get_plane_damage_clips">
<em class="property">struct</em> <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect">drm_rect</a> *<code class="sig-name descname">drm_helper_get_plane_damage_clips</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_get_plane_damage_clips" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns damage clips in <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_rect</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns plane damage rectangles in internal <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_rect</span></code></a>. Currently <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_rect</span></code></a>
can be obtained by simply typecasting <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_rect</span></code></a>. This is because both
are signed 32 and during <a class="reference internal" href="#c.drm_atomic_check_only" title="drm_atomic_check_only"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_check_only()</span></code></a> it is verified that damage
clips are inside fb.</p>
<p><strong>Return</strong></p>
<p>Clips in plane fb_damage_clips blob property.</p>
</div>
</div>
<div class="section" id="color-management-properties">
<h3>Color Management Properties<a class="headerlink" href="#color-management-properties" title="Permalink to this headline">¶</a></h3>
<p>Color management or color space adjustments is supported through a set of 5
properties on the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> object. They are set up by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>.</p>
<dl>
<dt>“DEGAMMA_LUT”:</dt><dd><p>Blob property to set the degamma lookup table (LUT) mapping pixel data
from the framebuffer before it is given to the transformation matrix.
The data is interpreted as an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p>Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.degamma_lut</span></code></a>.</p>
</dd>
<dt>“DEGAMMA_LUT_SIZE”:</dt><dd><p>Unsinged range property to give the size of the lookup table to be set
on the DEGAMMA_LUT property (the size depends on the underlying
hardware). If drivers support multiple LUT sizes then they should
publish the largest size, and sub-sample smaller sized LUTs (e.g. for
split-gamma modes) appropriately.</p>
</dd>
<dt>“CTM”:</dt><dd><p>Blob property to set the current transformation matrix (CTM) apply to
pixel data after the lookup through the degamma LUT and before the
lookup through the gamma LUT. The data is interpreted as a struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_color_ctm</span></code>.</p>
<p>Setting this to NULL (blob property value set to 0) means a
unit/pass-thru matrix should be used. This is generally the driver
boot-up state too. Drivers can access the blob for the color conversion
matrix through <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.ctm</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT”:</dt><dd><p>Blob property to set the gamma lookup table (LUT) mapping pixel data
after the transformation matrix to data sent to the connector. The
data is interpreted as an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p>Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.gamma_lut</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT_SIZE”:</dt><dd><p>Unsigned range property to give the size of the lookup table to be set
on the GAMMA_LUT property (the size depends on the underlying hardware).
If drivers support multiple LUT sizes then they should publish the
largest size, and sub-sample smaller sized LUTs (e.g. for split-gamma
modes) appropriately.</p>
</dd>
</dl>
<p>There is also support for a legacy gamma table, which is set up by calling
<a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>. Drivers which support both should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a> to alias the legacy gamma ramp with the
“GAMMA_LUT” property above.</p>
<p>Support for different non RGB color encodings is controlled through
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> specific COLOR_ENCODING and COLOR_RANGE properties. They
are set up by calling <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</p>
<dl class="simple">
<dt>“COLOR_ENCODING”</dt><dd><p>Optional plane enum property to support different non RGB
color encodings. The driver can provide a subset of standard
enum values supported by the DRM plane.</p>
</dd>
<dt>“COLOR_RANGE”</dt><dd><p>Optional plane enum property to support different non RGB
color parameter ranges. The driver can provide a subset of
standard enum values supported by the DRM plane.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_color_ctm_s31_32_to_qm_n">
u64 <code class="sig-name descname">drm_color_ctm_s31_32_to_qm_n</code><span class="sig-paren">(</span>u64 <em>user_input</em>, u32 <em>m</em>, u32 <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_ctm_s31_32_to_qm_n" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">user_input</span></code></dt><dd><p>input value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">m</span></code></dt><dd><p>number of integer bits, only support m &lt;= 32, include the sign-bit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">n</span></code></dt><dd><p>number of fractional bits, only support n &lt;= 32</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2’s complement).
The sign-bit BIT(m+n-1) and above are 0 for positive value and 1 for negative
the range of value is [-2^(m-1), 2^(m-1) - 2^-n]</p>
<p>For example
A Q3.12 format number:
- required bit: 3 + 12 = 15bits
- range: [-2^2, 2^2 - 2^−15]</p>
<p><strong>NOTE</strong></p>
<dl class="simple">
<dt>the m can be zero if all bit_precision are used to present fractional</dt><dd><p>bits like Q0.32</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_crtc_enable_color_mgmt">
void <code class="sig-name descname">drm_crtc_enable_color_mgmt</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, uint <em>degamma_lut_size</em>, bool <em>has_ctm</em>, uint <em>gamma_lut_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_enable_color_mgmt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable color management properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">degamma_lut_size</span></code></dt><dd><p>the size of the degamma lut (before CSC)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">has_ctm</span></code></dt><dd><p>whether to attach ctm_property for CSC matrix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">gamma_lut_size</span></code></dt><dd><p>the size of the gamma lut (after CSC)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function lets the driver enable the color correction
properties on a CRTC. This includes 3 degamma, csc and gamma
properties that userspace can set and 2 size properties to inform
the userspace of the lut sizes. Each of the properties are
optional. The gamma and degamma properties are only attached if
their size is not 0 and ctm_property is only attached if has_ctm is
true.</p>
<p>Drivers should use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a> to implement the
legacy <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.gamma_set</span></code></a> callback.</p>
<dl class="c function">
<dt id="c.drm_mode_crtc_set_gamma_size">
int <code class="sig-name descname">drm_mode_crtc_set_gamma_size</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, int <em>gamma_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_crtc_set_gamma_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the gamma table size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to set the gamma table size for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">gamma_size</span></code></dt><dd><p>size of the gamma table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which support gamma tables should set this to the supported gamma
table size when initializing the CRTC. Currently the drm core only supports a
fixed gamma table size.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="c function">
<dt id="c.drm_plane_create_color_properties">
int <code class="sig-name descname">drm_plane_create_color_properties</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>plane</em>, u32 <em>supported_encodings</em>, u32 <em>supported_ranges</em>, <em class="property">enum</em> drm_color_encoding <em>default_encoding</em>, <em class="property">enum</em> drm_color_range <em>default_range</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_color_properties" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>color encoding related plane properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">supported_encodings</span></code></dt><dd><p>bitfield indicating supported color encodings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">supported_ranges</span></code></dt><dd><p>bitfileld indicating supported color ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_color_encoding</span> <span class="pre">default_encoding</span></code></dt><dd><p>default color encoding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_color_range</span> <span class="pre">default_range</span></code></dt><dd><p>default color range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and attach plane specific COLOR_ENCODING and COLOR_RANGE
properties to <strong>plane</strong>. The supported encodings and ranges should
be provided in supported_encodings and supported_ranges bitmasks.
Each bit set in the bitmask indicates that its number as enum
value is supported.</p>
<dl class="c function">
<dt id="c.drm_color_lut_check">
int <code class="sig-name descname">drm_color_lut_check</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>lut</em>, u32 <em>tests</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_lut_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check validity of lookup table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*lut</span></code></dt><dd><p>property blob containing LUT to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">tests</span></code></dt><dd><p>bitmask of tests to run</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to check whether a userspace-provided lookup table is valid and
satisfies hardware requirements.  Drivers pass a bitmask indicating which of
the tests in <a class="reference internal" href="#c.drm_color_lut_tests" title="drm_color_lut_tests"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_color_lut_tests</span></code></a> should be performed.</p>
<p>Returns 0 on success, -EINVAL on failure.</p>
<dl class="c function">
<dt id="c.drm_color_lut_extract">
u32 <code class="sig-name descname">drm_color_lut_extract</code><span class="sig-paren">(</span>u32 <em>user_input</em>, int <em>bit_precision</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_lut_extract" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clamp and round LUT entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">user_input</span></code></dt><dd><p>input value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bit_precision</span></code></dt><dd><p>number of bits the hw LUT supports</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Extract a degamma/gamma LUT value provided by user (in the form of
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_color_lut</span></code> entries) and round it to the precision supported by the
hardware.</p>
<dl class="c function">
<dt id="c.drm_color_lut_size">
int <code class="sig-name descname">drm_color_lut_size</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_lut_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate the number of entries in the LUT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*blob</span></code></dt><dd><p>blob containing the LUT</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in the color LUT stored in <strong>blob</strong>.</p>
<dl class="c enum">
<dt id="c.drm_color_lut_tests">
<em class="property">enum </em><code class="sig-name descname">drm_color_lut_tests</code><a class="headerlink" href="#c.drm_color_lut_tests" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hw-specific LUT tests to perform</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_COLOR_LUT_EQUAL_CHANNELS</span></code></dt><dd><p>Checks whether the entries of a LUT all have equal values for the
red, green, and blue channels.  Intended for hardware that only
accepts a single value per LUT entry and assumes that value applies
to all three color components.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_COLOR_LUT_NON_DECREASING</span></code></dt><dd><p>Checks whether the entries of a LUT are always flat or increasing
(never decreasing).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_color_lut_check" title="drm_color_lut_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_color_lut_check()</span></code></a> function takes a bitmask of the values here to
determine which tests to apply to a userspace-provided LUT.</p>
</div>
<div class="section" id="tile-group-property">
<h3>Tile Group Property<a class="headerlink" href="#tile-group-property" title="Permalink to this headline">¶</a></h3>
<p>Tile groups are used to represent tiled monitors with a unique integer
identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle,
we store this in a tile group, so we have a common identifier for all tiles
in a monitor group. The property is called “TILE”. Drivers can manage tile
groups using <a class="reference internal" href="#c.drm_mode_create_tile_group" title="drm_mode_create_tile_group"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_create_tile_group()</span></code></a>, <a class="reference internal" href="#c.drm_mode_put_tile_group" title="drm_mode_put_tile_group"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_put_tile_group()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_get_tile_group" title="drm_mode_get_tile_group"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_get_tile_group()</span></code></a>. But this is only needed for internal panels where
the tile group information is exposed through a non-standard way.</p>
</div>
<div class="section" id="explicit-fencing-properties">
<h3>Explicit Fencing Properties<a class="headerlink" href="#explicit-fencing-properties" title="Permalink to this headline">¶</a></h3>
<p>Explicit fencing allows userspace to control the buffer synchronization
between devices. A Fence or a group of fences are transfered to/from
userspace using Sync File fds and there are two DRM properties for that.
IN_FENCE_FD on each DRM Plane to send fences to the kernel and
OUT_FENCE_PTR on each DRM CRTC to receive fences from the kernel.</p>
<p>As a contrast, with implicit fencing the kernel keeps track of any
ongoing rendering, and automatically ensures that the atomic update waits
for any pending rendering to complete. For shared buffers represented with
a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> this is tracked in <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a>.
Implicit syncing is how Linux traditionally worked (e.g. DRI2/3 on X.org),
whereas explicit fencing is what Android wants.</p>
<dl>
<dt>“IN_FENCE_FD”:</dt><dd><p>Use this property to pass a fence that DRM should wait on before
proceeding with the Atomic Commit request and show the framebuffer for
the plane on the screen. The fence can be either a normal fence or a
merged one, the sync_file framework will handle both cases and use a
fence_array if a merged fence is received. Passing -1 here means no
fences to wait on.</p>
<p>If the Atomic Commit request has the DRM_MODE_ATOMIC_TEST_ONLY flag
it will only check if the Sync File is a valid one.</p>
<p>On the driver side the fence is stored on the <strong>fence</strong> parameter of
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>. Drivers which also support implicit fencing
should set the implicit fence using <a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a>,
to make sure there’s consistent behaviour between drivers in precedence
of implicit vs. explicit fencing.</p>
</dd>
<dt>“OUT_FENCE_PTR”:</dt><dd><p>Use this property to pass a file descriptor pointer to DRM. Once the
Atomic Commit request call returns OUT_FENCE_PTR will be filled with
the file descriptor number of a Sync File. This Sync File contains the
CRTC fence that will be signaled when all framebuffers present on the
Atomic Commit * request for that given CRTC are scanned out on the
screen.</p>
<p>The Atomic Commit request fails if a invalid pointer is passed. If the
Atomic Commit request fails for any other reason the out fence fd
returned will be -1. On a Atomic Commit with the
DRM_MODE_ATOMIC_TEST_ONLY flag the out fence will also be set to -1.</p>
<p>Note that out-fences don’t have a special interface to drivers and are
internally represented by a <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span></code></a> in struct
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a>, which is also used by the nonblocking atomic commit
helpers and for the DRM event handling for existing userspace.</p>
</dd>
</dl>
</div>
<div class="section" id="variable-refresh-properties">
<h3>Variable Refresh Properties<a class="headerlink" href="#variable-refresh-properties" title="Permalink to this headline">¶</a></h3>
<p>Variable refresh rate capable displays can dynamically adjust their
refresh rate by extending the duration of their vertical front porch
until page flip or timeout occurs. This can reduce or remove stuttering
and latency in scenarios where the page flip does not align with the
vblank interval.</p>
<p>An example scenario would be an application flipping at a constant rate
of 48Hz on a 60Hz display. The page flip will frequently miss the vblank
interval and the same contents will be displayed twice. This can be
observed as stuttering for content with motion.</p>
<p>If variable refresh rate was active on a display that supported a
variable refresh range from 35Hz to 60Hz no stuttering would be observable
for the example scenario. The minimum supported variable refresh rate of
35Hz is below the page flip frequency and the vertical front porch can
be extended until the page flip occurs. The vblank interval will be
directly aligned to the page flip rate.</p>
<p>Not all userspace content is suitable for use with variable refresh rate.
Large and frequent changes in vertical front porch duration may worsen
perceived stuttering for input sensitive applications.</p>
<p>Panel brightness will also vary with vertical front porch duration. Some
panels may have noticeable differences in brightness between the minimum
vertical front porch duration and the maximum vertical front porch duration.
Large and frequent changes in vertical front porch duration may produce
observable flickering for such panels.</p>
<p>Userspace control for variable refresh rate is supported via properties
on the <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> and <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> objects.</p>
<dl>
<dt>“vrr_capable”:</dt><dd><p>Optional <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> boolean property that drivers should attach
with <a class="reference internal" href="#c.drm_connector_attach_vrr_capable_property" title="drm_connector_attach_vrr_capable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_vrr_capable_property()</span></code></a> on connectors that
could support variable refresh rates. Drivers should update the
property value by calling <a class="reference internal" href="#c.drm_connector_set_vrr_capable_property" title="drm_connector_set_vrr_capable_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_vrr_capable_property()</span></code></a>.</p>
<p>Absence of the property should indicate absence of support.</p>
</dd>
<dt>“VRR_ENABLED”:</dt><dd><p>Default <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> boolean property that notifies the driver that the
content on the CRTC is suitable for variable refresh rate presentation.
The driver will take this property as a hint to enable variable
refresh rate support if the receiver supports it, ie. if the
“vrr_capable” property is true on the <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> object. The
vertical front porch duration will be extended until page-flip or
timeout when enabled.</p>
<p>The minimum vertical front porch duration is defined as the vertical
front porch duration for the current mode.</p>
<p>The maximum vertical front porch duration is greater than or equal to
the minimum vertical front porch duration. The duration is derived
from the minimum supported variable refresh rate for the connector.</p>
<p>The driver may place further restrictions within these minimum
and maximum bounds.</p>
</dd>
</dl>
</div>
<div class="section" id="existing-kms-properties">
<h3>Existing KMS Properties<a class="headerlink" href="#existing-kms-properties" title="Permalink to this headline">¶</a></h3>
<p>The following table gives description of drm properties exposed by various
modules/drivers. Because this table is very unwieldy, do not add any new
properties here. Instead document them in a section above.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Owner Module/Drivers</p></th>
<th class="head"><p>Group</p></th>
<th class="head"><p>Property Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Property Values</p></th>
<th class="head"><p>Object attached</p></th>
<th class="head"><p>Description/Restrictions</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
<td><p>DVI-I</p></td>
<td><p>“subconnector”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Unknown”, “DVI-D”, “DVI-A” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“select subconnector”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Automatic”, “DVI-D”, “DVI-A” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>TV</p></td>
<td><p>“subconnector”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Unknown”, “Composite”, “SVIDEO”, “Component”, “SCART” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“select subconnector”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Automatic”, “Composite”, “SVIDEO”, “Component”, “SCART” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “NTSC_M”, “NTSC_J”, “NTSC_443”, “PAL_B” } etc.</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“left margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“right margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“top margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“bottom margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“contrast”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“flicker reduction”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“overscan”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“saturation”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“hue”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Virtual GPU</p></td>
<td><p>“suggested X”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffffff</p></td>
<td><p>Connector</p></td>
<td><p>property to suggest an X offset for a connector</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“suggested Y”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffffff</p></td>
<td><p>Connector</p></td>
<td><p>property to suggest an Y offset for a connector</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Optional</p></td>
<td><p>“aspect ratio”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “None”, “4:3”, “16:9” }</p></td>
<td><p>Connector</p></td>
<td><p>TDB</p></td>
</tr>
<tr class="row-even"><td><p>i915</p></td>
<td><p>Generic</p></td>
<td><p>“Broadcast RGB”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Automatic”, “Full”, “Limited 16:235” }</p></td>
<td><p>Connector</p></td>
<td><p>When this property is set to Limited 16:235 and CTM is set, the hardware will be programmed with the result of the multiplication of CTM by the limited range matrix to ensure the pixels normaly in the range 0..1.0 are remapped to the range 16/255..235/255.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“audio”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “force-dvi”, “off”, “auto”, “on” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>SDVO-TV</p></td>
<td><p>“mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “NTSC_M”, “NTSC_J”, “NTSC_443”, “PAL_B” } etc.</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“left_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“right_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“top_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“bottom_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“hpos”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“vpos”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“contrast”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“saturation”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“hue”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“sharpness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“flicker_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“flicker_filter_adaptive”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“flicker_filter_2d”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“tv_chroma_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“tv_luma_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“dot_crawl”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>SDVO-TV/LVDS</p></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>CDV gma-500</p></td>
<td><p>Generic</p></td>
<td><p>“Broadcast RGB”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Full”, “Limited 16:235” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“Broadcast RGB”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “off”, “auto”, “on” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>Poulsbo</p></td>
<td><p>Generic</p></td>
<td><p>“backlight”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=100</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>SDVO-TV</p></td>
<td><p>“mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “NTSC_M”, “NTSC_J”, “NTSC_443”, “PAL_B” } etc.</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“left_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“right_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“top_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“bottom_margin”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“hpos”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“vpos”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“contrast”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“saturation”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“hue”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“sharpness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“flicker_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“flicker_filter_adaptive”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“flicker_filter_2d”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“tv_chroma_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“tv_luma_filter”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“dot_crawl”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>SDVO-TV/LVDS</p></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max= SDVO dependent</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>armada</p></td>
<td><p>CRTC</p></td>
<td><p>“CSC_YUV”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Auto” , “CCIR601”, “CCIR709” }</p></td>
<td><p>CRTC</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“CSC_RGB”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “Auto”, “Computer system”, “Studio” }</p></td>
<td><p>CRTC</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Overlay</p></td>
<td><p>“colorkey”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“colorkey_min”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“colorkey_max”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“colorkey_val”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“colorkey_alpha”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0xffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“colorkey_mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “disabled”, “Y component”, “U component” , “V component”, “RGB”, “R component”, “G component”, “B component” }</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=256 + 255</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“contrast”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0x7fff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“saturation”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0x7fff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>exynos</p></td>
<td><p>CRTC</p></td>
<td><p>“mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “normal”, “blank” }</p></td>
<td><p>CRTC</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>i2c/ch7006_drv</p></td>
<td><p>Generic</p></td>
<td><p>“scale”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=2</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>TV</p></td>
<td><p>“mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “PAL”, “PAL-M”,”PAL-N”}, ”PAL-Nc” , “PAL-60”, “NTSC-M”, “NTSC-J” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>nouveau</p></td>
<td><p>NV10 Overlay</p></td>
<td><p>“colorkey”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0x01ffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“contrast”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=8192-1</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1024</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“hue”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=359</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“saturation”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=8192-1</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“iturbt_709”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Nv04 Overlay</p></td>
<td><p>“colorkey”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0x01ffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“brightness”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1024</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Display</p></td>
<td><p>“dithering mode”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “auto”, “off”, “on” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“dithering depth”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “auto”, “off”, “on”, “static 2x2”, “dynamic 2x2”, “temporal” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“underscan”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “auto”, “6 bpc”, “8 bpc” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“underscan hborder”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=128</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“underscan vborder”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=128</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“vibrant hue”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=180</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“color vibrance”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=200</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>omap</p></td>
<td><p>Generic</p></td>
<td><p>“zorder”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=3</p></td>
<td><p>CRTC, Plane</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>qxl</p></td>
<td><p>Generic</p></td>
<td><p>“hotplug_mode_update”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>radeon</p></td>
<td><p>DVI-I</p></td>
<td><p>“coherent”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>DAC enable load detect</p></td>
<td><p>“load detection”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=1</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>TV Standard</p></td>
<td><p>“tv standard”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “ntsc”, “pal”, “pal-m”, “pal-60”, “ntsc-j” , “scart-pal”, “pal-cn”, “secam” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>legacy TMDS PLL detect</p></td>
<td><p>“tmds_pll”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “driver”, “bios” }</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>Underscan</p></td>
<td><p>“underscan”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “off”, “on”, “auto” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“underscan hborder”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=128</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>“underscan vborder”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=128</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>Audio</p></td>
<td><p>“audio”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “off”, “on”, “auto” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>FMT Dithering</p></td>
<td><p>“dither”</p></td>
<td><p>ENUM</p></td>
<td><p>{ “off”, “on” }</p></td>
<td><p>Connector</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>“colorkey”</p></td>
<td><p>RANGE</p></td>
<td><p>Min=0, Max=0x01ffffff</p></td>
<td><p>Plane</p></td>
<td><p>TBD</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="vertical-blanking">
<h2>Vertical Blanking<a class="headerlink" href="#vertical-blanking" title="Permalink to this headline">¶</a></h2>
<p>From the computer’s perspective, every time the monitor displays
a new frame the scanout engine has “scanned out” the display image
from top to bottom, one row of pixels at a time. The current row
of pixels is referred to as the current scanline.</p>
<p>In addition to the display’s visible area, there’s usually a couple of
extra scanlines which aren’t actually displayed on the screen.
These extra scanlines don’t contain image data and are occasionally used
for features like audio and infoframes. The region made up of these
scanlines is referred to as the vertical blanking region, or vblank for
short.</p>
<p>For historical reference, the vertical blanking period was designed to
give the electron gun (on CRTs) enough time to move back to the top of
the screen to start scanning out the next frame. Similar for horizontal
blanking periods. They were designed to give the electron gun enough
time to move back to the other side of the screen to start scanning the
next scanline.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>physical →   ⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽
top of      |                                        |
display     |                                        |
            |               New frame                |
            |                                        |
            |↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓|
            |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ← Scanline,
            |↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓|   updates the
            |                                        |   frame as it
            |                                        |   travels down
            |                                        |   (&quot;sacn out&quot;)
            |               Old frame                |
            |                                        |
            |                                        |
            |                                        |
            |                                        |   physical
            |                                        |   bottom of
vertical    |⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽| ← display
blanking    ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
region   →  ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
            ┆xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx┆
start of →   ⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽⎽
new frame
</pre></div>
</div>
<p>“Physical top of display” is the reference point for the high-precision/
corrected timestamp.</p>
<p>On a lot of display hardware, programming needs to take effect during the
vertical blanking period so that settings like gamma, the image buffer
buffer to be scanned out, etc. can safely be changed without showing
any visual artifacts on the screen. In some unforgiving hardware, some of
this programming has to both start and end in the same vblank. To help
with the timing of the hardware programming, an interrupt is usually
available to notify the driver when it can start the updating of registers.
The interrupt is in this context named the vblank interrupt.</p>
<p>The vblank interrupt may be fired at different points depending on the
hardware. Some hardware implementations will fire the interrupt when the
new frame start, other implementations will fire the interrupt at different
points in time.</p>
<p>Vertical blanking plays a major role in graphics rendering. To achieve
tear-free display, users must synchronize page flips and/or rendering to
vertical blanking. The DRM API offers ioctls to perform page flips
synchronized to vertical blanking and wait for vertical blanking.</p>
<p>The DRM core handles most of the vertical blanking management logic, which
involves filtering out spurious interrupts, keeping race-free blanking
counters, coping with counter wrap-around and resets and keeping use counts.
It relies on the driver to generate vertical blanking interrupts and
optionally provide a hardware vertical blanking counter.</p>
<p>Drivers must initialize the vertical blanking handling core with a call to
<a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_init()</span></code></a>. Minimally, a driver needs to implement
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> and <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> plus call
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a> in its vblank interrupt handler for working vblank
support.</p>
<p>Vertical blanking interrupts can be enabled by the DRM core or by drivers
themselves (for instance to handle page flipping operations).  The DRM core
maintains a vertical blanking use count to ensure that the interrupts are not
disabled while a user still needs them. To increment the use count, drivers
call <a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_get()</span></code></a> and release the vblank reference again with
<a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_put()</span></code></a>. In between these two calls vblank interrupts are
guaranteed to be enabled.</p>
<p>On many hardware disabling the vblank interrupt cannot be done in a race-free
manner, see <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.vblank_disable_immediate</span></code></a> and
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.max_vblank_count</span></code></a>. In that case the vblank core only disables the
vblanks after a timer has expired, which can be configured through the
<code class="docutils literal notranslate"><span class="pre">vblankoffdelay</span></code> module parameter.</p>
<p>Drivers for hardware without support for vertical-blanking interrupts
must not call <a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_init()</span></code></a>. For such drivers, atomic helpers will
automatically generate fake vblank events as part of the display update.
This functionality also can be controlled by the driver by enabling and
disabling <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>.no_vblank.</p>
<div class="section" id="vertical-blanking-and-interrupt-handling-functions-reference">
<h3>Vertical Blanking and Interrupt Handling Functions Reference<a class="headerlink" href="#vertical-blanking-and-interrupt-handling-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_pending_vblank_event">
<em class="property">struct </em><code class="sig-name descname">drm_pending_vblank_event</code><a class="headerlink" href="#c.drm_pending_vblank_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>pending vblank event tracking</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pending_vblank_event {
  struct drm_pending_event base;
  unsigned int pipe;
  u64 sequence;
  union {
    struct drm_event base;
    struct drm_event_vblank vbl;
    struct drm_event_crtc_sequence seq;
  } event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base structure for tracking pending DRM events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> this event is for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sequence</span></code></dt><dd><p>frame event should be triggered at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>Actual event which will be sent to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event.base</span></code></dt><dd><p>DRM event base class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event.vbl</span></code></dt><dd><p>Event payload for vblank events, requested through
either the MODE_PAGE_FLIP or MODE_ATOMIC IOCTL. Also
generated by the legacy WAIT_VBLANK IOCTL, but new userspace
should use MODE_QUEUE_SEQUENCE and <code class="xref c c-type docutils literal notranslate"><span class="pre">event.seq</span></code> instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event.seq</span></code></dt><dd><p>Event payload for the MODE_QUEUEU_SEQUENCE IOCTL.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_vblank_crtc">
<em class="property">struct </em><code class="sig-name descname">drm_vblank_crtc</code><a class="headerlink" href="#c.drm_vblank_crtc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>vblank tracking for a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_vblank_crtc {
  struct drm_device *dev;
  wait_queue_head_t queue;
  struct timer_list disable_timer;
  seqlock_t seqlock;
  atomic64_t count;
  ktime_t time;
  atomic_t refcount;
  u32 last;
  u32 max_vblank_count;
  unsigned int inmodeset;
  unsigned int pipe;
  int framedur_ns;
  int linedur_ns;
  struct drm_display_mode hwmode;
  bool enabled;
  struct kthread_worker *worker;
  struct list_head pending_work;
  wait_queue_head_t work_wait_queue;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Pointer to the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p>Wait queue for vblank waiters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_timer</span></code></dt><dd><p>Disable timer for the delayed vblank disabling
hysteresis logic. Vblank disabling is controlled through the
drm_vblank_offdelay module option and the setting of the
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.max_vblank_count</span></code></a> value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqlock</span></code></dt><dd><p>Protect vblank count and time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Current software vblank counter.</p>
<p>Note that for a given vblank counter value <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>
and <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> or <a class="reference internal" href="#c.drm_crtc_vblank_count_and_time" title="drm_crtc_vblank_count_and_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count_and_time()</span></code></a>
provide a barrier: Any writes done before calling
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a> will be visible to callers of the later
functions, iff the vblank count is the same or a later one.</p>
<p>IMPORTANT: This guarantee requires barriers, therefor never access
this field directly. Use <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>Vblank timestamp corresponding to <strong>count</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>Number of users/waiters of the vblank interrupt. Only when
this refcount reaches 0 can the hardware interrupt be disabled using
<strong>disable_timer</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.vbl_lock</span></code></a>, used for wraparound handling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_vblank_count</span></code></dt><dd><p>Maximum value of the vblank registers for this crtc. This value +1
will result in a wrap-around of the vblank register. It is used
by the vblank core to handle wrap-arounds.</p>
<p>If set to zero the vblank core will try to guess the elapsed vblanks
between times when the vblank interrupt is disabled through
high-precision timestamps. That approach is suffering from small
races and imprecision over longer time periods, hence exposing a
hardware vblank counter is always recommended.</p>
<p>This is the runtime configurable per-crtc maximum set through
<a class="reference internal" href="#c.drm_crtc_set_max_vblank_count" title="drm_crtc_set_max_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_set_max_vblank_count()</span></code></a>. If this is used the driver
must leave the device wide <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.max_vblank_count</span></code></a> at zero.</p>
<p>If non-zero, <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.get_vblank_counter</span></code></a> must be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inmodeset</span></code></dt><dd><p>Tracks whether the vblank is disabled due to a modeset.
For legacy driver bit 2 additionally tracks whether an additional
temporary vblank reference has been acquired to paper over the
hardware counter resetting/jumping. KMS drivers should instead just
call <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_on()</span></code></a>, which explicitly
save and restore the vblank count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> corresponding to this
structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">framedur_ns</span></code></dt><dd><p>Frame/Field duration in ns, used by
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linedur_ns</span></code></dt><dd><p>Line duration in ns, used by
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwmode</span></code></dt><dd><p>Cache of the current hardware display mode. Only valid when <strong>enabled</strong>
is set. This is used by helpers like
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a>. We can’t just access
the hardware mode by e.g. looking at <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>,
because that one is really hard to get from interrupt context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>Tracks the enabling state of the corresponding <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> to
avoid double-disabling and hence corrupting saved state. Needed by
drivers not using atomic KMS, since those might go through their CRTC
disabling functions multiple times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">worker</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">kthread_worker</span></code> used for executing vblank works.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pending_work</span></code></dt><dd><p>A list of scheduled <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> items that are
waiting for a future vblank.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_wait_queue</span></code></dt><dd><p>The wait queue used for signaling that a
<a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> item has either finished executing, or was
cancelled.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure tracks the vblank state for one CRTC.</p>
<p>Note that for historical reasons - the vblank handling code is still shared
with legacy/non-kms drivers - this is a free-standing structure not directly
connected to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. But all public interface functions are taking
a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> to hide this implementation detail.</p>
<dl class="c function">
<dt id="c.drm_crtc_accurate_vblank_count">
u64 <code class="sig-name descname">drm_crtc_accurate_vblank_count</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_accurate_vblank_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve the master vblank counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which counter to retrieve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> but this function
interpolates to handle a race with vblank interrupts using the high precision
timestamping support.</p>
<p>This is mostly useful for hardware that can obtain the scanout position, but
doesn’t have a hardware frame counter.</p>
<dl class="c function">
<dt id="c.drm_vblank_init">
int <code class="sig-name descname">drm_vblank_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, unsigned int <em>num_crtcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize vblank support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_crtcs</span></code></dt><dd><p>number of CRTCs supported by <strong>dev</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes vblank support for <strong>num_crtcs</strong> display pipelines.
Cleanup is handled automatically through a cleanup function added with
<a class="reference internal" href="drm-internals.html#c.drmm_add_action_or_reset" title="drmm_add_action_or_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_add_action_or_reset()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_dev_has_vblank">
bool <code class="sig-name descname">drm_dev_has_vblank</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dev_has_vblank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>test if vblanking has been initialized for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may call this function to test if vblank support is
initialized for a device. For most hardware this means that vblanking
can also be enabled.</p>
<p>Atomic helpers use this function to initialize
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_vblank</span></code></a>. See also <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if vblanking has been initialized for the given device, false
otherwise.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_waitqueue">
wait_queue_head_t *<code class="sig-name descname">drm_crtc_vblank_waitqueue</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_waitqueue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get vblank waitqueue for the CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which CRTC’s vblank waitqueue to retrieve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a pointer to the vblank waitqueue for the CRTC.
Drivers can use this to implement vblank waits using <a class="reference internal" href="../driver-api/basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> and related
functions.</p>
<dl class="c function">
<dt id="c.drm_calc_timestamping_constants">
void <code class="sig-name descname">drm_calc_timestamping_constants</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_calc_timestamping_constants" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate vblank timestamp constants</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>drm_crtc whose timestamp constants should be updated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>display mode containing the scanout timings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate and store various constants which are later needed by vblank and
swap-completion timestamping, e.g, by
<a class="reference internal" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a>. They are derived from
CRTC’s true scanout timing, so they take things like panel scaling or
other adjustments into account.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_helper_get_vblank_timestamp_internal">
bool <code class="sig-name descname">drm_crtc_vblank_helper_get_vblank_timestamp_internal</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, int *<em>max_error</em>, ktime_t *<em>vblank_time</em>, bool <em>in_vblank_irq</em>, drm_vblank_get_scanout_position_func <em>get_scanout_position</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp_internal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>precise vblank timestamp helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC whose vblank timestamp to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*max_error</span></code></dt><dd><p>Desired maximum allowable error in timestamps (nanosecs)
On return contains true maximum error of timestamp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*vblank_time</span></code></dt><dd><p>Pointer to time which should receive the timestamp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">in_vblank_irq</span></code></dt><dd><p>True when called from <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm_vblank_get_scanout_position_func</span> <span class="pre">get_scanout_position</span></code></dt><dd><p>Callback function to retrieve the scanout position. See
<strong>struct</strong> drm_crtc_helper_funcs.get_scanout_position.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements calculation of exact vblank timestamps from given drm_display_mode
timings and current video scanout position of a CRTC.</p>
<p>The current implementation only handles standard video modes. For double scan
and interlaced modes the driver is supposed to adjust the hardware mode
(taken from <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted</span></code></a> mode for atomic modeset drivers) to
match the scanout position reported.</p>
<p>Note that atomic drivers must call <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a> before
enabling a CRTC. The atomic helpers already take care of that in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_calc_timestamping_constants" title="drm_atomic_helper_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_calc_timestamping_constants()</span></code></a>.</p>
<p>Returns true on success, and false on failure, i.e. when no accurate
timestamp could be acquired.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_helper_get_vblank_timestamp">
bool <code class="sig-name descname">drm_crtc_vblank_helper_get_vblank_timestamp</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, int *<em>max_error</em>, ktime_t *<em>vblank_time</em>, bool <em>in_vblank_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>precise vblank timestamp helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC whose vblank timestamp to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*max_error</span></code></dt><dd><p>Desired maximum allowable error in timestamps (nanosecs)
On return contains true maximum error of timestamp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*vblank_time</span></code></dt><dd><p>Pointer to time which should receive the timestamp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">in_vblank_irq</span></code></dt><dd><p>True when called from <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements calculation of exact vblank timestamps from given drm_display_mode
timings and current video scanout position of a CRTC. This can be directly
used as the <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.get_vblank_timestamp</span></code></a> implementation of a kms
driver if <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.get_scanout_position</span></code></a> is implemented.</p>
<p>The current implementation only handles standard video modes. For double scan
and interlaced modes the driver is supposed to adjust the hardware mode
(taken from <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted</span></code></a> mode for atomic modeset drivers) to
match the scanout position reported.</p>
<p>Note that atomic drivers must call <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a> before
enabling a CRTC. The atomic helpers already take care of that in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_calc_timestamping_constants" title="drm_atomic_helper_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_calc_timestamping_constants()</span></code></a>.</p>
<p>Returns true on success, and false on failure, i.e. when no accurate
timestamp could be acquired.</p>
<p><strong>Return</strong></p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_count">
u64 <code class="sig-name descname">drm_crtc_vblank_count</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve “cooked” vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which counter to retrieve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the “cooked” vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Note that this timer isn’t correct against a racing
vblank interrupt (since it only reports the software vblank counter), see
<a class="reference internal" href="#c.drm_crtc_accurate_vblank_count" title="drm_crtc_accurate_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_accurate_vblank_count()</span></code></a> for such use-cases.</p>
<p>Note that for a given vblank counter value <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>
and <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> or <a class="reference internal" href="#c.drm_crtc_vblank_count_and_time" title="drm_crtc_vblank_count_and_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count_and_time()</span></code></a>
provide a barrier: Any writes done before calling
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a> will be visible to callers of the later
functions, iff the vblank count is the same or a later one.</p>
<p>See also <a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.count</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The software vblank counter.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_count_and_time">
u64 <code class="sig-name descname">drm_crtc_vblank_count_and_time</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, ktime_t *<em>vblanktime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count_and_time" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve “cooked” vblank counter value and the system timestamp corresponding to that vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which counter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*vblanktime</span></code></dt><dd><p>Pointer to time to receive the vblank timestamp.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the “cooked” vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Returns corresponding system timestamp of the time
of the vblank interval that corresponds to the current vblank counter value.</p>
<p>Note that for a given vblank counter value <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>
and <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> or <a class="reference internal" href="#c.drm_crtc_vblank_count_and_time" title="drm_crtc_vblank_count_and_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count_and_time()</span></code></a>
provide a barrier: Any writes done before calling
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a> will be visible to callers of the later
functions, iff the vblank count is the same or a later one.</p>
<p>See also <a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.count</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_arm_vblank_event">
void <code class="sig-name descname">drm_crtc_arm_vblank_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_arm_vblank_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>arm vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the source CRTC of the vblank event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*e</span></code></dt><dd><p>the event to send</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A lot of drivers need to generate vblank events for the very next vblank
interrupt. For example when the page flip interrupt happens when the page
flip gets armed, but not when it actually executes within the next vblank
period. This helper function implements exactly the required vblank arming
behaviour.</p>
<ol class="arabic simple">
<li><p>Driver commits new hardware state into vblank-synchronized registers.</p></li>
<li><p>A vblank happens, committing the hardware state. Also the corresponding
vblank interrupt is fired off and fully processed by the interrupt
handler.</p></li>
<li><p>The atomic commit operation proceeds to call <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>.</p></li>
<li><p>The event is only send out for the next vblank, which is wrong.</p></li>
</ol>
<p>An equivalent race can happen when the driver calls
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> before writing out the new hardware state.</p>
<p>The only way to make this work safely is to prevent the vblank from firing
(and the hardware from committing anything else) until the entire atomic
commit sequence has run to completion. If the hardware does not have such a
feature (e.g. using a “go” bit), then it is unsafe to use this functions.
Instead drivers need to manually send out the event from their interrupt
handler by calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> and make sure that there’s no
possible race with the hardware committing the atomic update.</p>
<p>Caller must hold a vblank reference for the event <strong>e</strong> acquired by a
<a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_get()</span></code></a>, which will be dropped when the next vblank arrives.</p>
<p><strong>NOTE</strong></p>
<p>Drivers using this to send out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a> as part of an
atomic commit must ensure that the next vblank happens at exactly the same
time as the atomic commit is committed to the hardware. This function itself
does <strong>not</strong> protect against the next vblank interrupt racing with either this
function call or the atomic commit operation. A possible sequence could be:</p>
<dl class="c function">
<dt id="c.drm_crtc_send_vblank_event">
void <code class="sig-name descname">drm_crtc_send_vblank_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_send_vblank_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>helper to send vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the source CRTC of the vblank event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*e</span></code></dt><dd><p>the event to send</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates sequence # and timestamp on event for the most recently processed
vblank, and sends it to userspace.  Caller must hold event lock.</p>
<p>See <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> for a helper which can be used in certain
situation, especially to send out events for atomic commit operations.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_get">
int <code class="sig-name descname">drm_crtc_vblank_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a reference count on vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which CRTC to own</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquire a reference count on vblank events to avoid having them disabled
while in use.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_put">
void <code class="sig-name descname">drm_crtc_vblank_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>give up ownership of vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>which counter to give up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release ownership of a given vblank counter, turning off interrupts
if possible. Disable interrupts after drm_vblank_offdelay milliseconds.</p>
<dl class="c function">
<dt id="c.drm_wait_one_vblank">
void <code class="sig-name descname">drm_wait_one_vblank</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, unsigned int <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_wait_one_vblank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>CRTC index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>pipe</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>pipe</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<p>This is the legacy version of <a class="reference internal" href="#c.drm_crtc_wait_one_vblank" title="drm_crtc_wait_one_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_wait_one_vblank()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_wait_one_vblank">
void <code class="sig-name descname">drm_crtc_wait_one_vblank</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_wait_one_vblank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM crtc</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>crtc</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>crtc</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_off">
void <code class="sig-name descname">drm_crtc_vblank_off</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_off" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>disable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to shut down the vblank interrupt handling when
disabling a crtc. This function ensures that the latest vblank frame count is
stored so that drm_vblank_on can restore it again.</p>
<p>Drivers must use this function when the hardware vblank counter can get
reset, e.g. when suspending or disabling the <strong>crtc</strong> in general.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_reset">
void <code class="sig-name descname">drm_crtc_vblank_reset</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset vblank state to off on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to reset the vblank state to off at load time.
Drivers should use this together with the <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_on()</span></code></a> functions. The difference compared to
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> is that this function doesn’t save the vblank counter
and hence doesn’t need to call any driver hooks.</p>
<p>This is useful for recovering driver state e.g. on driver load, or on resume.</p>
<dl class="c function">
<dt id="c.drm_crtc_set_max_vblank_count">
void <code class="sig-name descname">drm_crtc_set_max_vblank_count</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, u32 <em>max_vblank_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_set_max_vblank_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configure the hw max vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_vblank_count</span></code></dt><dd><p>max hardware vblank counter value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the maximum hardware vblank counter value for <strong>crtc</strong>
at runtime. Useful for hardware where the operation of the
hardware vblank counter depends on the currently active
display configuration.</p>
<p>For example, if the hardware vblank counter does not work
when a specific connector is active the maximum can be set
to zero. And when that specific connector isn’t active the
maximum can again be set to the appropriate non-zero value.</p>
<p>If used, must be called before drm_vblank_on().</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_on">
void <code class="sig-name descname">drm_crtc_vblank_on</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_on" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions restores the vblank interrupt state captured with
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> again and is generally called when enabling <strong>crtc</strong>. Note
that calls to <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_on()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_off()</span></code></a> can be
unbalanced and so can also be unconditionally called in driver load code to
reflect the current hardware state of the crtc.</p>
<dl class="c function">
<dt id="c.drm_vblank_restore">
void <code class="sig-name descname">drm_vblank_restore</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, unsigned int <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_restore" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>estimate missed vblanks and update vblank count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>CRTC index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Power manamement features can cause frame counter resets between vblank
disable and enable. Drivers can use this function in their
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> implementation to estimate missed vblanks since
the last <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> using timestamps and update the
vblank counter.</p>
<p>This function is the legacy version of <a class="reference internal" href="#c.drm_crtc_vblank_restore" title="drm_crtc_vblank_restore"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_restore()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_vblank_restore">
void <code class="sig-name descname">drm_crtc_vblank_restore</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_restore" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>estimate missed vblanks and update vblank count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Power manamement features can cause frame counter resets between vblank
disable and enable. Drivers can use this function in their
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> implementation to estimate missed vblanks since
the last <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> using timestamps and update the
vblank counter.</p>
<dl class="c function">
<dt id="c.drm_handle_vblank">
bool <code class="sig-name descname">drm_handle_vblank</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, unsigned int <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_handle_vblank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>index of CRTC where this event occurred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the legacy version of <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_crtc_handle_vblank">
bool <code class="sig-name descname">drm_crtc_handle_vblank</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_handle_vblank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>where this event occurred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the native KMS version of <a class="reference internal" href="#c.drm_handle_vblank" title="drm_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_handle_vblank()</span></code></a>.</p>
<p>Note that for a given vblank counter value <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>
and <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count()</span></code></a> or <a class="reference internal" href="#c.drm_crtc_vblank_count_and_time" title="drm_crtc_vblank_count_and_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_count_and_time()</span></code></a>
provide a barrier: Any writes done before calling
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a> will be visible to callers of the later
functions, iff the vblank count is the same or a later one.</p>
<p>See also <a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.count</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if the event was successfully handled, false on failure.</p>
</div>
</div>
<div class="section" id="vertical-blank-work">
<h2>Vertical Blank Work<a class="headerlink" href="#vertical-blank-work" title="Permalink to this headline">¶</a></h2>
<p>Many DRM drivers need to program hardware in a time-sensitive manner, many
times with a deadline of starting and finishing within a certain region of
the scanout. Most of the time the safest way to accomplish this is to
simply do said time-sensitive programming in the driver’s IRQ handler,
which allows drivers to avoid being preempted during these critical
regions. Or even better, the hardware may even handle applying such
time-critical programming independently of the CPU.</p>
<p>While there’s a decent amount of hardware that’s designed so that the CPU
doesn’t need to be concerned with extremely time-sensitive programming,
there’s a few situations where it can’t be helped. Some unforgiving
hardware may require that certain time-sensitive programming be handled
completely by the CPU, and said programming may even take too long to
handle in an IRQ handler. Another such situation would be where the driver
needs to perform a task that needs to complete within a specific scanout
period, but might possibly block and thus cannot be handled in an IRQ
context. Both of these situations can’t be solved perfectly in Linux since
we’re not a realtime kernel, and thus the scheduler may cause us to miss
our deadline if it decides to preempt us. But for some drivers, it’s good
enough if we can lower our chance of being preempted to an absolute
minimum.</p>
<p>This is where <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> comes in. <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> provides a simple
generic delayed work implementation which delays work execution until a
particular vblank has passed, and then executes the work at realtime
priority. This provides the best possible chance at performing
time-sensitive hardware programming on time, even when the system is under
heavy load. <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> also supports rescheduling, so that self
re-arming work items can be easily implemented.</p>
<div class="section" id="vertical-blank-work-functions-reference">
<h3>Vertical Blank Work Functions Reference<a class="headerlink" href="#vertical-blank-work-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_vblank_work">
<em class="property">struct </em><code class="sig-name descname">drm_vblank_work</code><a class="headerlink" href="#c.drm_vblank_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A delayed work item which delays until a target vblank passes, and then executes at realtime priority outside of IRQ context.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_vblank_work {
  struct kthread_work base;
  struct drm_vblank_crtc *vblank;
  u64 count;
  int cancelling;
  struct list_head node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>The base <code class="xref c c-type docutils literal notranslate"><span class="pre">kthread_work</span></code> item which will be executed by
<a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.worker</span></code></a>. Drivers should not interact with this
directly, and instead rely on <a class="reference internal" href="#c.drm_vblank_work_init" title="drm_vblank_work_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_init()</span></code></a> to initialize
this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vblank</span></code></dt><dd><p>A pointer to <a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc</span></code></a> this work item belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>The target vblank this work will execute on. Drivers should
not modify this value directly, and instead use
<a class="reference internal" href="#c.drm_vblank_work_schedule" title="drm_vblank_work_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_schedule()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cancelling</span></code></dt><dd><p>The number of <a class="reference internal" href="#c.drm_vblank_work_cancel_sync" title="drm_vblank_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_cancel_sync()</span></code></a> calls that
are currently running. A work item cannot be rescheduled until all
calls have finished.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>The position of this work item in
<a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_crtc.pending_work</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also:
<a class="reference internal" href="#c.drm_vblank_work_schedule" title="drm_vblank_work_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_schedule()</span></code></a>
<a class="reference internal" href="#c.drm_vblank_work_init" title="drm_vblank_work_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_init()</span></code></a>
<a class="reference internal" href="#c.drm_vblank_work_cancel_sync" title="drm_vblank_work_cancel_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_cancel_sync()</span></code></a>
<a class="reference internal" href="#c.drm_vblank_work_flush" title="drm_vblank_work_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vblank_work_flush()</span></code></a></p>
<dl class="c macro">
<dt id="c.to_drm_vblank_work">
<code class="sig-name descname">to_drm_vblank_work</code><a class="headerlink" href="#c.to_drm_vblank_work" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">to_drm_vblank_work</span> <span class="pre">(_work)</span></code></p>
<blockquote>
<div><p>Retrieve the respective <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a> item from a <code class="xref c c-type docutils literal notranslate"><span class="pre">kthread_work</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_work</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">kthread_work</span></code> embedded inside a <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_vblank_work</span></code></a></p>
</dd>
</dl>
<dl class="c function">
<dt id="c.drm_vblank_work_schedule">
int <code class="sig-name descname">drm_vblank_work_schedule</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work">drm_vblank_work</a> *<em>work</em>, u64 <em>count</em>, bool <em>nextonmiss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_work_schedule" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>schedule a vblank work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vblank_work</span> <span class="pre">*work</span></code></dt><dd><p>vblank work to schedule</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">count</span></code></dt><dd><p>target vblank count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nextonmiss</span></code></dt><dd><p>defer until the next vblank if target vblank was missed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule <strong>work</strong> for execution once the crtc vblank count reaches <strong>count</strong>.</p>
<p>If the crtc vblank count has already reached <strong>count</strong> and <strong>nextonmiss</strong> is
<code class="docutils literal notranslate"><span class="pre">false</span></code> the work starts to execute immediately.</p>
<p>If the crtc vblank count has already reached <strong>count</strong> and <strong>nextonmiss</strong> is
<code class="docutils literal notranslate"><span class="pre">true</span></code> the work is deferred until the next vblank (as if <strong>count</strong> has been
specified as crtc vblank count + 1).</p>
<p>If <strong>work</strong> is already scheduled, this function will reschedule said work
using the new <strong>count</strong>. This can be used for self-rearming work items.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">1</span></code> if <strong>work</strong> was successfully (re)scheduled, <code class="docutils literal notranslate"><span class="pre">0</span></code> if it was either already
scheduled or cancelled, or a negative error code on failure.</p>
<dl class="c function">
<dt id="c.drm_vblank_work_cancel_sync">
bool <code class="sig-name descname">drm_vblank_work_cancel_sync</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work">drm_vblank_work</a> *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_work_cancel_sync" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel a vblank work and wait for it to finish executing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vblank_work</span> <span class="pre">*work</span></code></dt><dd><p>vblank work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel an already scheduled vblank work and wait for its
execution to finish.</p>
<p>On return, <strong>work</strong> is guaranteed to no longer be scheduled or running, even
if it’s self-arming.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the work was cancelled before it started to execute, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
<dl class="c function">
<dt id="c.drm_vblank_work_flush">
void <code class="sig-name descname">drm_vblank_work_flush</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work">drm_vblank_work</a> *<em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_work_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for a scheduled vblank work to finish executing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vblank_work</span> <span class="pre">*work</span></code></dt><dd><p>vblank work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until <strong>work</strong> has finished executing once.</p>
<dl class="c function">
<dt id="c.drm_vblank_work_init">
void <code class="sig-name descname">drm_vblank_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_vblank_work" title="drm_vblank_work">drm_vblank_work</a> *<em>work</em>, <em class="property">struct</em> <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, void (*<em>func</em>)<span class="sig-paren">(</span><em class="property">struct</em> kthread_work *work<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_work_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a vblank work item</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vblank_work</span> <span class="pre">*work</span></code></dt><dd><p>vblank work item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC whose vblank will trigger the work execution</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*func)(struct</span> <span class="pre">kthread_work</span> <span class="pre">*work)</span></code></dt><dd><p>work function to be executed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a vblank work item for a specific crtc.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral float-right" title="Mode Setting Helper Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-mm.html" class="btn btn-neutral float-left" title="DRM Memory Management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>