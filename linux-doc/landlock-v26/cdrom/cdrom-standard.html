

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>A Linux CD-ROM standard &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="IDE-CD driver documentation" href="ide-cd.html" />
    <link rel="prev" title="cdrom" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">cdrom</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">A Linux CD-ROM standard</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standardizing-through-another-software-level">Standardizing through another software level</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cd-rom-capabilities">CD-ROM capabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#options">Options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-need-to-know-the-purpose-of-opening-the-cd-rom-device">The need to know the purpose of opening the CD-ROM device</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#and-what-about-standards">And what about standards?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-preferred-strategy-of-open">The preferred strategy of <em>open()</em></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#description-of-routines-in-cdrom-c">Description of routines in <cite>cdrom.c</cite></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#directly-implemented-ioctl-s">Directly implemented <em>ioctl()’s</em></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ioctl-s-routed-through-audio-ioctl"><em>Ioctl*s routed through *audio_ioctl()</em></a></li>
<li class="toctree-l4"><a class="reference internal" href="#new-ioctl-s-in-cdrom-c">New <em>ioctl()’s</em> in <cite>cdrom.c</cite></a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-dependent-ioctl-s">Device dependent <em>ioctl()’s</em></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-update-your-driver">How to update your driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thanks">Thanks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ide-cd.html">IDE-CD driver documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet-writing.html">Packet writing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">cdrom</a> &raquo;</li>
        
      <li>A Linux CD-ROM standard</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/cdrom/cdrom-standard.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="a-linux-cd-rom-standard">
<h1>A Linux CD-ROM standard<a class="headerlink" href="#a-linux-cd-rom-standard" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>David van Leeuwen &lt;<a class="reference external" href="mailto:david&#37;&#52;&#48;ElseWare&#46;cistron&#46;nl">david<span>&#64;</span>ElseWare<span>&#46;</span>cistron<span>&#46;</span>nl</a>&gt;</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>12 March 1999</p>
</dd>
<dt class="field-odd">Updated by</dt>
<dd class="field-odd"><p>Erik Andersen (<a class="reference external" href="mailto:andersee&#37;&#52;&#48;debian&#46;org">andersee<span>&#64;</span>debian<span>&#46;</span>org</a>)</p>
</dd>
<dt class="field-even">Updated by</dt>
<dd class="field-even"><p>Jens Axboe (<a class="reference external" href="mailto:axboe&#37;&#52;&#48;image&#46;dk">axboe<span>&#64;</span>image<span>&#46;</span>dk</a>)</p>
</dd>
</dl>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Linux is probably the Unix-like operating system that supports
the widest variety of hardware devices. The reasons for this are
presumably</p>
<ul class="simple">
<li><p>The large list of hardware devices available for the many platforms
that Linux now supports (i.e., i386-PCs, Sparc Suns, etc.)</p></li>
<li><p>The open design of the operating system, such that anybody can write a
driver for Linux.</p></li>
<li><p>There is plenty of source code around as examples of how to write a driver.</p></li>
</ul>
<p>The openness of Linux, and the many different types of available
hardware has allowed Linux to support many different hardware devices.
Unfortunately, the very openness that has allowed Linux to support
all these different devices has also allowed the behavior of each
device driver to differ significantly from one device to another.
This divergence of behavior has been very significant for CD-ROM
devices; the way a particular drive reacts to a <cite>standard</cite> <em>ioctl()</em>
call varies greatly from one device driver to another. To avoid making
their drivers totally inconsistent, the writers of Linux CD-ROM
drivers generally created new device drivers by understanding, copying,
and then changing an existing one. Unfortunately, this practice did not
maintain uniform behavior across all the Linux CD-ROM drivers.</p>
<p>This document describes an effort to establish Uniform behavior across
all the different CD-ROM device drivers for Linux. This document also
defines the various <em>ioctl()’s</em>, and how the low-level CD-ROM device
drivers should implement them. Currently (as of the Linux 2.1.<em>x</em>
development kernels) several low-level CD-ROM device drivers, including
both IDE/ATAPI and SCSI, now use this Uniform interface.</p>
<p>When the CD-ROM was developed, the interface between the CD-ROM drive
and the computer was not specified in the standards. As a result, many
different CD-ROM interfaces were developed. Some of them had their
own proprietary design (Sony, Mitsumi, Panasonic, Philips), other
manufacturers adopted an existing electrical interface and changed
the functionality (CreativeLabs/SoundBlaster, Teac, Funai) or simply
adapted their drives to one or more of the already existing electrical
interfaces (Aztech, Sanyo, Funai, Vertos, Longshine, Optics Storage and
most of the <cite>NoName</cite> manufacturers). In cases where a new drive really
brought its own interface or used its own command set and flow control
scheme, either a separate driver had to be written, or an existing
driver had to be enhanced. History has delivered us CD-ROM support for
many of these different interfaces. Nowadays, almost all new CD-ROM
drives are either IDE/ATAPI or SCSI, and it is very unlikely that any
manufacturer will create a new interface. Even finding drives for the
old proprietary interfaces is getting difficult.</p>
<p>When (in the 1.3.70’s) I looked at the existing software interface,
which was expressed through <cite>cdrom.h</cite>, it appeared to be a rather wild
set of commands and data formats <a class="footnote-reference brackets" href="#f1" id="id1">1</a>. It seemed that many
features of the software interface had been added to accommodate the
capabilities of a particular drive, in an <em>ad hoc</em> manner. More
importantly, it appeared that the behavior of the <cite>standard</cite> commands
was different for most of the different drivers: e. g., some drivers
close the tray if an <em>open()</em> call occurs when the tray is open, while
others do not. Some drivers lock the door upon opening the device, to
prevent an incoherent file system, but others don’t, to allow software
ejection. Undoubtedly, the capabilities of the different drives vary,
but even when two drives have the same capability their drivers’
behavior was usually different.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>I cannot recollect what kernel version I looked at, then,
presumably 1.2.13 and 1.3.34 — the latest kernel that I was
indirectly involved in.</p>
</dd>
</dl>
<p>I decided to start a discussion on how to make all the Linux CD-ROM
drivers behave more uniformly. I began by contacting the developers of
the many CD-ROM drivers found in the Linux kernel. Their reactions
encouraged me to write the Uniform CD-ROM Driver which this document is
intended to describe. The implementation of the Uniform CD-ROM Driver is
in the file <cite>cdrom.c</cite>. This driver is intended to be an additional software
layer that sits on top of the low-level device drivers for each CD-ROM drive.
By adding this additional layer, it is possible to have all the different
CD-ROM devices behave <strong>exactly</strong> the same (insofar as the underlying
hardware will allow).</p>
<p>The goal of the Uniform CD-ROM Driver is <strong>not</strong> to alienate driver developers
whohave not yet taken steps to support this effort. The goal of Uniform CD-ROM
Driver is simply to give people writing application programs for CD-ROM drives
<strong>one</strong> Linux CD-ROM interface with consistent behavior for all
CD-ROM devices. In addition, this also provides a consistent interface
between the low-level device driver code and the Linux kernel. Care
is taken that 100% compatibility exists with the data structures and
programmer’s interface defined in <cite>cdrom.h</cite>. This guide was written to
help CD-ROM driver developers adapt their code to use the Uniform CD-ROM
Driver code defined in <cite>cdrom.c</cite>.</p>
<p>Personally, I think that the most important hardware interfaces are
the IDE/ATAPI drives and, of course, the SCSI drives, but as prices
of hardware drop continuously, it is also likely that people may have
more than one CD-ROM drive, possibly of mixed types. It is important
that these drives behave in the same way. In December 1994, one of the
cheapest CD-ROM drives was a Philips cm206, a double-speed proprietary
drive. In the months that I was busy writing a Linux driver for it,
proprietary drives became obsolete and IDE/ATAPI drives became the
standard. At the time of the last update to this document (November
1997) it is becoming difficult to even <strong>find</strong> anything less than a
16 speed CD-ROM drive, and 24 speed drives are common.</p>
</div>
<div class="section" id="standardizing-through-another-software-level">
<span id="cdrom-api"></span><h2>Standardizing through another software level<a class="headerlink" href="#standardizing-through-another-software-level" title="Permalink to this headline">¶</a></h2>
<p>At the time this document was conceived, all drivers directly
implemented the CD-ROM <em>ioctl()</em> calls through their own routines. This
led to the danger of different drivers forgetting to do important things
like checking that the user was giving the driver valid data. More
importantly, this led to the divergence of behavior, which has already
been discussed.</p>
<p>For this reason, the Uniform CD-ROM Driver was created to enforce consistent
CD-ROM drive behavior, and to provide a common set of services to the various
low-level CD-ROM device drivers. The Uniform CD-ROM Driver now provides another
software-level, that separates the <em>ioctl()</em> and <em>open()</em> implementation
from the actual hardware implementation. Note that this effort has
made few changes which will affect a user’s application programs. The
greatest change involved moving the contents of the various low-level
CD-ROM drivers' header files to the kernel’s cdrom directory. This was
done to help ensure that the user is only presented with only one cdrom
interface, the interface defined in <cite>cdrom.h</cite>.</p>
<p>CD-ROM drives are specific enough (i. e., different from other
block-devices such as floppy or hard disc drives), to define a set
of common <strong>CD-ROM device operations</strong>, <em>&lt;cdrom-device&gt;_dops</em>.
These operations are different from the classical block-device file
operations, <em>&lt;block-device&gt;_fops</em>.</p>
<p>The routines for the Uniform CD-ROM Driver interface level are implemented
in the file <cite>cdrom.c</cite>. In this file, the Uniform CD-ROM Driver interfaces
with the kernel as a block device by registering the following general
<em>struct file_operations</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct file_operations cdrom_fops = {
        NULL,                   /∗ lseek ∗/
        block _read ,           /∗ read—general block-dev read ∗/
        block _write,           /∗ write—general block-dev write ∗/
        NULL,                   /∗ readdir ∗/
        NULL,                   /∗ select ∗/
        cdrom_ioctl,            /∗ ioctl ∗/
        NULL,                   /∗ mmap ∗/
        cdrom_open,             /∗ open ∗/
        cdrom_release,          /∗ release ∗/
        NULL,                   /∗ fsync ∗/
        NULL,                   /∗ fasync ∗/
        NULL                    /∗ revalidate ∗/
};
</pre></div>
</div>
<p>Every active CD-ROM device shares this <em>struct</em>. The routines
declared above are all implemented in <cite>cdrom.c</cite>, since this file is the
place where the behavior of all CD-ROM-devices is defined and
standardized. The actual interface to the various types of CD-ROM
hardware is still performed by various low-level CD-ROM-device
drivers. These routines simply implement certain <strong>capabilities</strong>
that are common to all CD-ROM (and really, all removable-media
devices).</p>
<p>Registration of a low-level CD-ROM device driver is now done through
the general routines in <cite>cdrom.c</cite>, not through the Virtual File System
(VFS) any more. The interface implemented in <cite>cdrom.c</cite> is carried out
through two general structures that contain information about the
capabilities of the driver, and the specific drives on which the
driver operates. The structures are:</p>
<dl class="simple">
<dt>cdrom_device_ops</dt><dd><p>This structure contains information about the low-level driver for a
CD-ROM device. This structure is conceptually connected to the major
number of the device (although some drivers may have different
major numbers, as is the case for the IDE driver).</p>
</dd>
<dt>cdrom_device_info</dt><dd><p>This structure contains information about a particular CD-ROM drive,
such as its device name, speed, etc. This structure is conceptually
connected to the minor number of the device.</p>
</dd>
</dl>
<p>Registering a particular CD-ROM drive with the Uniform CD-ROM Driver
is done by the low-level device driver though a call to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>register_cdrom(struct cdrom_device_info * &lt;device&gt;_info)
</pre></div>
</div>
<p>The device information structure, <em>&lt;device&gt;_info</em>, contains all the
information needed for the kernel to interface with the low-level
CD-ROM device driver. One of the most important entries in this
structure is a pointer to the <em>cdrom_device_ops</em> structure of the
low-level driver.</p>
<p>The device operations structure, <em>cdrom_device_ops</em>, contains a list
of pointers to the functions which are implemented in the low-level
device driver. When <cite>cdrom.c</cite> accesses a CD-ROM device, it does it
through the functions in this structure. It is impossible to know all
the capabilities of future CD-ROM drives, so it is expected that this
list may need to be expanded from time to time as new technologies are
developed. For example, CD-R and CD-R/W drives are beginning to become
popular, and support will soon need to be added for them. For now, the
current <em>struct</em> is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_device_ops {
        int (*open)(struct cdrom_device_info *, int)
        void (*release)(struct cdrom_device_info *);
        int (*drive_status)(struct cdrom_device_info *, int);
        unsigned int (*check_events)(struct cdrom_device_info *,
                                     unsigned int, int);
        int (*media_changed)(struct cdrom_device_info *, int);
        int (*tray_move)(struct cdrom_device_info *, int);
        int (*lock_door)(struct cdrom_device_info *, int);
        int (*select_speed)(struct cdrom_device_info *, int);
        int (*select_disc)(struct cdrom_device_info *, int);
        int (*get_last_session) (struct cdrom_device_info *,
                                 struct cdrom_multisession *);
        int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
        int (*reset)(struct cdrom_device_info *);
        int (*audio_ioctl)(struct cdrom_device_info *,
                           unsigned int, void *);
        const int capability;           /* capability flags */
        int (*generic_packet)(struct cdrom_device_info *,
                              struct packet_command *);
};
</pre></div>
</div>
<p>When a low-level device driver implements one of these capabilities,
it should add a function pointer to this <em>struct</em>. When a particular
function is not implemented, however, this <em>struct</em> should contain a
NULL instead. The <em>capability</em> flags specify the capabilities of the
CD-ROM hardware and/or low-level CD-ROM driver when a CD-ROM drive
is registered with the Uniform CD-ROM Driver.</p>
<p>Note that most functions have fewer parameters than their
<em>blkdev_fops</em> counterparts. This is because very little of the
information in the structures <em>inode</em> and <em>file</em> is used. For most
drivers, the main parameter is the <em>struct</em> <em>cdrom_device_info</em>, from
which the major and minor number can be extracted. (Most low-level
CD-ROM drivers don’t even look at the major and minor number though,
since many of them only support one device.) This will be available
through <em>dev</em> in <em>cdrom_device_info</em> described below.</p>
<p>The drive-specific, minor-like information that is registered with
<cite>cdrom.c</cite>, currently contains the following fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_device_info {
      const struct cdrom_device_ops * ops;    /* device operations for this major */
      struct list_head list;                  /* linked list of all device_info */
      struct gendisk * disk;                  /* matching block layer disk */
      void *  handle;                         /* driver-dependent data */

      int mask;                               /* mask of capability: disables them */
      int speed;                              /* maximum speed for reading data */
      int capacity;                           /* number of discs in a jukebox */

      unsigned int options:30;                /* options flags */
      unsigned mc_flags:2;                    /*  media-change buffer flags */
      unsigned int vfs_events;                /*  cached events for vfs path */
      unsigned int ioctl_events;              /*  cached events for ioctl path */
      int use_count;                          /*  number of times device is opened */
      char name[20];                          /*  name of the device type */

      __u8 sanyo_slot : 2;                    /*  Sanyo 3-CD changer support */
      __u8 keeplocked : 1;                    /*  CDROM_LOCKDOOR status */
      __u8 reserved : 5;                      /*  not used yet */
      int cdda_method;                        /*  see CDDA_* flags */
      __u8 last_sense;                        /*  saves last sense key */
      __u8 media_written;                     /*  dirty flag, DVD+RW bookkeeping */
      unsigned short mmc3_profile;            /*  current MMC3 profile */
      int for_data;                           /*  unknown:TBD */
      int (*exit)(struct cdrom_device_info *);/*  unknown:TBD */
      int mrw_mode_page;                      /*  which MRW mode page is in use */
};
</pre></div>
</div>
<p>Using this <em>struct</em>, a linked list of the registered minor devices is
built, using the <em>next</em> field. The device number, the device operations
struct and specifications of properties of the drive are stored in this
structure.</p>
<p>The <em>mask</em> flags can be used to mask out some of the capabilities listed
in <em>ops-&gt;capability</em>, if a specific drive doesn’t support a feature
of the driver. The value <em>speed</em> specifies the maximum head-rate of the
drive, measured in units of normal audio speed (176kB/sec raw data or
150kB/sec file system data). The parameters are declared <em>const</em>
because they describe properties of the drive, which don’t change after
registration.</p>
<p>A few registers contain variables local to the CD-ROM drive. The
flags <em>options</em> are used to specify how the general CD-ROM routines
should behave. These various flags registers should provide enough
flexibility to adapt to the different users’ wishes (and <strong>not</strong> the
<cite>arbitrary</cite> wishes of the author of the low-level device driver, as is
the case in the old scheme). The register <em>mc_flags</em> is used to buffer
the information from <em>media_changed()</em> to two separate queues. Other
data that is specific to a minor drive, can be accessed through <em>handle</em>,
which can point to a data structure specific to the low-level driver.
The fields <em>use_count</em>, <em>next</em>, <em>options</em> and <em>mc_flags</em> need not be
initialized.</p>
<p>The intermediate software layer that <cite>cdrom.c</cite> forms will perform some
additional bookkeeping. The use count of the device (the number of
processes that have the device opened) is registered in <em>use_count</em>. The
function <em>cdrom_ioctl()</em> will verify the appropriate user-memory regions
for read and write, and in case a location on the CD is transferred,
it will <cite>sanitize</cite> the format by making requests to the low-level
drivers in a standard format, and translating all formats between the
user-software and low level drivers. This relieves much of the drivers’
memory checking and format checking and translation. Also, the necessary
structures will be declared on the program stack.</p>
<p>The implementation of the functions should be as defined in the
following sections. Two functions <strong>must</strong> be implemented, namely
<em>open()</em> and <em>release()</em>. Other functions may be omitted, their
corresponding capability flags will be cleared upon registration.
Generally, a function returns zero on success and negative on error. A
function call should return only after the command has completed, but of
course waiting for the device should not use processor time.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int open(struct cdrom_device_info *cdi, int purpose)
</pre></div>
</div>
<p><em>Open()</em> should try to open the device for a specific <em>purpose</em>, which
can be either:</p>
<ul class="simple">
<li><p>Open for reading data, as done by <cite>mount()</cite> (2), or the
user commands <cite>dd</cite> or <cite>cat</cite>.</p></li>
<li><p>Open for <em>ioctl</em> commands, as done by audio-CD playing programs.</p></li>
</ul>
<p>Notice that any strategic code (closing tray upon <em>open()</em>, etc.) is
done by the calling routine in <cite>cdrom.c</cite>, so the low-level routine
should only be concerned with proper initialization, such as spinning
up the disc, etc.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void release(struct cdrom_device_info *cdi)
</pre></div>
</div>
<p>Device-specific actions should be taken such as spinning down the device.
However, strategic actions such as ejection of the tray, or unlocking
the door, should be left over to the general routine <em>cdrom_release()</em>.
This is the only function returning type <em>void</em>.</p>
<div class="highlight-none notranslate" id="cdrom-drive-status"><div class="highlight"><pre><span></span>int drive_status(struct cdrom_device_info *cdi, int slot_nr)
</pre></div>
</div>
<p>The function <em>drive_status</em>, if implemented, should provide
information on the status of the drive (not the status of the disc,
which may or may not be in the drive). If the drive is not a changer,
<em>slot_nr</em> should be ignored. In <cite>cdrom.h</cite> the possibilities are listed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CDS_NO_INFO             /* no information available */
CDS_NO_DISC             /* no disc is inserted, tray is closed */
CDS_TRAY_OPEN           /* tray is opened */
CDS_DRIVE_NOT_READY     /* something is wrong, tray is moving? */
CDS_DISC_OK             /* a disc is loaded and everything is fine */
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int tray_move(struct cdrom_device_info *cdi, int position)
</pre></div>
</div>
<p>This function, if implemented, should control the tray movement. (No
other function should control this.) The parameter <em>position</em> controls
the desired direction of movement:</p>
<ul class="simple">
<li><p>0 Close tray</p></li>
<li><p>1 Open tray</p></li>
</ul>
<p>This function returns 0 upon success, and a non-zero value upon
error. Note that if the tray is already in the desired position, no
action need be taken, and the return value should be 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lock_door(struct cdrom_device_info *cdi, int lock)
</pre></div>
</div>
<p>This function (and no other code) controls locking of the door, if the
drive allows this. The value of <em>lock</em> controls the desired locking
state:</p>
<ul class="simple">
<li><p>0 Unlock door, manual opening is allowed</p></li>
<li><p>1 Lock door, tray cannot be ejected manually</p></li>
</ul>
<p>This function returns 0 upon success, and a non-zero value upon
error. Note that if the door is already in the requested state, no
action need be taken, and the return value should be 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int select_speed(struct cdrom_device_info *cdi, int speed)
</pre></div>
</div>
<p>Some CD-ROM drives are capable of changing their head-speed. There
are several reasons for changing the speed of a CD-ROM drive. Badly
pressed CD-ROM s may benefit from less-than-maximum head rate. Modern
CD-ROM drives can obtain very high head rates (up to <em>24x</em> is
common). It has been reported that these drives can make reading
errors at these high speeds, reducing the speed can prevent data loss
in these circumstances. Finally, some of these drives can
make an annoyingly loud noise, which a lower speed may reduce.</p>
<p>This function specifies the speed at which data is read or audio is
played back. The value of <em>speed</em> specifies the head-speed of the
drive, measured in units of standard cdrom speed (176kB/sec raw data
or 150kB/sec file system data). So to request that a CD-ROM drive
operate at 300kB/sec you would call the CDROM_SELECT_SPEED <em>ioctl</em>
with <em>speed=2</em>. The special value <cite>0</cite> means <cite>auto-selection</cite>, i. e.,
maximum data-rate or real-time audio rate. If the drive doesn’t have
this <cite>auto-selection</cite> capability, the decision should be made on the
current disc loaded and the return value should be positive. A negative
return value indicates an error.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int select_disc(struct cdrom_device_info *cdi, int number)
</pre></div>
</div>
<p>If the drive can store multiple discs (a juke-box) this function
will perform disc selection. It should return the number of the
selected disc on success, a negative value on error. Currently, only
the ide-cd driver supports this functionality.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_last_session(struct cdrom_device_info *cdi,
                     struct cdrom_multisession *ms_info)
</pre></div>
</div>
<p>This function should implement the old corresponding <em>ioctl()</em>. For
device <em>cdi-&gt;dev</em>, the start of the last session of the current disc
should be returned in the pointer argument <em>ms_info</em>. Note that
routines in <cite>cdrom.c</cite> have sanitized this argument: its requested
format will <strong>always</strong> be of the type <em>CDROM_LBA</em> (linear block
addressing mode), whatever the calling software requested. But
sanitization goes even further: the low-level implementation may
return the requested information in <em>CDROM_MSF</em> format if it wishes so
(setting the <em>ms_info-&gt;addr_format</em> field appropriately, of
course) and the routines in <cite>cdrom.c</cite> will make the transformation if
necessary. The return value is 0 upon success.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int get_mcn(struct cdrom_device_info *cdi,
            struct cdrom_mcn *mcn)
</pre></div>
</div>
<p>Some discs carry a <cite>Media Catalog Number</cite> (MCN), also called
<cite>Universal Product Code</cite> (UPC). This number should reflect the number
that is generally found in the bar-code on the product. Unfortunately,
the few discs that carry such a number on the disc don’t even use the
same format. The return argument to this function is a pointer to a
pre-declared memory region of type <em>struct cdrom_mcn</em>. The MCN is
expected as a 13-character string, terminated by a null-character.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int reset(struct cdrom_device_info *cdi)
</pre></div>
</div>
<p>This call should perform a hard-reset on the drive (although in
circumstances that a hard-reset is necessary, a drive may very well not
listen to commands anymore). Preferably, control is returned to the
caller only after the drive has finished resetting. If the drive is no
longer listening, it may be wise for the underlying low-level cdrom
driver to time out.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int audio_ioctl(struct cdrom_device_info *cdi,
                unsigned int cmd, void *arg)
</pre></div>
</div>
<p>Some of the CD-ROM-<em>ioctl()</em>‘s defined in <cite>cdrom.h</cite> can be
implemented by the routines described above, and hence the function
<em>cdrom_ioctl</em> will use those. However, most <em>ioctl()</em>‘s deal with
audio-control. We have decided to leave these to be accessed through a
single function, repeating the arguments <em>cmd</em> and <em>arg</em>. Note that
the latter is of type <em>void</em>, rather than <em>unsigned long int</em>.
The routine <em>cdrom_ioctl()</em> does do some useful things,
though. It sanitizes the address format type to <em>CDROM_MSF</em> (Minutes,
Seconds, Frames) for all audio calls. It also verifies the memory
location of <em>arg</em>, and reserves stack-memory for the argument. This
makes implementation of the <em>audio_ioctl()</em> much simpler than in the
old driver scheme. For example, you may look up the function
<em>cm206_audio_ioctl()</em> <cite>cm206.c</cite> that should be updated with
this documentation.</p>
<p>An unimplemented ioctl should return <em>-ENOSYS</em>, but a harmless request
(e. g., <em>CDROMSTART</em>) may be ignored by returning 0 (success). Other
errors should be according to the standards, whatever they are. When
an error is returned by the low-level driver, the Uniform CD-ROM Driver
tries whenever possible to return the error code to the calling program.
(We may decide to sanitize the return value in <em>cdrom_ioctl()</em> though, in
order to guarantee a uniform interface to the audio-player software.)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int dev_ioctl(struct cdrom_device_info *cdi,
              unsigned int cmd, unsigned long arg)
</pre></div>
</div>
<p>Some <em>ioctl()’s</em> seem to be specific to certain CD-ROM drives. That is,
they are introduced to service some capabilities of certain drives. In
fact, there are 6 different <em>ioctl()’s</em> for reading data, either in some
particular kind of format, or audio data. Not many drives support
reading audio tracks as data, I believe this is because of protection
of copyrights of artists. Moreover, I think that if audio-tracks are
supported, it should be done through the VFS and not via <em>ioctl()’s</em>. A
problem here could be the fact that audio-frames are 2352 bytes long,
so either the audio-file-system should ask for 75264 bytes at once
(the least common multiple of 512 and 2352), or the drivers should
bend their backs to cope with this incoherence (to which I would be
opposed). Furthermore, it is very difficult for the hardware to find
the exact frame boundaries, since there are no synchronization headers
in audio frames. Once these issues are resolved, this code should be
standardized in <cite>cdrom.c</cite>.</p>
<p>Because there are so many <em>ioctl()’s</em> that seem to be introduced to
satisfy certain drivers <a class="footnote-reference brackets" href="#f2" id="id2">2</a>, any non-standard <em>ioctl()</em>s
are routed through the call <em>dev_ioctl()</em>. In principle, <cite>private</cite>
<em>ioctl()</em>‘s should be numbered after the device’s major number, and not
the general CD-ROM <em>ioctl</em> number, <cite>0x53</cite>. Currently the
non-supported <em>ioctl()’s</em> are:</p>
<blockquote>
<div><p>CDROMREADMODE1, CDROMREADMODE2, CDROMREADAUDIO, CDROMREADRAW,
CDROMREADCOOKED, CDROMSEEK, CDROMPLAY-BLK and CDROM-READALL</p>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Is there software around that actually uses these? I’d be interested!</p>
</dd>
</dl>
<div class="section" id="cd-rom-capabilities">
<span id="cdrom-capabilities"></span><h3>CD-ROM capabilities<a class="headerlink" href="#cd-rom-capabilities" title="Permalink to this headline">¶</a></h3>
<p>Instead of just implementing some <em>ioctl</em> calls, the interface in
<cite>cdrom.c</cite> supplies the possibility to indicate the <strong>capabilities</strong>
of a CD-ROM drive. This can be done by ORing any number of
capability-constants that are defined in <cite>cdrom.h</cite> at the registration
phase. Currently, the capabilities are any of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CDC_CLOSE_TRAY          /* can close tray by software control */
CDC_OPEN_TRAY           /* can open tray */
CDC_LOCK                /* can lock and unlock the door */
CDC_SELECT_SPEED        /* can select speed, in units of * sim*150 ,kB/s */
CDC_SELECT_DISC         /* drive is juke-box */
CDC_MULTI_SESSION       /* can read sessions *&gt; rm1* */
CDC_MCN                 /* can read Media Catalog Number */
CDC_MEDIA_CHANGED       /* can report if disc has changed */
CDC_PLAY_AUDIO          /* can perform audio-functions (play, pause, etc) */
CDC_RESET               /* hard reset device */
CDC_IOCTLS              /* driver has non-standard ioctls */
CDC_DRIVE_STATUS        /* driver implements drive status */
</pre></div>
</div>
<p>The capability flag is declared <em>const</em>, to prevent drivers from
accidentally tampering with the contents. The capability flags actually
inform <cite>cdrom.c</cite> of what the driver can do. If the drive found
by the driver does not have the capability, is can be masked out by
the <em>cdrom_device_info</em> variable <em>mask</em>. For instance, the SCSI CD-ROM
driver has implemented the code for loading and ejecting CD-ROM’s, and
hence its corresponding flags in <em>capability</em> will be set. But a SCSI
CD-ROM drive might be a caddy system, which can’t load the tray, and
hence for this drive the <em>cdrom_device_info</em> struct will have set
the <em>CDC_CLOSE_TRAY</em> bit in <em>mask</em>.</p>
<p>In the file <cite>cdrom.c</cite> you will encounter many constructions of the type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (cdo-&gt;capability &amp; ∼cdi-&gt;mask &amp; CDC _⟨capability⟩) ...
</pre></div>
</div>
<p>There is no <em>ioctl</em> to set the mask… The reason is that
I think it is better to control the <strong>behavior</strong> rather than the
<strong>capabilities</strong>.</p>
</div>
<div class="section" id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>A final flag register controls the <strong>behavior</strong> of the CD-ROM
drives, in order to satisfy different users’ wishes, hopefully
independently of the ideas of the respective author who happened to
have made the drive’s support available to the Linux community. The
current behavior options are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CDO_AUTO_CLOSE  /* try to close tray upon device open() */
CDO_AUTO_EJECT  /* try to open tray on last device close() */
CDO_USE_FFLAGS  /* use file_pointer-&gt;f_flags to indicate purpose for open() */
CDO_LOCK        /* try to lock door if device is opened */
CDO_CHECK_TYPE  /* ensure disc type is data if opened for data */
</pre></div>
</div>
<p>The initial value of this register is
<cite>CDO_AUTO_CLOSE | CDO_USE_FFLAGS | CDO_LOCK</cite>, reflecting my own view on user
interface and software standards. Before you protest, there are two
new <em>ioctl()’s</em> implemented in <cite>cdrom.c</cite>, that allow you to control the
behavior by software. These are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CDROM_SET_OPTIONS       /* set options specified in (int)arg */
CDROM_CLEAR_OPTIONS     /* clear options specified in (int)arg */
</pre></div>
</div>
<p>One option needs some more explanation: <em>CDO_USE_FFLAGS</em>. In the next
newsection we explain what the need for this option is.</p>
<p>A software package <cite>setcd</cite>, available from the Debian distribution
and <cite>sunsite.unc.edu</cite>, allows user level control of these flags.</p>
</div>
</div>
<div class="section" id="the-need-to-know-the-purpose-of-opening-the-cd-rom-device">
<h2>The need to know the purpose of opening the CD-ROM device<a class="headerlink" href="#the-need-to-know-the-purpose-of-opening-the-cd-rom-device" title="Permalink to this headline">¶</a></h2>
<p>Traditionally, Unix devices can be used in two different <cite>modes</cite>,
either by reading/writing to the device file, or by issuing
controlling commands to the device, by the device’s <em>ioctl()</em>
call. The problem with CD-ROM drives, is that they can be used for
two entirely different purposes. One is to mount removable
file systems, CD-ROM’s, the other is to play audio CD’s. Audio commands
are implemented entirely through <em>ioctl()'s</em>, presumably because the
first implementation (SUN?) has been such. In principle there is
nothing wrong with this, but a good control of the <cite>CD player</cite> demands
that the device can <strong>always</strong> be opened in order to give the
<em>ioctl</em> commands, regardless of the state the drive is in.</p>
<p>On the other hand, when used as a removable-media disc drive (what the
original purpose of CD-ROM s is) we would like to make sure that the
disc drive is ready for operation upon opening the device. In the old
scheme, some CD-ROM drivers don’t do any integrity checking, resulting
in a number of i/o errors reported by the VFS to the kernel when an
attempt for mounting a CD-ROM on an empty drive occurs. This is not a
particularly elegant way to find out that there is no CD-ROM inserted;
it more-or-less looks like the old IBM-PC trying to read an empty floppy
drive for a couple of seconds, after which the system complains it
can’t read from it. Nowadays we can <strong>sense</strong> the existence of a
removable medium in a drive, and we believe we should exploit that
fact. An integrity check on opening of the device, that verifies the
availability of a CD-ROM and its correct type (data), would be
desirable.</p>
<p>These two ways of using a CD-ROM drive, principally for data and
secondarily for playing audio discs, have different demands for the
behavior of the <em>open()</em> call. Audio use simply wants to open the
device in order to get a file handle which is needed for issuing
<em>ioctl</em> commands, while data use wants to open for correct and
reliable data transfer. The only way user programs can indicate what
their <em>purpose</em> of opening the device is, is through the <em>flags</em>
parameter (see <cite>open(2)</cite>). For CD-ROM devices, these flags aren’t
implemented (some drivers implement checking for write-related flags,
but this is not strictly necessary if the device file has correct
permission flags). Most option flags simply don’t make sense to
CD-ROM devices: <em>O_CREAT</em>, <em>O_NOCTTY</em>, <em>O_TRUNC</em>, <em>O_APPEND</em>, and
<em>O_SYNC</em> have no meaning to a CD-ROM.</p>
<p>We therefore propose to use the flag <em>O_NONBLOCK</em> to indicate
that the device is opened just for issuing <em>ioctl</em>
commands. Strictly, the meaning of <em>O_NONBLOCK</em> is that opening and
subsequent calls to the device don’t cause the calling process to
wait. We could interpret this as don’t wait until someone has
inserted some valid data-CD-ROM. Thus, our proposal of the
implementation for the <em>open()</em> call for CD-ROM s is:</p>
<ul class="simple">
<li><p>If no other flags are set than <em>O_RDONLY</em>, the device is opened
for data transfer, and the return value will be 0 only upon successful
initialization of the transfer. The call may even induce some actions
on the CD-ROM, such as closing the tray.</p></li>
<li><p>If the option flag <em>O_NONBLOCK</em> is set, opening will always be
successful, unless the whole device doesn’t exist. The drive will take
no actions whatsoever.</p></li>
</ul>
<div class="section" id="and-what-about-standards">
<h3>And what about standards?<a class="headerlink" href="#and-what-about-standards" title="Permalink to this headline">¶</a></h3>
<p>You might hesitate to accept this proposal as it comes from the
Linux community, and not from some standardizing institute. What
about SUN, SGI, HP and all those other Unix and hardware vendors?
Well, these companies are in the lucky position that they generally
control both the hardware and software of their supported products,
and are large enough to set their own standard. They do not have to
deal with a dozen or more different, competing hardware
configurations<a class="footnote-reference brackets" href="#f3" id="id3">3</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Incidentally, I think that SUN’s approach to mounting CD-ROM s is very
good in origin: under Solaris a volume-daemon automatically mounts a
newly inserted CD-ROM under <cite>/cdrom/*&lt;volume-name&gt;*</cite>.</p>
<p>In my opinion they should have pushed this
further and have <strong>every</strong> CD-ROM on the local area network be
mounted at the similar location, i. e., no matter in which particular
machine you insert a CD-ROM, it will always appear at the same
position in the directory tree, on every system. When I wanted to
implement such a user-program for Linux, I came across the
differences in behavior of the various drivers, and the need for an
<em>ioctl</em> informing about media changes.</p>
</dd>
</dl>
<p>We believe that using <em>O_NONBLOCK</em> to indicate that a device is being opened
for <em>ioctl</em> commands only can be easily introduced in the Linux
community. All the CD-player authors will have to be informed, we can
even send in our own patches to the programs. The use of <em>O_NONBLOCK</em>
has most likely no influence on the behavior of the CD-players on
other operating systems than Linux. Finally, a user can always revert
to old behavior by a call to
<em>ioctl(file_descriptor, CDROM_CLEAR_OPTIONS, CDO_USE_FFLAGS)</em>.</p>
</div>
<div class="section" id="the-preferred-strategy-of-open">
<h3>The preferred strategy of <em>open()</em><a class="headerlink" href="#the-preferred-strategy-of-open" title="Permalink to this headline">¶</a></h3>
<p>The routines in <cite>cdrom.c</cite> are designed in such a way that run-time
configuration of the behavior of CD-ROM devices (of <strong>any</strong> type)
can be carried out, by the <em>CDROM_SET/CLEAR_OPTIONS</em> <em>ioctls</em>. Thus, various
modes of operation can be set:</p>
<dl class="simple">
<dt><cite>CDO_AUTO_CLOSE | CDO_USE_FFLAGS | CDO_LOCK</cite></dt><dd><p>This is the default setting. (With <em>CDO_CHECK_TYPE</em> it will be better, in
the future.) If the device is not yet opened by any other process, and if
the device is being opened for data (<em>O_NONBLOCK</em> is not set) and the
tray is found to be open, an attempt to close the tray is made. Then,
it is verified that a disc is in the drive and, if <em>CDO_CHECK_TYPE</em> is
set, that it contains tracks of type <cite>data mode 1</cite>. Only if all tests
are passed is the return value zero. The door is locked to prevent file
system corruption. If the drive is opened for audio (<em>O_NONBLOCK</em> is
set), no actions are taken and a value of 0 will be returned.</p>
</dd>
<dt><cite>CDO_AUTO_CLOSE | CDO_AUTO_EJECT | CDO_LOCK</cite></dt><dd><p>This mimics the behavior of the current sbpcd-driver. The option flags are
ignored, the tray is closed on the first open, if necessary. Similarly,
the tray is opened on the last release, i. e., if a CD-ROM is unmounted,
it is automatically ejected, such that the user can replace it.</p>
</dd>
</dl>
<p>We hope that these option can convince everybody (both driver
maintainers and user program developers) to adopt the new CD-ROM
driver scheme and option flag interpretation.</p>
</div>
</div>
<div class="section" id="description-of-routines-in-cdrom-c">
<h2>Description of routines in <cite>cdrom.c</cite><a class="headerlink" href="#description-of-routines-in-cdrom-c" title="Permalink to this headline">¶</a></h2>
<p>Only a few routines in <cite>cdrom.c</cite> are exported to the drivers. In this
new section we will discuss these, as well as the functions that <cite>take
over</cite> the CD-ROM interface to the kernel. The header file belonging
to <cite>cdrom.c</cite> is called <cite>cdrom.h</cite>. Formerly, some of the contents of this
file were placed in the file <cite>ucdrom.h</cite>, but this file has now been
merged back into <cite>cdrom.h</cite>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct file_operations cdrom_fops
</pre></div>
</div>
<p>The contents of this structure were described in <a class="reference internal" href="#cdrom-api">cdrom_api</a>.
A pointer to this structure is assigned to the <em>fops</em> field
of the <em>struct gendisk</em>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int register_cdrom(struct cdrom_device_info *cdi)
</pre></div>
</div>
<p>This function is used in about the same way one registers <em>cdrom_fops</em>
with the kernel, the device operations and information structures,
as described in <a class="reference internal" href="#cdrom-api">cdrom_api</a>, should be registered with the
Uniform CD-ROM Driver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>register_cdrom(&amp;&lt;device&gt;_info);
</pre></div>
</div>
<p>This function returns zero upon success, and non-zero upon
failure. The structure <em>&lt;device&gt;_info</em> should have a pointer to the
driver’s <em>&lt;device&gt;_dops</em>, as in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_device_info &lt;device&gt;_info = {
        &lt;device&gt;_dops;
        ...
}
</pre></div>
</div>
<p>Note that a driver must have one static structure, <em>&lt;device&gt;_dops</em>, while
it may have as many structures <em>&lt;device&gt;_info</em> as there are minor devices
active. <em>Register_cdrom()</em> builds a linked list from these.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void unregister_cdrom(struct cdrom_device_info *cdi)
</pre></div>
</div>
<p>Unregistering device <em>cdi</em> with minor number <em>MINOR(cdi-&gt;dev)</em> removes
the minor device from the list. If it was the last registered minor for
the low-level driver, this disconnects the registered device-operation
routines from the CD-ROM interface. This function returns zero upon
success, and non-zero upon failure.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int cdrom_open(struct inode * ip, struct file * fp)
</pre></div>
</div>
<p>This function is not called directly by the low-level drivers, it is
listed in the standard <em>cdrom_fops</em>. If the VFS opens a file, this
function becomes active. A strategy is implemented in this routine,
taking care of all capabilities and options that are set in the
<em>cdrom_device_ops</em> connected to the device. Then, the program flow is
transferred to the device_dependent <em>open()</em> call.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void cdrom_release(struct inode *ip, struct file *fp)
</pre></div>
</div>
<p>This function implements the reverse-logic of <em>cdrom_open()</em>, and then
calls the device-dependent <em>release()</em> routine. When the use-count has
reached 0, the allocated buffers are flushed by calls to <em>sync_dev(dev)</em>
and <em>invalidate_buffers(dev)</em>.</p>
<div class="highlight-none notranslate" id="cdrom-ioctl"><div class="highlight"><pre><span></span>int cdrom_ioctl(struct inode *ip, struct file *fp,
                unsigned int cmd, unsigned long arg)
</pre></div>
</div>
<p>This function handles all the standard <em>ioctl</em> requests for CD-ROM
devices in a uniform way. The different calls fall into three
categories: <em>ioctl()’s</em> that can be directly implemented by device
operations, ones that are routed through the call <em>audio_ioctl()</em>, and
the remaining ones, that are presumable device-dependent. Generally, a
negative return value indicates an error.</p>
<div class="section" id="directly-implemented-ioctl-s">
<h3>Directly implemented <em>ioctl()’s</em><a class="headerlink" href="#directly-implemented-ioctl-s" title="Permalink to this headline">¶</a></h3>
<p>The following <cite>old</cite> CD-ROM <em>ioctl()</em>‘s are implemented by directly
calling device-operations in <em>cdrom_device_ops</em>, if implemented and
not masked:</p>
<dl class="simple">
<dt><cite>CDROMMULTISESSION</cite></dt><dd><p>Requests the last session on a CD-ROM.</p>
</dd>
<dt><cite>CDROMEJECT</cite></dt><dd><p>Open tray.</p>
</dd>
<dt><cite>CDROMCLOSETRAY</cite></dt><dd><p>Close tray.</p>
</dd>
<dt><cite>CDROMEJECT_SW</cite></dt><dd><p>If <em>argnot=0</em>, set behavior to auto-close (close
tray on first open) and auto-eject (eject on last release), otherwise
set behavior to non-moving on <em>open()</em> and <em>release()</em> calls.</p>
</dd>
<dt><cite>CDROM_GET_MCN</cite></dt><dd><p>Get the Media Catalog Number from a CD.</p>
</dd>
</dl>
</div>
<div class="section" id="ioctl-s-routed-through-audio-ioctl">
<h3><em>Ioctl*s routed through *audio_ioctl()</em><a class="headerlink" href="#ioctl-s-routed-through-audio-ioctl" title="Permalink to this headline">¶</a></h3>
<p>The following set of <em>ioctl()’s</em> are all implemented through a call to
the <em>cdrom_fops</em> function <em>audio_ioctl()</em>. Memory checks and
allocation are performed in <em>cdrom_ioctl()</em>, and also sanitization of
address format (<em>CDROM_LBA</em>/<em>CDROM_MSF</em>) is done.</p>
<dl class="simple">
<dt><cite>CDROMSUBCHNL</cite></dt><dd><p>Get sub-channel data in argument <em>arg</em> of type
<cite>struct cdrom_subchnl *</cite>.</p>
</dd>
<dt><cite>CDROMREADTOCHDR</cite></dt><dd><p>Read Table of Contents header, in <em>arg</em> of type
<cite>struct cdrom_tochdr *</cite>.</p>
</dd>
<dt><cite>CDROMREADTOCENTRY</cite></dt><dd><p>Read a Table of Contents entry in <em>arg</em> and specified by <em>arg</em>
of type <cite>struct cdrom_tocentry *</cite>.</p>
</dd>
<dt><cite>CDROMPLAYMSF</cite></dt><dd><p>Play audio fragment specified in Minute, Second, Frame format,
delimited by <em>arg</em> of type <cite>struct cdrom_msf *</cite>.</p>
</dd>
<dt><cite>CDROMPLAYTRKIND</cite></dt><dd><p>Play audio fragment in track-index format delimited by <em>arg</em>
of type <cite>struct cdrom_ti *</cite>.</p>
</dd>
<dt><cite>CDROMVOLCTRL</cite></dt><dd><p>Set volume specified by <em>arg</em> of type <cite>struct cdrom_volctrl *</cite>.</p>
</dd>
<dt><cite>CDROMVOLREAD</cite></dt><dd><p>Read volume into by <em>arg</em> of type <cite>struct cdrom_volctrl *</cite>.</p>
</dd>
<dt><cite>CDROMSTART</cite></dt><dd><p>Spin up disc.</p>
</dd>
<dt><cite>CDROMSTOP</cite></dt><dd><p>Stop playback of audio fragment.</p>
</dd>
<dt><cite>CDROMPAUSE</cite></dt><dd><p>Pause playback of audio fragment.</p>
</dd>
<dt><cite>CDROMRESUME</cite></dt><dd><p>Resume playing.</p>
</dd>
</dl>
</div>
<div class="section" id="new-ioctl-s-in-cdrom-c">
<h3>New <em>ioctl()’s</em> in <cite>cdrom.c</cite><a class="headerlink" href="#new-ioctl-s-in-cdrom-c" title="Permalink to this headline">¶</a></h3>
<p>The following <em>ioctl()’s</em> have been introduced to allow user programs to
control the behavior of individual CD-ROM devices. New <em>ioctl</em>
commands can be identified by the underscores in their names.</p>
<dl>
<dt><cite>CDROM_SET_OPTIONS</cite></dt><dd><p>Set options specified by <em>arg</em>. Returns the option flag register
after modification. Use <em>arg = rm0</em> for reading the current flags.</p>
</dd>
<dt><cite>CDROM_CLEAR_OPTIONS</cite></dt><dd><p>Clear options specified by <em>arg</em>. Returns the option flag register
after modification.</p>
</dd>
<dt><cite>CDROM_SELECT_SPEED</cite></dt><dd><p>Select head-rate speed of disc specified as by <em>arg</em> in units
of standard cdrom speed (176,kB/sec raw data or
150kB/sec file system data). The value 0 means <cite>auto-select</cite>,
i. e., play audio discs at real time and data discs at maximum speed.
The value <em>arg</em> is checked against the maximum head rate of the
drive found in the <em>cdrom_dops</em>.</p>
</dd>
<dt><cite>CDROM_SELECT_DISC</cite></dt><dd><p>Select disc numbered <em>arg</em> from a juke-box.</p>
<p>First disc is numbered 0. The number <em>arg</em> is checked against the
maximum number of discs in the juke-box found in the <em>cdrom_dops</em>.</p>
</dd>
<dt><cite>CDROM_MEDIA_CHANGED</cite></dt><dd><p>Returns 1 if a disc has been changed since the last call.
For juke-boxes, an extra argument <em>arg</em>
specifies the slot for which the information is given. The special
value <em>CDSL_CURRENT</em> requests that information about the currently
selected slot be returned.</p>
</dd>
<dt><cite>CDROM_DRIVE_STATUS</cite></dt><dd><p>Returns the status of the drive by a call to
<em>drive_status()</em>. Return values are defined in <a class="reference internal" href="#cdrom-drive-status">cdrom_drive_status</a>.
Note that this call doesn’t return information on the
current playing activity of the drive; this can be polled through
an <em>ioctl</em> call to <em>CDROMSUBCHNL</em>. For juke-boxes, an extra argument
<em>arg</em> specifies the slot for which (possibly limited) information is
given. The special value <em>CDSL_CURRENT</em> requests that information
about the currently selected slot be returned.</p>
</dd>
<dt><cite>CDROM_DISC_STATUS</cite></dt><dd><p>Returns the type of the disc currently in the drive.
It should be viewed as a complement to <em>CDROM_DRIVE_STATUS</em>.
This <em>ioctl</em> can provide <em>some</em> information about the current
disc that is inserted in the drive. This functionality used to be
implemented in the low level drivers, but is now carried out
entirely in Uniform CD-ROM Driver.</p>
<p>The history of development of the CD’s use as a carrier medium for
various digital information has lead to many different disc types.
This <em>ioctl</em> is useful only in the case that CDs have emph {only
one} type of data on them. While this is often the case, it is
also very common for CDs to have some tracks with data, and some
tracks with audio. Because this is an existing interface, rather
than fixing this interface by changing the assumptions it was made
under, thereby breaking all user applications that use this
function, the Uniform CD-ROM Driver implements this <em>ioctl</em> as
follows: If the CD in question has audio tracks on it, and it has
absolutely no CD-I, XA, or data tracks on it, it will be reported
as <em>CDS_AUDIO</em>. If it has both audio and data tracks, it will
return <em>CDS_MIXED</em>. If there are no audio tracks on the disc, and
if the CD in question has any CD-I tracks on it, it will be
reported as <em>CDS_XA_2_2</em>. Failing that, if the CD in question
has any XA tracks on it, it will be reported as <em>CDS_XA_2_1</em>.
Finally, if the CD in question has any data tracks on it,
it will be reported as a data CD (<em>CDS_DATA_1</em>).</p>
<p>This <em>ioctl</em> can return:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CDS_NO_INFO     /* no information available */
CDS_NO_DISC     /* no disc is inserted, or tray is opened */
CDS_AUDIO       /* Audio disc (2352 audio bytes/frame) */
CDS_DATA_1      /* data disc, mode 1 (2048 user bytes/frame) */
CDS_XA_2_1      /* mixed data (XA), mode 2, form 1 (2048 user bytes) */
CDS_XA_2_2      /* mixed data (XA), mode 2, form 1 (2324 user bytes) */
CDS_MIXED       /* mixed audio/data disc */
</pre></div>
</div>
<p>For some information concerning frame layout of the various disc
types, see a recent version of <cite>cdrom.h</cite>.</p>
</dd>
<dt><cite>CDROM_CHANGER_NSLOTS</cite></dt><dd><p>Returns the number of slots in a juke-box.</p>
</dd>
<dt><cite>CDROMRESET</cite></dt><dd><p>Reset the drive.</p>
</dd>
<dt><cite>CDROM_GET_CAPABILITY</cite></dt><dd><p>Returns the <em>capability</em> flags for the drive. Refer to section
<a class="reference internal" href="#cdrom-capabilities">cdrom_capabilities</a> for more information on these flags.</p>
</dd>
<dt><cite>CDROM_LOCKDOOR</cite></dt><dd><p>Locks the door of the drive. <cite>arg == 0</cite> unlocks the door,
any other value locks it.</p>
</dd>
<dt><cite>CDROM_DEBUG</cite></dt><dd><p>Turns on debugging info. Only root is allowed to do this.
Same semantics as CDROM_LOCKDOOR.</p>
</dd>
</dl>
</div>
<div class="section" id="device-dependent-ioctl-s">
<h3>Device dependent <em>ioctl()’s</em><a class="headerlink" href="#device-dependent-ioctl-s" title="Permalink to this headline">¶</a></h3>
<p>Finally, all other <em>ioctl()’s</em> are passed to the function <em>dev_ioctl()</em>,
if implemented. No memory allocation or verification is carried out.</p>
</div>
</div>
<div class="section" id="how-to-update-your-driver">
<h2>How to update your driver<a class="headerlink" href="#how-to-update-your-driver" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Make a backup of your current driver.</p></li>
<li><p>Get hold of the files <cite>cdrom.c</cite> and <cite>cdrom.h</cite>, they should be in
the directory tree that came with this documentation.</p></li>
<li><p>Make sure you include <cite>cdrom.h</cite>.</p></li>
<li><p>Change the 3rd argument of <em>register_blkdev</em> from <cite>&amp;&lt;your-drive&gt;_fops</cite>
to <cite>&amp;cdrom_fops</cite>.</p></li>
<li><p>Just after that line, add the following to register with the Uniform
CD-ROM Driver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>register_cdrom(&amp;&lt;your-drive&gt;_info);*
</pre></div>
</div>
<p>Similarly, add a call to <em>unregister_cdrom()</em> at the appropriate place.</p>
</li>
<li><p>Copy an example of the device-operations <em>struct</em> to your
source, e. g., from <cite>cm206.c</cite> <em>cm206_dops</em>, and change all
entries to names corresponding to your driver, or names you just
happen to like. If your driver doesn’t support a certain function,
make the entry <em>NULL</em>. At the entry <em>capability</em> you should list all
capabilities your driver currently supports. If your driver
has a capability that is not listed, please send me a message.</p></li>
<li><p>Copy the <em>cdrom_device_info</em> declaration from the same example
driver, and modify the entries according to your needs. If your
driver dynamically determines the capabilities of the hardware, this
structure should also be declared dynamically.</p></li>
<li><p>Implement all functions in your <cite>&lt;device&gt;_dops</cite> structure,
according to prototypes listed in  <cite>cdrom.h</cite>, and specifications given
in <a class="reference internal" href="#cdrom-api">cdrom_api</a>. Most likely you have already implemented
the code in a large part, and you will almost certainly need to adapt the
prototype and return values.</p></li>
<li><p>Rename your <cite>&lt;device&gt;_ioctl()</cite> function to <em>audio_ioctl</em> and
change the prototype a little. Remove entries listed in the first
part in <a class="reference internal" href="#cdrom-ioctl">cdrom_ioctl</a>, if your code was OK, these are
just calls to the routines you adapted in the previous step.</p></li>
<li><p>You may remove all remaining memory checking code in the
<em>audio_ioctl()</em> function that deals with audio commands (these are
listed in the second part of <a class="reference internal" href="#cdrom-ioctl">cdrom_ioctl</a>. There is no
need for memory allocation either, so most <em>case*s in the *switch</em>
statement look similar to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>case CDROMREADTOCENTRY:
        get_toc_entry\bigl((struct cdrom_tocentry *) arg);
</pre></div>
</div>
</li>
<li><p>All remaining <em>ioctl</em> cases must be moved to a separate
function, <em>&lt;device&gt;_ioctl</em>, the device-dependent <em>ioctl()’s</em>. Note that
memory checking and allocation must be kept in this code!</p></li>
<li><p>Change the prototypes of <em>&lt;device&gt;_open()</em> and
<em>&lt;device&gt;_release()</em>, and remove any strategic code (i. e., tray
movement, door locking, etc.).</p></li>
<li><p>Try to recompile the drivers. We advise you to use modules, both
for <cite>cdrom.o</cite> and your driver, as debugging is much easier this
way.</p></li>
</ul>
</div>
<div class="section" id="thanks">
<h2>Thanks<a class="headerlink" href="#thanks" title="Permalink to this headline">¶</a></h2>
<p>Thanks to all the people involved. First, Erik Andersen, who has
taken over the torch in maintaining <cite>cdrom.c</cite> and integrating much
CD-ROM-related code in the 2.1-kernel. Thanks to Scott Snyder and
Gerd Knorr, who were the first to implement this interface for SCSI
and IDE-CD drivers and added many ideas for extension of the data
structures relative to kernel~2.0. Further thanks to Heiko Eißfeldt,
Thomas Quinot, Jon Tombs, Ken Pizzini, Eberhard Mönkeberg and Andrew Kroll,
the Linux CD-ROM device driver developers who were kind
enough to give suggestions and criticisms during the writing. Finally
of course, I want to thank Linus Torvalds for making this possible in
the first place.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ide-cd.html" class="btn btn-neutral float-right" title="IDE-CD driver documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="cdrom" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>