

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Unevictable LRU Infrastructure &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="z3fold" href="z3fold.html" />
    <link rel="prev" title="Transparent Hugepage Support" href="transhuge.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Memory Management Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#user-guides-for-mm-features">User guides for MM features</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#kernel-developers-mm-documentation">Kernel developers MM documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="active_mm.html">Active MM</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html">Architecture Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html#pte-page-table-helpers">PTE Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html#pmd-page-table-helpers">PMD Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html#pud-page-table-helpers">PUD Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html#hugetlb-page-table-helpers">HugeTLB Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="arch_pgtable_helpers.html#swap-page-table-helpers">SWAP Page Table Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="balance.html">Memory Balancing</a></li>
<li class="toctree-l3"><a class="reference internal" href="cleancache.html">Cleancache</a></li>
<li class="toctree-l3"><a class="reference internal" href="free_page_reporting.html">Free Page Reporting</a></li>
<li class="toctree-l3"><a class="reference internal" href="frontswap.html">Frontswap</a></li>
<li class="toctree-l3"><a class="reference internal" href="highmem.html">High Memory Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="hmm.html">Heterogeneous Memory Management (HMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hwpoison.html">hwpoison</a></li>
<li class="toctree-l3"><a class="reference internal" href="hugetlbfs_reserv.html">Hugetlbfs Reservation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-model.html">Physical Memory Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmu_notifier.html">When do you need to notify inside page table lock ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="numa.html">What is NUMA?</a></li>
<li class="toctree-l3"><a class="reference internal" href="overcommit-accounting.html">Overcommit Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_migration.html">Page migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_frags.html">Page fragments</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_owner.html">page owner: Tracking about who allocated each page</a></li>
<li class="toctree-l3"><a class="reference internal" href="remap_file_pages.html">remap_file_pages() system call</a></li>
<li class="toctree-l3"><a class="reference internal" href="slub.html">Short users guide for SLUB</a></li>
<li class="toctree-l3"><a class="reference internal" href="split_page_table_lock.html">Split page table lock</a></li>
<li class="toctree-l3"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Unevictable LRU Infrastructure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-unevictable-lru">The Unevictable LRU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlocked-pages">MLOCKED Pages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="z3fold.html">z3fold</a></li>
<li class="toctree-l3"><a class="reference internal" href="zsmalloc.html">zsmalloc</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux Memory Management Documentation</a> &raquo;</li>
        
      <li>Unevictable LRU Infrastructure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/unevictable-lru.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="unevictable-lru-infrastructure">
<span id="unevictable-lru"></span><h1>Unevictable LRU Infrastructure<a class="headerlink" href="#unevictable-lru-infrastructure" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-unevictable-lru" id="id2">The Unevictable LRU</a></p>
<ul>
<li><p><a class="reference internal" href="#the-unevictable-page-list" id="id3">The Unevictable Page List</a></p></li>
<li><p><a class="reference internal" href="#memory-control-group-interaction" id="id4">Memory Control Group Interaction</a></p></li>
<li><p><a class="reference internal" href="#marking-address-spaces-unevictable" id="id5">Marking Address Spaces Unevictable</a></p></li>
<li><p><a class="reference internal" href="#detecting-unevictable-pages" id="id6">Detecting Unevictable Pages</a></p></li>
<li><p><a class="reference internal" href="#vmscan-s-handling-of-unevictable-pages" id="id7">Vmscan’s Handling of Unevictable Pages</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mlocked-pages" id="id8">MLOCKED Pages</a></p>
<ul>
<li><p><a class="reference internal" href="#history" id="id9">History</a></p></li>
<li><p><a class="reference internal" href="#basic-management" id="id10">Basic Management</a></p></li>
<li><p><a class="reference internal" href="#mlock-mlockall-system-call-handling" id="id11">mlock()/mlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#filtering-special-vmas" id="id12">Filtering Special VMAs</a></p></li>
<li><p><a class="reference internal" href="#munlock-munlockall-system-call-handling" id="id13">munlock()/munlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#migrating-mlocked-pages" id="id14">Migrating MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#compacting-mlocked-pages" id="id15">Compacting MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#mlocking-transparent-huge-pages" id="id16">MLOCKING Transparent Huge Pages</a></p></li>
<li><p><a class="reference internal" href="#mmap-map-locked-system-call-handling" id="id17">mmap(MAP_LOCKED) System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#munmap-exit-exec-system-call-handling" id="id18">munmap()/exit()/exec() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#try-to-unmap" id="id19">try_to_unmap()</a></p></li>
<li><p><a class="reference internal" href="#try-to-munlock-reverse-map-scan" id="id20">try_to_munlock() Reverse Map Scan</a></p></li>
<li><p><a class="reference internal" href="#page-reclaim-in-shrink-list" id="id21">Page Reclaim in shrink_*_list()</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the Linux memory manager’s “Unevictable LRU”
infrastructure and the use of this to manage several types of “unevictable”
pages.</p>
<p>The document attempts to provide the overall rationale behind this mechanism
and the rationale for some of the design decisions that drove the
implementation.  The latter design rationale is discussed in the context of an
implementation description.  Admittedly, one can obtain the implementation
details - the “what does it do?” - by reading the code.  One hopes that the
descriptions below add value by provide the answer to “why does it do that?”.</p>
</div>
<div class="section" id="the-unevictable-lru">
<h2><a class="toc-backref" href="#id2">The Unevictable LRU</a><a class="headerlink" href="#the-unevictable-lru" title="Permalink to this headline">¶</a></h2>
<p>The Unevictable LRU facility adds an additional LRU list to track unevictable
pages and to hide these pages from vmscan.  This mechanism is based on a patch
by Larry Woodman of Red Hat to address several scalability problems with page
reclaim in Linux.  The problems have been observed at customer sites on large
memory x86_64 systems.</p>
<p>To illustrate this with an example, a non-NUMA x86_64 platform with 128GB of
main memory will have over 32 million 4k pages in a single zone.  When a large
fraction of these pages are not evictable for any reason [see below], vmscan
will spend a lot of time scanning the LRU lists looking for the small fraction
of pages that are evictable.  This can result in a situation where all CPUs are
spending 100% of their time in vmscan for hours or days on end, with the system
completely unresponsive.</p>
<p>The unevictable list addresses the following classes of unevictable pages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Those owned by ramfs.</p></li>
<li><p>Those mapped into SHM_LOCK’d shared memory regions.</p></li>
<li><p>Those mapped into VM_LOCKED [mlock()ed] VMAs.</p></li>
</ul>
</div></blockquote>
<p>The infrastructure may also be able to handle other conditions that make pages
unevictable, either by definition or by circumstance, in the future.</p>
<div class="section" id="the-unevictable-page-list">
<h3><a class="toc-backref" href="#id3">The Unevictable Page List</a><a class="headerlink" href="#the-unevictable-page-list" title="Permalink to this headline">¶</a></h3>
<p>The Unevictable LRU infrastructure consists of an additional, per-zone, LRU list
called the “unevictable” list and an associated page flag, PG_unevictable, to
indicate that the page is being managed on the unevictable list.</p>
<p>The PG_unevictable flag is analogous to, and mutually exclusive with, the
PG_active flag in that it indicates on which LRU list a page resides when
PG_lru is set.</p>
<p>The Unevictable LRU infrastructure maintains unevictable pages on an additional
LRU list for a few reasons:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>We get to “treat unevictable pages just like we treat other pages in the
system - which means we get to use the same code to manipulate them, the
same code to isolate them (for migrate, etc.), the same code to keep track
of the statistics, etc…” [Rik van Riel]</p></li>
<li><p>We want to be able to migrate unevictable pages between nodes for memory
defragmentation, workload management and memory hotplug.  The linux kernel
can only migrate pages that it can successfully isolate from the LRU
lists.  If we were to maintain pages elsewhere than on an LRU-like list,
where they can be found by isolate_lru_page(), we would prevent their
migration, unless we reworked migration code to find the unevictable pages
itself.</p></li>
</ol>
</div></blockquote>
<p>The unevictable list does not differentiate between file-backed and anonymous,
swap-backed pages.  This differentiation is only important while the pages are,
in fact, evictable.</p>
<p>The unevictable list benefits from the “arrayification” of the per-zone LRU
lists and statistics originally proposed and posted by Christoph Lameter.</p>
<p>The unevictable list does not use the LRU pagevec mechanism. Rather,
unevictable pages are placed directly on the page’s zone’s unevictable list
under the zone lru_lock.  This allows us to prevent the stranding of pages on
the unevictable list when one task has the page isolated from the LRU and other
tasks are changing the “evictability” state of the page.</p>
</div>
<div class="section" id="memory-control-group-interaction">
<h3><a class="toc-backref" href="#id4">Memory Control Group Interaction</a><a class="headerlink" href="#memory-control-group-interaction" title="Permalink to this headline">¶</a></h3>
<p>The unevictable LRU facility interacts with the memory control group [aka
memory controller; see <a class="reference internal" href="../admin-guide/cgroup-v1/memory.html"><span class="doc">Memory Resource Controller</span></a>] by extending the
lru_list enum.</p>
<p>The memory controller data structure automatically gets a per-zone unevictable
list as a result of the “arrayification” of the per-zone LRU lists (one per
lru_list enum element).  The memory controller tracks the movement of pages to
and from the unevictable list.</p>
<p>When a memory control group comes under memory pressure, the controller will
not attempt to reclaim pages on the unevictable list.  This has a couple of
effects:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Because the pages are “hidden” from reclaim on the unevictable list, the
reclaim process can be more efficient, dealing only with pages that have a
chance of being reclaimed.</p></li>
<li><p>On the other hand, if too many of the pages charged to the control group
are unevictable, the evictable portion of the working set of the tasks in
the control group may not fit into the available memory.  This can cause
the control group to thrash or to OOM-kill tasks.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="marking-address-spaces-unevictable">
<span id="mark-addr-space-unevict"></span><h3><a class="toc-backref" href="#id5">Marking Address Spaces Unevictable</a><a class="headerlink" href="#marking-address-spaces-unevictable" title="Permalink to this headline">¶</a></h3>
<p>For facilities such as ramfs none of the pages attached to the address space
may be evicted.  To prevent eviction of any such pages, the AS_UNEVICTABLE
address space flag is provided, and this can be manipulated by a filesystem
using a number of wrapper functions:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_set_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being completely unevictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_clear_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being evictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mapping_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Query the address space, and return true if it is completely
unevictable.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>These are currently used in three places in the kernel:</p>
<blockquote>
<div><ol class="arabic">
<li><p>By ramfs to mark the address spaces of its inodes when they are created,
and this mark remains for the life of the inode.</p></li>
<li><p>By SYSV SHM to mark SHM_LOCK’d address spaces until SHM_UNLOCK is called.</p>
<p>Note that SHM_LOCK is not required to page in the locked pages if they’re
swapped out; the application must touch the pages manually if it wants to
ensure they’re in memory.</p>
</li>
<li><p>By the i915 driver to mark pinned address space until it’s unpinned. The
amount of unevictable memory marked by i915 driver is roughly the bounded
object size in debugfs/dri/0/i915_gem_objects.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="detecting-unevictable-pages">
<h3><a class="toc-backref" href="#id6">Detecting Unevictable Pages</a><a class="headerlink" href="#detecting-unevictable-pages" title="Permalink to this headline">¶</a></h3>
<p>The function page_evictable() in vmscan.c determines whether a page is
evictable or not using the query function outlined above [see section
<a class="reference internal" href="#mark-addr-space-unevict"><span class="std std-ref">Marking address spaces unevictable</span></a>]
to check the AS_UNEVICTABLE flag.</p>
<p>For address spaces that are so marked after being populated (as SHM regions
might be), the lock action (eg: SHM_LOCK) can be lazy, and need not populate
the page tables for the region as does, for example, mlock(), nor need it make
any special effort to push any pages in the SHM_LOCK’d area to the unevictable
list.  Instead, vmscan will do this if and when it encounters the pages during
a reclamation scan.</p>
<p>On an unlock action (such as SHM_UNLOCK), the unlocker (eg: shmctl()) must scan
the pages in the region and “rescue” them from the unevictable list if no other
condition is keeping them unevictable.  If an unevictable region is destroyed,
the pages are also “rescued” from the unevictable list in the process of
freeing them.</p>
<p>page_evictable() also checks for mlocked pages by testing an additional page
flag, PG_mlocked (as wrapped by PageMlocked()), which is set when a page is
faulted into a VM_LOCKED vma, or found in a vma being VM_LOCKED.</p>
</div>
<div class="section" id="vmscan-s-handling-of-unevictable-pages">
<h3><a class="toc-backref" href="#id7">Vmscan’s Handling of Unevictable Pages</a><a class="headerlink" href="#vmscan-s-handling-of-unevictable-pages" title="Permalink to this headline">¶</a></h3>
<p>If unevictable pages are culled in the fault path, or moved to the unevictable
list at mlock() or mmap() time, vmscan will not encounter the pages until they
have become evictable again (via munlock() for example) and have been “rescued”
from the unevictable list.  However, there may be situations where we decide,
for the sake of expediency, to leave a unevictable page on one of the regular
active/inactive LRU lists for vmscan to deal with.  vmscan checks for such
pages in all of the shrink_{active|inactive|page}_list() functions and will
“cull” such pages that it encounters: that is, it diverts those pages to the
unevictable list for the zone being scanned.</p>
<p>There may be situations where a page is mapped into a VM_LOCKED VMA, but the
page is not marked as PG_mlocked.  Such pages will make it all the way to
shrink_page_list() where they will be detected when vmscan walks the reverse
map in try_to_unmap().  If try_to_unmap() returns SWAP_MLOCK,
shrink_page_list() will cull the page at that point.</p>
<p>To “cull” an unevictable page, vmscan simply puts the page back on the LRU list
using putback_lru_page() - the inverse operation to isolate_lru_page() - after
dropping the page lock.  Because the condition which makes the page unevictable
may change once the page is unlocked, putback_lru_page() will recheck the
unevictable state of a page that it places on the unevictable list.  If the
page has become unevictable, putback_lru_page() removes it from the list and
retries, including the page_unevictable() test.  Because such a race is a rare
event and movement of pages onto the unevictable list should be rare, these
extra evictabilty checks should not occur in the majority of calls to
putback_lru_page().</p>
</div>
</div>
<div class="section" id="mlocked-pages">
<h2><a class="toc-backref" href="#id8">MLOCKED Pages</a><a class="headerlink" href="#mlocked-pages" title="Permalink to this headline">¶</a></h2>
<p>The unevictable page list is also useful for mlock(), in addition to ramfs and
SYSV SHM.  Note that mlock() is only available in CONFIG_MMU=y situations; in
NOMMU situations, all mappings are effectively mlocked.</p>
<div class="section" id="history">
<h3><a class="toc-backref" href="#id9">History</a><a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h3>
<p>The “Unevictable mlocked Pages” infrastructure is based on work originally
posted by Nick Piggin in an RFC patch entitled “mm: mlocked pages off LRU”.
Nick posted his patch as an alternative to a patch posted by Christoph Lameter
to achieve the same objective: hiding mlocked pages from vmscan.</p>
<p>In Nick’s patch, he used one of the struct page LRU list link fields as a count
of VM_LOCKED VMAs that map the page.  This use of the link field for a count
prevented the management of the pages on an LRU list, and thus mlocked pages
were not migratable as isolate_lru_page() could not find them, and the LRU list
link field was not available to the migration subsystem.</p>
<p>Nick resolved this by putting mlocked pages back on the lru list before
attempting to isolate them, thus abandoning the count of VM_LOCKED VMAs.  When
Nick’s patch was integrated with the Unevictable LRU work, the count was
replaced by walking the reverse map to determine whether any VM_LOCKED VMAs
mapped the page.  More on this below.</p>
</div>
<div class="section" id="basic-management">
<h3><a class="toc-backref" href="#id10">Basic Management</a><a class="headerlink" href="#basic-management" title="Permalink to this headline">¶</a></h3>
<p>mlocked pages - pages mapped into a VM_LOCKED VMA - are a class of unevictable
pages.  When such a page has been “noticed” by the memory management subsystem,
the page is marked with the PG_mlocked flag.  This can be manipulated using the
PageMlocked() functions.</p>
<p>A PG_mlocked page will be placed on the unevictable list when it is added to
the LRU.  Such pages can be “noticed” by memory management in several places:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>in the mlock()/mlockall() system call handlers;</p></li>
<li><p>in the mmap() system call handler when mmapping a region with the
MAP_LOCKED flag;</p></li>
<li><p>mmapping a region in a task that has called mlockall() with the MCL_FUTURE
flag</p></li>
<li><p>in the fault path, if mlocked pages are “culled” in the fault path,
and when a VM_LOCKED stack segment is expanded; or</p></li>
<li><p>as mentioned above, in vmscan:shrink_page_list() when attempting to
reclaim a page in a VM_LOCKED VMA via try_to_unmap()</p></li>
</ol>
</div></blockquote>
<p>all of which result in the VM_LOCKED flag being set for the VMA if it doesn’t
already have it set.</p>
<p>mlocked pages become unlocked and rescued from the unevictable list when:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>mapped in a range unlocked via the munlock()/munlockall() system calls;</p></li>
<li><p>munmap()’d out of the last VM_LOCKED VMA that maps the page, including
unmapping at task exit;</p></li>
<li><p>when the page is truncated from the last VM_LOCKED VMA of an mmapped file;
or</p></li>
<li><p>before a page is COW’d in a VM_LOCKED VMA.</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mlock-mlockall-system-call-handling">
<h3><a class="toc-backref" href="#id11">mlock()/mlockall() System Call Handling</a><a class="headerlink" href="#mlock-mlockall-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>Both [do_]mlock() and [do_]mlockall() system call handlers call mlock_fixup()
for each VMA in the range specified by the call.  In the case of mlockall(),
this is the entire active address space of the task.  Note that mlock_fixup()
is used for both mlocking and munlocking a range of memory.  A call to mlock()
an already VM_LOCKED VMA, or to munlock() a VMA that is not VM_LOCKED is
treated as a no-op, and mlock_fixup() simply returns.</p>
<p>If the VMA passes some filtering as described in “Filtering Special Vmas”
below, mlock_fixup() will attempt to merge the VMA with its neighbors or split
off a subset of the VMA if the range does not cover the entire VMA.  Once the
VMA has been merged or split or neither, mlock_fixup() will call
populate_vma_page_range() to fault in the pages via get_user_pages() and to
mark the pages as mlocked via mlock_vma_page().</p>
<p>Note that the VMA being mlocked might be mapped with PROT_NONE.  In this case,
get_user_pages() will be unable to fault in the pages.  That’s okay.  If pages
do end up getting faulted into this VM_LOCKED VMA, we’ll handle them in the
fault path or in vmscan.</p>
<p>Also note that a page returned by get_user_pages() could be truncated or
migrated out from under us, while we’re trying to mlock it.  To detect this,
populate_vma_page_range() checks page_mapping() after acquiring the page lock.
If the page is still associated with its mapping, we’ll go ahead and call
mlock_vma_page().  If the mapping is gone, we just unlock the page and move on.
In the worst case, this will result in a page mapped in a VM_LOCKED VMA
remaining on a normal LRU list without being PageMlocked().  Again, vmscan will
detect and cull such pages.</p>
<p>mlock_vma_page() will call TestSetPageMlocked() for each page returned by
get_user_pages().  We use TestSetPageMlocked() because the page might already
be mlocked by another task/VMA and we don’t want to do extra work.  We
especially do not want to count an mlocked page more than once in the
statistics.  If the page was already mlocked, mlock_vma_page() need do nothing
more.</p>
<p>If the page was NOT already mlocked, mlock_vma_page() attempts to isolate the
page from the LRU, as it is likely on the appropriate active or inactive list
at that time.  If the isolate_lru_page() succeeds, mlock_vma_page() will put
back the page - by calling putback_lru_page() - which will notice that the page
is now mlocked and divert the page to the zone’s unevictable list.  If
mlock_vma_page() is unable to isolate the page from the LRU, vmscan will handle
it later if and when it attempts to reclaim the page.</p>
</div>
<div class="section" id="filtering-special-vmas">
<h3><a class="toc-backref" href="#id12">Filtering Special VMAs</a><a class="headerlink" href="#filtering-special-vmas" title="Permalink to this headline">¶</a></h3>
<p>mlock_fixup() filters several classes of “special” VMAs:</p>
<ol class="arabic simple">
<li><p>VMAs with VM_IO or VM_PFNMAP set are skipped entirely.  The pages behind
these mappings are inherently pinned, so we don’t need to mark them as
mlocked.  In any case, most of the pages have no struct page in which to so
mark the page.  Because of this, get_user_pages() will fail for these VMAs,
so there is no sense in attempting to visit them.</p></li>
<li><p>VMAs mapping hugetlbfs page are already effectively pinned into memory.  We
neither need nor want to mlock() these pages.  However, to preserve the
prior behavior of mlock() - before the unevictable/mlock changes -
mlock_fixup() will call make_pages_present() in the hugetlbfs VMA range to
allocate the huge pages and populate the ptes.</p></li>
<li><p>VMAs with VM_DONTEXPAND are generally userspace mappings of kernel pages,
such as the VDSO page, relay channel pages, etc. These pages
are inherently unevictable and are not managed on the LRU lists.
mlock_fixup() treats these VMAs the same as hugetlbfs VMAs.  It calls
make_pages_present() to populate the ptes.</p></li>
</ol>
<p>Note that for all of these special VMAs, mlock_fixup() does not set the
VM_LOCKED flag.  Therefore, we won’t have to deal with them later during
munlock(), munmap() or task exit.  Neither does mlock_fixup() account these
VMAs against the task’s “locked_vm”.</p>
</div>
<div class="section" id="munlock-munlockall-system-call-handling">
<span id="munlock-munlockall-handling"></span><h3><a class="toc-backref" href="#id13">munlock()/munlockall() System Call Handling</a><a class="headerlink" href="#munlock-munlockall-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>The munlock() and munlockall() system calls are handled by the same functions -
do_mlock[all]() - as the mlock() and mlockall() system calls with the unlock vs
lock operation indicated by an argument.  So, these system calls are also
handled by mlock_fixup().  Again, if called for an already munlocked VMA,
mlock_fixup() simply returns.  Because of the VMA filtering discussed above,
VM_LOCKED will not be set in any “special” VMAs.  So, these VMAs will be
ignored for munlock.</p>
<p>If the VMA is VM_LOCKED, mlock_fixup() again attempts to merge or split off the
specified range.  The range is then munlocked via the function
populate_vma_page_range() - the same function used to mlock a VMA range -
passing a flag to indicate that munlock() is being performed.</p>
<p>Because the VMA access protections could have been changed to PROT_NONE after
faulting in and mlocking pages, get_user_pages() was unreliable for visiting
these pages for munlocking.  Because we don’t want to leave pages mlocked,
get_user_pages() was enhanced to accept a flag to ignore the permissions when
fetching the pages - all of which should be resident as a result of previous
mlocking.</p>
<p>For munlock(), populate_vma_page_range() unlocks individual pages by calling
munlock_vma_page().  munlock_vma_page() unconditionally clears the PG_mlocked
flag using TestClearPageMlocked().  As with mlock_vma_page(),
munlock_vma_page() use the Test*PageMlocked() function to handle the case where
the page might have already been unlocked by another task.  If the page was
mlocked, munlock_vma_page() updates that zone statistics for the number of
mlocked pages.  Note, however, that at this point we haven’t checked whether
the page is mapped by other VM_LOCKED VMAs.</p>
<p>We can’t call try_to_munlock(), the function that walks the reverse map to
check for other VM_LOCKED VMAs, without first isolating the page from the LRU.
try_to_munlock() is a variant of try_to_unmap() and thus requires that the page
not be on an LRU list [more on these below].  However, the call to
isolate_lru_page() could fail, in which case we couldn’t try_to_munlock().  So,
we go ahead and clear PG_mlocked up front, as this might be the only chance we
have.  If we can successfully isolate the page, we go ahead and
try_to_munlock(), which will restore the PG_mlocked flag and update the zone
page statistics if it finds another VMA holding the page mlocked.  If we fail
to isolate the page, we’ll have left a potentially mlocked page on the LRU.
This is fine, because we’ll catch it later if and if vmscan tries to reclaim
the page.  This should be relatively rare.</p>
</div>
<div class="section" id="migrating-mlocked-pages">
<h3><a class="toc-backref" href="#id14">Migrating MLOCKED Pages</a><a class="headerlink" href="#migrating-mlocked-pages" title="Permalink to this headline">¶</a></h3>
<p>A page that is being migrated has been isolated from the LRU lists and is held
locked across unmapping of the page, updating the page’s address space entry
and copying the contents and state, until the page table entry has been
replaced with an entry that refers to the new page.  Linux supports migration
of mlocked pages and other unevictable pages.  This involves simply moving the
PG_mlocked and PG_unevictable states from the old page to the new page.</p>
<p>Note that page migration can race with mlocking or munlocking of the same page.
This has been discussed from the mlock/munlock perspective in the respective
sections above.  Both processes (migration and m[un]locking) hold the page
locked.  This provides the first level of synchronization.  Page migration
zeros out the page_mapping of the old page before unlocking it, so m[un]lock
can skip these pages by testing the page mapping under page lock.</p>
<p>To complete page migration, we place the new and old pages back onto the LRU
after dropping the page lock.  The “unneeded” page - old page on success, new
page on failure - will be freed when the reference count held by the migration
process is released.  To ensure that we don’t strand pages on the unevictable
list because of a race between munlock and migration, page migration uses the
putback_lru_page() function to add migrated pages back to the LRU.</p>
</div>
<div class="section" id="compacting-mlocked-pages">
<h3><a class="toc-backref" href="#id15">Compacting MLOCKED Pages</a><a class="headerlink" href="#compacting-mlocked-pages" title="Permalink to this headline">¶</a></h3>
<p>The unevictable LRU can be scanned for compactable regions and the default
behavior is to do so.  /proc/sys/vm/compact_unevictable_allowed controls
this behavior (see <a class="reference internal" href="../admin-guide/sysctl/vm.html"><span class="doc">Documentation for /proc/sys/vm/</span></a>).  Once scanning of the
unevictable LRU is enabled, the work of compaction is mostly handled by
the page migration code and the same work flow as described in MIGRATING
MLOCKED PAGES will apply.</p>
</div>
<div class="section" id="mlocking-transparent-huge-pages">
<h3><a class="toc-backref" href="#id16">MLOCKING Transparent Huge Pages</a><a class="headerlink" href="#mlocking-transparent-huge-pages" title="Permalink to this headline">¶</a></h3>
<p>A transparent huge page is represented by a single entry on an LRU list.
Therefore, we can only make unevictable an entire compound page, not
individual subpages.</p>
<p>If a user tries to mlock() part of a huge page, we want the rest of the
page to be reclaimable.</p>
<p>We cannot just split the page on partial mlock() as split_huge_page() can
fail and new intermittent failure mode for the syscall is undesirable.</p>
<p>We handle this by keeping PTE-mapped huge pages on normal LRU lists: the
PMD on border of VM_LOCKED VMA will be split into PTE table.</p>
<p>This way the huge page is accessible for vmscan. Under memory pressure the
page will be split, subpages which belong to VM_LOCKED VMAs will be moved
to unevictable LRU and the rest can be reclaimed.</p>
<p>See also comment in follow_trans_huge_pmd().</p>
</div>
<div class="section" id="mmap-map-locked-system-call-handling">
<h3><a class="toc-backref" href="#id17">mmap(MAP_LOCKED) System Call Handling</a><a class="headerlink" href="#mmap-map-locked-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>In addition the mlock()/mlockall() system calls, an application can request
that a region of memory be mlocked supplying the MAP_LOCKED flag to the mmap()
call. There is one important and subtle difference here, though. mmap() + mlock()
will fail if the range cannot be faulted in (e.g. because mm_populate fails)
and returns with ENOMEM while mmap(MAP_LOCKED) will not fail. The mmaped
area will still have properties of the locked area - aka. pages will not get
swapped out - but major page faults to fault memory in might still happen.</p>
<p>Furthermore, any mmap() call or brk() call that expands the heap by a
task that has previously called mlockall() with the MCL_FUTURE flag will result
in the newly mapped memory being mlocked.  Before the unevictable/mlock
changes, the kernel simply called make_pages_present() to allocate pages and
populate the page table.</p>
<p>To mlock a range of memory under the unevictable/mlock infrastructure, the
mmap() handler and task address space expansion functions call
populate_vma_page_range() specifying the vma and the address range to mlock.</p>
<p>The callers of populate_vma_page_range() will have already added the memory range
to be mlocked to the task’s “locked_vm”.  To account for filtered VMAs,
populate_vma_page_range() returns the number of pages NOT mlocked.  All of the
callers then subtract a non-negative return value from the task’s locked_vm.  A
negative return value represent an error - for example, from get_user_pages()
attempting to fault in a VMA with PROT_NONE access.  In this case, we leave the
memory range accounted as locked_vm, as the protections could be changed later
and pages allocated into that region.</p>
</div>
<div class="section" id="munmap-exit-exec-system-call-handling">
<h3><a class="toc-backref" href="#id18">munmap()/exit()/exec() System Call Handling</a><a class="headerlink" href="#munmap-exit-exec-system-call-handling" title="Permalink to this headline">¶</a></h3>
<p>When unmapping an mlocked region of memory, whether by an explicit call to
munmap() or via an internal unmap from exit() or exec() processing, we must
munlock the pages if we’re removing the last VM_LOCKED VMA that maps the pages.
Before the unevictable/mlock changes, mlocking did not mark the pages in any
way, so unmapping them required no processing.</p>
<p>To munlock a range of memory under the unevictable/mlock infrastructure, the
munmap() handler and task address space call tear down function
munlock_vma_pages_all().  The name reflects the observation that one always
specifies the entire VMA range when munlock()ing during unmap of a region.
Because of the VMA filtering when mlocking() regions, only “normal” VMAs that
actually contain mlocked pages will be passed to munlock_vma_pages_all().</p>
<p>munlock_vma_pages_all() clears the VM_LOCKED VMA flag and, like mlock_fixup()
for the munlock case, calls __munlock_vma_pages_range() to walk the page table
for the VMA’s memory range and munlock_vma_page() each resident page mapped by
the VMA.  This effectively munlocks the page, only if this is the last
VM_LOCKED VMA that maps the page.</p>
</div>
<div class="section" id="try-to-unmap">
<h3><a class="toc-backref" href="#id19">try_to_unmap()</a><a class="headerlink" href="#try-to-unmap" title="Permalink to this headline">¶</a></h3>
<p>Pages can, of course, be mapped into multiple VMAs.  Some of these VMAs may
have VM_LOCKED flag set.  It is possible for a page mapped into one or more
VM_LOCKED VMAs not to have the PG_mlocked flag set and therefore reside on one
of the active or inactive LRU lists.  This could happen if, for example, a task
in the process of munlocking the page could not isolate the page from the LRU.
As a result, vmscan/shrink_page_list() might encounter such a page as described
in section “vmscan’s handling of unevictable pages”.  To handle this situation,
try_to_unmap() checks for VM_LOCKED VMAs while it is walking a page’s reverse
map.</p>
<p>try_to_unmap() is always called, by either vmscan for reclaim or for page
migration, with the argument page locked and isolated from the LRU.  Separate
functions handle anonymous and mapped file and KSM pages, as these types of
pages have different reverse map lookup mechanisms, with different locking.
In each case, whether rmap_walk_anon() or rmap_walk_file() or rmap_walk_ksm(),
it will call try_to_unmap_one() for every VMA which might contain the page.</p>
<p>When trying to reclaim, if try_to_unmap_one() finds the page in a VM_LOCKED
VMA, it will then mlock the page via mlock_vma_page() instead of unmapping it,
and return SWAP_MLOCK to indicate that the page is unevictable: and the scan
stops there.</p>
<p>mlock_vma_page() is called while holding the page table’s lock (in addition
to the page lock, and the rmap lock): to serialize against concurrent mlock or
munlock or munmap system calls, mm teardown (munlock_vma_pages_all), reclaim,
holepunching, and truncation of file pages and their anonymous COWed pages.</p>
</div>
<div class="section" id="try-to-munlock-reverse-map-scan">
<h3><a class="toc-backref" href="#id20">try_to_munlock() Reverse Map Scan</a><a class="headerlink" href="#try-to-munlock-reverse-map-scan" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>[!] TODO/FIXME: a better name might be page_mlocked() - analogous to the
page_referenced() reverse map walker.</p>
</div>
<p>When munlock_vma_page() [see section <a class="reference internal" href="#munlock-munlockall-handling"><span class="std std-ref">munlock()/munlockall() System Call
Handling</span></a> above] tries to munlock a
page, it needs to determine whether or not the page is mapped by any
VM_LOCKED VMA without actually attempting to unmap all PTEs from the
page.  For this purpose, the unevictable/mlock infrastructure
introduced a variant of try_to_unmap() called try_to_munlock().</p>
<p>try_to_munlock() calls the same functions as try_to_unmap() for anonymous and
mapped file and KSM pages with a flag argument specifying unlock versus unmap
processing.  Again, these functions walk the respective reverse maps looking
for VM_LOCKED VMAs.  When such a VMA is found, as in the try_to_unmap() case,
the functions mlock the page via mlock_vma_page() and return SWAP_MLOCK.  This
undoes the pre-clearing of the page’s PG_mlocked done by munlock_vma_page.</p>
<p>Note that try_to_munlock()’s reverse map walk must visit every VMA in a page’s
reverse map to determine that a page is NOT mapped into any VM_LOCKED VMA.
However, the scan can terminate when it encounters a VM_LOCKED VMA.
Although try_to_munlock() might be called a great many times when munlocking a
large region or tearing down a large address space that has been mlocked via
mlockall(), overall this is a fairly rare event.</p>
</div>
<div class="section" id="page-reclaim-in-shrink-list">
<h3><a class="toc-backref" href="#id21">Page Reclaim in shrink_*_list()</a><a class="headerlink" href="#page-reclaim-in-shrink-list" title="Permalink to this headline">¶</a></h3>
<p>shrink_active_list() culls any obviously unevictable pages - i.e.
!page_evictable(page) - diverting these to the unevictable list.
However, shrink_active_list() only sees unevictable pages that made it onto the
active/inactive lru lists.  Note that these pages do not have PageUnevictable
set - otherwise they would be on the unevictable list and shrink_active_list
would never see them.</p>
<p>Some examples of these unevictable pages on the LRU lists are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>ramfs pages that have been placed on the LRU lists when first allocated.</p></li>
<li><p>SHM_LOCK’d shared memory pages.  shmctl(SHM_LOCK) does not attempt to
allocate or fault in the pages in the shared memory region.  This happens
when an application accesses the page the first time after SHM_LOCK’ing
the segment.</p></li>
<li><p>mlocked pages that could not be isolated from the LRU and moved to the
unevictable list in mlock_vma_page().</p></li>
</ol>
</div></blockquote>
<p>shrink_inactive_list() also diverts any unevictable pages that it finds on the
inactive lists to the appropriate zone’s unevictable list.</p>
<p>shrink_inactive_list() should only see SHM_LOCK’d pages that became SHM_LOCK’d
after shrink_active_list() had moved them to the inactive list, or pages mapped
into VM_LOCKED VMAs that munlock_vma_page() couldn’t isolate from the LRU to
recheck via try_to_munlock().  shrink_inactive_list() won’t notice the latter,
but will pass on to shrink_page_list().</p>
<p>shrink_page_list() again culls obviously unevictable pages that it could
encounter for similar reason to shrink_inactive_list().  Pages mapped into
VM_LOCKED VMAs but without PG_mlocked set will make it all the way to
try_to_unmap().  shrink_page_list() will divert them to the unevictable list
when try_to_unmap() returns SWAP_MLOCK, as discussed above.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="z3fold.html" class="btn btn-neutral float-right" title="z3fold" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="transhuge.html" class="btn btn-neutral float-left" title="Transparent Hugepage Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>