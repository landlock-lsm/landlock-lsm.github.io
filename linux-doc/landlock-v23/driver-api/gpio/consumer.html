

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GPIO Descriptor Consumer Interface &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="GPIO Mappings" href="board.html" />
    <link rel="prev" title="GPIO Driver Interface" href="driver.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">General Purpose Input/Output (GPIO)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="using-gpio.html">Using GPIO Lines in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver.html">GPIO Driver Interface</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">GPIO Descriptor Consumer Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#guidelines-for-gpios-consumers">Guidelines for GPIOs consumers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#obtaining-and-disposing-gpios">Obtaining and Disposing GPIOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-gpios">Using GPIOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpios-and-acpi">GPIOs and ACPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interacting-with-the-legacy-gpio-subsystem">Interacting With the Legacy GPIO Subsystem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">General Purpose Input/Output (GPIO)</a> &raquo;</li>
        
      <li>GPIO Descriptor Consumer Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/gpio/consumer.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gpio-descriptor-consumer-interface">
<h1>GPIO Descriptor Consumer Interface<a class="headerlink" href="#gpio-descriptor-consumer-interface" title="Permalink to this headline">¶</a></h1>
<p>This document describes the consumer interface of the GPIO framework. Note that
it describes the new descriptor-based interface. For a description of the
deprecated integer-based GPIO interface please refer to gpio-legacy.txt.</p>
<div class="section" id="guidelines-for-gpios-consumers">
<h2>Guidelines for GPIOs consumers<a class="headerlink" href="#guidelines-for-gpios-consumers" title="Permalink to this headline">¶</a></h2>
<p>Drivers that can’t work without standard GPIO calls should have Kconfig entries
that depend on GPIOLIB or select GPIOLIB. The functions that allow a driver to
obtain and use GPIOs are available by including the following file:</p>
<blockquote>
<div><p>#include &lt;linux/gpio/consumer.h&gt;</p>
</div></blockquote>
<p>There are static inline stubs for all functions in the header file in the case
where GPIOLIB is disabled. When these stubs are called they will emit
warnings. These stubs are used for two use cases:</p>
<ul class="simple">
<li><p>Simple compile coverage with e.g. COMPILE_TEST - it does not matter that
the current platform does not enable or select GPIOLIB because we are not
going to execute the system anyway.</p></li>
<li><p>Truly optional GPIOLIB support - where the driver does not really make use
of the GPIOs on certain compile-time configurations for certain systems, but
will use it under other compile-time configurations. In this case the
consumer must make sure not to call into these functions, or the user will
be met with console warnings that may be perceived as intimidating.</p></li>
</ul>
<p>All the functions that work with the descriptor-based GPIO interface are
prefixed with <code class="docutils literal notranslate"><span class="pre">gpiod_</span></code>. The <code class="docutils literal notranslate"><span class="pre">gpio_</span></code> prefix is used for the legacy
interface. No other function in the kernel should use these prefixes. The use
of the legacy functions is strongly discouraged, new code should use
&lt;linux/gpio/consumer.h&gt; and descriptors exclusively.</p>
</div>
<div class="section" id="obtaining-and-disposing-gpios">
<h2>Obtaining and Disposing GPIOs<a class="headerlink" href="#obtaining-and-disposing-gpios" title="Permalink to this headline">¶</a></h2>
<p>With the descriptor-based interface, GPIOs are identified with an opaque,
non-forgeable handler that must be obtained through a call to one of the
<a class="reference internal" href="index.html#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> functions. Like many other kernel subsystems, <a class="reference internal" href="index.html#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> takes the
device that will use the GPIO and the function the requested GPIO is supposed to
fulfill:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_desc *gpiod_get(struct device *dev, const char *con_id,
                            enum gpiod_flags flags)
</pre></div>
</div>
<p>If a function is implemented by using several GPIOs together (e.g. a simple LED
device that displays digits), an additional index argument can be specified:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_desc *gpiod_get_index(struct device *dev,
                                  const char *con_id, unsigned int idx,
                                  enum gpiod_flags flags)
</pre></div>
</div>
<p>For a more detailed description of the con_id parameter in the DeviceTree case
see <a class="reference internal" href="board.html"><span class="doc">GPIO Mappings</span></a></p>
<p>The flags parameter is used to optionally specify a direction and initial value
for the GPIO. Values can be:</p>
<ul class="simple">
<li><p>GPIOD_ASIS or 0 to not initialize the GPIO at all. The direction must be set
later with one of the dedicated functions.</p></li>
<li><p>GPIOD_IN to initialize the GPIO as input.</p></li>
<li><p>GPIOD_OUT_LOW to initialize the GPIO as output with a value of 0.</p></li>
<li><p>GPIOD_OUT_HIGH to initialize the GPIO as output with a value of 1.</p></li>
<li><p>GPIOD_OUT_LOW_OPEN_DRAIN same as GPIOD_OUT_LOW but also enforce the line
to be electrically used with open drain.</p></li>
<li><p>GPIOD_OUT_HIGH_OPEN_DRAIN same as GPIOD_OUT_HIGH but also enforce the line
to be electrically used with open drain.</p></li>
</ul>
<p>The two last flags are used for use cases where open drain is mandatory, such
as I2C: if the line is not already configured as open drain in the mappings
(see board.txt), then open drain will be enforced anyway and a warning will be
printed that the board configuration needs to be updated to match the use case.</p>
<p>Both functions return either a valid GPIO descriptor, or an error code checkable
with IS_ERR() (they will never return a NULL pointer). -ENOENT will be returned
if and only if no GPIO has been assigned to the device/function/index triplet,
other error codes are used for cases where a GPIO has been assigned but an error
occurred while trying to acquire it. This is useful to discriminate between mere
errors and an absence of GPIO for optional GPIO parameters. For the common
pattern where a GPIO is optional, the <a class="reference internal" href="index.html#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a> and
<a class="reference internal" href="index.html#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a> functions can be used. These functions return NULL
instead of -ENOENT if no GPIO has been assigned to the requested function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_desc *gpiod_get_optional(struct device *dev,
                                     const char *con_id,
                                     enum gpiod_flags flags)

struct gpio_desc *gpiod_get_index_optional(struct device *dev,
                                           const char *con_id,
                                           unsigned int index,
                                           enum gpiod_flags flags)
</pre></div>
</div>
<p>Note that gpio_get*_optional() functions (and their managed variants), unlike
the rest of gpiolib API, also return NULL when gpiolib support is disabled.
This is helpful to driver authors, since they do not need to special case
-ENOSYS return codes.  System integrators should however be careful to enable
gpiolib on systems that need it.</p>
<p>For a function using multiple GPIOs all of those can be obtained with one call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_descs *gpiod_get_array(struct device *dev,
                                   const char *con_id,
                                   enum gpiod_flags flags)
</pre></div>
</div>
<p>This function returns a struct gpio_descs which contains an array of
descriptors.  It also contains a pointer to a gpiolib private structure which,
if passed back to get/set array functions, may speed up I/O proocessing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_descs {
        struct gpio_array *info;
        unsigned int ndescs;
        struct gpio_desc *desc[];
}
</pre></div>
</div>
<p>The following function returns NULL instead of -ENOENT if no GPIOs have been
assigned to the requested function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_descs *gpiod_get_array_optional(struct device *dev,
                                            const char *con_id,
                                            enum gpiod_flags flags)
</pre></div>
</div>
<p>Device-managed variants of these functions are also defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id,
                                 enum gpiod_flags flags)

struct gpio_desc *devm_gpiod_get_index(struct device *dev,
                                       const char *con_id,
                                       unsigned int idx,
                                       enum gpiod_flags flags)

struct gpio_desc *devm_gpiod_get_optional(struct device *dev,
                                          const char *con_id,
                                          enum gpiod_flags flags)

struct gpio_desc *devm_gpiod_get_index_optional(struct device *dev,
                                                const char *con_id,
                                                unsigned int index,
                                                enum gpiod_flags flags)

struct gpio_descs *devm_gpiod_get_array(struct device *dev,
                                        const char *con_id,
                                        enum gpiod_flags flags)

struct gpio_descs *devm_gpiod_get_array_optional(struct device *dev,
                                                 const char *con_id,
                                                 enum gpiod_flags flags)
</pre></div>
</div>
<p>A GPIO descriptor can be disposed of using the <a class="reference internal" href="index.html#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void gpiod_put(struct gpio_desc *desc)
</pre></div>
</div>
<p>For an array of GPIOs this function can be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void gpiod_put_array(struct gpio_descs *descs)
</pre></div>
</div>
<p>It is strictly forbidden to use a descriptor after calling these functions.
It is also not allowed to individually release descriptors (using <a class="reference internal" href="index.html#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a>)
from an array acquired with <a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>.</p>
<p>The device-managed variants are, unsurprisingly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void devm_gpiod_put(struct device *dev, struct gpio_desc *desc)

void devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)
</pre></div>
</div>
</div>
<div class="section" id="using-gpios">
<h2>Using GPIOs<a class="headerlink" href="#using-gpios" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setting-direction">
<h3>Setting Direction<a class="headerlink" href="#setting-direction" title="Permalink to this headline">¶</a></h3>
<p>The first thing a driver must do with a GPIO is setting its direction. If no
direction-setting flags have been given to gpiod_get*(), this is done by
invoking one of the gpiod_direction_*() functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_direction_input(struct gpio_desc *desc)
int gpiod_direction_output(struct gpio_desc *desc, int value)
</pre></div>
</div>
<p>The return value is zero for success, else a negative errno. It should be
checked, since the get/set calls don’t return errors and since misconfiguration
is possible. You should normally issue these calls from a task context. However,
for spinlock-safe GPIOs it is OK to use them before tasking is enabled, as part
of early board setup.</p>
<p>For output GPIOs, the value provided becomes the initial output value. This
helps avoid signal glitching during system startup.</p>
<p>A driver can also query the current direction of a GPIO:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_get_direction(const struct gpio_desc *desc)
</pre></div>
</div>
<p>This function returns 0 for output, 1 for input, or an error code in case of error.</p>
<p>Be aware that there is no default direction for GPIOs. Therefore, <strong>using a GPIO
without setting its direction first is illegal and will result in undefined
behavior!</strong></p>
</div>
<div class="section" id="spinlock-safe-gpio-access">
<h3>Spinlock-Safe GPIO Access<a class="headerlink" href="#spinlock-safe-gpio-access" title="Permalink to this headline">¶</a></h3>
<p>Most GPIO controllers can be accessed with memory read/write instructions. Those
don’t need to sleep, and can safely be done from inside hard (non-threaded) IRQ
handlers and similar contexts.</p>
<p>Use the following calls to access GPIOs from an atomic context:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_get_value(const struct gpio_desc *desc);
void gpiod_set_value(struct gpio_desc *desc, int value);
</pre></div>
</div>
<p>The values are boolean, zero for low, nonzero for high. When reading the value
of an output pin, the value returned should be what’s seen on the pin. That
won’t always match the specified output value, because of issues including
open-drain signaling and output latencies.</p>
<p>The get/set calls do not return errors because “invalid GPIO” should have been
reported earlier from gpiod_direction_*(). However, note that not all platforms
can read the value of output pins; those that can’t should always return zero.
Also, using these calls for GPIOs that can’t safely be accessed without sleeping
(see below) is an error.</p>
</div>
<div class="section" id="gpio-access-that-may-sleep">
<h3>GPIO Access That May Sleep<a class="headerlink" href="#gpio-access-that-may-sleep" title="Permalink to this headline">¶</a></h3>
<p>Some GPIO controllers must be accessed using message based buses like I2C or
SPI. Commands to read or write those GPIO values require waiting to get to the
head of a queue to transmit a command and get its response. This requires
sleeping, which can’t be done from inside IRQ handlers.</p>
<p>Platforms that support this type of GPIO distinguish them from other GPIOs by
returning nonzero from this call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_cansleep(const struct gpio_desc *desc)
</pre></div>
</div>
<p>To access such GPIOs, a different set of accessors is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_get_value_cansleep(const struct gpio_desc *desc)
void gpiod_set_value_cansleep(struct gpio_desc *desc, int value)
</pre></div>
</div>
<p>Accessing such GPIOs requires a context which may sleep, for example a threaded
IRQ handler, and those accessors must be used instead of spinlock-safe
accessors without the cansleep() name suffix.</p>
<p>Other than the fact that these accessors might sleep, and will work on GPIOs
that can’t be accessed from hardIRQ handlers, these calls act the same as the
spinlock-safe calls.</p>
</div>
<div class="section" id="the-active-low-and-open-drain-semantics">
<h3>The active low and open drain semantics<a class="headerlink" href="#the-active-low-and-open-drain-semantics" title="Permalink to this headline">¶</a></h3>
<p>As a consumer should not have to care about the physical line level, all of the
gpiod_set_value_xxx() or gpiod_set_array_value_xxx() functions operate with
the <em>logical</em> value. With this they take the active low property into account.
This means that they check whether the GPIO is configured to be active low,
and if so, they manipulate the passed value before the physical line level is
driven.</p>
<p>The same is applicable for open drain or open source output lines: those do not
actively drive their output high (open drain) or low (open source), they just
switch their output to a high impedance value. The consumer should not need to
care. (For details read about open drain in driver.txt.)</p>
<p>With this, all the gpiod_set_(array)_value_xxx() functions interpret the
parameter “value” as “asserted” (“1”) or “de-asserted” (“0”). The physical line
level will be driven accordingly.</p>
<p>As an example, if the active low property for a dedicated GPIO is set, and the
gpiod_set_(array)_value_xxx() passes “asserted” (“1”), the physical line level
will be driven low.</p>
<p>To summarize:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Function (example)                 line property          physical line
gpiod_set_raw_value(desc, 0);      don&#39;t care             low
gpiod_set_raw_value(desc, 1);      don&#39;t care             high
gpiod_set_value(desc, 0);          default (active high)  low
gpiod_set_value(desc, 1);          default (active high)  high
gpiod_set_value(desc, 0);          active low             high
gpiod_set_value(desc, 1);          active low             low
gpiod_set_value(desc, 0);          open drain             low
gpiod_set_value(desc, 1);          open drain             high impedance
gpiod_set_value(desc, 0);          open source            high impedance
gpiod_set_value(desc, 1);          open source            high
</pre></div>
</div>
<p>It is possible to override these semantics using the set_raw/get_raw functions
but it should be avoided as much as possible, especially by system-agnostic drivers
which should not need to care about the actual physical line level and worry about
the logical value instead.</p>
</div>
<div class="section" id="accessing-raw-gpio-values">
<h3>Accessing raw GPIO values<a class="headerlink" href="#accessing-raw-gpio-values" title="Permalink to this headline">¶</a></h3>
<p>Consumers exist that need to manage the logical state of a GPIO line, i.e. the value
their device will actually receive, no matter what lies between it and the GPIO
line.</p>
<p>The following set of calls ignore the active-low or open drain property of a GPIO and
work on the raw line value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_get_raw_value(const struct gpio_desc *desc)
void gpiod_set_raw_value(struct gpio_desc *desc, int value)
int gpiod_get_raw_value_cansleep(const struct gpio_desc *desc)
void gpiod_set_raw_value_cansleep(struct gpio_desc *desc, int value)
int gpiod_direction_output_raw(struct gpio_desc *desc, int value)
</pre></div>
</div>
<p>The active low state of a GPIO can also be queried using the following call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_is_active_low(const struct gpio_desc *desc)
</pre></div>
</div>
<p>Note that these functions should only be used with great moderation; a driver
should not have to care about the physical line level or open drain semantics.</p>
</div>
<div class="section" id="access-multiple-gpios-with-a-single-function-call">
<h3>Access multiple GPIOs with a single function call<a class="headerlink" href="#access-multiple-gpios-with-a-single-function-call" title="Permalink to this headline">¶</a></h3>
<p>The following functions get or set the values of an array of GPIOs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_get_array_value(unsigned int array_size,
                          struct gpio_desc **desc_array,
                          struct gpio_array *array_info,
                          unsigned long *value_bitmap);
int gpiod_get_raw_array_value(unsigned int array_size,
                              struct gpio_desc **desc_array,
                              struct gpio_array *array_info,
                              unsigned long *value_bitmap);
int gpiod_get_array_value_cansleep(unsigned int array_size,
                                   struct gpio_desc **desc_array,
                                   struct gpio_array *array_info,
                                   unsigned long *value_bitmap);
int gpiod_get_raw_array_value_cansleep(unsigned int array_size,
                                   struct gpio_desc **desc_array,
                                   struct gpio_array *array_info,
                                   unsigned long *value_bitmap);

int gpiod_set_array_value(unsigned int array_size,
                          struct gpio_desc **desc_array,
                          struct gpio_array *array_info,
                          unsigned long *value_bitmap)
int gpiod_set_raw_array_value(unsigned int array_size,
                              struct gpio_desc **desc_array,
                              struct gpio_array *array_info,
                              unsigned long *value_bitmap)
int gpiod_set_array_value_cansleep(unsigned int array_size,
                                   struct gpio_desc **desc_array,
                                   struct gpio_array *array_info,
                                   unsigned long *value_bitmap)
int gpiod_set_raw_array_value_cansleep(unsigned int array_size,
                                       struct gpio_desc **desc_array,
                                       struct gpio_array *array_info,
                                       unsigned long *value_bitmap)
</pre></div>
</div>
<p>The array can be an arbitrary set of GPIOs. The functions will try to access
GPIOs belonging to the same bank or chip simultaneously if supported by the
corresponding chip driver. In that case a significantly improved performance
can be expected. If simultaneous access is not possible the GPIOs will be
accessed sequentially.</p>
<dl class="simple">
<dt>The functions take three arguments:</dt><dd><ul class="simple">
<li><p>array_size    - the number of array elements</p></li>
<li><p>desc_array    - an array of GPIO descriptors</p></li>
<li><p>array_info    - optional information obtained from <a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a></p></li>
<li><dl class="simple">
<dt>value_bitmap  - a bitmap to store the GPIOs’ values (get) or</dt><dd><p>a bitmap of values to assign to the GPIOs (set)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>The descriptor array can be obtained using the <a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a> function
or one of its variants. If the group of descriptors returned by that function
matches the desired group of GPIOs, those GPIOs can be accessed by simply using
the struct gpio_descs returned by <a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_descs *my_gpio_descs = gpiod_get_array(...);
gpiod_set_array_value(my_gpio_descs-&gt;ndescs, my_gpio_descs-&gt;desc,
                      my_gpio_descs-&gt;info, my_gpio_value_bitmap);
</pre></div>
</div>
<p>It is also possible to access a completely arbitrary array of descriptors. The
descriptors may be obtained using any combination of <a class="reference internal" href="index.html#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> and
<a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>. Afterwards the array of descriptors has to be setup
manually before it can be passed to one of the above functions.  In that case,
array_info should be set to NULL.</p>
<p>Note that for optimal performance GPIOs belonging to the same chip should be
contiguous within the array of descriptors.</p>
<p>Still better performance may be achieved if array indexes of the descriptors
match hardware pin numbers of a single chip.  If an array passed to a get/set
array function matches the one obtained from <a class="reference internal" href="index.html#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a> and array_info
associated with the array is also passed, the function may take a fast bitmap
processing path, passing the value_bitmap argument directly to the respective
.get/set_multiple() callback of the chip.  That allows for utilization of GPIO
banks as data I/O ports without much loss of performance.</p>
<p>The return value of <a class="reference internal" href="index.html#c.gpiod_get_array_value" title="gpiod_get_array_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_value()</span></code></a> and its variants is 0 on success
or negative on error. Note the difference to <a class="reference internal" href="index.html#c.gpiod_get_value" title="gpiod_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_value()</span></code></a>, which returns
0 or 1 on success to convey the GPIO value. With the array functions, the GPIO
values are stored in value_array rather than passed back as return value.</p>
</div>
<div class="section" id="gpios-mapped-to-irqs">
<h3>GPIOs mapped to IRQs<a class="headerlink" href="#gpios-mapped-to-irqs" title="Permalink to this headline">¶</a></h3>
<p>GPIO lines can quite often be used as IRQs. You can get the IRQ number
corresponding to a given GPIO using the following call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiod_to_irq(const struct gpio_desc *desc)
</pre></div>
</div>
<p>It will return an IRQ number, or a negative errno code if the mapping can’t be
done (most likely because that particular GPIO cannot be used as IRQ). It is an
unchecked error to use a GPIO that wasn’t set up as an input using
<a class="reference internal" href="index.html#c.gpiod_direction_input" title="gpiod_direction_input"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_direction_input()</span></code></a>, or to use an IRQ number that didn’t originally come
from <a class="reference internal" href="index.html#c.gpiod_to_irq" title="gpiod_to_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_to_irq()</span></code></a>. <a class="reference internal" href="index.html#c.gpiod_to_irq" title="gpiod_to_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_to_irq()</span></code></a> is not allowed to sleep.</p>
<p>Non-error values returned from <a class="reference internal" href="index.html#c.gpiod_to_irq" title="gpiod_to_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_to_irq()</span></code></a> can be passed to <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> or
<a class="reference internal" href="../../core-api/genericirq.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>. They will often be stored into IRQ resources for platform devices,
by the board-specific initialization code. Note that IRQ trigger options are
part of the IRQ interface, e.g. IRQF_TRIGGER_FALLING, as are system wakeup
capabilities.</p>
</div>
</div>
<div class="section" id="gpios-and-acpi">
<h2>GPIOs and ACPI<a class="headerlink" href="#gpios-and-acpi" title="Permalink to this headline">¶</a></h2>
<p>On ACPI systems, GPIOs are described by GpioIo()/GpioInt() resources listed by
the _CRS configuration objects of devices.  Those resources do not provide
connection IDs (names) for GPIOs, so it is necessary to use an additional
mechanism for this purpose.</p>
<p>Systems compliant with ACPI 5.1 or newer may provide a _DSD configuration object
which, among other things, may be used to provide connection IDs for specific
GPIOs described by the GpioIo()/GpioInt() resources in _CRS.  If that is the
case, it will be handled by the GPIO subsystem automatically.  However, if the
_DSD is not present, the mappings between GpioIo()/GpioInt() resources and GPIO
connection IDs need to be provided by device drivers.</p>
<p>For details refer to <a class="reference internal" href="../../firmware-guide/acpi/gpio-properties.html"><span class="doc">_DSD Device Properties Related to GPIO</span></a></p>
</div>
<div class="section" id="interacting-with-the-legacy-gpio-subsystem">
<h2>Interacting With the Legacy GPIO Subsystem<a class="headerlink" href="#interacting-with-the-legacy-gpio-subsystem" title="Permalink to this headline">¶</a></h2>
<p>Many kernel subsystems still handle GPIOs using the legacy integer-based
interface. Although it is strongly encouraged to upgrade them to the safer
descriptor-based API, the following two functions allow you to convert a GPIO
descriptor into the GPIO integer namespace and vice-versa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int desc_to_gpio(const struct gpio_desc *desc)
struct gpio_desc *gpio_to_desc(unsigned gpio)
</pre></div>
</div>
<p>The GPIO number returned by <a class="reference internal" href="index.html#c.desc_to_gpio" title="desc_to_gpio"><code class="xref c c-func docutils literal notranslate"><span class="pre">desc_to_gpio()</span></code></a> can be safely used as long as the
GPIO descriptor has not been freed. All the same, a GPIO number passed to
<a class="reference internal" href="index.html#c.gpio_to_desc" title="gpio_to_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpio_to_desc()</span></code></a> must have been properly acquired, and usage of the returned GPIO
descriptor is only possible after the GPIO number has been released.</p>
<p>Freeing a GPIO obtained by one API with the other API is forbidden and an
unchecked error.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="board.html" class="btn btn-neutral float-right" title="GPIO Mappings" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="driver.html" class="btn btn-neutral float-left" title="GPIO Driver Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>