

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux-USB Host Side API &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="USB Gadget API for Linux" href="gadget.html" />
    <link rel="prev" title="Linux USB API" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux USB API</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Linux-USB Host Side API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction-to-usb-on-linux">Introduction to USB on Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-host-side-api-model">USB Host-Side API Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-standard-types">USB-Standard Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-side-data-types-and-macros">Host-Side Data Types and Macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-core-apis">USB Core APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-controller-apis">Host Controller APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-usb-character-device-nodes">The USB character device nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-usb-devices">The USB devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gadget.html">USB Gadget API for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="anchors.html">USB Anchors</a></li>
<li class="toctree-l3"><a class="reference internal" href="bulk-streams.html">USB bulk streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="callbacks.html">USB core callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma.html">USB DMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="URB.html">USB Request Block (URB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="power-management.html">Power Management for USB</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotplug.html">USB hotplugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="persist.html">USB device persistence during system suspend</a></li>
<li class="toctree-l3"><a class="reference internal" href="error-codes.html">USB Error codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_usb_driver.html">Writing USB Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dwc3.html">Synopsys DesignWare Core SuperSpeed USB 3.0 Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_musb_glue_layer.html">Writing a MUSB Glue Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="typec.html">USB Type-C connector class</a></li>
<li class="toctree-l3"><a class="reference internal" href="typec_bus.html">API for USB Type-C Alternate Mode drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb3-debug-port.html">USB3 debug port</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux USB API</a> &raquo;</li>
        
      <li>The Linux-USB Host Side API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/usb/usb.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-usb-host-side-api">
<span id="usb-hostside-api"></span><h1>The Linux-USB Host Side API<a class="headerlink" href="#the-linux-usb-host-side-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-to-usb-on-linux">
<h2>Introduction to USB on Linux<a class="headerlink" href="#introduction-to-usb-on-linux" title="Permalink to this headline">¶</a></h2>
<p>A Universal Serial Bus (USB) is used to connect a host, such as a PC or
workstation, to a number of peripheral devices. USB uses a tree
structure, with the host as the root (the system’s master), hubs as
interior nodes, and peripherals as leaves (and slaves). Modern PCs
support several such trees of USB devices, usually
a few USB 3.0 (5 GBit/s) or USB 3.1 (10 GBit/s) and some legacy
USB 2.0 (480 MBit/s) busses just in case.</p>
<p>That master/slave asymmetry was designed-in for a number of reasons, one
being ease of use. It is not physically possible to mistake upstream and
downstream or it does not matter with a type C plug (or they are built into the
peripheral). Also, the host software doesn’t need to deal with
distributed auto-configuration since the pre-designated master node
manages all that.</p>
<p>Kernel developers added USB support to Linux early in the 2.2 kernel
series and have been developing it further since then. Besides support
for each new generation of USB, various host controllers gained support,
new drivers for peripherals have been added and advanced features for latency
measurement and improved power management introduced.</p>
<p>Linux can run inside USB devices as well as on the hosts that control
the devices. But USB device drivers running inside those peripherals
don’t do the same things as the ones running inside hosts, so they’ve
been given a different name: <em>gadget drivers</em>. This document does not
cover gadget drivers.</p>
</div>
<div class="section" id="usb-host-side-api-model">
<h2>USB Host-Side API Model<a class="headerlink" href="#usb-host-side-api-model" title="Permalink to this headline">¶</a></h2>
<p>Host-side drivers for USB devices talk to the “usbcore” APIs. There are
two. One is intended for <em>general-purpose</em> drivers (exposed through
driver frameworks), and the other is for drivers that are <em>part of the
core</em>. Such core drivers include the <em>hub</em> driver (which manages trees
of USB devices) and several different kinds of <em>host controller
drivers</em>, which control individual busses.</p>
<p>The device model seen by USB drivers is relatively complex.</p>
<ul>
<li><p>USB supports four kinds of data transfers (control, bulk, interrupt,
and isochronous). Two of them (control and bulk) use bandwidth as
it’s available, while the other two (interrupt and isochronous) are
scheduled to provide guaranteed bandwidth.</p></li>
<li><p>The device description model includes one or more “configurations”
per device, only one of which is active at a time. Devices are supposed
to be capable of operating at lower than their top
speeds and may provide a BOS descriptor showing the lowest speed they
remain fully operational at.</p></li>
<li><p>From USB 3.0 on configurations have one or more “functions”, which
provide a common functionality and are grouped together for purposes
of power management.</p></li>
<li><p>Configurations or functions have one or more “interfaces”, each of which may have
“alternate settings”. Interfaces may be standardized by USB “Class”
specifications, or may be specific to a vendor or device.</p>
<p>USB device drivers actually bind to interfaces, not devices. Think of
them as “interface drivers”, though you may not see many devices
where the distinction is important. <em>Most USB devices are simple,
with only one function, one configuration, one interface, and one alternate
setting.</em></p>
</li>
<li><p>Interfaces have one or more “endpoints”, each of which supports one
type and direction of data transfer such as “bulk out” or “interrupt
in”. The entire configuration may have up to sixteen endpoints in
each direction, allocated as needed among all the interfaces.</p></li>
<li><p>Data transfer on USB is packetized; each endpoint has a maximum
packet size. Drivers must often be aware of conventions such as
flagging the end of bulk transfers using “short” (including zero
length) packets.</p></li>
<li><p>The Linux USB API supports synchronous calls for control and bulk
messages. It also supports asynchronous calls for all kinds of data
transfer, using request structures called “URBs” (USB Request
Blocks).</p></li>
</ul>
<p>Accordingly, the USB Core API exposed to device drivers covers quite a
lot of territory. You’ll probably need to consult the USB 3.0
specification, available online from www.usb.org at no cost, as well as
class or device specifications.</p>
<p>The only host-side drivers that actually touch hardware (reading/writing
registers, handling IRQs, and so on) are the HCDs. In theory, all HCDs
provide the same functionality through the same API. In practice, that’s
becoming more true, but there are still differences
that crop up especially with fault handling on the less common controllers.
Different controllers don’t
necessarily report the same aspects of failures, and recovery from
faults (including software-induced ones like unlinking an URB) isn’t yet
fully consistent. Device driver authors should make a point of doing
disconnect testing (while the device is active) with each different host
controller driver, to make sure drivers don’t have bugs of their own as
well as to make sure they aren’t relying on some HCD-specific behavior.</p>
</div>
<div class="section" id="usb-standard-types">
<span id="usb-chapter9"></span><h2>USB-Standard Types<a class="headerlink" href="#usb-standard-types" title="Permalink to this headline">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">&lt;linux/usb/ch9.h&gt;</span></code> you will find the USB data types defined in
chapter 9 of the USB specification. These data types are used throughout
USB, and in APIs including this host side API, gadget APIs, usb character
devices and debugfs interfaces.</p>
<dl class="c function">
<dt id="c.usb_ep_type_string">
<em class="property">const</em> char *<code class="sig-name descname">usb_ep_type_string</code><span class="sig-paren">(</span>int <em>ep_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ep_type_string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns human readable-name of the endpoint type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ep_type</span></code></dt><dd><p>The endpoint type to return human-readable name for.  If it’s not
any of the types: USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT},
usually got by usb_endpoint_type(), the string ‘unknown’ will be returned.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.usb_speed_string">
<em class="property">const</em> char *<code class="sig-name descname">usb_speed_string</code><span class="sig-paren">(</span><em class="property">enum</em> usb_device_speed <em>speed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_speed_string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns human readable-name of the speed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">usb_device_speed</span> <span class="pre">speed</span></code></dt><dd><p>The speed to return human-readable name for.  If it’s not
any of the speeds defined in usb_device_speed enum, string for
USB_SPEED_UNKNOWN will be returned.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.usb_get_maximum_speed">
<em class="property">enum</em> usb_device_speed <code class="sig-name descname">usb_get_maximum_speed</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_maximum_speed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get maximum requested speed for a given USB controller.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the given USB controller device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function gets the maximum speed string from property “maximum-speed”,
and returns the corresponding enum usb_device_speed.</p>
<dl class="c function">
<dt id="c.usb_state_string">
<em class="property">const</em> char *<code class="sig-name descname">usb_state_string</code><span class="sig-paren">(</span><em class="property">enum</em> usb_device_state <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_state_string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns human readable name for the state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">usb_device_state</span> <span class="pre">state</span></code></dt><dd><p>The state to return a human-readable name for. If it’s not
any of the states devices in usb_device_state_string enum,
the string UNKNOWN will be returned.</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.usb_decode_ctrl">
<em class="property">const</em> char *<code class="sig-name descname">usb_decode_ctrl</code><span class="sig-paren">(</span>char *<em>str</em>, size_t <em>size</em>, __u8 <em>bRequestType</em>, __u8 <em>bRequest</em>, __u16 <em>wValue</em>, __u16 <em>wIndex</em>, __u16 <em>wLength</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_decode_ctrl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns human readable representation of control request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>buffer to return a human-readable representation of control request.
This buffer should have about 200 bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of str buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">bRequestType</span></code></dt><dd><p>matches the USB bmRequestType field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">bRequest</span></code></dt><dd><p>matches the USB bRequest field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">wValue</span></code></dt><dd><p>matches the USB wValue field (CPU byte order)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">wIndex</span></code></dt><dd><p>matches the USB wIndex field (CPU byte order)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">wLength</span></code></dt><dd><p>matches the USB wLength field (CPU byte order)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns decoded, formatted and human-readable description of
control request packet.</p>
<p>The usage scenario for this is for tracepoints, so function as a return
use the same value as in parameters. This approach allows to use this
function in TP_printk</p>
<p>Important: wValue, wIndex, wLength parameters before invoking this function
should be processed by le16_to_cpu macro.</p>
</div>
<div class="section" id="host-side-data-types-and-macros">
<span id="usb-header"></span><h2>Host-Side Data Types and Macros<a class="headerlink" href="#host-side-data-types-and-macros" title="Permalink to this headline">¶</a></h2>
<p>The host side API exposes several layers to drivers, some of which are
more necessary than others. These support lifecycle models for host side
drivers and devices, and support passing buffers through usbcore to some
HCD that performs the I/O for the device driver.</p>
<dl class="c struct">
<dt id="c.usb_host_endpoint">
<em class="property">struct </em><code class="sig-name descname">usb_host_endpoint</code><a class="headerlink" href="#c.usb_host_endpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>host-side endpoint descriptor and queue</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_host_endpoint {
  struct usb_endpoint_descriptor          desc;
  struct usb_ss_ep_comp_descriptor        ss_ep_comp;
  struct usb_ssp_isoc_ep_comp_descriptor  ssp_isoc_ep_comp;
  struct list_head                urb_list;
  void *hcpriv;
  struct ep_device                *ep_dev;
  unsigned char *extra;
  int extralen;
  int enabled;
  int streams;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>descriptor for this endpoint, wMaxPacketSize in native byteorder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ss_ep_comp</span></code></dt><dd><p>SuperSpeed companion descriptor for this endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp_isoc_ep_comp</span></code></dt><dd><p>SuperSpeedPlus isoc companion descriptor for this endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">urb_list</span></code></dt><dd><p>urbs queued to this endpoint; maintained by usbcore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hcpriv</span></code></dt><dd><p>for use by HCD; typically holds hardware dma queue head (QH)
with one or more transfer descriptors (TDs) per urb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_dev</span></code></dt><dd><p>ep_device for sysfs info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra</span></code></dt><dd><p>descriptors following this endpoint in the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extralen</span></code></dt><dd><p>how many bytes of “extra” are valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>URBs may be submitted to this endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">streams</span></code></dt><dd><p>number of USB-3 streams allocated on the endpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB requests are always queued to a given endpoint, identified by a
descriptor within an active interface in a given USB configuration.</p>
<dl class="c struct">
<dt id="c.usb_interface">
<em class="property">struct </em><code class="sig-name descname">usb_interface</code><a class="headerlink" href="#c.usb_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>what usb device drivers talk to</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_interface {
  struct usb_host_interface *altsetting;
  struct usb_host_interface *cur_altsetting;
  unsigned num_altsetting;
  struct usb_interface_assoc_descriptor *intf_assoc;
  int minor;
  enum usb_interface_condition condition;
  unsigned sysfs_files_created:1;
  unsigned ep_devs_created:1;
  unsigned unregistering:1;
  unsigned needs_remote_wakeup:1;
  unsigned needs_altsetting0:1;
  unsigned needs_binding:1;
  unsigned resetting_device:1;
  unsigned authorized:1;
  struct device dev;
  struct device *usb_dev;
  struct work_struct reset_ws;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">altsetting</span></code></dt><dd><p>array of interface structures, one for each alternate
setting that may be selected.  Each one includes a set of
endpoint configurations.  They will be in no particular order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_altsetting</span></code></dt><dd><p>the current altsetting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_altsetting</span></code></dt><dd><p>number of altsettings defined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf_assoc</span></code></dt><dd><p>interface association descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>the minor number assigned to this interface, if this
interface is bound to a driver that uses the USB major number.
If this interface does not use the USB major, this field should
be unused.  The driver should set this value in the probe()
function of the driver, after it has been assigned a minor
number from the USB core by calling <a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>binding state of the interface: not bound, binding
(in probe()), bound to a driver, or unbinding (in disconnect())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_files_created</span></code></dt><dd><p>sysfs attributes exist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_devs_created</span></code></dt><dd><p>endpoint child pseudo-devices exist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unregistering</span></code></dt><dd><p>flag set when the interface is being unregistered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_remote_wakeup</span></code></dt><dd><p>flag set when the driver requires remote-wakeup
capability during autosuspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_altsetting0</span></code></dt><dd><p>flag set when a set-interface request for altsetting 0
has been deferred.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_binding</span></code></dt><dd><p>flag set when the driver should be re-probed or unbound
following a reset or suspend operation it doesn’t support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resetting_device</span></code></dt><dd><p>USB core reset the device, so use alt setting 0 as
current; needs bandwidth alloc after reset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">authorized</span></code></dt><dd><p>This allows to (de)authorize individual interfaces instead
a whole device in contrast to the device authorization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model’s view of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb_dev</span></code></dt><dd><p>if an interface is bound to the USB major, this will point
to the sysfs representation for that device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_ws</span></code></dt><dd><p>Used for scheduling resets from atomic context.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB device drivers attach to interfaces on a physical device.  Each
interface encapsulates a single high level function, such as feeding
an audio stream to a speaker or reporting a change in a volume control.
Many USB devices only have one interface.  The protocol used to talk to
an interface’s endpoints can be defined in a usb “class” specification,
or by a product’s vendor.  The (default) control endpoint is part of
every interface, but is never listed among the interface’s descriptors.</p>
<p>The driver that is bound to the interface can use standard driver model
calls such as dev_get_drvdata() on the dev member of this structure.</p>
<p>Each interface may have alternate settings.  The initial configuration
of a device sets altsetting 0, but the device driver can change
that setting using <a class="reference internal" href="#c.usb_set_interface" title="usb_set_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_set_interface()</span></code></a>.  Alternate settings are often
used to control the use of periodic endpoints, such as by having
different endpoints use different amounts of reserved USB bandwidth.
All standards-conformant USB devices that use isochronous endpoints
will use them in non-default settings.</p>
<p>The USB specification says that alternate setting numbers must run from
0 to one less than the total number of alternate settings.  But some
devices manage to mess this up, and the structures aren’t necessarily
stored in numerical order anyhow.  Use <a class="reference internal" href="#c.usb_altnum_to_altsetting" title="usb_altnum_to_altsetting"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_altnum_to_altsetting()</span></code></a> to
look up an alternate setting in the altsetting array based on its number.</p>
<dl class="c struct">
<dt id="c.usb_interface_cache">
<em class="property">struct </em><code class="sig-name descname">usb_interface_cache</code><a class="headerlink" href="#c.usb_interface_cache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>long-term representation of a device interface</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_interface_cache {
  unsigned num_altsetting;
  struct kref ref;
  struct usb_host_interface altsetting[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_altsetting</span></code></dt><dd><p>number of altsettings defined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ref</span></code></dt><dd><p>reference counter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">altsetting</span></code></dt><dd><p>variable-length array of interface structures, one for
each alternate setting that may be selected.  Each one includes a
set of endpoint configurations.  They will be in no particular order.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These structures persist for the lifetime of a usb_device, unlike
<a class="reference internal" href="#c.usb_interface" title="usb_interface"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span></code></a> (which persists only as long as its configuration
is installed).  The altsetting arrays can be accessed through these
structures at any time, permitting comparison of configurations and
providing support for the /sys/kernel/debug/usb/devices pseudo-file.</p>
<dl class="c struct">
<dt id="c.usb_host_config">
<em class="property">struct </em><code class="sig-name descname">usb_host_config</code><a class="headerlink" href="#c.usb_host_config" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>representation of a device’s configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_host_config {
  struct usb_config_descriptor    desc;
  char *string;
  struct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];
  struct usb_interface *interface[USB_MAXINTERFACES];
  struct usb_interface_cache *intf_cache[USB_MAXINTERFACES];
  unsigned char *extra;
  int extralen;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>the device’s configuration descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code></dt><dd><p>pointer to the cached version of the iConfiguration string, if
present for this configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf_assoc</span></code></dt><dd><p>list of any interface association descriptors in this config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interface</span></code></dt><dd><p>array of pointers to usb_interface structures, one for each
interface in the configuration.  The number of interfaces is stored
in desc.bNumInterfaces.  These pointers are valid only while the
configuration is active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf_cache</span></code></dt><dd><p>array of pointers to usb_interface_cache structures, one
for each interface in the configuration.  These structures exist
for the entire life of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra</span></code></dt><dd><p>pointer to buffer containing all extra descriptors associated
with this configuration (those preceding the first interface
descriptor).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extralen</span></code></dt><dd><p>length of the extra descriptors buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB devices may have multiple configurations, but only one can be active
at any time.  Each encapsulates a different operational environment;
for example, a dual-speed device would have separate configurations for
full-speed and high-speed operation.  The number of configurations
available is stored in the device descriptor as bNumConfigurations.</p>
<p>A configuration can contain multiple interfaces.  Each corresponds to
a different function of the USB device, and all are available whenever
the configuration is active.  The USB standard says that interfaces
are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot
of devices get this wrong.  In addition, the interface array is not
guaranteed to be sorted in numerical order.  Use <a class="reference internal" href="#c.usb_ifnum_to_if" title="usb_ifnum_to_if"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_ifnum_to_if()</span></code></a> to
look up an interface entry based on its number.</p>
<p>Device drivers should not attempt to activate configurations.  The choice
of which configuration to install is a policy decision based on such
considerations as available power, functionality provided, and the user’s
desires (expressed through userspace tools).  However, drivers can call
<a class="reference internal" href="#c.usb_reset_configuration" title="usb_reset_configuration"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_configuration()</span></code></a> to reinitialize the current configuration and
all its interfaces.</p>
<dl class="c struct">
<dt id="c.usb_device">
<em class="property">struct </em><code class="sig-name descname">usb_device</code><a class="headerlink" href="#c.usb_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>kernel’s representation of a USB device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_device {
  int devnum;
  char devpath[16];
  u32 route;
  enum usb_device_state   state;
  enum usb_device_speed   speed;
  unsigned int            rx_lanes;
  unsigned int            tx_lanes;
  struct usb_tt   *tt;
  int ttport;
  unsigned int toggle[2];
  struct usb_device *parent;
  struct usb_bus *bus;
  struct usb_host_endpoint ep0;
  struct device dev;
  struct usb_device_descriptor descriptor;
  struct usb_host_bos *bos;
  struct usb_host_config *config;
  struct usb_host_config *actconfig;
  struct usb_host_endpoint *ep_in[16];
  struct usb_host_endpoint *ep_out[16];
  char **rawdescriptors;
  unsigned short bus_mA;
  u8 portnum;
  u8 level;
  u8 devaddr;
  unsigned can_submit:1;
  unsigned persist_enabled:1;
  unsigned have_langid:1;
  unsigned authorized:1;
  unsigned authenticated:1;
  unsigned wusb:1;
  unsigned lpm_capable:1;
  unsigned usb2_hw_lpm_capable:1;
  unsigned usb2_hw_lpm_besl_capable:1;
  unsigned usb2_hw_lpm_enabled:1;
  unsigned usb2_hw_lpm_allowed:1;
  unsigned usb3_lpm_u1_enabled:1;
  unsigned usb3_lpm_u2_enabled:1;
  int string_langid;
  char *product;
  char *manufacturer;
  char *serial;
  struct list_head filelist;
  int maxchild;
  u32 quirks;
  atomic_t urbnum;
  unsigned long active_duration;
#ifdef CONFIG_PM;
  unsigned long connect_time;
  unsigned do_remote_wakeup:1;
  unsigned reset_resume:1;
  unsigned port_is_suspended:1;
#endif;
  struct wusb_dev *wusb_dev;
  int slot_id;
  enum usb_device_removable removable;
  struct usb2_lpm_parameters l1_params;
  struct usb3_lpm_parameters u1_params;
  struct usb3_lpm_parameters u2_params;
  unsigned lpm_disable_count;
  u16 hub_delay;
  unsigned use_generic_driver:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">devnum</span></code></dt><dd><p>device number; address on a USB bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devpath</span></code></dt><dd><p>device ID string for use in messages (e.g., /port/…)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">route</span></code></dt><dd><p>tree topology hex string for use with xHCI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>device state: configured, not attached, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>device speed: high/full/low (or error)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_lanes</span></code></dt><dd><p>number of rx lanes in use, USB 3.2 adds dual-lane support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_lanes</span></code></dt><dd><p>number of tx lanes in use, USB 3.2 adds dual-lane support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tt</span></code></dt><dd><p>Transaction Translator info; used with low/full speed dev, highspeed hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ttport</span></code></dt><dd><p>device port on that tt hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">toggle</span></code></dt><dd><p>one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>our hub, unless we’re the root</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>bus we’re part of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep0</span></code></dt><dd><p>endpoint 0 data (default control pipe)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>generic device interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptor</span></code></dt><dd><p>USB device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bos</span></code></dt><dd><p>USB device BOS descriptor set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>all of the device’s configs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actconfig</span></code></dt><dd><p>the active configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_in</span></code></dt><dd><p>array of IN endpoints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_out</span></code></dt><dd><p>array of OUT endpoints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rawdescriptors</span></code></dt><dd><p>raw descriptors for each config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_mA</span></code></dt><dd><p>Current available from the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">portnum</span></code></dt><dd><p>parent port number (origin 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">level</span></code></dt><dd><p>number of USB hub ancestors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devaddr</span></code></dt><dd><p>device address, XHCI: assigned by HW, others: same as devnum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_submit</span></code></dt><dd><p>URBs may be submitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">persist_enabled</span></code></dt><dd><p>USB_PERSIST enabled for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">have_langid</span></code></dt><dd><p>whether string_langid is valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">authorized</span></code></dt><dd><p>policy has said we can use it;
(user space) policy determines if we authorize this device to be
used or not. By default, wired USB devices are authorized.
WUSB devices are not, until we authorize them from user space.
FIXME – complete doc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">authenticated</span></code></dt><dd><p>Crypto authentication passed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wusb</span></code></dt><dd><p>device is Wireless USB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpm_capable</span></code></dt><dd><p>device supports LPM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb2_hw_lpm_capable</span></code></dt><dd><p>device can perform USB2 hardware LPM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb2_hw_lpm_besl_capable</span></code></dt><dd><p>device can perform USB2 hardware BESL LPM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb2_hw_lpm_enabled</span></code></dt><dd><p>USB2 hardware LPM is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb2_hw_lpm_allowed</span></code></dt><dd><p>Userspace allows USB 2.0 LPM to be enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb3_lpm_u1_enabled</span></code></dt><dd><p>USB3 hardware U1 LPM enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb3_lpm_u2_enabled</span></code></dt><dd><p>USB3 hardware U2 LPM enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string_langid</span></code></dt><dd><p>language ID for strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">product</span></code></dt><dd><p>iProduct string, if present (static)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">manufacturer</span></code></dt><dd><p>iManufacturer string, if present (static)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">serial</span></code></dt><dd><p>iSerialNumber string, if present (static)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filelist</span></code></dt><dd><p>usbfs files that are open to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxchild</span></code></dt><dd><p>number of ports if hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirks</span></code></dt><dd><p>quirks of the whole device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">urbnum</span></code></dt><dd><p>number of URBs submitted for the whole device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_duration</span></code></dt><dd><p>total time device is not suspended</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect_time</span></code></dt><dd><p>time device was first connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">do_remote_wakeup</span></code></dt><dd><p>remote wakeup should be enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_resume</span></code></dt><dd><p>needs reset instead of resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_is_suspended</span></code></dt><dd><p>the upstream port is suspended (L2 or U3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wusb_dev</span></code></dt><dd><p>if this is a Wireless USB device, link to the WUSB
specific data for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slot_id</span></code></dt><dd><p>Slot ID assigned by xHCI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">removable</span></code></dt><dd><p>Device can be physically removed from this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l1_params</span></code></dt><dd><p>best effor service latency for USB2 L1 LPM state, and L1 timeout.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u1_params</span></code></dt><dd><p>exit latencies for USB3 U1 LPM state, and hub-initiated timeout.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u2_params</span></code></dt><dd><p>exit latencies for USB3 U2 LPM state, and hub-initiated timeout.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpm_disable_count</span></code></dt><dd><p>Ref count used by usb_disable_lpm() and usb_enable_lpm()
to keep track of the number of functions that require USB 3.0 Link Power
Management to be disabled for this usb_device.  This count should only
be manipulated by those functions, with the bandwidth_mutex is held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hub_delay</span></code></dt><dd><p>cached value consisting of:
parent-&gt;hub_delay + wHubDelay + tTPTransmissionDelay (40ns)
Will be used as wValue for SetIsochDelay requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_generic_driver</span></code></dt><dd><p>ask driver core to reprobe using the generic driver.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<p>Usbcore drivers should not set usbdev-&gt;state directly.  Instead use
<a class="reference internal" href="#c.usb_set_device_state" title="usb_set_device_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_set_device_state()</span></code></a>.</p>
<dl class="c macro">
<dt id="c.usb_hub_for_each_child">
<code class="sig-name descname">usb_hub_for_each_child</code><a class="headerlink" href="#c.usb_hub_for_each_child" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">usb_hub_for_each_child</span> <span class="pre">(hdev,</span> <span class="pre">port1,</span> <span class="pre">child)</span></code></p>
<blockquote>
<div><p>iterate over all child devices on the hub</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hdev</span></code></dt><dd><p>USB device belonging to the usb hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port1</span></code></dt><dd><p>portnum associated with child device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child</span></code></dt><dd><p>child device pointer</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.usb_interface_claimed">
int <code class="sig-name descname">usb_interface_claimed</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_interface_claimed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns true iff an interface is claimed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*iface</span></code></dt><dd><p>the interface being checked</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> (nonzero) iff the interface is claimed, else <code class="docutils literal notranslate"><span class="pre">false</span></code>
(zero).</p>
<p><strong>Note</strong></p>
<p>Callers must own the driver model’s usb bus readlock.  So driver
probe() entries don’t need extra locking, but other call contexts
may need to explicitly claim that lock.</p>
<dl class="c function">
<dt id="c.usb_make_path">
int <code class="sig-name descname">usb_make_path</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, char *<em>buf</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_make_path" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns stable device path in the usb tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose path is being constructed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how big is “buf”?</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Length of the string (&gt; 0) or negative if size was too small.</p>
<p><strong>Note</strong></p>
<p>This identifier is intended to be “stable”, reflecting physical paths in
hardware such as physical bus addresses for host controllers or ports on
USB hubs.  That makes it stay the same until systems are physically
reconfigured, by re-cabling a tree of USB devices or by moving USB host
controllers.  Adding and removing devices, including virtual root hubs
in host controller driver modules, does not change these path identifiers;
neither does rebooting or re-enumerating.  These are more useful identifiers
than changeable (“unstable”) ones like bus numbers or device addresses.</p>
<p><strong>Description</strong></p>
<p>With a partial exception for devices connected to USB 2.0 root hubs, these
identifiers are also predictable.  So long as the device tree isn’t changed,
plugging any USB device into a given hub port always gives it the same path.
Because of the use of “companion” controllers, devices connected to ports on
USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
high speed, and a different one if they are full or low speed.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE">
<code class="sig-name descname">USB_DEVICE</code><a class="headerlink" href="#c.USB_DEVICE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE</span> <span class="pre">(vend,</span> <span class="pre">prod)</span></code></p>
<blockquote>
<div><p>macro used to describe a specific usb device</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific device.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_VER">
<code class="sig-name descname">USB_DEVICE_VER</code><a class="headerlink" href="#c.USB_DEVICE_VER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_VER</span> <span class="pre">(vend,</span> <span class="pre">prod,</span> <span class="pre">lo,</span> <span class="pre">hi)</span></code></p>
<blockquote>
<div><p>describe a specific usb device with a version range</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lo</span></code></dt><dd><p>the bcdDevice_lo value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hi</span></code></dt><dd><p>the bcdDevice_hi value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific device, with a version range.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_INTERFACE_CLASS">
<code class="sig-name descname">USB_DEVICE_INTERFACE_CLASS</code><a class="headerlink" href="#c.USB_DEVICE_INTERFACE_CLASS" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_INTERFACE_CLASS</span> <span class="pre">(vend,</span> <span class="pre">prod,</span> <span class="pre">cl)</span></code></p>
<blockquote>
<div><p>describe a usb device with a specific interface class</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cl</span></code></dt><dd><p>bInterfaceClass value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific interface class of devices.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_INTERFACE_PROTOCOL">
<code class="sig-name descname">USB_DEVICE_INTERFACE_PROTOCOL</code><a class="headerlink" href="#c.USB_DEVICE_INTERFACE_PROTOCOL" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_INTERFACE_PROTOCOL</span> <span class="pre">(vend,</span> <span class="pre">prod,</span> <span class="pre">pr)</span></code></p>
<blockquote>
<div><p>describe a usb device with a specific interface protocol</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pr</span></code></dt><dd><p>bInterfaceProtocol value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific interface protocol of devices.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_INTERFACE_NUMBER">
<code class="sig-name descname">USB_DEVICE_INTERFACE_NUMBER</code><a class="headerlink" href="#c.USB_DEVICE_INTERFACE_NUMBER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_INTERFACE_NUMBER</span> <span class="pre">(vend,</span> <span class="pre">prod,</span> <span class="pre">num)</span></code></p>
<blockquote>
<div><p>describe a usb device with a specific interface number</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>bInterfaceNumber value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific interface number of devices.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_INFO">
<code class="sig-name descname">USB_DEVICE_INFO</code><a class="headerlink" href="#c.USB_DEVICE_INFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_INFO</span> <span class="pre">(cl,</span> <span class="pre">sc,</span> <span class="pre">pr)</span></code></p>
<blockquote>
<div><p>macro used to describe a class of usb devices</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cl</span></code></dt><dd><p>bDeviceClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt><dd><p>bDeviceSubClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pr</span></code></dt><dd><p>bDeviceProtocol value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific class of devices.</p>
<dl class="c macro">
<dt id="c.USB_INTERFACE_INFO">
<code class="sig-name descname">USB_INTERFACE_INFO</code><a class="headerlink" href="#c.USB_INTERFACE_INFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_INTERFACE_INFO</span> <span class="pre">(cl,</span> <span class="pre">sc,</span> <span class="pre">pr)</span></code></p>
<blockquote>
<div><p>macro used to describe a class of usb interfaces</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cl</span></code></dt><dd><p>bInterfaceClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt><dd><p>bInterfaceSubClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pr</span></code></dt><dd><p>bInterfaceProtocol value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific class of interfaces.</p>
<dl class="c macro">
<dt id="c.USB_DEVICE_AND_INTERFACE_INFO">
<code class="sig-name descname">USB_DEVICE_AND_INTERFACE_INFO</code><a class="headerlink" href="#c.USB_DEVICE_AND_INTERFACE_INFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_DEVICE_AND_INTERFACE_INFO</span> <span class="pre">(vend,</span> <span class="pre">prod,</span> <span class="pre">cl,</span> <span class="pre">sc,</span> <span class="pre">pr)</span></code></p>
<blockquote>
<div><p>describe a specific usb device with a class of usb interfaces</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod</span></code></dt><dd><p>the 16 bit USB Product ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cl</span></code></dt><dd><p>bInterfaceClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt><dd><p>bInterfaceSubClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pr</span></code></dt><dd><p>bInterfaceProtocol value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific device with a specific class of interfaces.</p>
<p>This is especially useful when explicitly matching devices that have
vendor specific bDeviceClass values, but standards-compliant interfaces.</p>
<dl class="c macro">
<dt id="c.USB_VENDOR_AND_INTERFACE_INFO">
<code class="sig-name descname">USB_VENDOR_AND_INTERFACE_INFO</code><a class="headerlink" href="#c.USB_VENDOR_AND_INTERFACE_INFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">USB_VENDOR_AND_INTERFACE_INFO</span> <span class="pre">(vend,</span> <span class="pre">cl,</span> <span class="pre">sc,</span> <span class="pre">pr)</span></code></p>
<blockquote>
<div><p>describe a specific usb vendor with a class of usb interfaces</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend</span></code></dt><dd><p>the 16 bit USB Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cl</span></code></dt><dd><p>bInterfaceClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt><dd><p>bInterfaceSubClass value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pr</span></code></dt><dd><p>bInterfaceProtocol value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_id</span></code></a> that matches a
specific vendor with a specific class of interfaces.</p>
<p>This is especially useful when explicitly matching devices that have
vendor specific bDeviceClass values, but standards-compliant interfaces.</p>
<dl class="c struct">
<dt id="c.usbdrv_wrap">
<em class="property">struct </em><code class="sig-name descname">usbdrv_wrap</code><a class="headerlink" href="#c.usbdrv_wrap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wrapper for driver-model structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdrv_wrap {
  struct device_driver driver;
  int for_devices;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>The driver-model core driver structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">for_devices</span></code></dt><dd><p>Non-zero for device drivers, 0 for interface drivers.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.usb_driver">
<em class="property">struct </em><code class="sig-name descname">usb_driver</code><a class="headerlink" href="#c.usb_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies USB interface driver to usbcore</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_driver {
  const char *name;
  int (*probe) (struct usb_interface *intf, const struct usb_device_id *id);
  void (*disconnect) (struct usb_interface *intf);
  int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
  int (*suspend) (struct usb_interface *intf, pm_message_t message);
  int (*resume) (struct usb_interface *intf);
  int (*reset_resume)(struct usb_interface *intf);
  int (*pre_reset)(struct usb_interface *intf);
  int (*post_reset)(struct usb_interface *intf);
  const struct usb_device_id *id_table;
  const struct attribute_group **dev_groups;
  struct usb_dynids dynids;
  struct usbdrv_wrap drvwrap;
  unsigned int no_dynamic_id:1;
  unsigned int supports_autosuspend:1;
  unsigned int disable_hub_initiated_lpm:1;
  unsigned int soft_unbind:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The driver name should be unique among USB drivers,
and should normally be the same as the module name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called to see if the driver is willing to manage a particular
interface on a device.  If it is, probe returns zero and uses
usb_set_intfdata() to associate driver-specific data with the
interface.  It may also use <a class="reference internal" href="#c.usb_set_interface" title="usb_set_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_set_interface()</span></code></a> to specify the
appropriate altsetting.  If unwilling to manage the interface,
return -ENODEV, if genuine IO errors occurred, an appropriate
negative errno value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>Called when the interface is no longer accessible, usually
because its device has been (or is being) disconnected or the
driver module is being unloaded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlocked_ioctl</span></code></dt><dd><p>Used for drivers that want to talk to userspace through
the “usbfs” filesystem.  This lets devices provide ways to
expose information to user space regardless of where they
do (or don’t) show up otherwise in the filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Called when the device is going to be suspended by the
system either from system sleep or runtime suspend context. The
return value will be ignored in system sleep context, so do NOT
try to continue using the device if suspend fails in this case.
Instead, let the resume or reset-resume routine recover from
the failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Called when the device is being resumed by the system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_resume</span></code></dt><dd><p>Called when the suspended device has been reset instead
of being resumed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_reset</span></code></dt><dd><p>Called by <a class="reference internal" href="#c.usb_reset_device" title="usb_reset_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_device()</span></code></a> when the device is about to be
reset.  This routine must not return until the driver has no active
URBs for the device, and no more URBs may be submitted until the
post_reset method is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_reset</span></code></dt><dd><p>Called by <a class="reference internal" href="#c.usb_reset_device" title="usb_reset_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_device()</span></code></a> after the device
has been reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>USB drivers use ID table to support hotplugging.
Export this with MODULE_DEVICE_TABLE(usb,…).  This must be set
or your driver’s probe function will never get called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_groups</span></code></dt><dd><p>Attributes attached to the device that will be created once it
is bound to the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dynids</span></code></dt><dd><p>used internally to hold the list of dynamically added device
ids for this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drvwrap</span></code></dt><dd><p>Driver-model core structure wrapper.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_dynamic_id</span></code></dt><dd><p>if set to 1, the USB core will not allow dynamic ids to be
added to this driver by preventing the sysfs file from being created.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supports_autosuspend</span></code></dt><dd><p>if set to 0, the USB core will not allow autosuspend
for interfaces bound to this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_hub_initiated_lpm</span></code></dt><dd><p>if set to 1, the USB core will not allow hubs
to initiate lower power link state transitions when an idle timeout
occurs.  Device-initiated USB 3.0 link PM will still be allowed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_unbind</span></code></dt><dd><p>if set to 1, the USB core will not kill URBs and disable
endpoints before calling the driver’s disconnect method.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB interface drivers must provide a name, probe() and disconnect()
methods, and an id_table.  Other driver fields are optional.</p>
<p>The id_table is used in hotplugging.  It holds a set of descriptors,
and specialized data may be associated with each entry.  That table
is used by both user and kernel mode hotplugging support.</p>
<p>The probe() and disconnect() methods are called in a context where
they can sleep, but they should avoid abusing the privilege.  Most
work to connect to a device should be done when the device is opened,
and undone at the last close.  The disconnect code needs to address
concurrency issues with respect to open() and close() methods, as
well as forcing all pending I/O requests to complete (by unlinking
them as necessary, and blocking until the unlinks complete).</p>
<dl class="c struct">
<dt id="c.usb_device_driver">
<em class="property">struct </em><code class="sig-name descname">usb_device_driver</code><a class="headerlink" href="#c.usb_device_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies USB device driver to usbcore</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_device_driver {
  const char *name;
  bool (*match) (struct usb_device *udev);
  int (*probe) (struct usb_device *udev);
  void (*disconnect) (struct usb_device *udev);
  int (*suspend) (struct usb_device *udev, pm_message_t message);
  int (*resume) (struct usb_device *udev, pm_message_t message);
  const struct attribute_group **dev_groups;
  struct usbdrv_wrap drvwrap;
  const struct usb_device_id *id_table;
  unsigned int supports_autosuspend:1;
  unsigned int generic_subclass:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The driver name should be unique among USB drivers,
and should normally be the same as the module name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>If set, used for better device/driver matching.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called to see if the driver is willing to manage a particular
device.  If it is, probe returns zero and uses dev_set_drvdata()
to associate driver-specific data with the device.  If unwilling
to manage the device, return a negative errno value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>Called when the device is no longer accessible, usually
because it has been (or is being) disconnected or the driver’s
module is being unloaded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Called when the device is going to be suspended by the system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Called when the device is being resumed by the system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_groups</span></code></dt><dd><p>Attributes attached to the device that will be created once it
is bound to the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drvwrap</span></code></dt><dd><p>Driver-model core structure wrapper.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>used with <strong>match()</strong> to select better matching driver at
probe() time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supports_autosuspend</span></code></dt><dd><p>if set to 0, the USB core will not allow autosuspend
for devices bound to this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generic_subclass</span></code></dt><dd><p>if set to 1, the generic USB driver’s probe, disconnect,
resume and suspend functions will be called in addition to the driver’s
own, so this part of the setup does not need to be replicated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB drivers must provide all the fields listed above except drvwrap,
match, and id_table.</p>
<dl class="c struct">
<dt id="c.usb_class_driver">
<em class="property">struct </em><code class="sig-name descname">usb_class_driver</code><a class="headerlink" href="#c.usb_class_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>identifies a USB driver that wants to use the USB major number</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_class_driver {
  char *name;
  char *(*devnode)(struct device *dev, umode_t *mode);
  const struct file_operations *fops;
  int minor_base;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>the usb class device name for this driver.  Will show up in sysfs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devnode</span></code></dt><dd><p>Callback to provide a naming hint for a possible
device node to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fops</span></code></dt><dd><p>pointer to the struct file_operations of this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor_base</span></code></dt><dd><p>the start of the minor range for this driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used for the <a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a> and
<a class="reference internal" href="#c.usb_deregister_dev" title="usb_deregister_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_deregister_dev()</span></code></a> functions, to consolidate a number of the
parameters used for them.</p>
<dl class="c macro">
<dt id="c.module_usb_driver">
<code class="sig-name descname">module_usb_driver</code><a class="headerlink" href="#c.module_usb_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_usb_driver</span> <span class="pre">(__usb_driver)</span></code></p>
<blockquote>
<div><p>Helper macro for registering a USB driver</p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__usb_driver</span></code></dt><dd><p>usb_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for USB drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="../basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="../basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
<dl class="c struct">
<dt id="c.urb">
<em class="property">struct </em><code class="sig-name descname">urb</code><a class="headerlink" href="#c.urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>USB Request Block</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct urb {
  struct list_head urb_list;
  struct list_head anchor_list;
  struct usb_anchor *anchor;
  struct usb_device *dev;
  struct usb_host_endpoint *ep;
  unsigned int pipe;
  unsigned int stream_id;
  int status;
  unsigned int transfer_flags;
  void *transfer_buffer;
  dma_addr_t transfer_dma;
  struct scatterlist *sg;
  int num_mapped_sgs;
  int num_sgs;
  u32 transfer_buffer_length;
  u32 actual_length;
  unsigned char *setup_packet;
  dma_addr_t setup_dma;
  int start_frame;
  int number_of_packets;
  int interval;
  int error_count;
  void *context;
  usb_complete_t complete;
  struct usb_iso_packet_descriptor iso_frame_desc[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">urb_list</span></code></dt><dd><p>For use by current owner of the URB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">anchor_list</span></code></dt><dd><p>membership in the list of an anchor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">anchor</span></code></dt><dd><p>to anchor URBs to a common mooring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Identifies the USB device to perform the request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep</span></code></dt><dd><p>Points to the endpoint’s data structure.  Will eventually
replace <strong>pipe</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p>Holds endpoint number, direction, type, and more.
Create these values with the eight macros available;
usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is “ctrl”
(control), “bulk”, “int” (interrupt), or “iso” (isochronous).
For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint
numbers range from zero to fifteen.  Note that “in” endpoint two
is a different endpoint (and pipe) from “out” endpoint two.
The current configuration controls the existence, type, and
maximum packet size of any given endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt><dd><p>the endpoint’s stream ID for bulk streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>This is read in non-iso completion functions to get the
status of the particular request.  ISO requests only use it
to tell whether the URB was unlinked; detailed status for
each frame is in the fields of the iso_frame-desc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_flags</span></code></dt><dd><p>A variety of flags may be used to affect how URB
submission, unlinking, or operation are handled.  Different
kinds of URB can use different flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_buffer</span></code></dt><dd><p>This identifies the buffer to (or from) which the I/O
request will be performed unless URB_NO_TRANSFER_DMA_MAP is set
(however, do not leave garbage in transfer_buffer even then).
This buffer must be suitable for DMA; allocate it with
<a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or equivalent.  For transfers to “in” endpoints, contents
of this buffer will be modified.  This buffer is used for the data
stage of control transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_dma</span></code></dt><dd><p>When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,
the device driver is saying that it provided this DMA address,
which the host controller driver should use in preference to the
transfer_buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sg</span></code></dt><dd><p>scatter gather buffer list, the buffer size of each element in
the list (except the last) must be divisible by the endpoint’s
max packet size if no_sg_constraint isn’t set in ‘struct usb_bus’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_mapped_sgs</span></code></dt><dd><p>(internal) number of mapped sg entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sgs</span></code></dt><dd><p>number of entries in the sg list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_buffer_length</span></code></dt><dd><p>How big is transfer_buffer.  The transfer may
be broken up into chunks according to the current maximum packet
size for the endpoint, which is a function of the configuration
and is encoded in the pipe.  When the length is zero, neither
transfer_buffer nor transfer_dma is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actual_length</span></code></dt><dd><p>This is read in non-iso completion functions, and
it tells how many bytes (out of transfer_buffer_length) were
transferred.  It will normally be the same as requested, unless
either an error was reported or a short read was performed.
The URB_SHORT_NOT_OK transfer flag may be used to make such
short reads be reported as errors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_packet</span></code></dt><dd><p>Only used for control transfers, this points to eight bytes
of setup data.  Control transfers always start by sending this data
to the device.  Then transfer_buffer is read or written, if needed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_dma</span></code></dt><dd><p>DMA pointer for the setup packet.  The caller must not use
this field; setup_packet must point to a valid buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_frame</span></code></dt><dd><p>Returns the initial frame for isochronous transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">number_of_packets</span></code></dt><dd><p>Lists the number of ISO transfer buffers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interval</span></code></dt><dd><p>Specifies the polling interval for interrupt or isochronous
transfers.  The units are frames (milliseconds) for full and low
speed devices, and microframes (1/8 millisecond) for highspeed
and SuperSpeed devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_count</span></code></dt><dd><p>Returns the number of ISO transfers that reported errors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>For use in completion functions.  This normally points to
request-specific driver context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt><dd><p>Completion handler. This URB is passed as the parameter to the
completion function.  The completion function may then do what
it likes with the URB, including resubmitting or freeing it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iso_frame_desc</span></code></dt><dd><p>Used to provide arrays of ISO transfer buffers and to
collect the transfer status for each buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure identifies USB transfer requests.  URBs must be allocated by
calling <a class="reference internal" href="#c.usb_alloc_urb" title="usb_alloc_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_alloc_urb()</span></code></a> and freed with a call to <a class="reference internal" href="#c.usb_free_urb" title="usb_free_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_free_urb()</span></code></a>.
Initialization may be done using various usb_fill_*_urb() functions.  URBs
are submitted using <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a>, and pending requests may be canceled
using <a class="reference internal" href="#c.usb_unlink_urb" title="usb_unlink_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_unlink_urb()</span></code></a> or <a class="reference internal" href="#c.usb_kill_urb" title="usb_kill_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_kill_urb()</span></code></a>.</p>
<p>Data Transfer Buffers:</p>
<p>Normally drivers provide I/O buffers allocated with <a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or otherwise
taken from the general page pool.  That is provided by transfer_buffer
(control requests also use setup_packet), and host controller drivers
perform a dma mapping (and unmapping) for each buffer transferred.  Those
mapping operations can be expensive on some platforms (perhaps using a dma
bounce buffer or talking to an IOMMU),
although they’re cheap on commodity x86 and ppc hardware.</p>
<p>Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
which tells the host controller driver that no such mapping is needed for
the transfer_buffer since
the device driver is DMA-aware.  For example, a device driver might
allocate a DMA buffer with <a class="reference internal" href="#c.usb_alloc_coherent" title="usb_alloc_coherent"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_alloc_coherent()</span></code></a> or call usb_buffer_map().
When this transfer flag is provided, host controller drivers will
attempt to use the dma address found in the transfer_dma
field rather than determining a dma address themselves.</p>
<p>Note that transfer_buffer must still be set if the controller
does not support DMA (as indicated by hcd_uses_dma()) and when talking
to root hub. If you have to trasfer between highmem zone and the device
on such controller, create a bounce buffer or bail out with an error.
If transfer_buffer cannot be set (is in highmem) and the controller is DMA
capable, assign NULL to it, so that usbmon knows not to use the value.
The setup_packet must always be set, so it cannot be located in highmem.</p>
<p>Initialization:</p>
<p>All URBs submitted must initialize the dev, pipe, transfer_flags (may be
zero), and complete fields.  All URBs must also initialize
transfer_buffer and transfer_buffer_length.  They may provide the
URB_SHORT_NOT_OK transfer flag, indicating that short reads are
to be treated as errors; that flag is invalid for write requests.</p>
<p>Bulk URBs may
use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers
should always terminate with a short packet, even if it means adding an
extra zero length packet.</p>
<p>Control URBs must provide a valid pointer in the setup_packet field.
Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
beforehand.</p>
<p>Interrupt URBs must provide an interval, saying how often (in milliseconds
or, for highspeed devices, 125 microsecond units)
to poll for transfers.  After the URB has been submitted, the interval
field reflects how the transfer was actually scheduled.
The polling interval may be more frequent than requested.
For example, some controllers have a maximum interval of 32 milliseconds,
while others support intervals of up to 1024 milliseconds.
Isochronous URBs also have transfer intervals.  (Note that for isochronous
endpoints, as well as high speed interrupt endpoints, the encoding of
the transfer interval in the endpoint descriptor is logarithmic.
Device drivers must convert that value to linear units themselves.)</p>
<p>If an isochronous endpoint queue isn’t already running, the host
controller will schedule a new URB to start as soon as bandwidth
utilization allows.  If the queue is running then a new URB will be
scheduled to start in the first transfer slot following the end of the
preceding URB, if that slot has not already expired.  If the slot has
expired (which can happen when IRQ delivery is delayed for a long time),
the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
is clear then the URB will be scheduled to start in the expired slot,
implying that some of its packets will not be transferred; if the flag
is set then the URB will be scheduled in the first unexpired slot,
breaking the queue’s synchronization.  Upon URB completion, the
start_frame field will be set to the (micro)frame number in which the
transfer was scheduled.  Ranges for frame counter values are HC-specific
and can go from as low as 256 to as high as 65536 frames.</p>
<p>Isochronous URBs have a different data transfer model, in part because
the quality of service is only “best effort”.  Callers provide specially
allocated URBs, with number_of_packets worth of iso_frame_desc structures
at the end.  Each such packet is an individual ISO transfer.  Isochronous
URBs are normally queued, submitted by drivers to arrange that
transfers are at least double buffered, and then explicitly resubmitted
in completion handlers, so
that data (such as audio or video) streams at as constant a rate as the
host controller scheduler can support.</p>
<p>Completion Callbacks:</p>
<p>The completion callback is made in_interrupt(), and one of the first
things that a completion handler should do is check the status field.
The status field is provided for all URBs.  It is used to report
unlinked URBs, and status for all non-ISO transfers.  It should not
be examined before the URB is returned to the completion handler.</p>
<p>The context field is normally used to link URBs back to the relevant
driver or request state.</p>
<p>When the completion callback is invoked for non-isochronous URBs, the
actual_length field tells how many bytes were transferred.  This field
is updated even when the URB terminated with an error or was unlinked.</p>
<p>ISO transfer status is reported in the status and actual_length fields
of the iso_frame_desc array, and the number of errors is reported in
error_count.  Completion callbacks for ISO transfers will normally
(re)submit URBs to ensure a constant transfer rate.</p>
<p>Note that even fields marked “public” should not be touched by the driver
when the urb is owned by the hcd, that is, since the call to
<a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a> till the entry into the completion routine.</p>
<dl class="c function">
<dt id="c.usb_fill_control_urb">
void <code class="sig-name descname">usb_fill_control_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>pipe</em>, unsigned char *<em>setup_packet</em>, void *<em>transfer_buffer</em>, int <em>buffer_length</em>, usb_complete_t <em>complete_fn</em>, void *<em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_fill_control_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes a control urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a> for this urb.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>the endpoint pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*setup_packet</span></code></dt><dd><p>pointer to the setup_packet buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*transfer_buffer</span></code></dt><dd><p>pointer to the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buffer_length</span></code></dt><dd><p>length of the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb_complete_t</span> <span class="pre">complete_fn</span></code></dt><dd><p>pointer to the usb_complete_t function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>what to set the urb context to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a control urb with the proper information needed to submit
it to a device.</p>
<dl class="c function">
<dt id="c.usb_fill_bulk_urb">
void <code class="sig-name descname">usb_fill_bulk_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>pipe</em>, void *<em>transfer_buffer</em>, int <em>buffer_length</em>, usb_complete_t <em>complete_fn</em>, void *<em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_fill_bulk_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>macro to help initialize a bulk urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a> for this urb.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>the endpoint pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*transfer_buffer</span></code></dt><dd><p>pointer to the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buffer_length</span></code></dt><dd><p>length of the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb_complete_t</span> <span class="pre">complete_fn</span></code></dt><dd><p>pointer to the usb_complete_t function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>what to set the urb context to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a bulk urb with the proper information needed to submit it
to a device.</p>
<dl class="c function">
<dt id="c.usb_fill_int_urb">
void <code class="sig-name descname">usb_fill_int_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>pipe</em>, void *<em>transfer_buffer</em>, int <em>buffer_length</em>, usb_complete_t <em>complete_fn</em>, void *<em>context</em>, int <em>interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_fill_int_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>macro to help initialize a interrupt urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a> for this urb.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>the endpoint pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*transfer_buffer</span></code></dt><dd><p>pointer to the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buffer_length</span></code></dt><dd><p>length of the transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usb_complete_t</span> <span class="pre">complete_fn</span></code></dt><dd><p>pointer to the usb_complete_t function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>what to set the urb context to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">interval</span></code></dt><dd><p>what to set the urb interval to, encoded like
the endpoint descriptor’s bInterval value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a interrupt urb with the proper information needed to submit
it to a device.</p>
<p>Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic
encoding of the endpoint interval, and express polling intervals in
microframes (eight per millisecond) rather than in frames (one per
millisecond).</p>
<p>Wireless USB also uses the logarithmic encoding, but specifies it in units of
128us instead of 125us.  For Wireless USB devices, the interval is passed
through to the host controller, rather than being translated into microframe
units.</p>
<dl class="c function">
<dt id="c.usb_urb_dir_in">
int <code class="sig-name descname">usb_urb_dir_in</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_urb_dir_in" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if an URB describes an IN transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>URB to be checked</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>urb</strong> describes an IN transfer (device-to-host),
otherwise 0.</p>
<dl class="c function">
<dt id="c.usb_urb_dir_out">
int <code class="sig-name descname">usb_urb_dir_out</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_urb_dir_out" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if an URB describes an OUT transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>URB to be checked</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>urb</strong> describes an OUT transfer (host-to-device),
otherwise 0.</p>
<dl class="c struct">
<dt id="c.usb_sg_request">
<em class="property">struct </em><code class="sig-name descname">usb_sg_request</code><a class="headerlink" href="#c.usb_sg_request" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>support for scatter/gather I/O</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_sg_request {
  int status;
  size_t bytes;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>zero indicates success, else negative errno</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>counts bytes transferred.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These requests are initialized using <a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a>, and then are used
as request handles passed to <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a> or <a class="reference internal" href="#c.usb_sg_cancel" title="usb_sg_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_cancel()</span></code></a>.  Most
members of the request object aren’t for driver access.</p>
<p>The status and bytecount values are valid only after <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a>
returns.  If the status is zero, then the bytecount matches the total
from the request.</p>
<p>After an error completion, drivers may need to clear a halt condition
on the endpoint.</p>
</div>
<div class="section" id="usb-core-apis">
<h2>USB Core APIs<a class="headerlink" href="#usb-core-apis" title="Permalink to this headline">¶</a></h2>
<p>There are two basic I/O models in the USB API. The most elemental one is
asynchronous: drivers submit requests in the form of an URB, and the
URB’s completion callback handles the next step. All USB transfer types
support that model, although there are special cases for control URBs
(which always have setup and status stages, but may not have a data
stage) and isochronous URBs (which allow large packets and include
per-packet fault reports). Built on top of that is synchronous API
support, where a driver calls a routine that allocates one or more URBs,
submits them, and waits until they complete. There are synchronous
wrappers for single-buffer control and bulk transfers (which are awkward
to use in some driver disconnect scenarios), and for scatterlist based
streaming i/o (bulk or interrupt).</p>
<p>USB drivers need to provide buffers that can be used for DMA, although
they don’t necessarily need to provide the DMA mapping themselves. There
are APIs to use used when allocating DMA buffers, which can prevent use
of bounce buffers on some systems. In some cases, drivers may be able to
rely on 64bit DMA to eliminate another kind of bounce buffer.</p>
<dl class="c function">
<dt id="c.usb_init_urb">
void <code class="sig-name descname">usb_init_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_init_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes a urb so that it can be used by a USB driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a urb so that the USB subsystem can use it properly.</p>
<p>If a urb is created with a call to <a class="reference internal" href="#c.usb_alloc_urb" title="usb_alloc_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_alloc_urb()</span></code></a> it is not
necessary to call this function.  Only use this if you allocate the
space for a <a class="reference internal" href="#c.urb" title="urb"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span></code></a> on your own.  If you call this function, be
careful when freeing the memory for your urb that it is no longer in
use by the USB core.</p>
<p>Only use this function if you _really_ understand what you are doing.</p>
<dl class="c function">
<dt id="c.usb_alloc_urb">
<em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<code class="sig-name descname">usb_alloc_urb</code><span class="sig-paren">(</span>int <em>iso_packets</em>, gfp_t <em>mem_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_alloc_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>creates a new urb for a USB driver to use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">iso_packets</span></code></dt><dd><p>number of iso packets for this urb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>the type of memory to allocate, see <a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> for a list of
valid options for this.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an urb for the USB driver to use, initializes a few internal
structures, increments the usage counter, and returns a pointer to it.</p>
<p>If the driver want to use this urb for interrupt, control, or bulk
endpoints, pass ‘0’ as the number of iso packets.</p>
<p>The driver must call <a class="reference internal" href="#c.usb_free_urb" title="usb_free_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_free_urb()</span></code></a> when it is finished with the urb.</p>
<p><strong>Return</strong></p>
<p>A pointer to the new urb, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no memory is available.</p>
<dl class="c function">
<dt id="c.usb_free_urb">
void <code class="sig-name descname">usb_free_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_free_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>frees the memory used by a urb when all users of it are finished</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to free, may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a urb is finished with it.  When the last user
of the urb calls this function, the memory of the urb is freed.</p>
<p><strong>Note</strong></p>
<p>The transfer buffer associated with the urb is not freed unless the
URB_FREE_BUFFER transfer flag is set.</p>
<dl class="c function">
<dt id="c.usb_get_urb">
<em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<code class="sig-name descname">usb_get_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increments the reference count of the urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to modify, may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be  called whenever a urb is transferred from a device driver to a
host controller driver.  This allows proper reference counting to happen
for urbs.</p>
<p><strong>Return</strong></p>
<p>A pointer to the urb with the incremented reference counter.</p>
<dl class="c function">
<dt id="c.usb_anchor_urb">
void <code class="sig-name descname">usb_anchor_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, <em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_anchor_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>anchors an URB while it is processed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to anchor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>pointer to the anchor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called to have access to URBs which are to be executed
without bothering to track them</p>
<dl class="c function">
<dt id="c.usb_unanchor_urb">
void <code class="sig-name descname">usb_unanchor_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_unanchor_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unanchors an URB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb to anchor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this to stop the system keeping track of this URB</p>
<dl class="c function">
<dt id="c.usb_pipe_type_check">
int <code class="sig-name descname">usb_pipe_type_check</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_pipe_type_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sanity check of a specific pipe for a usb device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a> to be checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>pipe to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This performs a light-weight sanity check for the endpoint in the
given usb device.  It returns 0 if the pipe is valid for the specific usb
device, otherwise a negative error code.</p>
<dl class="c function">
<dt id="c.usb_urb_ep_type_check">
int <code class="sig-name descname">usb_urb_ep_type_check</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_urb_ep_type_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sanity check of endpoint in the given urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>urb to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This performs a light-weight sanity check for the endpoint in the
given urb.  It returns 0 if the urb contains a valid endpoint, otherwise
a negative error code.</p>
<dl class="c function">
<dt id="c.usb_submit_urb">
int <code class="sig-name descname">usb_submit_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, gfp_t <em>mem_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_submit_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>issue an asynchronous transfer request for an endpoint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to the urb describing the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>the type of memory to allocate, see <a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> for a list
of valid options for this.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This submits a transfer request, and transfers control of the URB
describing that request to the USB subsystem.  Request completion will
be indicated later, asynchronously, by calling the completion handler.
The three types of completion are success, error, and unlink
(a software-induced fault, also called “request cancellation”).</p>
<p>URBs may be submitted in interrupt context.</p>
<p>The caller must have correctly initialized the URB before submitting
it.  Functions such as <a class="reference internal" href="#c.usb_fill_bulk_urb" title="usb_fill_bulk_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_fill_bulk_urb()</span></code></a> and <a class="reference internal" href="#c.usb_fill_control_urb" title="usb_fill_control_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_fill_control_urb()</span></code></a> are
available to ensure that most fields are correctly initialized, for
the particular kind of transfer, although they will not initialize
any transfer flags.</p>
<p>If the submission is successful, the complete() callback from the URB
will be called exactly once, when the USB core and Host Controller Driver
(HCD) are finished with the URB.  When the completion function is called,
control of the URB is returned to the device driver which issued the
request.  The completion handler may then immediately free or reuse that
URB.</p>
<p>With few exceptions, USB device drivers should never access URB fields
provided by usbcore or the HCD until its complete() is called.
The exceptions relate to periodic transfer scheduling.  For both
interrupt and isochronous urbs, as part of successful URB submission
urb-&gt;interval is modified to reflect the actual transfer period used
(normally some power of two units).  And for isochronous urbs,
urb-&gt;start_frame is modified to reflect when the URB’s transfers were
scheduled to start.</p>
<p>Not all isochronous transfer scheduling policies will work, but most
host controller drivers should easily handle ISO queues going from now
until 10-200 msec into the future.  Drivers should try to keep at
least one or two msec of data in the queue; many controllers require
that new transfers start at least 1 msec in the future when they are
added.  If the driver is unable to keep up and the queue empties out,
the behavior for new submissions is governed by the URB_ISO_ASAP flag.
If the flag is set, or if the queue is idle, then the URB is always
assigned to the first available (and not yet expired) slot in the
endpoint’s schedule.  If the flag is not set and the queue is active
then the URB is always assigned to the next slot in the schedule
following the end of the endpoint’s previous URB, even if that slot is
in the past.  When a packet is assigned in this way to a slot that has
already expired, the packet is not transmitted and the corresponding
usb_iso_packet_descriptor’s status field will return -EXDEV.  If this
would happen to all the packets in the URB, submission fails with a
-EXDEV error code.</p>
<p>For control endpoints, the synchronous <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> call is
often used (in non-interrupt context) instead of this call.
That is often used through convenience wrappers, for the requests
that are standardized in the USB 2.0 specification.  For bulk
endpoints, a synchronous <a class="reference internal" href="#c.usb_bulk_msg" title="usb_bulk_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_bulk_msg()</span></code></a> call is available.</p>
<p>Request Queuing:</p>
<p>URBs may be submitted to endpoints before previous ones complete, to
minimize the impact of interrupt latencies and system overhead on data
throughput.  With that queuing policy, an endpoint’s queue would never
be empty.  This is required for continuous isochronous data streams,
and may also be required for some kinds of interrupt transfers. Such
queuing also maximizes bandwidth utilization by letting USB controllers
start work on later requests before driver software has finished the
completion processing for earlier (successful) requests.</p>
<p>As of Linux 2.6, all USB endpoint transfer queues support depths greater
than one.  This was previously a HCD-specific behavior, except for ISO
transfers.  Non-isochronous endpoint queues are inactive during cleanup
after faults (transfer errors or cancellation).</p>
<p>Reserved Bandwidth Transfers:</p>
<p>Periodic transfers (interrupt or isochronous) are performed repeatedly,
using the interval specified in the urb.  Submitting the first urb to
the endpoint reserves the bandwidth necessary to make those transfers.
If the USB subsystem can’t allocate sufficient bandwidth to perform
the periodic request, submitting such a periodic request should fail.</p>
<p>For devices under xHCI, the bandwidth is reserved at configuration time, or
when the alt setting is selected.  If there is not enough bus bandwidth, the
configuration/alt setting request will fail.  Therefore, submissions to
periodic endpoints on devices under xHCI should never fail due to bandwidth
constraints.</p>
<p>Device drivers must explicitly request that repetition, by ensuring that
some URB is always on the endpoint’s queue (except possibly for short
periods during completion callbacks).  When there is no longer an urb
queued, the endpoint’s bandwidth reservation is canceled.  This means
drivers can use their completion handlers to ensure they keep bandwidth
they need, by reinitializing and resubmitting the just-completed urb
until the driver longer needs that periodic bandwidth.</p>
<p>Memory Flags:</p>
<p>The general rules for how to decide which mem_flags to use
are the same as for kmalloc.  There are four
different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and
GFP_ATOMIC.</p>
<p>GFP_NOFS is not ever used, as it has not been implemented yet.</p>
<dl class="simple">
<dt>GFP_ATOMIC is used when</dt><dd><ol class="loweralpha simple">
<li><p>you are inside a completion handler, an interrupt, bottom half,
tasklet or timer, or</p></li>
<li><p>you are holding a spinlock or rwlock (does not apply to
semaphores), or</p></li>
<li><p>current-&gt;state != TASK_RUNNING, this is the case only after
you’ve changed it.</p></li>
</ol>
</dd>
</dl>
<p>GFP_NOIO is used in the block io path and error handling of storage
devices.</p>
<p>All other situations use GFP_KERNEL.</p>
<dl class="simple">
<dt>Some more specific rules for mem_flags can be inferred, such as</dt><dd><ol class="arabic simple">
<li><p>start_xmit, timeout, and receive methods of network drivers must
use GFP_ATOMIC (they are called with a spinlock held);</p></li>
<li><p>queuecommand methods of scsi drivers must use GFP_ATOMIC (also
called with a spinlock held);</p></li>
<li><p>If you use a kernel thread with a network driver you must use
GFP_NOIO, unless (b) or (c) apply;</p></li>
<li><p>after you have done a down() you can use GFP_KERNEL, unless (b) or (c)
apply or your are in a storage driver’s block io path;</p></li>
<li><p>USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and</p></li>
<li><p>changing firmware on a running storage or net device uses
GFP_NOIO, unless b) or c) apply</p></li>
</ol>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on successful submissions. A negative error number otherwise.</p>
<dl class="c function">
<dt id="c.usb_unlink_urb">
int <code class="sig-name descname">usb_unlink_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_unlink_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>abort/cancel a transfer request for an endpoint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to urb describing a previously submitted request,
may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine cancels an in-progress request.  URBs complete only once
per submission, and may be canceled only once per submission.
Successful cancellation means termination of <strong>urb</strong> will be expedited
and the completion handler will be called with a status code
indicating that the request has been canceled (rather than any other
code).</p>
<p>Drivers should not call this routine or related routines, such as
<a class="reference internal" href="#c.usb_kill_urb" title="usb_kill_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_kill_urb()</span></code></a> or <a class="reference internal" href="#c.usb_unlink_anchored_urbs" title="usb_unlink_anchored_urbs"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_unlink_anchored_urbs()</span></code></a>, after their disconnect
method has returned.  The disconnect function should synchronize with
a driver’s I/O routines to insure that all URB-related activity has
completed before it returns.</p>
<p>This request is asynchronous, however the HCD might call the -&gt;complete()
callback during unlink. Therefore when drivers call <a class="reference internal" href="#c.usb_unlink_urb" title="usb_unlink_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_unlink_urb()</span></code></a>, they
must not hold any locks that may be taken by the completion function.
Success is indicated by returning -EINPROGRESS, at which time the URB will
probably not yet have been given back to the device driver. When it is
eventually called, the completion function will see <strong>urb-&gt;status</strong> ==
-ECONNRESET.
Failure is indicated by <a class="reference internal" href="#c.usb_unlink_urb" title="usb_unlink_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_unlink_urb()</span></code></a> returning any other value.
Unlinking will fail when <strong>urb</strong> is not currently “linked” (i.e., it was
never submitted, or it was unlinked before, or the hardware is already
finished with it), even if the completion handler has not yet run.</p>
<p>The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.</p>
<p>Unlinking and Endpoint Queues:</p>
<p>[The behaviors and guarantees described below do not apply to virtual
root hubs but only to endpoint queues for physical USB devices.]</p>
<p>Host Controller Drivers (HCDs) place all the URBs for a particular
endpoint in a queue.  Normally the queue advances as the controller
hardware processes each request.  But when an URB terminates with an
error its queue generally stops (see below), at least until that URB’s
completion routine returns.  It is guaranteed that a stopped queue
will not restart until all its unlinked URBs have been fully retired,
with their completion routines run, even if that’s not until some time
after the original completion handler returns.  The same behavior and
guarantee apply when an URB terminates because it was unlinked.</p>
<p>Bulk and interrupt endpoint queues are guaranteed to stop whenever an
URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
and -EREMOTEIO.  Control endpoint queues behave the same way except
that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
for isochronous endpoints are treated differently, because they must
advance at fixed rates.  Such queues do not stop when an URB
encounters an error or is unlinked.  An unlinked isochronous URB may
leave a gap in the stream of packets; it is undefined whether such
gaps can be filled in.</p>
<p>Note that early termination of an URB because a short packet was
received will generate a -EREMOTEIO error if and only if the
URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device
drivers can build deep queues for large or complex bulk transfers
and clean them up reliably after any sort of aborted transfer by
unlinking all pending URBs at the first fault.</p>
<p>When a control URB terminates with an error other than -EREMOTEIO, it
is quite likely that the status stage of the transfer will not take
place.</p>
<p><strong>Return</strong></p>
<p>-EINPROGRESS on success. See description for other values on
failure.</p>
<dl class="c function">
<dt id="c.usb_kill_urb">
void <code class="sig-name descname">usb_kill_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_kill_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel a transfer request and wait for it to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to URB describing a previously submitted request,
may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine cancels an in-progress request.  It is guaranteed that
upon return all completion handlers will have finished and the URB
will be totally idle and available for reuse.  These features make
this an ideal way to stop I/O in a disconnect() callback or close()
function.  If the request has not already finished or been unlinked
the completion handler will see urb-&gt;status == -ENOENT.</p>
<p>While the routine is running, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB’s completion handler always
tries to resubmit, it will not succeed and the URB will become idle.</p>
<p>The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.</p>
<p>This routine may not be used in an interrupt context (such as a bottom
half or a completion handler), or when holding a spinlock, or in other
situations where the caller can’t schedule().</p>
<p>This routine should not be called by a driver after its disconnect
method has returned.</p>
<dl class="c function">
<dt id="c.usb_poison_urb">
void <code class="sig-name descname">usb_poison_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_poison_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reliably kill a transfer and prevent further use of an URB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to URB describing a previously submitted request,
may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine cancels an in-progress request.  It is guaranteed that
upon return all completion handlers will have finished and the URB
will be totally idle and cannot be reused.  These features make
this an ideal way to stop I/O in a disconnect() callback.
If the request has not already finished or been unlinked
the completion handler will see urb-&gt;status == -ENOENT.</p>
<p>After and while the routine runs, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB’s completion handler always
tries to resubmit, it will not succeed and the URB will become idle.</p>
<p>The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.</p>
<p>This routine may not be used in an interrupt context (such as a bottom
half or a completion handler), or when holding a spinlock, or in other
situations where the caller can’t schedule().</p>
<p>This routine should not be called by a driver after its disconnect
method has returned.</p>
<dl class="c function">
<dt id="c.usb_block_urb">
void <code class="sig-name descname">usb_block_urb</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_block_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reliably prevent further use of an URB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>pointer to URB to be blocked, may be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After the routine has run, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB’s completion handler always
tries to resubmit, it will not succeed and the URB will become idle.</p>
<p>The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.</p>
<dl class="c function">
<dt id="c.usb_kill_anchored_urbs">
void <code class="sig-name descname">usb_kill_anchored_urbs</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_kill_anchored_urbs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>kill all URBs associated with an anchor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>anchor the requests are bound to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This kills all outstanding URBs starting from the back of the queue,
with guarantee that no completer callbacks will take place from the
anchor after this function returns.</p>
<p>This routine should not be called by a driver after its disconnect
method has returned.</p>
<dl class="c function">
<dt id="c.usb_poison_anchored_urbs">
void <code class="sig-name descname">usb_poison_anchored_urbs</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_poison_anchored_urbs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cease all traffic from an anchor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>anchor the requests are bound to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this allows all outstanding URBs to be poisoned starting
from the back of the queue. Newly added URBs will also be
poisoned</p>
<p>This routine should not be called by a driver after its disconnect
method has returned.</p>
<dl class="c function">
<dt id="c.usb_unpoison_anchored_urbs">
void <code class="sig-name descname">usb_unpoison_anchored_urbs</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_unpoison_anchored_urbs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>let an anchor be used successfully again</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>anchor the requests are bound to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses the effect of usb_poison_anchored_urbs
the anchor can be used normally after it returns</p>
<dl class="c function">
<dt id="c.usb_unlink_anchored_urbs">
void <code class="sig-name descname">usb_unlink_anchored_urbs</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_unlink_anchored_urbs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>asynchronously cancel transfer requests en masse</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>anchor the requests are bound to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this allows all outstanding URBs to be unlinked starting
from the back of the queue. This function is asynchronous.
The unlinking is just triggered. It may happen after this
function has returned.</p>
<p>This routine should not be called by a driver after its disconnect
method has returned.</p>
<dl class="c function">
<dt id="c.usb_anchor_suspend_wakeups">
void <code class="sig-name descname">usb_anchor_suspend_wakeups</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_anchor_suspend_wakeups" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor you want to suspend wakeups on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this to stop the last urb being unanchored from waking up any
usb_wait_anchor_empty_timeout waiters. This is used in the hcd urb give-
back path to delay waking up until after the completion handler has run.</p>
<dl class="c function">
<dt id="c.usb_anchor_resume_wakeups">
void <code class="sig-name descname">usb_anchor_resume_wakeups</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_anchor_resume_wakeups" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor you want to resume wakeups on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow usb_wait_anchor_empty_timeout waiters to be woken up again, and
wake up any current waiters if the anchor is empty.</p>
<dl class="c function">
<dt id="c.usb_wait_anchor_empty_timeout">
int <code class="sig-name descname">usb_wait_anchor_empty_timeout</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em>, unsigned int <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_wait_anchor_empty_timeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for an anchor to be unused</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor you want to become unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>how long you are willing to wait in milliseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this is you want to be sure all an anchor’s
URBs have finished</p>
<p><strong>Return</strong></p>
<p>Non-zero if the anchor became unused. Zero on timeout.</p>
<dl class="c function">
<dt id="c.usb_get_from_anchor">
<em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<code class="sig-name descname">usb_get_from_anchor</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_from_anchor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get an anchor’s oldest urb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor whose urb you want</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will take the oldest urb from an anchor,
unanchor and return it</p>
<p><strong>Return</strong></p>
<p>The oldest urb from <strong>anchor</strong>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if <strong>anchor</strong> has no
urbs associated with it.</p>
<dl class="c function">
<dt id="c.usb_scuttle_anchored_urbs">
void <code class="sig-name descname">usb_scuttle_anchored_urbs</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_scuttle_anchored_urbs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unanchor all an anchor’s urbs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor whose urbs you want to unanchor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>use this to get rid of all an anchor’s urbs</p>
<dl class="c function">
<dt id="c.usb_anchor_empty">
int <code class="sig-name descname">usb_anchor_empty</code><span class="sig-paren">(</span><em class="property">struct</em> usb_anchor *<em>anchor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_anchor_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is an anchor empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_anchor</span> <span class="pre">*anchor</span></code></dt><dd><p>the anchor you want to query</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the anchor has no urbs associated with it.</p>
<dl class="c function">
<dt id="c.usb_control_msg">
int <code class="sig-name descname">usb_control_msg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>pipe</em>, __u8 <em>request</em>, __u8 <em>requesttype</em>, __u16 <em>value</em>, __u16 <em>index</em>, void *<em>data</em>, __u16 <em>size</em>, int <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_control_msg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builds a control urb, sends it off and waits for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the usb device to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>endpoint “pipe” to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">request</span></code></dt><dd><p>USB message request value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">requesttype</span></code></dt><dd><p>USB message request type value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">value</span></code></dt><dd><p>USB message value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">index</span></code></dt><dd><p>USB message index value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">size</span></code></dt><dd><p>length in bytes of the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>time in msecs to wait for the message to complete before timing
out (if 0 the wait is forever)</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function sends a simple control message to a specified endpoint and
waits for the message to complete, or timeout.</p>
<p>Don’t use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a>. If a thread in your driver uses this call,
make sure your disconnect() method can wait for it to complete. Since you
don’t have a handle on the URB used, you can’t cancel the request.</p>
<p><strong>Return</strong></p>
<p>If successful, the number of bytes transferred. Otherwise, a negative
error number.</p>
<dl class="c function">
<dt id="c.usb_control_msg_send">
int <code class="sig-name descname">usb_control_msg_send</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, __u8 <em>endpoint</em>, __u8 <em>request</em>, __u8 <em>requesttype</em>, __u16 <em>value</em>, __u16 <em>index</em>, <em class="property">const</em> void *<em>driver_data</em>, __u16 <em>size</em>, int <em>timeout</em>, gfp_t <em>memflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_control_msg_send" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builds a control “send” message, sends it off and waits for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the usb device to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">request</span></code></dt><dd><p>USB message request value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">requesttype</span></code></dt><dd><p>USB message request type value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">value</span></code></dt><dd><p>USB message value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">index</span></code></dt><dd><p>USB message index value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*driver_data</span></code></dt><dd><p>pointer to the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">size</span></code></dt><dd><p>length in bytes of the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>time in msecs to wait for the message to complete before timing
out (if 0 the wait is forever)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">memflags</span></code></dt><dd><p>the flags for memory allocation for buffers</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function sends a control message to a specified endpoint that is not
expected to fill in a response (i.e. a “send message”) and waits for the
message to complete, or timeout.</p>
<p>Do not use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a>. If a thread in your driver uses this call,
make sure your disconnect() method can wait for it to complete. Since you
don’t have a handle on the URB used, you can’t cancel the request.</p>
<p>The data pointer can be made to a reference on the stack, or anywhere else,
as it will not be modified at all.  This does not have the restriction that
<a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> has where the data pointer must be to dynamically allocated
memory (i.e. memory that can be successfully DMAed to a device).</p>
<p><strong>Return</strong></p>
<p>If successful, 0 is returned, Otherwise, a negative error number.</p>
<dl class="c function">
<dt id="c.usb_control_msg_recv">
int <code class="sig-name descname">usb_control_msg_recv</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, __u8 <em>endpoint</em>, __u8 <em>request</em>, __u8 <em>requesttype</em>, __u16 <em>value</em>, __u16 <em>index</em>, void *<em>driver_data</em>, __u16 <em>size</em>, int <em>timeout</em>, gfp_t <em>memflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_control_msg_recv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builds a control “receive” message, sends it off and waits for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the usb device to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">request</span></code></dt><dd><p>USB message request value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">requesttype</span></code></dt><dd><p>USB message request type value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">value</span></code></dt><dd><p>USB message value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">index</span></code></dt><dd><p>USB message index value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*driver_data</span></code></dt><dd><p>pointer to the data to be filled in by the message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">size</span></code></dt><dd><p>length in bytes of the data to be received</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>time in msecs to wait for the message to complete before timing
out (if 0 the wait is forever)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">memflags</span></code></dt><dd><p>the flags for memory allocation for buffers</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function sends a control message to a specified endpoint that is
expected to fill in a response (i.e. a “receive message”) and waits for the
message to complete, or timeout.</p>
<p>Do not use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a>. If a thread in your driver uses this call,
make sure your disconnect() method can wait for it to complete. Since you
don’t have a handle on the URB used, you can’t cancel the request.</p>
<p>The data pointer can be made to a reference on the stack, or anywhere else
that can be successfully written to.  This function does not have the
restriction that <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> has where the data pointer must be to
dynamically allocated memory (i.e. memory that can be successfully DMAed to a
device).</p>
<p>The “whole” message must be properly received from the device in order for
this function to be successful.  If a device returns less than the expected
amount of data, then the function will fail.  Do not use this for messages
where a variable amount of data might be returned.</p>
<p><strong>Return</strong></p>
<p>If successful, 0 is returned, Otherwise, a negative error number.</p>
<dl class="c function">
<dt id="c.usb_interrupt_msg">
int <code class="sig-name descname">usb_interrupt_msg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>usb_dev</em>, unsigned int <em>pipe</em>, void *<em>data</em>, int <em>len</em>, int *<em>actual_length</em>, int <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_interrupt_msg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builds an interrupt urb, sends it off and waits for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*usb_dev</span></code></dt><dd><p>pointer to the usb device to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>endpoint “pipe” to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length in bytes of the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*actual_length</span></code></dt><dd><p>pointer to a location to put the actual length transferred
in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function sends a simple interrupt message to a specified endpoint and
waits for the message to complete, or timeout.</p>
<p>Don’t use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a> If a thread in your driver uses this call,
make sure your disconnect() method can wait for it to complete. Since you
don’t have a handle on the URB used, you can’t cancel the request.</p>
<p><strong>Return</strong></p>
<p>If successful, 0. Otherwise a negative error number. The number of actual
bytes transferred will be stored in the <strong>actual_length</strong> parameter.</p>
<dl class="c function">
<dt id="c.usb_bulk_msg">
int <code class="sig-name descname">usb_bulk_msg</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>usb_dev</em>, unsigned int <em>pipe</em>, void *<em>data</em>, int <em>len</em>, int *<em>actual_length</em>, int <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_bulk_msg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Builds a bulk urb, sends it off and waits for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*usb_dev</span></code></dt><dd><p>pointer to the usb device to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>endpoint “pipe” to send the message to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length in bytes of the data to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*actual_length</span></code></dt><dd><p>pointer to a location to put the actual length transferred
in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function sends a simple bulk message to a specified endpoint
and waits for the message to complete, or timeout.</p>
<p>Don’t use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use <a class="reference internal" href="#c.usb_submit_urb" title="usb_submit_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_submit_urb()</span></code></a> If a thread in your driver uses this call,
make sure your disconnect() method can wait for it to complete. Since you
don’t have a handle on the URB used, you can’t cancel the request.</p>
<p>Because there is no <a class="reference internal" href="#c.usb_interrupt_msg" title="usb_interrupt_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_interrupt_msg()</span></code></a> and no USBDEVFS_INTERRUPT ioctl,
users are forced to abuse this routine by using it to submit URBs for
interrupt endpoints.  We will take the liberty of creating an interrupt URB
(with the default interval) if the target is an interrupt endpoint.</p>
<p><strong>Return</strong></p>
<p>If successful, 0. Otherwise a negative error number. The number of actual
bytes transferred will be stored in the <strong>actual_length</strong> parameter.</p>
<dl class="c function">
<dt id="c.usb_sg_init">
int <code class="sig-name descname">usb_sg_init</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_sg_request" title="usb_sg_request">usb_sg_request</a> *<em>io</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned <em>pipe</em>, unsigned <em>period</em>, <em class="property">struct</em> scatterlist *<em>sg</em>, int <em>nents</em>, size_t <em>length</em>, gfp_t <em>mem_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_sg_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes scatterlist-based bulk/interrupt I/O request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_sg_request</span> <span class="pre">*io</span></code></dt><dd><p>request block being initialized.  until <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a> returns,
treat this as a pointer to an opaque block of memory,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the usb device that will send or receive the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">pipe</span></code></dt><dd><p>endpoint “pipe” used to transfer the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">period</span></code></dt><dd><p>polling rate for interrupt endpoints, in frames or
(for high speed endpoints) microframes; ignored for bulk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sg</span></code></dt><dd><p>scatterlist entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt><dd><p>how many entries in the scatterlist</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>how many bytes to send from the scatterlist, or zero to
send every byte identified in the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>SLAB_* flags affecting memory allocations in this call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This initializes a scatter/gather request, allocating resources such as
I/O mappings and urb memory (except maybe memory used by USB controller
drivers).</p>
<p>The request must be issued using <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a>, which waits for the I/O to
complete (or to be canceled) and then cleans up all resources allocated by
<a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a>.</p>
<p>The request may be canceled with <a class="reference internal" href="#c.usb_sg_cancel" title="usb_sg_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_cancel()</span></code></a>, either before or after
<a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a> is called.</p>
<p><strong>Return</strong></p>
<p>Zero for success, else a negative errno value.</p>
<dl class="c function">
<dt id="c.usb_sg_wait">
void <code class="sig-name descname">usb_sg_wait</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_sg_request" title="usb_sg_request">usb_sg_request</a> *<em>io</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_sg_wait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>synchronously execute scatter/gather request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_sg_request</span> <span class="pre">*io</span></code></dt><dd><p>request block handle, as initialized with <a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a>.
some fields become accessible when this call returns.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This function blocks until the specified I/O operation completes.  It
leverages the grouping of the related I/O requests to get good transfer
rates, by queueing the requests.  At higher speeds, such queuing can
significantly improve USB throughput.</p>
<p>There are three kinds of completion for this function.</p>
<ol class="arabic simple">
<li><p>success, where io-&gt;status is zero.  The number of io-&gt;bytes
transferred is as requested.</p></li>
<li><p>error, where io-&gt;status is a negative errno value.  The number
of io-&gt;bytes transferred before the error is usually less
than requested, and can be nonzero.</p></li>
<li><p>cancellation, a type of error with status -ECONNRESET that
is initiated by <a class="reference internal" href="#c.usb_sg_cancel" title="usb_sg_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_cancel()</span></code></a>.</p></li>
</ol>
<p>When this function returns, all memory allocated through <a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a> or
this call will have been freed.  The request block parameter may still be
passed to <a class="reference internal" href="#c.usb_sg_cancel" title="usb_sg_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_cancel()</span></code></a>, or it may be freed.  It could also be
reinitialized and then reused.</p>
<p>Data Transfer Rates:</p>
<p>Bulk transfers are valid for full or high speed endpoints.
The best full speed data rate is 19 packets of 64 bytes each
per frame, or 1216 bytes per millisecond.
The best high speed data rate is 13 packets of 512 bytes each
per microframe, or 52 KBytes per millisecond.</p>
<p>The reason to use interrupt transfers through this API would most likely
be to reserve high speed bandwidth, where up to 24 KBytes per millisecond
could be transferred.  That capability is less useful for low or full
speed interrupt endpoints, which allow at most one packet per millisecond,
of at most 8 or 64 bytes (respectively).</p>
<p>It is not necessary to call this function to reserve bandwidth for devices
under an xHCI host controller, as the bandwidth is reserved when the
configuration or interface alt setting is selected.</p>
<dl class="c function">
<dt id="c.usb_sg_cancel">
void <code class="sig-name descname">usb_sg_cancel</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_sg_request" title="usb_sg_request">usb_sg_request</a> *<em>io</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_sg_cancel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stop scatter/gather i/o issued by <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_sg_request</span> <span class="pre">*io</span></code></dt><dd><p>request block, initialized with <a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This stops a request after it has been started by <a class="reference internal" href="#c.usb_sg_wait" title="usb_sg_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_wait()</span></code></a>.
It can also prevents one initialized by <a class="reference internal" href="#c.usb_sg_init" title="usb_sg_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_sg_init()</span></code></a> from starting,
so that call just frees resources allocated to the request.</p>
<dl class="c function">
<dt id="c.usb_get_descriptor">
int <code class="sig-name descname">usb_get_descriptor</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned char <em>type</em>, unsigned char <em>index</em>, void *<em>buf</em>, int <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_descriptor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>issues a generic GET_DESCRIPTOR request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose descriptor is being retrieved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">type</span></code></dt><dd><p>the descriptor type (USB_DT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">index</span></code></dt><dd><p>the number of the descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>how big is “buf”?</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>Gets a USB descriptor.  Convenience functions exist to simplify
getting some types of descriptors.  Use
usb_get_string() or <a class="reference internal" href="gadget.html#c.usb_string" title="usb_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string()</span></code></a> for USB_DT_STRING.
Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)
are part of the device structure.
In addition to a number of USB-standard descriptors, some
devices also use class-specific or vendor-specific descriptors.</p>
<p>This call is synchronous, and may not be used in an interrupt context.</p>
<p><strong>Return</strong></p>
<p>The number of bytes received on success, or else the status code
returned by the underlying <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> call.</p>
<dl class="c function">
<dt id="c.usb_string">
int <code class="sig-name descname">usb_string</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, int <em>index</em>, char *<em>buf</em>, size_t <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>returns UTF-8 version of a string descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose string descriptor is being retrieved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>the number of the descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how big is “buf”?</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This converts the UTF-16LE encoded strings returned by devices, from
usb_get_string_descriptor(), to null-terminated UTF-8 encoded ones
that are more usable in most kernel contexts.  Note that this function
chooses strings in the first language supported by the device.</p>
<p>This call is synchronous, and may not be used in an interrupt context.</p>
<p><strong>Return</strong></p>
<p>length of the string (&gt;= 0) or usb_control_msg status (&lt; 0).</p>
<dl class="c function">
<dt id="c.usb_get_status">
int <code class="sig-name descname">usb_get_status</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, int <em>recip</em>, int <em>type</em>, int <em>target</em>, void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_status" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>issues a GET_STATUS call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose status is being checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">recip</span></code></dt><dd><p>USB_RECIP_*; for device, interface, or endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>USB_STATUS_TYPE_*; for standard or PTM status types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">target</span></code></dt><dd><p>zero (for device), else interface or endpoint number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to two bytes of bitmap data</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>Returns device, interface, or endpoint status.  Normally only of
interest to see if the device is self powered, or has enabled the
remote wakeup facility; or whether a bulk or interrupt endpoint
is halted (“stalled”).</p>
<p>Bits in these status bitmaps are set using the SET_FEATURE request,
and cleared using the CLEAR_FEATURE request.  The <a class="reference internal" href="#c.usb_clear_halt" title="usb_clear_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_clear_halt()</span></code></a>
function should be used to clear halt (“stall”) status.</p>
<p>This call is synchronous, and may not be used in an interrupt context.</p>
<p>Returns 0 and the status value in <strong>*data</strong> (in host byte order) on success,
or else the status code from the underlying <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> call.</p>
<dl class="c function">
<dt id="c.usb_clear_halt">
int <code class="sig-name descname">usb_clear_halt</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, int <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_clear_halt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tells device to clear endpoint halt/stall condition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>device whose endpoint is halted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pipe</span></code></dt><dd><p>endpoint “pipe” being cleared</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This is used to clear halt conditions for bulk and interrupt endpoints,
as reported by URB completion status.  Endpoints that are halted are
sometimes referred to as being “stalled”.  Such endpoints are unable
to transmit or receive data until the halt status is cleared.  Any URBs
queued for such an endpoint should normally be unlinked by the driver
before clearing the halt condition, as described in sections 5.7.5
and 5.8.5 of the USB 2.0 spec.</p>
<p>Note that control and isochronous endpoints don’t halt, although control
endpoints report “protocol stall” (for unsupported requests) using the
same status code used to report a true stall.</p>
<p>This call is synchronous, and may not be used in an interrupt context.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or else the status code returned by the
underlying <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> call.</p>
<dl class="c function">
<dt id="c.usb_reset_endpoint">
void <code class="sig-name descname">usb_reset_endpoint</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned int <em>epaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_reset_endpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset an endpoint’s state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose endpoint is to be reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">epaddr</span></code></dt><dd><p>the endpoint’s address.  Endpoint number for output,
endpoint number + USB_DIR_IN for input</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets any host-side endpoint state such as the toggle bit,
sequence number or current window.</p>
<dl class="c function">
<dt id="c.usb_set_interface">
int <code class="sig-name descname">usb_set_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, int <em>interface</em>, int <em>alternate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_set_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Makes a particular alternate setting be current</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose interface is being updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">interface</span></code></dt><dd><p>the interface being updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alternate</span></code></dt><dd><p>the setting being chosen.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt ()</p>
<p><strong>Description</strong></p>
<p>This is used to enable data transfers on interfaces that may not
be enabled by default.  Not all devices support such configurability.
Only the driver bound to an interface may change its setting.</p>
<p>Within any given configuration, each interface may have several
alternative settings.  These are often used to control levels of
bandwidth consumption.  For example, the default setting for a high
speed interrupt endpoint may not send more than 64 bytes per microframe,
while interrupt transfers of up to 3KBytes per microframe are legal.
Also, isochronous endpoints may never be part of an
interface’s default setting.  To access such bandwidth, alternate
interface settings must be made current.</p>
<p>Note that in the Linux USB subsystem, bandwidth associated with
an endpoint in a given alternate setting is not reserved until an URB
is submitted that needs that bandwidth.  Some other operating systems
allocate bandwidth early, when a configuration is chosen.</p>
<p>xHCI reserves bandwidth and configures the alternate setting in
usb_hcd_alloc_bandwidth(). If it fails the original interface altsetting
may be disabled. Drivers cannot rely on any particular alternate
setting being in effect after a failure.</p>
<p>This call is synchronous, and may not be used in an interrupt context.
Also, drivers must not change altsettings while urbs are scheduled for
endpoints in that interface; all such urbs must first be completed
(perhaps forced by unlinking).</p>
<p><strong>Return</strong></p>
<p>Zero on success, or else the status code returned by the
underlying <a class="reference internal" href="#c.usb_control_msg" title="usb_control_msg"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_control_msg()</span></code></a> call.</p>
<dl class="c function">
<dt id="c.usb_reset_configuration">
int <code class="sig-name descname">usb_reset_configuration</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_reset_configuration" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lightweight device reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose configuration is being reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This issues a standard SET_CONFIGURATION request to the device using
the current configuration.  The effect is to reset most USB-related
state in the device, including interface altsettings (reset to zero),
endpoint halts (cleared), and endpoint state (only for bulk and interrupt
endpoints).  Other usbcore state is unchanged, including bindings of
usb device drivers to interfaces.</p>
<p>Because this affects multiple interfaces, avoid using this with composite
(multi-interface) devices.  Instead, the driver for each interface may
use <a class="reference internal" href="#c.usb_set_interface" title="usb_set_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_set_interface()</span></code></a> on the interfaces it claims.  Be careful though;
some devices don’t support the SET_INTERFACE request, and others won’t
reset all the interface state (notably endpoint state).  Resetting the whole
configuration would affect other drivers’ interfaces.</p>
<p>The caller must own the device lock.</p>
<p>If this routine fails the device will probably be in an unusable state
with endpoints disabled, and interfaces only partially enabled.</p>
<p><strong>Return</strong></p>
<p>Zero on success, else a negative error code.</p>
<dl class="c function">
<dt id="c.usb_driver_set_configuration">
int <code class="sig-name descname">usb_driver_set_configuration</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em>, int <em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_driver_set_configuration" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provide a way for drivers to change device configurations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>the device whose configuration is being updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">config</span></code></dt><dd><p>the configuration being chosen.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>In process context, must be able to sleep</p>
<p><strong>Description</strong></p>
<p>Device interface drivers are not allowed to change device configurations.
This is because changing configurations will destroy the interface the
driver is bound to and create new ones; it would be like a floppy-disk
driver telling the computer to replace the floppy-disk drive with a
tape drive!</p>
<p>Still, in certain specialized circumstances the need may arise.  This
routine gets around the normal restrictions by using a work thread to
submit the change-config request.</p>
<p><strong>Return</strong></p>
<p>0 if the request was successfully queued, error code otherwise.
The caller has no way to know whether the queued request will eventually
succeed.</p>
<dl class="c function">
<dt id="c.cdc_parse_cdc_header">
int <code class="sig-name descname">cdc_parse_cdc_header</code><span class="sig-paren">(</span><em class="property">struct</em> usb_cdc_parsed_header *<em>hdr</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em>, u8 *<em>buffer</em>, int <em>buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdc_parse_cdc_header" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>parse the extra headers present in CDC devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_cdc_parsed_header</span> <span class="pre">*hdr</span></code></dt><dd><p>the place to put the results of the parsing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the interface for which parsing is requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buffer</span></code></dt><dd><p>pointer to the extra headers to be parsed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>length of the extra headers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This evaluates the extra headers present in CDC devices which
bind the interfaces for data and control and provide details
about the capabilities of the device.</p>
<p><strong>Return</strong></p>
<p>number of descriptors parsed or -EINVAL
if the header is contradictory beyond salvage</p>
<dl class="c function">
<dt id="c.usb_register_dev">
int <code class="sig-name descname">usb_register_dev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_class_driver" title="usb_class_driver">usb_class_driver</a> *<em>class_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_register_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a USB device, and ask for a minor number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>pointer to the usb_interface that is being registered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_class_driver</span> <span class="pre">*class_driver</span></code></dt><dd><p>pointer to the usb_class_driver for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by all USB drivers that use the USB major number.
If CONFIG_USB_DYNAMIC_MINORS is enabled, the minor number will be
dynamically allocated out of the list of available ones.  If it is not
enabled, the minor number will be based on the next available free minor,
starting at the class_driver-&gt;minor_base.</p>
<p>This function also creates a usb class device in the sysfs tree.</p>
<p><a class="reference internal" href="#c.usb_deregister_dev" title="usb_deregister_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_deregister_dev()</span></code></a> must be called when the driver is done with
the minor numbers given out by this function.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if something bad happens with trying to register a
device, and 0 on success.</p>
<dl class="c function">
<dt id="c.usb_deregister_dev">
void <code class="sig-name descname">usb_deregister_dev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_class_driver" title="usb_class_driver">usb_class_driver</a> *<em>class_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_deregister_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deregister a USB device’s dynamic minor.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>pointer to the usb_interface that is being deregistered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_class_driver</span> <span class="pre">*class_driver</span></code></dt><dd><p>pointer to the usb_class_driver for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used in conjunction with <a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a>.  This function is called
when the USB driver is finished with the minor numbers gotten from a
call to <a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a> (usually when the device is disconnected
from the system.)</p>
<p>This function also removes the usb class device from the sysfs tree.</p>
<p>This should be called by all drivers that use the USB major number.</p>
<dl class="c function">
<dt id="c.usb_driver_claim_interface">
int <code class="sig-name descname">usb_driver_claim_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_driver" title="usb_driver">usb_driver</a> *<em>driver</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>iface</em>, void *<em>priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_driver_claim_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>bind a driver to an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver to be bound</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*iface</span></code></dt><dd><p>the interface to which it will be bound; must be in the
usb device’s active configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>driver data associated with that interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used by usb device drivers that need to claim more than one
interface on a device when probing (audio and acm are current examples).
No device driver should directly modify internal usb_interface or
usb_device structure members.</p>
<p>Few drivers should need to use this routine, since the most natural
way to bind to an interface is to return the private data from
the driver’s probe() method.</p>
<p>Callers must own the device lock, so driver probe() entries don’t need
extra locking, but other call contexts may need to explicitly claim that
lock.</p>
<p><strong>Return</strong></p>
<p>0 on success.</p>
<dl class="c function">
<dt id="c.usb_driver_release_interface">
void <code class="sig-name descname">usb_driver_release_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_driver" title="usb_driver">usb_driver</a> *<em>driver</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_driver_release_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unbind a driver from an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver to be unbound</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*iface</span></code></dt><dd><p>the interface from which it will be unbound</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used by drivers to release an interface without waiting
for their disconnect() methods to be called.  In typical cases this
also causes the driver disconnect() method to be called.</p>
<p>This call is synchronous, and may not be used in an interrupt context.
Callers must own the device lock, so driver disconnect() entries don’t
need extra locking, but other call contexts may need to explicitly claim
that lock.</p>
<dl class="c function">
<dt id="c.usb_match_id">
<em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id">usb_device_id</a> *<code class="sig-name descname">usb_match_id</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>interface</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id">usb_device_id</a> *<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_match_id" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find first usb_device_id matching device or interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*interface</span></code></dt><dd><p>the interface of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_device_id</span> <span class="pre">*id</span></code></dt><dd><p>array of usb_device_id structures, terminated by zero entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>usb_match_id searches an array of usb_device_id’s and returns
the first one matching the device or interface, or null.
This is used when binding (or rebinding) a driver to an interface.
Most USB device drivers will use this indirectly, through the usb core,
but some layered driver frameworks use it directly.
These device tables are exported with MODULE_DEVICE_TABLE, through
modutils, to support the driver loading functionality of USB hotplugging.</p>
<p>What Matches:</p>
<p>The “match_flags” element in a usb_device_id controls which
members are used.  If the corresponding bit is set, the
value in the device_id must match its corresponding member
in the device or interface descriptor, or else the device_id
does not match.</p>
<p>“driver_info” is normally used only by device drivers,
but you can create a wildcard “matches anything” usb_device_id
as a driver’s “modules.usbmap” entry if you provide an id with
only a nonzero “driver_info” field.  If you do this, the USB device
driver’s probe() routine should use additional intelligence to
decide whether to bind to the specified interface.</p>
<p>What Makes Good usb_device_id Tables:</p>
<p>The match algorithm is very simple, so that intelligence in
driver selection must come from smart driver id records.
Unless you have good reasons to use another selection policy,
provide match elements only in related groups, and order match
specifiers from specific to general.  Use the macros provided
for that purpose if you can.</p>
<p>The most specific match specifiers use device descriptor
data.  These are commonly used with product-specific matches;
the USB_DEVICE macro lets you provide vendor and product IDs,
and you can also match against ranges of product revisions.
These are widely used for devices with application or vendor
specific bDeviceClass values.</p>
<p>Matches based on device class/subclass/protocol specifications
are slightly more general; use the USB_DEVICE_INFO macro, or
its siblings.  These are used with single-function devices
where bDeviceClass doesn’t specify that each interface has
its own class.</p>
<p>Matches based on interface class/subclass/protocol are the
most general; they let drivers bind to any interface on a
multiple-function device.  Use the USB_INTERFACE_INFO
macro, or its siblings, to match class-per-interface style
devices (as recorded in bInterfaceClass).</p>
<p>Note that an entry created by USB_INTERFACE_INFO won’t match
any interface if the device class is set to Vendor-Specific.
This is deliberate; according to the USB spec the meanings of
the interface class/subclass/protocol for these devices are also
vendor-specific, and hence matching against a standard product
class wouldn’t work anyway.  If you really want to use an
interface-based match for such a device, create a match record
that also specifies the vendor ID.  (Unforunately there isn’t a
standard macro for creating records like this.)</p>
<p>Within those groups, remember that not all combinations are
meaningful.  For example, don’t give a product version range
without vendor and product IDs; or specify a protocol without
its associated class and subclass.</p>
<p><strong>Return</strong></p>
<p>The first matching usb_device_id, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.usb_register_device_driver">
int <code class="sig-name descname">usb_register_device_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device_driver" title="usb_device_driver">usb_device_driver</a> *<em>new_udriver</em>, <em class="property">struct</em> module *<em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_register_device_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a USB device (not interface) driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_driver</span> <span class="pre">*new_udriver</span></code></dt><dd><p>USB operations for the device driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module owner of this driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a USB device driver with the USB core.  The list of
unattached devices will be rescanned whenever a new driver is
added, allowing the new driver to attach to any recognized devices.</p>
<p><strong>Return</strong></p>
<p>A negative error code on failure and 0 on success.</p>
<dl class="c function">
<dt id="c.usb_deregister_device_driver">
void <code class="sig-name descname">usb_deregister_device_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device_driver" title="usb_device_driver">usb_device_driver</a> *<em>udriver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_deregister_device_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a USB device (not interface) driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device_driver</span> <span class="pre">*udriver</span></code></dt><dd><p>USB operations of the device driver to unregister</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>must be able to sleep</p>
<p><strong>Description</strong></p>
<p>Unlinks the specified driver from the internal USB driver list.</p>
<dl class="c function">
<dt id="c.usb_register_driver">
int <code class="sig-name descname">usb_register_driver</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_driver" title="usb_driver">usb_driver</a> *<em>new_driver</em>, <em class="property">struct</em> module *<em>owner</em>, <em class="property">const</em> char *<em>mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_register_driver" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a USB interface driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span> <span class="pre">*new_driver</span></code></dt><dd><p>USB operations for the interface driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module owner of this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>module name string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a USB interface driver with the USB core.  The list of
unattached interfaces will be rescanned whenever a new driver is
added, allowing the new driver to attach to any recognized interfaces.</p>
<p><strong>Return</strong></p>
<p>A negative error code on failure and 0 on success.</p>
<p><strong>NOTE</strong></p>
<p>if you want your driver to use the USB major number, you must call
<a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a> to enable that functionality.  This function no longer
takes care of that.</p>
<dl class="c function">
<dt id="c.usb_deregister">
void <code class="sig-name descname">usb_deregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_driver" title="usb_driver">usb_driver</a> *<em>driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_deregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a USB interface driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span> <span class="pre">*driver</span></code></dt><dd><p>USB operations of the interface driver to unregister</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>must be able to sleep</p>
<p><strong>Description</strong></p>
<p>Unlinks the specified driver from the internal USB driver list.</p>
<p><strong>NOTE</strong></p>
<p>If you called <a class="reference internal" href="#c.usb_register_dev" title="usb_register_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_register_dev()</span></code></a>, you still need to call
<a class="reference internal" href="#c.usb_deregister_dev" title="usb_deregister_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_deregister_dev()</span></code></a> to clean up your driver’s allocated minor numbers,
this * call will no longer do it for you.</p>
<dl class="c function">
<dt id="c.usb_enable_autosuspend">
void <code class="sig-name descname">usb_enable_autosuspend</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_enable_autosuspend" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allow a USB device to be autosuspended</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>the USB device which may be autosuspended</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine allows <strong>udev</strong> to be autosuspended.  An autosuspend won’t
take place until the autosuspend_delay has elapsed and all the other
necessary conditions are satisfied.</p>
<p>The caller must hold <strong>udev</strong>’s device lock.</p>
<dl class="c function">
<dt id="c.usb_disable_autosuspend">
void <code class="sig-name descname">usb_disable_autosuspend</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_disable_autosuspend" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prevent a USB device from being autosuspended</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>the USB device which may not be autosuspended</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine prevents <strong>udev</strong> from being autosuspended and wakes it up
if it is already autosuspended.</p>
<p>The caller must hold <strong>udev</strong>’s device lock.</p>
<dl class="c function">
<dt id="c.usb_autopm_put_interface">
void <code class="sig-name descname">usb_autopm_put_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_put_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be decremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine should be called by an interface driver when it is
finished using <strong>intf</strong> and wants to allow it to autosuspend.  A typical
example would be a character-device driver when its device file is
closed.</p>
<p>The routine decrements <strong>intf</strong>’s usage counter.  When the counter reaches
0, a delayed autosuspend request for <strong>intf</strong>’s device is attempted.  The
attempt may fail (see autosuspend_check()).</p>
<p>This routine can run only in process context.</p>
<dl class="c function">
<dt id="c.usb_autopm_put_interface_async">
void <code class="sig-name descname">usb_autopm_put_interface_async</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_put_interface_async" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be decremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine does much the same thing as <a class="reference internal" href="#c.usb_autopm_put_interface" title="usb_autopm_put_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface()</span></code></a>:
It decrements <strong>intf</strong>’s usage counter and schedules a delayed
autosuspend request if the counter is &lt;= 0.  The difference is that it
does not perform any synchronization; callers should hold a private
lock and handle all synchronization issues themselves.</p>
<p>Typically a driver would call this routine during an URB’s completion
handler, if no more URBs were pending.</p>
<p>This routine can run in atomic context.</p>
<dl class="c function">
<dt id="c.usb_autopm_put_interface_no_suspend">
void <code class="sig-name descname">usb_autopm_put_interface_no_suspend</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_put_interface_no_suspend" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be decremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine decrements <strong>intf</strong>’s usage counter but does not carry out an
autosuspend.</p>
<p>This routine can run in atomic context.</p>
<dl class="c function">
<dt id="c.usb_autopm_get_interface">
int <code class="sig-name descname">usb_autopm_get_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_get_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be incremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine should be called by an interface driver when it wants to
use <strong>intf</strong> and needs to guarantee that it is not suspended.  In addition,
the routine prevents <strong>intf</strong> from being autosuspended subsequently.  (Note
that this will not prevent suspend events originating in the PM core.)
This prevention will persist until <a class="reference internal" href="#c.usb_autopm_put_interface" title="usb_autopm_put_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface()</span></code></a> is called
or <strong>intf</strong> is unbound.  A typical example would be a character-device
driver when its device file is opened.</p>
<p><strong>intf</strong>’s usage counter is incremented to prevent subsequent autosuspends.
However if the autoresume fails then the counter is re-decremented.</p>
<p>This routine can run only in process context.</p>
<p><strong>Return</strong></p>
<p>0 on success.</p>
<dl class="c function">
<dt id="c.usb_autopm_get_interface_async">
int <code class="sig-name descname">usb_autopm_get_interface_async</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_get_interface_async" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be incremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine does much the same thing as
<a class="reference internal" href="#c.usb_autopm_get_interface" title="usb_autopm_get_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface()</span></code></a>: It increments <strong>intf</strong>’s usage counter and
queues an autoresume request if the device is suspended.  The
differences are that it does not perform any synchronization (callers
should hold a private lock and handle all synchronization issues
themselves), and it does not autoresume the device directly (it only
queues a request).  After a successful call, the device may not yet be
resumed.</p>
<p>This routine can run in atomic context.</p>
<p><strong>Return</strong></p>
<p>0 on success. A negative error code otherwise.</p>
<dl class="c function">
<dt id="c.usb_autopm_get_interface_no_resume">
void <code class="sig-name descname">usb_autopm_get_interface_no_resume</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_autopm_get_interface_no_resume" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment a USB interface’s PM-usage counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the usb_interface whose counter should be incremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine increments <strong>intf</strong>’s usage counter but does not carry out an
autoresume.</p>
<p>This routine can run in atomic context.</p>
<dl class="c function">
<dt id="c.usb_find_common_endpoints">
int <code class="sig-name descname">usb_find_common_endpoints</code><span class="sig-paren">(</span><em class="property">struct</em> usb_host_interface *<em>alt</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>bulk_in</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>bulk_out</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>int_in</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>int_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_find_common_endpoints" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>look up common endpoint descriptors</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_host_interface</span> <span class="pre">*alt</span></code></dt><dd><p>alternate setting to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**bulk_in</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**bulk_out</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**int_in</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**int_out</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the alternate setting’s endpoint descriptors for the first bulk-in,
bulk-out, interrupt-in and interrupt-out endpoints and return them in the
provided pointers (unless they are NULL).</p>
<p>If a requested endpoint is not found, the corresponding pointer is set to
NULL.</p>
<p><strong>Return</strong></p>
<p>Zero if all requested descriptors were found, or -ENXIO otherwise.</p>
<dl class="c function">
<dt id="c.usb_find_common_endpoints_reverse">
int <code class="sig-name descname">usb_find_common_endpoints_reverse</code><span class="sig-paren">(</span><em class="property">struct</em> usb_host_interface *<em>alt</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>bulk_in</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>bulk_out</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>int_in</em>, <em class="property">struct</em> usb_endpoint_descriptor **<em>int_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_find_common_endpoints_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>look up common endpoint descriptors</p></li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_host_interface</span> <span class="pre">*alt</span></code></dt><dd><p>alternate setting to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**bulk_in</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**bulk_out</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**int_in</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_endpoint_descriptor</span> <span class="pre">**int_out</span></code></dt><dd><p>pointer to descriptor pointer, or NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the alternate setting’s endpoint descriptors for the last bulk-in,
bulk-out, interrupt-in and interrupt-out endpoints and return them in the
provided pointers (unless they are NULL).</p>
<p>If a requested endpoint is not found, the corresponding pointer is set to
NULL.</p>
<p><strong>Return</strong></p>
<p>Zero if all requested descriptors were found, or -ENXIO otherwise.</p>
<dl class="c function">
<dt id="c.usb_find_alt_setting">
<em class="property">struct</em> usb_host_interface *<code class="sig-name descname">usb_find_alt_setting</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_host_config" title="usb_host_config">usb_host_config</a> *<em>config</em>, unsigned int <em>iface_num</em>, unsigned int <em>alt_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_find_alt_setting" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Given a configuration, find the alternate setting for the given interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_host_config</span> <span class="pre">*config</span></code></dt><dd><p>the configuration to search (not necessarily the current config).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">iface_num</span></code></dt><dd><p>interface number to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">alt_num</span></code></dt><dd><p>alternate interface setting number to search for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the configuration’s interface cache for the given alt setting.</p>
<p><strong>Return</strong></p>
<p>The alternate setting, if found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.usb_ifnum_to_if">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<code class="sig-name descname">usb_ifnum_to_if</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, unsigned <em>ifnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ifnum_to_if" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the interface object with a given interface number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose current configuration is considered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">ifnum</span></code></dt><dd><p>the desired interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This walks the device descriptor for the currently active configuration
to find the interface object with the particular interface number.</p>
<p>Note that configuration descriptors are not required to assign interface
numbers sequentially, so that it would be incorrect to assume that
the first interface in that descriptor corresponds to interface zero.
This routine helps device drivers avoid such mistakes.
However, you should make sure that you do the right thing with any
alternate settings available for this interfaces.</p>
<p>Don’t call this function unless you are bound to one of the interfaces
on this device or you have locked the device!</p>
<p><strong>Return</strong></p>
<p>A pointer to the interface that has <strong>ifnum</strong> as interface number,
if found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.usb_altnum_to_altsetting">
<em class="property">struct</em> usb_host_interface *<code class="sig-name descname">usb_altnum_to_altsetting</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em>, unsigned int <em>altnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_altnum_to_altsetting" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the altsetting structure with a given alternate setting number.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the interface containing the altsetting in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">altnum</span></code></dt><dd><p>the desired alternate setting number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This searches the altsetting array of the specified interface for
an entry with the correct bAlternateSetting value.</p>
<p>Note that altsettings need not be stored sequentially by number, so
it would be incorrect to assume that the first altsetting entry in
the array corresponds to altsetting zero.  This routine helps device
drivers avoid such mistakes.</p>
<p>Don’t call this function unless you are bound to the intf interface
or you have locked the device!</p>
<p><strong>Return</strong></p>
<p>A pointer to the entry of the altsetting array of <strong>intf</strong> that
has <strong>altnum</strong> as the alternate setting number. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not found.</p>
<dl class="c function">
<dt id="c.usb_find_interface">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<code class="sig-name descname">usb_find_interface</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_driver" title="usb_driver">usb_driver</a> *<em>drv</em>, int <em>minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_find_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find usb_interface pointer for driver and device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver whose current configuration is considered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">minor</span></code></dt><dd><p>the minor number of the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This walks the bus device list and returns a pointer to the interface
with the matching minor and driver.  Note, this only works for devices
that share the USB major number.</p>
<p><strong>Return</strong></p>
<p>A pointer to the interface with the matching major and <strong>minor</strong>.</p>
<dl class="c function">
<dt id="c.usb_for_each_dev">
int <code class="sig-name descname">usb_for_each_dev</code><span class="sig-paren">(</span>void *<em>data</em>, int (*<em>fn</em>)<span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a>*, void*<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_for_each_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>iterate over all USB devices in the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer that will be handed to the callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">usb_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback function to be called for each USB device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all USB devices and call <strong>fn</strong> for each, passing it <strong>data</strong>. If it
returns anything other than 0, we break the iteration prematurely and return
that value.</p>
<dl class="c function">
<dt id="c.usb_alloc_dev">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<code class="sig-name descname">usb_alloc_dev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>parent</em>, <em class="property">struct</em> usb_bus *<em>bus</em>, unsigned <em>port1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_alloc_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>usb device constructor (usbcore-internal)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*parent</span></code></dt><dd><p>hub to which device is connected; null to allocate a root hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus used to access the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">port1</span></code></dt><dd><p>one-based index of port; ignored for root hubs</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Only hub drivers (including virtual root hub drivers for host
controllers) should ever call this.</p>
<p>This call may not be used in a non-sleeping context.</p>
<p><strong>Return</strong></p>
<p>On success, a pointer to the allocated usb device. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on
failure.</p>
<dl class="c function">
<dt id="c.usb_get_dev">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<code class="sig-name descname">usb_get_dev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increments the reference count of the usb device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device being referenced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a device should be refcounted.</p>
<p>Drivers for USB interfaces should normally record such references in
their probe() methods, when they bind to an interface, and release
them by calling <a class="reference internal" href="#c.usb_put_dev" title="usb_put_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_put_dev()</span></code></a>, in their disconnect() methods.</p>
<p><strong>Return</strong></p>
<p>A pointer to the device with the incremented reference counter.</p>
<dl class="c function">
<dt id="c.usb_put_dev">
void <code class="sig-name descname">usb_put_dev</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_put_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a use of the usb device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>device that’s been disconnected</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.</p>
<dl class="c function">
<dt id="c.usb_get_intf">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<code class="sig-name descname">usb_get_intf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_intf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increments the reference count of the usb interface structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>the interface being referenced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a interface must be refcounted.</p>
<p>Drivers for USB interfaces should normally record such references in
their probe() methods, when they bind to an interface, and release
them by calling <a class="reference internal" href="#c.usb_put_intf" title="usb_put_intf"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_put_intf()</span></code></a>, in their disconnect() methods.</p>
<p><strong>Return</strong></p>
<p>A pointer to the interface with the incremented reference counter.</p>
<dl class="c function">
<dt id="c.usb_put_intf">
void <code class="sig-name descname">usb_put_intf</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_put_intf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a use of the usb interface structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*intf</span></code></dt><dd><p>interface that’s been decremented</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of an interface is finished with it.  When the
last user of the interface calls this function, the memory of the interface
is freed.</p>
<dl class="c function">
<dt id="c.usb_lock_device_for_reset">
int <code class="sig-name descname">usb_lock_device_for_reset</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_lock_device_for_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cautiously acquire the lock for a usb device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>device that’s being locked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*iface</span></code></dt><dd><p>interface bound to the driver making the request (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to acquire the device lock, but fails if the device is
NOTATTACHED or SUSPENDED, or if iface is specified and the interface
is neither BINDING nor BOUND.  Rather than sleeping to wait for the
lock, the routine polls repeatedly.  This is to prevent deadlock with
disconnect; in some drivers (such as usb-storage) the disconnect()
or suspend() method will block waiting for a device reset to complete.</p>
<p><strong>Return</strong></p>
<p>A negative error code for failure, otherwise 0.</p>
<dl class="c function">
<dt id="c.usb_get_current_frame_number">
int <code class="sig-name descname">usb_get_current_frame_number</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_get_current_frame_number" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return current bus frame number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device whose bus is being queried</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The current frame number for the USB host controller used
with the given USB device. This can be used when scheduling
isochronous requests.</p>
<p><strong>Note</strong></p>
<p>Different kinds of host controller have different “scheduling
horizons”. While one type might support scheduling only 32 frames
into the future, others could support scheduling up to 1024 frames
into the future.</p>
<dl class="c function">
<dt id="c.usb_alloc_coherent">
void *<code class="sig-name descname">usb_alloc_coherent</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, size_t <em>size</em>, gfp_t <em>mem_flags</em>, dma_addr_t *<em>dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_alloc_coherent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>device the buffer will be used with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>requested buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>affect whether allocation may block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*dma</span></code></dt><dd><p>used to return DMA address of buffer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Either null (indicating no buffer could be allocated), or the
cpu-space pointer to a buffer that may be used to perform DMA to the
specified device.  Such cpu-space buffers are returned along with the DMA
address (through the pointer provided).</p>
<p><strong>Note</strong></p>
<p>These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags
to avoid behaviors like using “DMA bounce buffers”, or thrashing IOMMU
hardware during URB completion/resubmit.  The implementation varies between
platforms, depending on details of how DMA will work to this device.
Using these buffers also eliminates cacheline sharing problems on
architectures where CPU caches are not DMA-coherent.  On systems without
bus-snooping caches, these buffers are uncached.</p>
<p><strong>Description</strong></p>
<p>When the buffer is no longer used, free it with <a class="reference internal" href="#c.usb_free_coherent" title="usb_free_coherent"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_free_coherent()</span></code></a>.</p>
<dl class="c function">
<dt id="c.usb_free_coherent">
void <code class="sig-name descname">usb_free_coherent</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>dev</em>, size_t <em>size</em>, void *<em>addr</em>, dma_addr_t <em>dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_free_coherent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free memory allocated with <a class="reference internal" href="#c.usb_alloc_coherent" title="usb_alloc_coherent"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_alloc_coherent()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*dev</span></code></dt><dd><p>device the buffer was used with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>requested buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>CPU address of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt><dd><p>DMA address of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reclaims an I/O buffer, letting it be reused.  The memory must have
been allocated using <a class="reference internal" href="#c.usb_alloc_coherent" title="usb_alloc_coherent"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_alloc_coherent()</span></code></a>, and the parameters must match
those provided in that allocation request.</p>
<dl class="c function">
<dt id="c.usb_hub_clear_tt_buffer">
int <code class="sig-name descname">usb_hub_clear_tt_buffer</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hub_clear_tt_buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>clear control/bulk TT state in high speed hub</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>an URB associated with the failed or incomplete split transaction</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>High speed HCDs use this to tell the hub driver that some split control or
bulk transaction failed in a way that requires clearing internal state of
a transaction translator.  This is normally detected (and reported) from
interrupt context.</p>
<p>It may not be possible for that hub to handle additional full (or low)
speed transactions until that state is fully cleared out.</p>
<p><strong>Return</strong></p>
<p>0 if successful. A negative error code otherwise.</p>
<dl class="c function">
<dt id="c.usb_set_device_state">
void <code class="sig-name descname">usb_set_device_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em>, <em class="property">enum</em> usb_device_state <em>new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_set_device_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>change a device’s current state (usbcore, hcds)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>pointer to device whose state should be changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">usb_device_state</span> <span class="pre">new_state</span></code></dt><dd><p>new state value to be stored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>udev-&gt;state is _not_ fully protected by the device lock.  Although
most transitions are made only while holding the lock, the state can
can change to USB_STATE_NOTATTACHED at almost any time.  This
is so that devices can be marked as disconnected as soon as possible,
without having to wait for any semaphores to be released.  As a result,
all changes to any device’s state must be protected by the
device_state_lock spinlock.</p>
<p>Once a device has been added to the device tree, all changes to its state
should be made using this routine.  The state should _not_ be set directly.</p>
<p>If udev-&gt;state is already USB_STATE_NOTATTACHED then no change is made.
Otherwise udev-&gt;state is set to new_state, and if new_state is
USB_STATE_NOTATTACHED then all of udev’s descendants’ states are also set
to USB_STATE_NOTATTACHED.</p>
<dl class="c function">
<dt id="c.usb_root_hub_lost_power">
void <code class="sig-name descname">usb_root_hub_lost_power</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>rhdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_root_hub_lost_power" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>called by HCD if the root hub lost Vbus power</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*rhdev</span></code></dt><dd><p><a class="reference internal" href="#c.usb_device" title="usb_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span></code></a> for the root hub</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The USB host controller driver calls this function when its root hub
is resumed and Vbus power has been interrupted or the controller
has been reset.  The routine marks <strong>rhdev</strong> as having lost power.
When the hub driver is resumed it will take notice and carry out
power-session recovery for all the “USB-PERSIST”-enabled child devices;
the others will be disconnected.</p>
<dl class="c function">
<dt id="c.usb_reset_device">
int <code class="sig-name descname">usb_reset_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>udev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_reset_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>warn interface drivers and perform a USB port reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*udev</span></code></dt><dd><p>device to reset (not in NOTATTACHED state)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Warns all drivers bound to registered interfaces (using their pre_reset
method), performs the port reset, and then lets the drivers know that
the reset is over (using their post_reset method).</p>
<p>If an interface is currently being probed or disconnected, we assume
its driver knows how to handle resets.  For all other interfaces,
if the driver doesn’t have pre_reset and post_reset methods then
we attempt to unbind it and rebind afterward.</p>
<p><strong>Return</strong></p>
<p>The same as for usb_reset_and_verify_device().</p>
<p><strong>Note</strong></p>
<p>The caller must own the device lock.  For example, it’s safe to use
this from a driver probe() routine after downloading new firmware.
For calls that might not occur during probe(), drivers should lock
the device using <a class="reference internal" href="#c.usb_lock_device_for_reset" title="usb_lock_device_for_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_lock_device_for_reset()</span></code></a>.</p>
<dl class="c function">
<dt id="c.usb_queue_reset_device">
void <code class="sig-name descname">usb_queue_reset_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_queue_reset_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset a USB device from an atomic context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*iface</span></code></dt><dd><p>USB interface belonging to the device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to reset a USB device from an atomic
context, where <a class="reference internal" href="#c.usb_reset_device" title="usb_reset_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_device()</span></code></a> won’t work (as it blocks).</p>
<p>Doing a reset via this method is functionally equivalent to calling
<a class="reference internal" href="#c.usb_reset_device" title="usb_reset_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_device()</span></code></a>, except for the fact that it is delayed to a
workqueue. This means that any drivers bound to other interfaces
might be unbound, as well as users from usbfs in user space.</p>
<p>Corner cases:</p>
<ul class="simple">
<li><p>Scheduling two resets at the same time from two different drivers
attached to two different interfaces of the same device is
possible; depending on how the driver attached to each interface
handles -&gt;pre_reset(), the second reset might happen or not.</p></li>
<li><p>If the reset is delayed so long that the interface is unbound from
its driver, the reset will be skipped.</p></li>
<li><p>This function can be called during .probe().  It can also be called
during .disconnect(), but doing so is pointless because the reset
will not occur.  If you really want to reset the device during
.disconnect(), call <a class="reference internal" href="#c.usb_reset_device" title="usb_reset_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_reset_device()</span></code></a> directly – but watch out
for nested unbinding issues!</p></li>
</ul>
<dl class="c function">
<dt id="c.usb_hub_find_child">
<em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<code class="sig-name descname">usb_hub_find_child</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_device" title="usb_device">usb_device</a> *<em>hdev</em>, int <em>port1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hub_find_child" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the pointer of child device attached to the port which is specified by <strong>port1</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*hdev</span></code></dt><dd><p>USB device belonging to the usb hub</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port1</span></code></dt><dd><p>port num to indicate which port the child device
is attached to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB drivers call this function to get hub’s child device
pointer.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if input param is invalid and
child’s usb_device pointer if non-NULL.</p>
</div>
<div class="section" id="host-controller-apis">
<h2>Host Controller APIs<a class="headerlink" href="#host-controller-apis" title="Permalink to this headline">¶</a></h2>
<p>These APIs are only for use by host controller drivers, most of which
implement standard register interfaces such as XHCI, EHCI, OHCI, or UHCI. UHCI
was one of the first interfaces, designed by Intel and also used by VIA;
it doesn’t do much in hardware. OHCI was designed later, to have the
hardware do more work (bigger transfers, tracking protocol state, and so
on). EHCI was designed with USB 2.0; its design has features that
resemble OHCI (hardware does much more work) as well as UHCI (some parts
of ISO support, TD list processing). XHCI was designed with USB 3.0. It
continues to shift support for functionality into hardware.</p>
<p>There are host controllers other than the “big three”, although most PCI
based controllers (and a few non-PCI based ones) use one of those
interfaces. Not all host controllers use DMA; some use PIO, and there is
also a simulator and a virtual host controller to pipe USB over the network.</p>
<p>The same basic APIs are available to drivers for all those controllers.
For historical reasons they are in two layers: <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">usb_bus</span></code> is a rather thin layer that became available
in the 2.2 kernels, while <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span></code>
is a more featureful layer
that lets HCDs share common code, to shrink driver size and
significantly reduce hcd-specific behaviors.</p>
<dl class="c function">
<dt id="c.usb_calc_bus_time">
long <code class="sig-name descname">usb_calc_bus_time</code><span class="sig-paren">(</span>int <em>speed</em>, int <em>is_input</em>, int <em>isoc</em>, int <em>bytecount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_calc_bus_time" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>approximate periodic transaction time in nanoseconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>from dev-&gt;speed; USB_SPEED_{LOW,FULL,HIGH}</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">is_input</span></code></dt><dd><p>true iff the transaction sends data to the host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">isoc</span></code></dt><dd><p>true for isochronous transactions, false for interrupt ones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bytecount</span></code></dt><dd><p>how many bytes in the transaction.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Approximate bus time in nanoseconds for a periodic transaction.</p>
<p><strong>Note</strong></p>
<p>See USB 2.0 spec section 5.11.3; only periodic transfers need to be
scheduled in software, this function is only used for such scheduling.</p>
<dl class="c function">
<dt id="c.usb_hcd_link_urb_to_ep">
int <code class="sig-name descname">usb_hcd_link_urb_to_ep</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em>, <em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_link_urb_to_ep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add an URB to its endpoint queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>host controller to which <strong>urb</strong> was submitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>URB being submitted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Host controller drivers should call this routine in their enqueue()
method.  The HCD’s private spinlock must be held and interrupts must
be disabled.  The actions carried out here are required for URB
submission, as well as for endpoint shutdown and for usb_kill_urb.</p>
<p><strong>Return</strong></p>
<p>0 for no error, otherwise a negative error code (in which case
the enqueue() method must fail).  If no error occurs but enqueue() fails
anyway, it must call <a class="reference internal" href="#c.usb_hcd_unlink_urb_from_ep" title="usb_hcd_unlink_urb_from_ep"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_hcd_unlink_urb_from_ep()</span></code></a> before releasing
the private spinlock and returning.</p>
<dl class="c function">
<dt id="c.usb_hcd_check_unlink_urb">
int <code class="sig-name descname">usb_hcd_check_unlink_urb</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em>, <em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, int <em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_check_unlink_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check whether an URB may be unlinked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>host controller to which <strong>urb</strong> was submitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>URB being checked for unlinkability</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>error code to store in <strong>urb</strong> if the unlink succeeds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Host controller drivers should call this routine in their dequeue()
method.  The HCD’s private spinlock must be held and interrupts must
be disabled.  The actions carried out here are required for making
sure than an unlink is valid.</p>
<p><strong>Return</strong></p>
<p>0 for no error, otherwise a negative error code (in which case
the dequeue() method must fail).  The possible error codes are:</p>
<blockquote>
<div><dl class="simple">
<dt>-EIDRM: <strong>urb</strong> was not submitted or has already completed.</dt><dd><p>The completion function may not have been called yet.</p>
</dd>
</dl>
<p>-EBUSY: <strong>urb</strong> has already been unlinked.</p>
</div></blockquote>
<dl class="c function">
<dt id="c.usb_hcd_unlink_urb_from_ep">
void <code class="sig-name descname">usb_hcd_unlink_urb_from_ep</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em>, <em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_unlink_urb_from_ep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove an URB from its endpoint queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>host controller to which <strong>urb</strong> was submitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>URB being unlinked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Host controller drivers should call this routine before calling
<a class="reference internal" href="#c.usb_hcd_giveback_urb" title="usb_hcd_giveback_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_hcd_giveback_urb()</span></code></a>.  The HCD’s private spinlock must be held and
interrupts must be disabled.  The actions carried out here are required
for URB completion.</p>
<dl class="c function">
<dt id="c.usb_hcd_giveback_urb">
void <code class="sig-name descname">usb_hcd_giveback_urb</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em>, <em class="property">struct</em> <a class="reference internal" href="#c.urb" title="urb">urb</a> *<em>urb</em>, int <em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_giveback_urb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return URB from HCD to device driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>host controller returning the URB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span> <span class="pre">*urb</span></code></dt><dd><p>urb being returned to the USB device driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>completion status code for the URB.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>in_interrupt()</p>
<p><strong>Description</strong></p>
<p>This hands the URB from HCD to its USB device driver, using its
completion function.  The HCD has freed all per-urb resources
(and is done using urb-&gt;hcpriv).  It also released all HCD locks;
the device driver won’t cause problems if it frees, modifies,
or resubmits this URB.</p>
<p>If <strong>urb</strong> was unlinked, the value of <strong>status</strong> will be overridden by
<strong>urb-&gt;unlinked</strong>.  Erroneous short transfers are detected in case
the HCD hasn’t checked for them.</p>
<dl class="c function">
<dt id="c.usb_alloc_streams">
int <code class="sig-name descname">usb_alloc_streams</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>interface</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_host_endpoint" title="usb_host_endpoint">usb_host_endpoint</a> **<em>eps</em>, unsigned int <em>num_eps</em>, unsigned int <em>num_streams</em>, gfp_t <em>mem_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_alloc_streams" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate bulk endpoint stream IDs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*interface</span></code></dt><dd><p>alternate setting that includes all endpoints.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_host_endpoint</span> <span class="pre">**eps</span></code></dt><dd><p>array of endpoints that need streams.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_eps</span></code></dt><dd><p>number of endpoints in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_streams</span></code></dt><dd><p>number of streams to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>flags hcd should use to allocate memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a group of bulk endpoints to have <strong>num_streams</strong> stream IDs available.
Drivers may queue multiple transfers to different stream IDs, which may
complete in a different order than they were queued.</p>
<p><strong>Return</strong></p>
<p>On success, the number of allocated streams. On failure, a negative
error code.</p>
<dl class="c function">
<dt id="c.usb_free_streams">
int <code class="sig-name descname">usb_free_streams</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.usb_interface" title="usb_interface">usb_interface</a> *<em>interface</em>, <em class="property">struct</em> <a class="reference internal" href="#c.usb_host_endpoint" title="usb_host_endpoint">usb_host_endpoint</a> **<em>eps</em>, unsigned int <em>num_eps</em>, gfp_t <em>mem_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_free_streams" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free bulk endpoint stream IDs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_interface</span> <span class="pre">*interface</span></code></dt><dd><p>alternate setting that includes all endpoints.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_host_endpoint</span> <span class="pre">**eps</span></code></dt><dd><p>array of endpoints to remove streams from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_eps</span></code></dt><dd><p>number of endpoints in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>flags hcd should use to allocate memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverts a group of bulk endpoints back to not using stream IDs.
Can fail if we are given bad arguments, or HCD is broken.</p>
<p><strong>Return</strong></p>
<p>0 on success. On failure, a negative error code.</p>
<dl class="c function">
<dt id="c.usb_hcd_resume_root_hub">
void <code class="sig-name descname">usb_hcd_resume_root_hub</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_resume_root_hub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>called by HCD to resume its root hub</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>host controller for this root hub</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The USB host controller calls this function when its root hub is
suspended (with the remote wakeup feature enabled) and a remote
wakeup request is received.  The routine submits a workqueue request
to resume the root hub (that is, manage its downstream ports again).</p>
<dl class="c function">
<dt id="c.usb_bus_start_enum">
int <code class="sig-name descname">usb_bus_start_enum</code><span class="sig-paren">(</span><em class="property">struct</em> usb_bus *<em>bus</em>, unsigned <em>port_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_bus_start_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start immediate enumeration (for OTG)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the bus (must use hcd framework)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">port_num</span></code></dt><dd><p>1-based number of port; usually bus-&gt;otg_port</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Starts enumeration, with an immediate reset followed later by
hub_wq identifying and possibly configuring the device.
This is needed by OTG controller drivers, where it helps meet
HNP protocol timing requirements for starting a port reset.</p>
<p><strong>Return</strong></p>
<p>0 if successful.</p>
<dl class="c function">
<dt id="c.usb_hcd_irq">
irqreturn_t <code class="sig-name descname">usb_hcd_irq</code><span class="sig-paren">(</span>int <em>irq</em>, void *<em>__hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_irq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>hook IRQs to HCD framework (bus glue)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the IRQ being raised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*__hcd</span></code></dt><dd><p>pointer to the HCD whose IRQ is being signaled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the controller isn’t HALTed, calls the driver’s irq handler.
Checks whether the controller is now dead.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IRQ_HANDLED</span></code> if the IRQ was handled. <code class="docutils literal notranslate"><span class="pre">IRQ_NONE</span></code> otherwise.</p>
<dl class="c function">
<dt id="c.usb_hc_died">
void <code class="sig-name descname">usb_hc_died</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hc_died" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report abnormal shutdown of a host controller (bus glue)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>pointer to the HCD representing the controller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called by bus glue to report a USB host controller that died
while operations may still have been pending.  It’s called automatically
by the PCI glue, so only glue for non-PCI busses should need to call it.</p>
<p>Only call this function with the primary HCD.</p>
<dl class="c function">
<dt id="c.usb_create_shared_hcd">
<em class="property">struct</em> usb_hcd *<code class="sig-name descname">usb_create_shared_hcd</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> hc_driver *<em>driver</em>, <em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> char *<em>bus_name</em>, <em class="property">struct</em> usb_hcd *<em>primary_hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_create_shared_hcd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create and initialize an HCD structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hc_driver</span> <span class="pre">*driver</span></code></dt><dd><p>HC driver that will use this hcd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for this HC, stored in hcd-&gt;self.controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_name</span></code></dt><dd><p>value to store in hcd-&gt;self.bus_name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*primary_hcd</span></code></dt><dd><p>a pointer to the usb_hcd structure that is sharing the
PCI device.  Only allocate certain resources for the primary HCD</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Allocate a struct usb_hcd, with extra space at the end for the
HC driver’s private data.  Initialize the generic members of the
hcd structure.</p>
<p><strong>Return</strong></p>
<p>On success, a pointer to the created and initialized HCD structure.
On failure (e.g. if memory is unavailable), <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.usb_create_hcd">
<em class="property">struct</em> usb_hcd *<code class="sig-name descname">usb_create_hcd</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> hc_driver *<em>driver</em>, <em class="property">struct</em> <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> char *<em>bus_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_create_hcd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create and initialize an HCD structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hc_driver</span> <span class="pre">*driver</span></code></dt><dd><p>HC driver that will use this hcd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for this HC, stored in hcd-&gt;self.controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_name</span></code></dt><dd><p>value to store in hcd-&gt;self.bus_name</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Allocate a struct usb_hcd, with extra space at the end for the
HC driver’s private data.  Initialize the generic members of the
hcd structure.</p>
<p><strong>Return</strong></p>
<p>On success, a pointer to the created and initialized HCD
structure. On failure (e.g. if memory is unavailable), <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="c function">
<dt id="c.usb_add_hcd">
int <code class="sig-name descname">usb_add_hcd</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em>, unsigned int <em>irqnum</em>, unsigned long <em>irqflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_add_hcd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>finish generic HCD structure initialization and register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>the usb_hcd structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irqnum</span></code></dt><dd><p>Interrupt line to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt><dd><p>Interrupt type flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish the remaining parts of generic HCD initialization: allocate the
buffers of consistent memory, register the bus, request the IRQ line,
and call the driver’s reset() and <a class="reference internal" href="../../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> routines.</p>
<dl class="c function">
<dt id="c.usb_remove_hcd">
void <code class="sig-name descname">usb_remove_hcd</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_remove_hcd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>shutdown processing for generic HCDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>the usb_hcd structure to remove</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Disconnects the root hub, then reverses the effects of <a class="reference internal" href="#c.usb_add_hcd" title="usb_add_hcd"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_hcd()</span></code></a>,
invoking the HCD’s <a class="reference internal" href="../../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a> method.</p>
<dl class="c function">
<dt id="c.usb_hcd_pci_probe">
int <code class="sig-name descname">usb_hcd_pci_probe</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> *<em>id</em>, <em class="property">const</em> <em class="property">struct</em> hc_driver *<em>driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_pci_probe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize PCI-based HCDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>USB Host Controller being probed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*id</span></code></dt><dd><p>pci hotplug id connecting controller to HCD framework</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hc_driver</span> <span class="pre">*driver</span></code></dt><dd><p>USB HC driver handle</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Allocates basic PCI resources for this USB host controller, and
then invokes the <a class="reference internal" href="../../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> method for the HCD associated with it
through the hotplug entry’s driver_data.</p>
<p>Store this function in the HCD’s <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a> as probe().</p>
<p><strong>Return</strong></p>
<p>0 if successful.</p>
<dl class="c function">
<dt id="c.usb_hcd_pci_remove">
void <code class="sig-name descname">usb_hcd_pci_remove</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_pci_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>shutdown processing for PCI-based HCDs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>USB Host Controller being removed</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Reverses the effect of <a class="reference internal" href="#c.usb_hcd_pci_probe" title="usb_hcd_pci_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_hcd_pci_probe()</span></code></a>, first invoking
the HCD’s <a class="reference internal" href="../../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a> method.  It is always called from a thread
context, normally “rmmod”, “apmd”, or something similar.</p>
<p>Store this function in the HCD’s <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a> as remove().</p>
<dl class="c function">
<dt id="c.usb_hcd_pci_shutdown">
void <code class="sig-name descname">usb_hcd_pci_shutdown</code><span class="sig-paren">(</span><em class="property">struct</em> pci_dev *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_hcd_pci_shutdown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>shutdown host controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>USB Host Controller being shutdown</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.hcd_buffer_create">
int <code class="sig-name descname">hcd_buffer_create</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hcd_buffer_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize buffer pools</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>the bus whose buffer pools are to be initialized</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Call this as part of initializing a host controller that uses the dma
memory allocators.  It initializes some pools of dma-coherent memory that
will be shared by all drivers using that controller.</p>
<p>Call <a class="reference internal" href="#c.hcd_buffer_destroy" title="hcd_buffer_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">hcd_buffer_destroy()</span></code></a> to clean up after using those pools.</p>
<p><strong>Return</strong></p>
<p>0 if successful. A negative errno value otherwise.</p>
<dl class="c function">
<dt id="c.hcd_buffer_destroy">
void <code class="sig-name descname">hcd_buffer_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> usb_hcd *<em>hcd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hcd_buffer_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deallocate buffer pools</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_hcd</span> <span class="pre">*hcd</span></code></dt><dd><p>the bus whose buffer pools are to be destroyed</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>This frees the buffer pools created by <a class="reference internal" href="#c.hcd_buffer_create" title="hcd_buffer_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">hcd_buffer_create()</span></code></a>.</p>
</div>
<div class="section" id="the-usb-character-device-nodes">
<h2>The USB character device nodes<a class="headerlink" href="#the-usb-character-device-nodes" title="Permalink to this headline">¶</a></h2>
<p>This chapter presents the Linux character device nodes. You may prefer
to avoid writing new kernel code for your USB driver. User mode device
drivers are usually packaged as applications or libraries, and may use
character devices through some programming library that wraps it.
Such libraries include:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://libusb.sourceforge.net">libusb</a> for C/C++, and</p></li>
<li><p><a class="reference external" href="http://jUSB.sourceforge.net">jUSB</a> for Java.</p></li>
</ul>
</div></blockquote>
<p>Some old information about it can be seen at the “USB Device Filesystem”
section of the USB Guide. The latest copy of the USB Guide can be found
at <a class="reference external" href="http://www.linux-usb.org/">http://www.linux-usb.org/</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>They were used to be implemented via <em>usbfs</em>, but this is not part of
the sysfs debug interface.</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>This particular documentation is incomplete, especially with respect
to the asynchronous mode. As of kernel 2.5.66 the code and this
(new) documentation need to be cross-reviewed.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="what-files-are-in-devtmpfs">
<h3>What files are in “devtmpfs”?<a class="headerlink" href="#what-files-are-in-devtmpfs" title="Permalink to this headline">¶</a></h3>
<p>Conventionally mounted at <code class="docutils literal notranslate"><span class="pre">/dev/bus/usb/</span></code>, usbfs features include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/dev/bus/usb/BBB/DDD</span></code> … magic files exposing the each device’s
configuration descriptors, and supporting a series of ioctls for
making device requests, including I/O to devices. (Purely for access
by programs.)</p></li>
</ul>
<p>Each bus is given a number (<code class="docutils literal notranslate"><span class="pre">BBB</span></code>) based on when it was enumerated; within
each bus, each device is given a similar number (<code class="docutils literal notranslate"><span class="pre">DDD</span></code>). Those <code class="docutils literal notranslate"><span class="pre">BBB/DDD</span></code>
paths are not “stable” identifiers; expect them to change even if you
always leave the devices plugged in to the same hub port. <em>Don’t even
think of saving these in application configuration files.</em> Stable
identifiers are available, for user mode applications that want to use
them. HID and networking devices expose these stable IDs, so that for
example you can be sure that you told the right UPS to power down its
second server. Pleast note that it doesn’t (yet) expose those IDs.</p>
</div>
<div class="section" id="dev-bus-usb-bbb-ddd">
<h3>/dev/bus/usb/BBB/DDD<a class="headerlink" href="#dev-bus-usb-bbb-ddd" title="Permalink to this headline">¶</a></h3>
<p>Use these files in one of these basic ways:</p>
<ul class="simple">
<li><p><em>They can be read,</em> producing first the device descriptor (18 bytes) and
then the descriptors for the current configuration. See the USB 2.0 spec
for details about those binary data formats. You’ll need to convert most
multibyte values from little endian format to your native host byte
order, although a few of the fields in the device descriptor (both of
the BCD-encoded fields, and the vendor and product IDs) will be
byteswapped for you. Note that configuration descriptors include
descriptors for interfaces, altsettings, endpoints, and maybe additional
class descriptors.</p></li>
<li><p><em>Perform USB operations</em> using <em>ioctl()</em> requests to make endpoint I/O
requests (synchronously or asynchronously) or manage the device. These
requests need the <code class="docutils literal notranslate"><span class="pre">CAP_SYS_RAWIO</span></code> capability, as well as filesystem
access permissions. Only one ioctl request can be made on one of these
device files at a time. This means that if you are synchronously reading
an endpoint from one thread, you won’t be able to write to a different
endpoint from another thread until the read completes. This works for
<em>half duplex</em> protocols, but otherwise you’d use asynchronous i/o
requests.</p></li>
</ul>
<p>Each connected USB device has one file.  The <code class="docutils literal notranslate"><span class="pre">BBB</span></code> indicates the bus
number.  The <code class="docutils literal notranslate"><span class="pre">DDD</span></code> indicates the device address on that bus.  Both
of these numbers are assigned sequentially, and can be reused, so
you can’t rely on them for stable access to devices.  For example,
it’s relatively common for devices to re-enumerate while they are
still connected (perhaps someone jostled their power supply, hub,
or USB cable), so a device might be <code class="docutils literal notranslate"><span class="pre">002/027</span></code> when you first connect
it and <code class="docutils literal notranslate"><span class="pre">002/048</span></code> sometime later.</p>
<p>These files can be read as binary data.  The binary data consists
of first the device descriptor, then the descriptors for each
configuration of the device.  Multi-byte fields in the device descriptor
are converted to host endianness by the kernel.  The configuration
descriptors are in bus endian format! The configuration descriptor
are wTotalLength bytes apart. If a device returns less configuration
descriptor data than indicated by wTotalLength there will be a hole in
the file for the missing bytes.  This information is also shown
in text form by the <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/usb/devices</span></code> file, described later.</p>
<p>These files may also be used to write user-level drivers for the USB
devices.  You would open the <code class="docutils literal notranslate"><span class="pre">/dev/bus/usb/BBB/DDD</span></code> file read/write,
read its descriptors to make sure it’s the device you expect, and then
bind to an interface (or perhaps several) using an ioctl call.  You
would issue more ioctls to the device to communicate to it using
control, bulk, or other kinds of USB transfers.  The IOCTLs are
listed in the <code class="docutils literal notranslate"><span class="pre">&lt;linux/usbdevice_fs.h&gt;</span></code> file, and at this writing the
source code (<code class="docutils literal notranslate"><span class="pre">linux/drivers/usb/core/devio.c</span></code>) is the primary reference
for how to access devices through those files.</p>
<p>Note that since by default these <code class="docutils literal notranslate"><span class="pre">BBB/DDD</span></code> files are writable only by
root, only root can write such user mode drivers.  You can selectively
grant read/write permissions to other users by using <code class="docutils literal notranslate"><span class="pre">chmod</span></code>.  Also,
usbfs mount options such as <code class="docutils literal notranslate"><span class="pre">devmode=0666</span></code> may be helpful.</p>
</div>
<div class="section" id="life-cycle-of-user-mode-drivers">
<h3>Life Cycle of User Mode Drivers<a class="headerlink" href="#life-cycle-of-user-mode-drivers" title="Permalink to this headline">¶</a></h3>
<p>Such a driver first needs to find a device file for a device it knows
how to handle. Maybe it was told about it because a <code class="docutils literal notranslate"><span class="pre">/sbin/hotplug</span></code>
event handling agent chose that driver to handle the new device. Or
maybe it’s an application that scans all the <code class="docutils literal notranslate"><span class="pre">/dev/bus/usb</span></code> device files,
and ignores most devices. In either case, it should <code class="xref c c-func docutils literal notranslate"><span class="pre">read()</span></code>
all the descriptors from the device file, and check them against what it
knows how to handle. It might just reject everything except a particular
vendor and product ID, or need a more complex policy.</p>
<p>Never assume there will only be one such device on the system at a time!
If your code can’t handle more than one device at a time, at least
detect when there’s more than one, and have your users choose which
device to use.</p>
<p>Once your user mode driver knows what device to use, it interacts with
it in either of two styles. The simple style is to make only control
requests; some devices don’t need more complex interactions than those.
(An example might be software using vendor-specific control requests for
some initialization or configuration tasks, with a kernel driver for the
rest.)</p>
<p>More likely, you need a more complex style driver: one using non-control
endpoints, reading or writing data and claiming exclusive use of an
interface. <em>Bulk</em> transfers are easiest to use, but only their sibling
<em>interrupt</em> transfers work with low speed devices. Both interrupt and
<em>isochronous</em> transfers offer service guarantees because their bandwidth
is reserved. Such “periodic” transfers are awkward to use through usbfs,
unless you’re using the asynchronous calls. However, interrupt transfers
can also be used in a synchronous “one shot” style.</p>
<p>Your user-mode driver should never need to worry about cleaning up
request state when the device is disconnected, although it should close
its open file descriptors as soon as it starts seeing the ENODEV errors.</p>
</div>
<div class="section" id="the-ioctl-requests">
<h3>The ioctl() Requests<a class="headerlink" href="#the-ioctl-requests" title="Permalink to this headline">¶</a></h3>
<p>To use these ioctls, you need to include the following headers in your
userspace program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/usb.h&gt;
#include &lt;linux/usbdevice_fs.h&gt;
#include &lt;asm/byteorder.h&gt;
</pre></div>
</div>
<p>The standard USB device model requests, from “Chapter 9” of the USB 2.0
specification, are automatically included from the <code class="docutils literal notranslate"><span class="pre">&lt;linux/usb/ch9.h&gt;</span></code>
header.</p>
<p>Unless noted otherwise, the ioctl requests described here will update
the modification time on the usbfs file to which they are applied
(unless they fail). A return of zero indicates success; otherwise, a
standard USB error code is returned (These are documented in
<a class="reference internal" href="error-codes.html#usb-error-codes"><span class="std std-ref">USB Error codes</span></a>).</p>
<p>Each of these files multiplexes access to several I/O streams, one per
endpoint. Each device has one control endpoint (endpoint zero) which
supports a limited RPC style RPC access. Devices are configured by
hub_wq (in the kernel) setting a device-wide <em>configuration</em> that
affects things like power consumption and basic functionality. The
endpoints are part of USB <em>interfaces</em>, which may have <em>altsettings</em>
affecting things like which endpoints are available. Many devices only
have a single configuration and interface, so drivers for them will
ignore configurations and altsettings.</p>
<div class="section" id="management-status-requests">
<h4>Management/Status Requests<a class="headerlink" href="#management-status-requests" title="Permalink to this headline">¶</a></h4>
<p>A number of usbfs requests don’t deal very directly with device I/O.
They mostly relate to device management and status. These are all
synchronous requests.</p>
<dl>
<dt>USBDEVFS_CLAIMINTERFACE</dt><dd><p>This is used to force usbfs to claim a specific interface, which has
not previously been claimed by usbfs or any other kernel driver. The
ioctl parameter is an integer holding the number of the interface
(bInterfaceNumber from descriptor).</p>
<p>Note that if your driver doesn’t claim an interface before trying to
use one of its endpoints, and no other driver has bound to it, then
the interface is automatically claimed by usbfs.</p>
<p>This claim will be released by a RELEASEINTERFACE ioctl, or by
closing the file descriptor. File modification time is not updated
by this request.</p>
</dd>
<dt>USBDEVFS_CONNECTINFO</dt><dd><p>Says whether the device is lowspeed. The ioctl parameter points to a
structure like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_connectinfo {
        unsigned int   devnum;
        unsigned char  slow;
};
</pre></div>
</div>
<p>File modification time is not updated by this request.</p>
<p><em>You can’t tell whether a “not slow” device is connected at high
speed (480 MBit/sec) or just full speed (12 MBit/sec).</em> You should
know the devnum value already, it’s the DDD value of the device file
name.</p>
</dd>
<dt>USBDEVFS_GETDRIVER</dt><dd><p>Returns the name of the kernel driver bound to a given interface (a
string). Parameter is a pointer to this structure, which is
modified:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_getdriver {
        unsigned int  interface;
        char          driver[USBDEVFS_MAXDRIVERNAME + 1];
};
</pre></div>
</div>
<p>File modification time is not updated by this request.</p>
</dd>
<dt>USBDEVFS_IOCTL</dt><dd><p>Passes a request from userspace through to a kernel driver that has
an ioctl entry in the <em><a class="reference internal" href="#c.usb_driver" title="usb_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_driver</span></code></a></em> it registered:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_ioctl {
        int     ifno;
        int     ioctl_code;
        void    *data;
};

/* user mode call looks like this.
 * &#39;request&#39; becomes the driver-&gt;ioctl() &#39;code&#39; parameter.
 * the size of &#39;param&#39; is encoded in &#39;request&#39;, and that data
 * is copied to or from the driver-&gt;ioctl() &#39;buf&#39; parameter.
 */
static int
usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
{
        struct usbdevfs_ioctl   wrapper;

        wrapper.ifno = ifno;
        wrapper.ioctl_code = request;
        wrapper.data = param;

        return ioctl (fd, USBDEVFS_IOCTL, &amp;wrapper);
}
</pre></div>
</div>
<p>File modification time is not updated by this request.</p>
<p>This request lets kernel drivers talk to user mode code through
filesystem operations even when they don’t create a character or
block special device. It’s also been used to do things like ask
devices what device special file should be used. Two pre-defined
ioctls are used to disconnect and reconnect kernel drivers, so that
user mode code can completely manage binding and configuration of
devices.</p>
</dd>
<dt>USBDEVFS_RELEASEINTERFACE</dt><dd><p>This is used to release the claim usbfs made on interface, either
implicitly or because of a USBDEVFS_CLAIMINTERFACE call, before the
file descriptor is closed. The ioctl parameter is an integer holding
the number of the interface (bInterfaceNumber from descriptor); File
modification time is not updated by this request.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><em>No security check is made to ensure that the task which made
the claim is the one which is releasing it. This means that user
mode driver may interfere other ones.</em></p>
</div>
</dd>
<dt>USBDEVFS_RESETEP</dt><dd><p>Resets the data toggle value for an endpoint (bulk or interrupt) to
DATA0. The ioctl parameter is an integer endpoint number (1 to 15,
as identified in the endpoint descriptor), with USB_DIR_IN added
if the device’s endpoint sends data to the host.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><em>Avoid using this request. It should probably be removed.</em> Using
it typically means the device and driver will lose toggle
synchronization. If you really lost synchronization, you likely
need to completely handshake with the device, using a request
like CLEAR_HALT or SET_INTERFACE.</p>
</div>
</dd>
<dt>USBDEVFS_DROP_PRIVILEGES</dt><dd><p>This is used to relinquish the ability to do certain operations
which are considered to be privileged on a usbfs file descriptor.
This includes claiming arbitrary interfaces, resetting a device on
which there are currently claimed interfaces from other users, and
issuing USBDEVFS_IOCTL calls. The ioctl parameter is a 32 bit mask
of interfaces the user is allowed to claim on this file descriptor.
You may issue this ioctl more than one time to narrow said mask.</p>
</dd>
</dl>
</div>
<div class="section" id="synchronous-i-o-support">
<h4>Synchronous I/O Support<a class="headerlink" href="#synchronous-i-o-support" title="Permalink to this headline">¶</a></h4>
<p>Synchronous requests involve the kernel blocking until the user mode
request completes, either by finishing successfully or by reporting an
error. In most cases this is the simplest way to use usbfs, although as
noted above it does prevent performing I/O to more than one endpoint at
a time.</p>
<dl>
<dt>USBDEVFS_BULK</dt><dd><p>Issues a bulk read or write request to the device. The ioctl
parameter is a pointer to this structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_bulktransfer {
        unsigned int  ep;
        unsigned int  len;
        unsigned int  timeout; /* in milliseconds */
        void          *data;
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ep</span></code> value identifies a bulk endpoint number (1 to 15, as
identified in an endpoint descriptor), masked with USB_DIR_IN when
referring to an endpoint which sends data to the host from the
device. The length of the data buffer is identified by <code class="docutils literal notranslate"><span class="pre">len</span></code>; Recent
kernels support requests up to about 128KBytes. <em>FIXME say how read
length is returned, and how short reads are handled.</em>.</p>
</dd>
<dt>USBDEVFS_CLEAR_HALT</dt><dd><p>Clears endpoint halt (stall) and resets the endpoint toggle. This is
only meaningful for bulk or interrupt endpoints. The ioctl parameter
is an integer endpoint number (1 to 15, as identified in an endpoint
descriptor), masked with USB_DIR_IN when referring to an endpoint
which sends data to the host from the device.</p>
<p>Use this on bulk or interrupt endpoints which have stalled,
returning <code class="docutils literal notranslate"><span class="pre">-EPIPE</span></code> status to a data transfer request. Do not issue
the control request directly, since that could invalidate the host’s
record of the data toggle.</p>
</dd>
<dt>USBDEVFS_CONTROL</dt><dd><p>Issues a control request to the device. The ioctl parameter points
to a structure like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_ctrltransfer {
        __u8   bRequestType;
        __u8   bRequest;
        __u16  wValue;
        __u16  wIndex;
        __u16  wLength;
        __u32  timeout;  /* in milliseconds */
        void   *data;
};
</pre></div>
</div>
<p>The first eight bytes of this structure are the contents of the
SETUP packet to be sent to the device; see the USB 2.0 specification
for details. The bRequestType value is composed by combining a
<code class="docutils literal notranslate"><span class="pre">USB_TYPE_*</span></code> value, a <code class="docutils literal notranslate"><span class="pre">USB_DIR_*</span></code> value, and a <code class="docutils literal notranslate"><span class="pre">USB_RECIP_*</span></code>
value (from <code class="docutils literal notranslate"><span class="pre">linux/usb.h</span></code>). If wLength is nonzero, it describes
the length of the data buffer, which is either written to the device
(USB_DIR_OUT) or read from the device (USB_DIR_IN).</p>
<p>At this writing, you can’t transfer more than 4 KBytes of data to or
from a device; usbfs has a limit, and some host controller drivers
have a limit. (That’s not usually a problem.) <em>Also</em> there’s no way
to say it’s not OK to get a short read back from the device.</p>
</dd>
<dt>USBDEVFS_RESET</dt><dd><p>Does a USB level device reset. The ioctl parameter is ignored. After
the reset, this rebinds all device interfaces. File modification
time is not updated by this request.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><em>Avoid using this call</em> until some usbcore bugs get fixed, since
it does not fully synchronize device, interface, and driver (not
just usbfs) state.</p>
</div>
<dl>
<dt>USBDEVFS_SETINTERFACE</dt><dd><p>Sets the alternate setting for an interface. The ioctl parameter is
a pointer to a structure like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_setinterface {
        unsigned int  interface;
        unsigned int  altsetting;
};
</pre></div>
</div>
<p>File modification time is not updated by this request.</p>
<p>Those struct members are from some interface descriptor applying to
the current configuration. The interface number is the
bInterfaceNumber value, and the altsetting number is the
bAlternateSetting value. (This resets each endpoint in the
interface.)</p>
</dd>
<dt>USBDEVFS_SETCONFIGURATION</dt><dd><p>Issues the <code class="xref c c-func docutils literal notranslate"><span class="pre">usb_set_configuration()</span></code> call for the
device. The parameter is an integer holding the number of a
configuration (bConfigurationValue from descriptor). File
modification time is not updated by this request.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><em>Avoid using this call</em> until some usbcore bugs get fixed, since
it does not fully synchronize device, interface, and driver (not
just usbfs) state.</p>
</div>
</div>
<div class="section" id="asynchronous-i-o-support">
<h4>Asynchronous I/O Support<a class="headerlink" href="#asynchronous-i-o-support" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, there are situations where it may be important to
initiate concurrent operations from user mode code. This is particularly
important for periodic transfers (interrupt and isochronous), but it can
be used for other kinds of USB requests too. In such cases, the
asynchronous requests described here are essential. Rather than
submitting one request and having the kernel block until it completes,
the blocking is separate.</p>
<p>These requests are packaged into a structure that resembles the URB used
by kernel device drivers. (No POSIX Async I/O support here, sorry.) It
identifies the endpoint type (<code class="docutils literal notranslate"><span class="pre">USBDEVFS_URB_TYPE_*</span></code>), endpoint
(number, masked with USB_DIR_IN as appropriate), buffer and length,
and a user “context” value serving to uniquely identify each request.
(It’s usually a pointer to per-request data.) Flags can modify requests
(not as many as supported for kernel drivers).</p>
<p>Each request can specify a realtime signal number (between SIGRTMIN and
SIGRTMAX, inclusive) to request a signal be sent when the request
completes.</p>
<p>When usbfs returns these urbs, the status value is updated, and the
buffer may have been modified. Except for isochronous transfers, the
actual_length is updated to say how many bytes were transferred; if the
USBDEVFS_URB_DISABLE_SPD flag is set (“short packets are not OK”), if
fewer bytes were read than were requested then you get an error report:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usbdevfs_iso_packet_desc {
        unsigned int                     length;
        unsigned int                     actual_length;
        unsigned int                     status;
};

struct usbdevfs_urb {
        unsigned char                    type;
        unsigned char                    endpoint;
        int                              status;
        unsigned int                     flags;
        void                             *buffer;
        int                              buffer_length;
        int                              actual_length;
        int                              start_frame;
        int                              number_of_packets;
        int                              error_count;
        unsigned int                     signr;
        void                             *usercontext;
        struct usbdevfs_iso_packet_desc  iso_frame_desc[];
};
</pre></div>
</div>
<p>For these asynchronous requests, the file modification time reflects
when the request was initiated. This contrasts with their use with the
synchronous requests, where it reflects when requests complete.</p>
<dl class="simple">
<dt>USBDEVFS_DISCARDURB</dt><dd><p><em>TBS</em> File modification time is not updated by this request.</p>
</dd>
<dt>USBDEVFS_DISCSIGNAL</dt><dd><p><em>TBS</em> File modification time is not updated by this request.</p>
</dd>
<dt>USBDEVFS_REAPURB</dt><dd><p><em>TBS</em> File modification time is not updated by this request.</p>
</dd>
<dt>USBDEVFS_REAPURBNDELAY</dt><dd><p><em>TBS</em> File modification time is not updated by this request.</p>
</dd>
<dt>USBDEVFS_SUBMITURB</dt><dd><p><em>TBS</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="the-usb-devices">
<h2>The USB devices<a class="headerlink" href="#the-usb-devices" title="Permalink to this headline">¶</a></h2>
<p>The USB devices are now exported via debugfs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/usb/devices</span></code> … a text file showing each of the USB
devices on known to the kernel, and their configuration descriptors.
You can also poll() this to learn about new devices.</p></li>
</ul>
<div class="section" id="sys-kernel-debug-usb-devices">
<h3>/sys/kernel/debug/usb/devices<a class="headerlink" href="#sys-kernel-debug-usb-devices" title="Permalink to this headline">¶</a></h3>
<p>This file is handy for status viewing tools in user mode, which can scan
the text format and ignore most of it. More detailed device status
(including class and vendor status) is available from device-specific
files. For information about the current format of this file, see below.</p>
<p>This file, in combination with the poll() system call, can also be used
to detect when devices are added or removed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fd;
struct pollfd pfd;

fd = open(&quot;/sys/kernel/debug/usb/devices&quot;, O_RDONLY);
pfd = { fd, POLLIN, 0 };
for (;;) {
    /* The first time through, this call will return immediately. */
    poll(&amp;pfd, 1, -1);

    /* To see what&#39;s changed, compare the file&#39;s previous and current
       contents or scan the filesystem.  (Scanning is more precise.) */
}
</pre></div>
</div>
<p>Note that this behavior is intended to be used for informational and
debug purposes. It would be more appropriate to use programs such as
udev or HAL to initialize a device or start a user-mode helper program,
for instance.</p>
<p>In this file, each device’s output has multiple lines of ASCII output.</p>
<p>I made it ASCII instead of binary on purpose, so that someone
can obtain some useful data from it without the use of an
auxiliary program.  However, with an auxiliary program, the numbers
in the first 4 columns of each <code class="docutils literal notranslate"><span class="pre">T:</span></code> line (topology info:
Lev, Prnt, Port, Cnt) can be used to build a USB topology diagram.</p>
<p>Each line is tagged with a one-character ID for that line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T = Topology (etc.)
B = Bandwidth (applies only to USB host controllers, which are
virtualized as root hubs)
D = Device descriptor info.
P = Product ID info. (from Device descriptor, but they won&#39;t fit
together on one line)
S = String descriptors.
C = Configuration descriptor info. (* = active configuration)
I = Interface descriptor info.
E = Endpoint descriptor info.
</pre></div>
</div>
<div class="section" id="sys-kernel-debug-usb-devices-output-format">
<h4>/sys/kernel/debug/usb/devices output format<a class="headerlink" href="#sys-kernel-debug-usb-devices-output-format" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>Legend::</dt><dd><p>d = decimal number (may have leading spaces or 0’s)
x = hexadecimal number (may have leading spaces or 0’s)
s = string</p>
</dd>
</dl>
<div class="section" id="topology-info">
<h5>Topology info<a class="headerlink" href="#topology-info" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T:  Bus=dd Lev=dd Prnt=dd Port=dd Cnt=dd Dev#=ddd Spd=dddd MxCh=dd
|   |      |      |       |       |      |        |        |__MaxChildren
|   |      |      |       |       |      |        |__Device Speed in Mbps
|   |      |      |       |       |      |__DeviceNumber
|   |      |      |       |       |__Count of devices at this level
|   |      |      |       |__Connector/Port on Parent for this device
|   |      |      |__Parent DeviceNumber
|   |      |__Level in topology for this bus
|   |__Bus number
|__Topology info tag
</pre></div>
</div>
<p>Speed may be:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>1.5</p></td>
<td><p>Mbit/s for low speed USB</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>Mbit/s for full speed USB</p></td>
</tr>
<tr class="row-odd"><td><p>480</p></td>
<td><p>Mbit/s for high speed USB (added for USB 2.0);
also used for Wireless USB, which has no fixed speed</p></td>
</tr>
<tr class="row-even"><td><p>5000</p></td>
<td><p>Mbit/s for SuperSpeed USB (added for USB 3.0)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For reasons lost in the mists of time, the Port number is always
too low by 1.  For example, a device plugged into port 4 will
show up with <code class="docutils literal notranslate"><span class="pre">Port=03</span></code>.</p>
</div>
<div class="section" id="bandwidth-info">
<h5>Bandwidth info<a class="headerlink" href="#bandwidth-info" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>B:  Alloc=ddd/ddd us (xx%), #Int=ddd, #Iso=ddd
|   |                       |         |__Number of isochronous requests
|   |                       |__Number of interrupt requests
|   |__Total Bandwidth allocated to this bus
|__Bandwidth info tag
</pre></div>
</div>
<p>Bandwidth allocation is an approximation of how much of one frame
(millisecond) is in use.  It reflects only periodic transfers, which
are the only transfers that reserve bandwidth.  Control and bulk
transfers use all other bandwidth, including reserved bandwidth that
is not used for transfers (such as for short packets).</p>
<p>The percentage is how much of the “reserved” bandwidth is scheduled by
those transfers.  For a low or full speed bus (loosely, “USB 1.1”),
90% of the bus bandwidth is reserved.  For a high speed bus (loosely,
“USB 2.0”) 80% is reserved.</p>
</div>
<div class="section" id="device-descriptor-info-product-id-info">
<h5>Device descriptor info &amp; Product ID info<a class="headerlink" href="#device-descriptor-info-product-id-info" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>D:  Ver=x.xx Cls=xx(s) Sub=xx Prot=xx MxPS=dd #Cfgs=dd
P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
</pre></div>
</div>
<p>where:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>D:  Ver=x.xx Cls=xx(sssss) Sub=xx Prot=xx MxPS=dd #Cfgs=dd
|   |        |             |      |       |       |__NumberConfigurations
|   |        |             |      |       |__MaxPacketSize of Default Endpoint
|   |        |             |      |__DeviceProtocol
|   |        |             |__DeviceSubClass
|   |        |__DeviceClass
|   |__Device USB version
|__Device info tag #1
</pre></div>
</div>
<p>where:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
|   |           |           |__Product revision number
|   |           |__Product ID code
|   |__Vendor ID code
|__Device info tag #2
</pre></div>
</div>
</div>
<div class="section" id="string-descriptor-info">
<h5>String descriptor info<a class="headerlink" href="#string-descriptor-info" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>S:  Manufacturer=ssss
|   |__Manufacturer of this device as read from the device.
|      For USB host controller drivers (virtual root hubs) this may
|      be omitted, or (for newer drivers) will identify the kernel
|      version and the driver which provides this hub emulation.
|__String info tag

S:  Product=ssss
|   |__Product description of this device as read from the device.
|      For older USB host controller drivers (virtual root hubs) this
|      indicates the driver; for newer ones, it&#39;s a product (and vendor)
|      description that often comes from the kernel&#39;s PCI ID database.
|__String info tag

S:  SerialNumber=ssss
|   |__Serial Number of this device as read from the device.
|      For USB host controller drivers (virtual root hubs) this is
|      some unique ID, normally a bus ID (address or slot name) that
|      can&#39;t be shared with any other device.
|__String info tag
</pre></div>
</div>
</div>
<div class="section" id="configuration-descriptor-info">
<h5>Configuration descriptor info<a class="headerlink" href="#configuration-descriptor-info" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>C:* #Ifs=dd Cfg#=dd Atr=xx MPwr=dddmA
| | |       |       |      |__MaxPower in mA
| | |       |       |__Attributes
| | |       |__ConfiguratioNumber
| | |__NumberOfInterfaces
| |__ &quot;*&quot; indicates the active configuration (others are &quot; &quot;)
|__Config info tag
</pre></div>
</div>
<p>USB devices may have multiple configurations, each of which act
rather differently.  For example, a bus-powered configuration
might be much less capable than one that is self-powered.  Only
one device configuration can be active at a time; most devices
have only one configuration.</p>
<p>Each configuration consists of one or more interfaces.  Each
interface serves a distinct “function”, which is typically bound
to a different USB device driver.  One common example is a USB
speaker with an audio interface for playback, and a HID interface
for use with software volume control.</p>
</div>
<div class="section" id="interface-descriptor-info-can-be-multiple-per-config">
<h5>Interface descriptor info (can be multiple per Config)<a class="headerlink" href="#interface-descriptor-info-can-be-multiple-per-config" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>I:* If#=dd Alt=dd #EPs=dd Cls=xx(sssss) Sub=xx Prot=xx Driver=ssss
| | |      |      |       |             |      |       |__Driver name
| | |      |      |       |             |      |          or &quot;(none)&quot;
| | |      |      |       |             |      |__InterfaceProtocol
| | |      |      |       |             |__InterfaceSubClass
| | |      |      |       |__InterfaceClass
| | |      |      |__NumberOfEndpoints
| | |      |__AlternateSettingNumber
| | |__InterfaceNumber
| |__ &quot;*&quot; indicates the active altsetting (others are &quot; &quot;)
|__Interface info tag
</pre></div>
</div>
<p>A given interface may have one or more “alternate” settings.
For example, default settings may not use more than a small
amount of periodic bandwidth.  To use significant fractions
of bus bandwidth, drivers must select a non-default altsetting.</p>
<p>Only one setting for an interface may be active at a time, and
only one driver may bind to an interface at a time.  Most devices
have only one alternate setting per interface.</p>
</div>
<div class="section" id="endpoint-descriptor-info-can-be-multiple-per-interface">
<h5>Endpoint descriptor info (can be multiple per Interface)<a class="headerlink" href="#endpoint-descriptor-info-can-be-multiple-per-interface" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>E:  Ad=xx(s) Atr=xx(ssss) MxPS=dddd Ivl=dddss
|   |        |            |         |__Interval (max) between transfers
|   |        |            |__EndpointMaxPacketSize
|   |        |__Attributes(EndpointType)
|   |__EndpointAddress(I=In,O=Out)
|__Endpoint info tag
</pre></div>
</div>
<p>The interval is nonzero for all periodic (interrupt or isochronous)
endpoints.  For high speed endpoints the transfer interval may be
measured in microseconds rather than milliseconds.</p>
<p>For high speed periodic endpoints, the <code class="docutils literal notranslate"><span class="pre">EndpointMaxPacketSize</span></code> reflects
the per-microframe data transfer size.  For “high bandwidth”
endpoints, that can reflect two or three packets (for up to
3KBytes every 125 usec) per endpoint.</p>
<p>With the Linux-USB stack, periodic bandwidth reservations use the
transfer intervals and sizes provided by URBs, which can be less
than those found in endpoint descriptor.</p>
</div>
</div>
<div class="section" id="usage-examples">
<h4>Usage examples<a class="headerlink" href="#usage-examples" title="Permalink to this headline">¶</a></h4>
<p>If a user or script is interested only in Topology info, for
example, use something like <code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">^T:</span> <span class="pre">/sys/kernel/debug/usb/devices</span></code>
for only the Topology lines.  A command like
<code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">-i</span> <span class="pre">^[tdp]:</span> <span class="pre">/sys/kernel/debug/usb/devices</span></code> can be used to list
only the lines that begin with the characters in square brackets,
where the valid characters are TDPCIE.  With a slightly more able
script, it can display any selected lines (for example, only T, D,
and P lines) and change their output format.  (The <code class="docutils literal notranslate"><span class="pre">procusb</span></code>
Perl script is the beginning of this idea.  It will list only
selected lines [selected from TBDPSCIE] or “All” lines from
<code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/usb/devices</span></code>.)</p>
<p>The Topology lines can be used to generate a graphic/pictorial
of the USB devices on a system’s root hub.  (See more below
on how to do this.)</p>
<p>The Interface lines can be used to determine what driver is
being used for each device, and which altsetting it activated.</p>
<p>The Configuration lines could be used to list maximum power
(in milliamps) that a system’s USB devices are using.
For example, <code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">^C:</span> <span class="pre">/sys/kernel/debug/usb/devices</span></code>.</p>
<p>Here’s an example, from a system which has a UHCI root hub,
an external hub connected to the root hub, and a mouse and
a serial converter connected to the external hub.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 2
B:  Alloc= 28/900 us ( 3%), #Int=  2, #Iso=  0
D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=0000 ProdID=0000 Rev= 0.00
S:  Product=USB UHCI Root Hub
S:  SerialNumber=dce0
C:* #Ifs= 1 Cfg#= 1 Atr=40 MxPwr=  0mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=255ms

T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12   MxCh= 4
D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=0451 ProdID=1446 Rev= 1.00
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=100mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   1 Ivl=255ms

T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  3 Spd=1.5  MxCh= 0
D:  Ver= 1.00 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=04b4 ProdID=0001 Rev= 0.00
C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=100mA
I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
E:  Ad=81(I) Atr=03(Int.) MxPS=   3 Ivl= 10ms

T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev#=  4 Spd=12   MxCh= 0
D:  Ver= 1.00 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=0565 ProdID=0001 Rev= 1.08
S:  Manufacturer=Peracom Networks, Inc.
S:  Product=Peracom USB to Serial Converter
C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
I:  If#= 0 Alt= 0 #EPs= 3 Cls=00(&gt;ifc ) Sub=00 Prot=00 Driver=serial
E:  Ad=81(I) Atr=02(Bulk) MxPS=  64 Ivl= 16ms
E:  Ad=01(O) Atr=02(Bulk) MxPS=  16 Ivl= 16ms
E:  Ad=82(I) Atr=03(Int.) MxPS=   8 Ivl=  8ms
</pre></div>
</div>
<p>Selecting only the <code class="docutils literal notranslate"><span class="pre">T:</span></code> and <code class="docutils literal notranslate"><span class="pre">I:</span></code> lines from this (for example, by using
<code class="docutils literal notranslate"><span class="pre">procusb</span> <span class="pre">ti</span></code>), we have</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 2
T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12   MxCh= 4
I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  3 Spd=1.5  MxCh= 0
I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev#=  4 Spd=12   MxCh= 0
I:  If#= 0 Alt= 0 #EPs= 3 Cls=00(&gt;ifc ) Sub=00 Prot=00 Driver=serial
</pre></div>
</div>
<p>Physically this looks like (or could be converted to):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    +------------------+
                    |  PC/root_hub (12)|   Dev# = 1
                    +------------------+   (nn) is Mbps.
  Level 0           |  CN.0   |  CN.1  |   [CN = connector/port #]
                    +------------------+
                        /
                       /
          +-----------------------+
Level 1   | Dev#2: 4-port hub (12)|
          +-----------------------+
          |CN.0 |CN.1 |CN.2 |CN.3 |
          +-----------------------+
              \           \____________________
               \_____                          \
                     \                          \
             +--------------------+      +--------------------+
Level 2      | Dev# 3: mouse (1.5)|      | Dev# 4: serial (12)|
             +--------------------+      +--------------------+
</pre></div>
</div>
<p>Or, in a more tree-like structure (ports [Connectors] without
connections could be omitted):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PC:  Dev# 1, root hub, 2 ports, 12 Mbps
|_ CN.0:  Dev# 2, hub, 4 ports, 12 Mbps
     |_ CN.0:  Dev #3, mouse, 1.5 Mbps
     |_ CN.1:
     |_ CN.2:  Dev #4, serial, 12 Mbps
     |_ CN.3:
|_ CN.1:
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gadget.html" class="btn btn-neutral float-right" title="USB Gadget API for Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Linux USB API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>