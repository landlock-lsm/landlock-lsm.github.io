

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device links &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Component Helper for Aggregate Drivers" href="component.html" />
    <link rel="prev" title="Buffer Sharing and Synchronization" href="dma-buf.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Device links</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state-machine">State machine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Device links</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/device_link.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-links">
<span id="device-link"></span><h1>Device links<a class="headerlink" href="#device-links" title="Permalink to this headline">¶</a></h1>
<p>By default, the driver core only enforces dependencies between devices
that are borne out of a parent/child relationship within the device
hierarchy: When suspending, resuming or shutting down the system, devices
are ordered based on this relationship, i.e. children are always suspended
before their parent, and the parent is always resumed before its children.</p>
<p>Sometimes there is a need to represent device dependencies beyond the
mere parent/child relationship, e.g. between siblings, and have the
driver core automatically take care of them.</p>
<p>Secondly, the driver core by default does not enforce any driver presence
dependencies, i.e. that one device must be bound to a driver before
another one can probe or function correctly.</p>
<p>Often these two dependency types come together, so a device depends on
another one both with regards to driver presence <em>and</em> with regards to
suspend/resume and shutdown ordering.</p>
<p>Device links allow representation of such dependencies in the driver core.</p>
<p>In its standard or <em>managed</em> form, a device link combines <em>both</em> dependency
types:  It guarantees correct suspend/resume and shutdown ordering between a
“supplier” device and its “consumer” devices, and it guarantees driver
presence on the supplier.  The consumer devices are not probed before the
supplier is bound to a driver, and they’re unbound before the supplier
is unbound.</p>
<p>When driver presence on the supplier is irrelevant and only correct
suspend/resume and shutdown ordering is needed, the device link may
simply be set up with the <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> flag.  In other words,
enforcing driver presence on the supplier is optional.</p>
<p>Another optional feature is runtime PM integration:  By setting the
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> flag on addition of the device link, the PM core
is instructed to runtime resume the supplier and keep it active
whenever and for as long as the consumer is runtime resumed.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The earliest point in time when device links can be added is after
<a class="reference internal" href="infrastructure.html#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> has been called for the supplier and
<a class="reference internal" href="infrastructure.html#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a> has been called for the consumer.</p>
<p>It is legal to add them later, but care must be taken that the system
remains in a consistent state:  E.g. a device link cannot be added in
the midst of a suspend/resume transition, so either commencement of
such a transition needs to be prevented with <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_system_sleep()</span></code>,
or the device link needs to be added from a function which is guaranteed
not to run in parallel to a suspend/resume transition, such as from a
device <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback or a boot-time PCI quirk.</p>
<p>Another example for an inconsistent state would be a device link that
represents a driver presence dependency, yet is added from the consumer’s
<code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback while the supplier hasn’t started to probe yet:  Had the
driver core known about the device link earlier, it wouldn’t have probed the
consumer in the first place.  The onus is thus on the consumer to check
presence of the supplier after adding the link, and defer probing on
non-presence.  [Note that it is valid to create a link from the consumer’s
<code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback while the supplier is still probing, but the consumer must
know that the supplier is functional already at the link creation time (that is
the case, for instance, if the consumer has just acquired some resources that
would not have been available had the supplier not been functional then).]</p>
<p>If a device link with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> set (i.e. a stateless device link)
is added in the <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback of the supplier or consumer driver, it is
typically deleted in its <code class="docutils literal notranslate"><span class="pre">-&gt;remove</span></code> callback for symmetry.  That way, if the
driver is compiled as a module, the device link is added on module load and
orderly deleted on unload.  The same restrictions that apply to device link
addition (e.g. exclusion of a parallel suspend/resume transition) apply equally
to deletion.  Device links managed by the driver core are deleted automatically
by it.</p>
<p>Several flags may be specified on device link addition, two of which
have already been mentioned above:  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> to express that no
driver presence dependency is needed (but only correct suspend/resume and
shutdown ordering) and <code class="docutils literal notranslate"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> to express that runtime PM
integration is desired.</p>
<p>Two other flags are specifically targeted at use cases where the device
link is added from the consumer’s <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback:  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_RPM_ACTIVE</span></code>
can be specified to runtime resume the supplier and prevent it from suspending
before the consumer is runtime suspended.  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code>
causes the device link to be automatically purged when the consumer fails to
probe or later unbinds.</p>
<p>Similarly, when the device link is added from supplier’s <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback,
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> causes the device link to be automatically
purged when the supplier fails to probe or later unbinds.</p>
<p>If neither <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code> nor <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code>
is set, <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOPROBE_CONSUMER</span></code> can be used to request the driver core
to probe for a driver for the consumer driver on the link automatically after
a driver has been bound to the supplier device.</p>
<p>Note, however, that any combinations of <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code>,
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> or <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOPROBE_CONSUMER</span></code> with
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> are invalid and cannot be used.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>Driver authors should be aware that a driver presence dependency for managed
device links (i.e. when <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> is not specified on link addition)
may cause probing of the consumer to be deferred indefinitely.  This can become
a problem if the consumer is required to probe before a certain initcall level
is reached.  Worse, if the supplier driver is blacklisted or missing, the
consumer will never be probed.</p>
<p>Moreover, managed device links cannot be deleted directly.  They are deleted
by the driver core when they are not necessary any more in accordance with the
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code> and <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> flags.
However, stateless device links (i.e. device links with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code>
set) are expected to be removed by whoever called <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>
to add them with the help of either <a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or
<a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">DL_FLAG_RPM_ACTIVE</span></code> along with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> to
<a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> may cause the PM-runtime usage counter of the
supplier device to remain nonzero after a subsequent invocation of either
<a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a> to remove the
device link returned by it.  This happens if <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> is
called twice in a row for the same consumer-supplier pair without removing the
link between these calls, in which case allowing the PM-runtime usage counter
of the supplier to drop on an attempt to remove the link may cause it to be
suspended while the consumer is still PM-runtime-active and that has to be
avoided.  [To work around this limitation it is sufficient to let the consumer
runtime suspend at least once, or call <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_set_suspended()</span></code> for
it with PM-runtime disabled, between the <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> and
<a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a> calls.]</p>
<p>Sometimes drivers depend on optional resources.  They are able to operate
in a degraded mode (reduced feature set or performance) when those resources
are not present.  An example is an SPI controller that can use a DMA engine
or work in PIO mode.  The controller can determine presence of the optional
resources at probe time but on non-presence there is no way to know whether
they will become available in the near future (due to a supplier driver
probing) or never.  Consequently it cannot be determined whether to defer
probing or not.  It would be possible to notify drivers when optional
resources become available after probing, but it would come at a high cost
for drivers as switching between modes of operation at runtime based on the
availability of such resources would be much more complex than a mechanism
based on probe deferral.  In any case optional resources are beyond the
scope of device links.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>An MMU device exists alongside a busmaster device, both are in the same
power domain.  The MMU implements DMA address translation for the busmaster
device and shall be runtime resumed and kept active whenever and as long
as the busmaster device is active.  The busmaster device’s driver shall
not bind before the MMU is bound.  To achieve this, a device link with
runtime PM integration is added from the busmaster device (consumer)
to the MMU device (supplier).  The effect with regards to runtime PM
is the same as if the MMU was the parent of the master device.</p>
<p>The fact that both devices share the same power domain would normally
suggest usage of a <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> or struct generic_pm_domain,
however these are not independent devices that happen to share a power
switch, but rather the MMU device serves the busmaster device and is
useless without it.  A device link creates a synthetic hierarchical
relationship between the devices and is thus more apt.</p>
</li>
<li><p>A Thunderbolt host controller comprises a number of PCIe hotplug ports
and an NHI device to manage the PCIe switch.  On resume from system sleep,
the NHI device needs to re-establish PCI tunnels to attached devices
before the hotplug ports can resume.  If the hotplug ports were children
of the NHI, this resume order would automatically be enforced by the
PM core, but unfortunately they’re aunts.  The solution is to add
device links from the hotplug ports (consumers) to the NHI device
(supplier).  A driver presence dependency is not necessary for this
use case.</p></li>
<li><p>Discrete GPUs in hybrid graphics laptops often feature an HDA controller
for HDMI/DP audio.  In the device hierarchy the HDA controller is a sibling
of the VGA device, yet both share the same power domain and the HDA
controller is only ever needed when an HDMI/DP display is attached to the
VGA device.  A device link from the HDA controller (consumer) to the
VGA device (supplier) aptly represents this relationship.</p></li>
<li><p>ACPI allows definition of a device start order by way of _DEP objects.
A classical example is when ACPI power management methods on one device
are implemented in terms of I<sup>2</sup>C accesses and require a specific
I<sup>2</sup>C controller to be present and functional for the power
management of the device in question to work.</p></li>
<li><p>In some SoCs a functional dependency exists from display, video codec and
video processing IP cores on transparent memory access IP cores that handle
burst access and compression/decompression.</p></li>
</ul>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> can be used to override the bus,
class or device type callbacks.  It is intended for devices sharing
a single on/off switch, however it does not guarantee a specific
suspend/resume ordering, this needs to be implemented separately.
It also does not by itself track the runtime PM status of the involved
devices and turn off the power switch only when all of them are runtime
suspended.  Furthermore it cannot be used to enforce a specific shutdown
ordering or a driver presence dependency.</p></li>
<li><p>A struct generic_pm_domain is a lot more heavyweight than a
device link and does not allow for shutdown ordering or driver presence
dependencies.  It also cannot be used on ACPI systems.</p></li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The device hierarchy, which – as the name implies – is a tree,
becomes a directed acyclic graph once device links are added.</p>
<p>Ordering of these devices during suspend/resume is determined by the
dpm_list.  During shutdown it is determined by the devices_kset.  With
no device links present, the two lists are a flattened, one-dimensional
representations of the device tree such that a device is placed behind
all its ancestors.  That is achieved by traversing the ACPI namespace
or OpenFirmware device tree top-down and appending devices to the lists
as they are discovered.</p>
<p>Once device links are added, the lists need to satisfy the additional
constraint that a device is placed behind all its suppliers, recursively.
To ensure this, upon addition of the device link the consumer and the
entire sub-graph below it (all children and consumers of the consumer)
are moved to the end of the list.  (Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_reorder_to_tail()</span></code>
from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>.)</p>
<p>To prevent introduction of dependency loops into the graph, it is
verified upon device link addition that the supplier is not dependent
on the consumer or any children or consumers of the consumer.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_is_dependent()</span></code> from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>.)
If that constraint is violated, <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> will return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> and a <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> will be logged.</p>
<p>Notably this also prevents the addition of a device link from a parent
device to a child.  However the converse is allowed, i.e. a device link
from a child to a parent.  Since the driver core already guarantees
correct suspend/resume and shutdown ordering between parent and child,
such a device link only makes sense if a driver presence dependency is
needed on top of that.  In this case driver authors should weigh
carefully if a device link is at all the right tool for the purpose.
A more suitable approach might be to simply use deferred probing or
add a device flag causing the parent driver to be probed before the
child one.</p>
</div>
<div class="section" id="state-machine">
<h2>State machine<a class="headerlink" href="#state-machine" title="Permalink to this headline">¶</a></h2>
<dl class="c enum">
<dt id="c.device_link_state">
<em class="property">enum </em><code class="sig-name descname">device_link_state</code><a class="headerlink" href="#c.device_link_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Device link states.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_NONE</span></code></dt><dd><p>The presence of the drivers is not being tracked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code></dt><dd><p>None of the supplier/consumer drivers is present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code></dt><dd><p>The supplier driver is present, but the consumer is not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code></dt><dd><p>The consumer is probing (supplier driver present).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_ACTIVE</span></code></dt><dd><p>Both the supplier and consumer drivers are present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code></dt><dd><p>The supplier driver is unbinding.</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                .=============================.
                |                             |
                v                             |
DORMANT &lt;=&gt; AVAILABLE &lt;=&gt; CONSUMER_PROBE =&gt; ACTIVE
   ^                                          |
   |                                          |
   &#39;============ SUPPLIER_UNBIND &lt;============&#39;
</pre></div>
</div>
<ul class="simple">
<li><p>The initial state of a device link is automatically determined by
<a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> based on the driver presence on the supplier
and consumer.  If the link is created before any devices are probed, it
is set to <code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code>.</p></li>
<li><p>When a supplier device is bound to a driver, links to its consumers
progress to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_bound()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">driver_bound()</span></code>.)</p></li>
<li><p>Before a consumer device is probed, presence of supplier drivers is
verified by checking the consumer device is not in the wait_for_suppliers
list and by checking that links to suppliers are in <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>
state.  The state of the links is updated to <code class="docutils literal notranslate"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)
This prevents the supplier from unbinding.
(Call to <a class="reference internal" href="infrastructure.html#c.wait_for_device_probe" title="wait_for_device_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_for_device_probe()</span></code></a> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_unbind_consumers()</span></code>.)</p></li>
<li><p>If the probe fails, links to suppliers revert back to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_no_driver()</span></code> from <code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)</p></li>
<li><p>If the probe succeeds, links to suppliers progress to <code class="docutils literal notranslate"><span class="pre">DL_STATE_ACTIVE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_bound()</span></code> from <code class="xref c c-func docutils literal notranslate"><span class="pre">driver_bound()</span></code>.)</p></li>
<li><p>When the consumer’s driver is later on removed, links to suppliers revert
back to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">__device_links_no_driver()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_cleanup()</span></code>, which in turn is called from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)</p></li>
<li><p>Before a supplier’s driver is removed, links to consumers that are not
bound to a driver are updated to <code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_busy()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)
This prevents the consumers from binding.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)
Consumers that are bound are freed from their driver; consumers that are
probing are waited for until they are done.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_unbind_consumers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)
Once all links to consumers are in <code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code> state,
the supplier driver is released and the links revert to <code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_cleanup()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)</p></li>
</ul>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>, <a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> and <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="component.html" class="btn btn-neutral float-right" title="Component Helper for Aggregate Drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dma-buf.html" class="btn btn-neutral float-left" title="Buffer Sharing and Synchronization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>