

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Userland interfaces &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel clients" href="drm-client.html" />
    <link rel="prev" title="Mode Setting Helper Functions" href="drm-kms-helpers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Userland interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libdrm-device-lookup">libdrm Device Lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primary-nodes-drm-master-and-authentication">Primary Nodes, DRM Master and Authentication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#open-source-userspace-requirements">Open-Source Userspace Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#render-nodes">Render nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-hot-unplug">Device Hot-Unplug</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements-for-kms-uapi">Requirements for KMS UAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#requirements-for-render-and-cross-device-uapi">Requirements for Render and Cross-Device UAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#requirements-for-memory-maps">Requirements for Memory Maps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-support-on-device-nodes">IOCTL Support on Device Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#recommended-ioctl-return-values">Recommended IOCTL Return Values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-and-validation">Testing and validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#testing-requirements-for-userspace-api">Testing Requirements for userspace API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#validating-changes-with-igt">Validating changes with IGT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-vkms-to-test-drm-api">Using VKMS to test DRM API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-crc-support">Display CRC Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugfs-support">Debugfs Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-support">Sysfs Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vblank-event-handling">VBlank event handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#userspace-api-structures">Userspace API Structures</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight.html">Backlight support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>Userland interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-uapi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="userland-interfaces">
<h1>Userland interfaces<a class="headerlink" href="#userland-interfaces" title="Permalink to this headline">¶</a></h1>
<p>The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers &amp; device-aware applications through ioctls and sysfs files.</p>
<p>External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.</p>
<p>Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.</p>
<div class="section" id="libdrm-device-lookup">
<h2>libdrm Device Lookup<a class="headerlink" href="#libdrm-device-lookup" title="Permalink to this headline">¶</a></h2>
<p>BEWARE THE DRAGONS! MIND THE TRAPDOORS!</p>
<p>In an attempt to warn anyone else who’s trying to figure out what’s going
on here, I’ll try to summarize the story. First things first, let’s clear up
the names, because the kernel internals, libdrm and the ioctls are all named
differently:</p>
<blockquote>
<div><ul class="simple">
<li><p>GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm
through the drmGetBusid function.</p></li>
<li><p>The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All
that code is nerved in the kernel with <a class="reference internal" href="#c.drm_invalid_op" title="drm_invalid_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_invalid_op()</span></code></a>.</p></li>
<li><p>The internal set_busid kernel functions and driver callbacks are
exclusively use by the SET_VERSION ioctl, because only drm 1.0 (which is
nerved) allowed userspace to set the busid through the above ioctl.</p></li>
<li><p>Other ioctls and functions involved are named consistently.</p></li>
</ul>
</div></blockquote>
<p>For anyone wondering what’s the difference between drm 1.1 and 1.4: Correctly
handling pci domains in the busid on ppc. Doing this correctly was only
implemented in libdrm in 2010, hence can’t be nerved yet. No one knows what’s
special with drm 1.2 and 1.3.</p>
<p>Now the actual horror story of how device lookup in drm works. At large,
there’s 2 different ways, either by busid, or by device driver name.</p>
<p>Opening by busid is fairly simple:</p>
<ol class="arabic simple">
<li><p>First call SET_VERSION to make sure pci domains are handled properly. As a
side-effect this fills out the unique name in the master structure.</p></li>
<li><p>Call GET_UNIQUE to read out the unique name from the master structure,
which matches the busid thanks to step 1. If it doesn’t, proceed to try
the next device node.</p></li>
</ol>
<p>Opening by name is slightly different:</p>
<ol class="arabic simple">
<li><p>Directly call VERSION to get the version and to match against the driver
name returned by that ioctl. Note that SET_VERSION is not called, which
means the the unique name for the master node just opening is _not_ filled
out. This despite that with current drm device nodes are always bound to
one device, and can’t be runtime assigned like with drm 1.0.</p></li>
<li><p>Match driver name. If it mismatches, proceed to the next device node.</p></li>
<li><p>Call GET_UNIQUE, and check whether the unique name has length zero (by
checking that the first byte in the string is 0). If that’s not the case
libdrm skips and proceeds to the next device node. Probably this is just
copypasta from drm 1.0 times where a set unique name meant that the driver
was in use already, but that’s just conjecture.</p></li>
</ol>
<p>Long story short: To keep the open by name logic working, GET_UNIQUE must
_not_ return a unique string when SET_VERSION hasn’t been called yet,
otherwise libdrm breaks. Even when that unique string can’t ever change, and
is totally irrelevant for actually opening the device because runtime
assignable device instances were only support in drm 1.0, which is long dead.
But the libdrm code in drmOpenByName somehow survived, hence this can’t be
broken.</p>
</div>
<div class="section" id="primary-nodes-drm-master-and-authentication">
<span id="drm-primary-node"></span><h2>Primary Nodes, DRM Master and Authentication<a class="headerlink" href="#primary-nodes-drm-master-and-authentication" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> is used to track groups of clients with open
primary/legacy device nodes. For every <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> which has had at
least once successfully became the device master (either through the
SET_MASTER IOCTL, or implicitly through opening the primary device node when
no one else is the current master that time) there exists one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a>.
This is noted in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.is_master</span></code></a>. All other clients have just a pointer
to the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> they are associated with.</p>
<p>In addition only one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> can be the current master for a <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a>.
It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
implicitly through closing/openeing the primary device node. See also
<a class="reference internal" href="#c.drm_is_current_master" title="drm_is_current_master"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_is_current_master()</span></code></a>.</p>
<p>Clients can authenticate against the current master (if it matches their own)
using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
this allows controlled access to the device for an entire group of mutually
trusted clients.</p>
<dl class="c function">
<dt id="c.drm_is_current_master">
bool <code class="sig-name descname">drm_is_current_master</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>fpriv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_current_master" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks whether <strong>priv</strong> is the current master</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*fpriv</span></code></dt><dd><p>DRM file private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>fpriv</strong> is current master on its device. This decides whether a
client is allowed to run DRM_MASTER IOCTLs.</p>
<p>Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting
- the current master is assumed to own the non-shareable display hardware.</p>
<dl class="c function">
<dt id="c.drm_master_get">
<em class="property">struct</em> <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> *<code class="sig-name descname">drm_master_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> *<em>master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reference a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">*master</span></code></dt><dd><p><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count of <strong>master</strong> and returns a pointer to <strong>master</strong>.</p>
<dl class="c function">
<dt id="c.drm_master_put">
void <code class="sig-name descname">drm_master_put</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> **<em>master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unreference and clear a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">**master</span></code></dt><dd><p>pointer to a pointer of <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This decrements the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> behind <strong>master</strong> and sets it to NULL.</p>
<dl class="c struct">
<dt id="c.drm_master">
<em class="property">struct </em><code class="sig-name descname">drm_master</code><a class="headerlink" href="#c.drm_master" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>drm master structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_master {
  struct kref refcount;
  struct drm_device *dev;
  char *unique;
  int unique_len;
  struct idr magic_map;
  void *driver_priv;
  struct drm_master *lessor;
  int lessee_id;
  struct list_head lessee_list;
  struct list_head lessees;
  struct idr leases;
  struct idr lessee_idr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>Refcount for this master object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Link back to the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unique</span></code></dt><dd><p>Unique identifier: e.g. busid. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unique_len</span></code></dt><dd><p>Length of unique field. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">magic_map</span></code></dt><dd><p>Map of used authentication tokens. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_priv</span></code></dt><dd><p>Pointer to driver-private information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessor</span></code></dt><dd><p>Lease holder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>id for lessees. Owners always have id 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_list</span></code></dt><dd><p>other lessees of the same master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessees</span></code></dt><dd><p>drm_masters leasing from this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leases</span></code></dt><dd><p>Objects leased to this drm_master.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_idr</span></code></dt><dd><p>All lessees under this owner (only used where lessor == NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm_minor.</p>
</div>
<div class="section" id="open-source-userspace-requirements">
<h2>Open-Source Userspace Requirements<a class="headerlink" href="#open-source-userspace-requirements" title="Permalink to this headline">¶</a></h2>
<p>The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.</p>
<p>The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.</p>
<p>GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that’s required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.</p>
<p>Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:</p>
<ul class="simple">
<li><p>The Linux kernel’s “no regression” policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.</p></li>
<li><p>Any new userspace interface must have an open-source implementation as
demonstration vehicle.</p></li>
</ul>
<p>The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:</p>
<ul class="simple">
<li><p>The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.</p></li>
<li><p>The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.  The userspace-side reviewer should also provide an Acked-by on the
kernel uAPI patch indicating that they believe the proposed uAPI is sound and
sufficiently documented and validated for userspace’s consumption.</p></li>
<li><p>The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.</p></li>
<li><p>The kernel patch can only be merged after all the above requirements are met,
but it <strong>must</strong> be merged to either drm-next or drm-misc-next <strong>before</strong> the
userspace patches land. uAPI always flows from the kernel, doing things the
other way round risks divergence of the uAPI definitions and header files.</p></li>
</ul>
<p>These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel’s guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.</p>
</div>
<div class="section" id="render-nodes">
<span id="drm-render-node"></span><h2>Render nodes<a class="headerlink" href="#render-nodes" title="Permalink to this headline">¶</a></h2>
<p>DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&lt;num&gt;. Additionally, a currently unused control node,
called controlD&lt;num&gt; is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.</p>
<p>With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.</p>
<p>If a driver advertises render node support, DRM core will create a
separate render node called renderD&lt;num&gt;. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM_OPEN will be explicitly prohibited. Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.</p>
<p>With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.</p>
<p>Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.</p>
</div>
<div class="section" id="device-hot-unplug">
<h2>Device Hot-Unplug<a class="headerlink" href="#device-hot-unplug" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following is the plan. Implementation is not there yet
(2020 May).</p>
</div>
<p>Graphics devices (display and/or render) may be connected via USB (e.g.
display adapters or docking stations) or Thunderbolt (e.g. eGPU). An end
user is able to hot-unplug this kind of devices while they are being
used, and expects that the very least the machine does not crash. Any
damage from hot-unplugging a DRM device needs to be limited as much as
possible and userspace must be given the chance to handle it if it wants
to. Ideally, unplugging a DRM device still lets a desktop continue to
run, but that is going to need explicit support throughout the whole
graphics stack: from kernel and userspace drivers, through display
servers, via window system protocols, and in applications and libraries.</p>
<p>Other scenarios that should lead to the same are: unrecoverable GPU
crash, PCI device disappearing off the bus, or forced unbind of a driver
from the physical device.</p>
<p>In other words, from userspace perspective everything needs to keep on
working more or less, until userspace stops using the disappeared DRM
device and closes it completely. Userspace will learn of the device
disappearance from the device removed uevent, ioctls returning ENODEV
(or driver-specific ioctls returning driver-specific things), or open()
returning ENXIO.</p>
<p>Only after userspace has closed all relevant DRM device and dmabuf file
descriptors and removed all mmaps, the DRM driver can tear down its
instance for the device that no longer exists. If the same physical
device somehow comes back in the mean time, it shall be a new DRM
device.</p>
<p>Similar to PIDs, chardev minor numbers are not recycled immediately. A
new DRM device always picks the next free minor number compared to the
previous one allocated, and wraps around when minor numbers are
exhausted.</p>
<p>The goal raises at least the following requirements for the kernel and
drivers.</p>
<div class="section" id="requirements-for-kms-uapi">
<h3>Requirements for KMS UAPI<a class="headerlink" href="#requirements-for-kms-uapi" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>KMS connectors must change their status to disconnected.</p></li>
<li><p>Legacy modesets and pageflips, and atomic commits, both real and
TEST_ONLY, and any other ioctls either fail with ENODEV or fake
success.</p></li>
<li><p>Pending non-blocking KMS operations deliver the DRM events userspace
is expecting. This applies also to ioctls that faked success.</p></li>
<li><p>open() on a device node whose underlying device has disappeared will
fail with ENXIO.</p></li>
<li><p>Attempting to create a DRM lease on a disappeared DRM device will
fail with ENODEV. Existing DRM leases remain and work as listed
above.</p></li>
</ul>
</div>
<div class="section" id="requirements-for-render-and-cross-device-uapi">
<h3>Requirements for Render and Cross-Device UAPI<a class="headerlink" href="#requirements-for-render-and-cross-device-uapi" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>All GPU jobs that can no longer run must have their fences
force-signalled to avoid inflicting hangs on userspace.
The associated error code is ENODEV.</p></li>
<li><p>Some userspace APIs already define what should happen when the device
disappears (OpenGL, GL ES: <a class="reference external" href="https://www.khronos.org/registry/OpenGL/extensions/KHR/KHR_robustness.txt">GL_KHR_robustness</a>; <a class="reference external" href="https://www.khronos.org/vulkan/">Vulkan</a>:
VK_ERROR_DEVICE_LOST; etc.). DRM drivers are free to implement this
behaviour the way they see best, e.g. returning failures in
driver-specific ioctls and handling those in userspace drivers, or
rely on uevents, and so on.</p></li>
<li><p>dmabuf which point to memory that has disappeared will either fail to
import with ENODEV or continue to be successfully imported if it would
have succeeded before the disappearance. See also about memory maps
below for already imported dmabufs.</p></li>
<li><p>Attempting to import a dmabuf to a disappeared device will either fail
with ENODEV or succeed if it would have succeeded without the
disappearance.</p></li>
<li><p>open() on a device node whose underlying device has disappeared will
fail with ENXIO.</p></li>
</ul>
</div>
<div class="section" id="requirements-for-memory-maps">
<h3>Requirements for Memory Maps<a class="headerlink" href="#requirements-for-memory-maps" title="Permalink to this headline">¶</a></h3>
<p>Memory maps have further requirements that apply to both existing maps
and maps created after the device has disappeared. If the underlying
memory disappears, the map is created or modified such that reads and
writes will still complete successfully but the result is undefined.
This applies to both userspace mmap()’d memory and memory pointed to by
dmabuf which might be mapped to other devices (cross-device dmabuf
imports).</p>
<p>Raising SIGBUS is not an option, because userspace cannot realistically
handle it. Signal handlers are global, which makes them extremely
difficult to use correctly from libraries like those that Mesa produces.
Signal handlers are not composable, you can’t have different handlers
for GPU1 and GPU2 from different vendors, and a third handler for
mmapped regular files. Threads cause additional pain with signal
handling as well.</p>
</div>
</div>
<div class="section" id="ioctl-support-on-device-nodes">
<span id="drm-driver-ioctl"></span><h2>IOCTL Support on Device Nodes<a class="headerlink" href="#ioctl-support-on-device-nodes" title="Permalink to this headline">¶</a></h2>
<p>First things first, driver private IOCTLs should only be needed for drivers
supporting rendering. Kernel modesetting is all standardized, and extended
through properties. There are a few exceptions in some existing drivers,
which define IOCTL for use by the display DRM master, but they all predate
properties.</p>
<p>Now if you do have a render driver you always have to support it through
driver private properties. There’s a few steps needed to wire all the things
up.</p>
<p>First you need to define the structure for your IOCTL in your driver private
UAPI header in <code class="docutils literal notranslate"><span class="pre">include/uapi/drm/my_driver_drm.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_driver_operation {
        u32 some_thing;
        u32 another_thing;
};
</pre></div>
</div>
<p>Please make sure that you follow all the best practices from
<code class="docutils literal notranslate"><span class="pre">Documentation/process/botching-up-ioctls.rst</span></code>. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a>
automatically zero-extends structures, hence make sure you can add more stuff
at the end, i.e. don’t put a variable sized array there.</p>
<p>Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(),
DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL_ prefix:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>##define DRM_IOCTL_MY_DRIVER_OPERATION  *         DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
</pre></div>
</div>
<p>DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
DRM_COMMAND_END. Finally you need an array of <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> to wire
up the handlers and set the access rights:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct drm_ioctl_desc my_driver_ioctls[] = {
    DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
            DRM_AUTH|DRM_RENDER_ALLOW),
};
</pre></div>
</div>
<p>And then assign this to the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.ioctls</span></code></a> field in your driver
structure.</p>
<p>See the separate chapter on <a class="reference internal" href="drm-internals.html#drm-driver-fops"><span class="std std-ref">file operations</span></a> for how
the driver-specific IOCTLs are wired up.</p>
<div class="section" id="recommended-ioctl-return-values">
<h3>Recommended IOCTL Return Values<a class="headerlink" href="#recommended-ioctl-return-values" title="Permalink to this headline">¶</a></h3>
<p>In theory a driver’s IOCTL callback is only allowed to return very few error
codes. In practice it’s good to abuse a few more. This section documents common
practice within the DRM subsystem:</p>
<dl>
<dt>ENOENT:</dt><dd><p>Strictly this should only be used when a file doesn’t exist e.g. when
calling the open() syscall. We reuse that to signal any kind of object
lookup failure, e.g. for unknown GEM buffer object handles, unknown KMS
object handles and similar cases.</p>
</dd>
<dt>ENOSPC:</dt><dd><p>Some drivers use this to differentiate “out of kernel memory” from “out
of VRAM”. Sometimes also applies to other limited gpu resources used for
rendering (e.g. when you have a special limited compression buffer).
Sometimes resource allocation/reservation issues in command submission
IOCTLs are also signalled through EDEADLK.</p>
<p>Simply running out of kernel/system memory is signalled through ENOMEM.</p>
</dd>
<dt>EPERM/EACCES:</dt><dd><p>Returned for an operation that is valid, but needs more privileges.
E.g. root-only or much more common, DRM master-only operations return
this when called by unpriviledged clients. There’s no clear
difference between EACCES and EPERM.</p>
</dd>
<dt>ENODEV:</dt><dd><p>The device is not present anymore or is not yet fully initialized.</p>
</dd>
<dt>EOPNOTSUPP:</dt><dd><p>Feature (like PRIME, modesetting, GEM) is not supported by the driver.</p>
</dd>
<dt>ENXIO:</dt><dd><p>Remote failure, either a hardware transaction (like i2c), but also used
when the exporting driver of a shared dma-buf or fence doesn’t support a
feature needed.</p>
</dd>
<dt>EINTR:</dt><dd><p>DRM drivers assume that userspace restarts all IOCTLs. Any DRM IOCTL can
return EINTR and in such a case should be restarted with the IOCTL
parameters left unchanged.</p>
</dd>
<dt>EIO:</dt><dd><p>The GPU died and couldn’t be resurrected through a reset. Modesetting
hardware failures are signalled through the “link status” connector
property.</p>
</dd>
<dt>EINVAL:</dt><dd><p>Catch-all for anything that is an invalid argument combination which
cannot work.</p>
</dd>
</dl>
<p>IOCTL also use other error codes like ETIME, EFAULT, EBUSY, ENOTTY but their
usage is in line with the common meanings. The above list tries to just document
DRM specific patterns. Note that ENOTTY has the slightly unintuitive meaning of
“this IOCTL does not exist”, and is used exactly as such in DRM.</p>
<dl class="c macro">
<dt id="c.drm_ioctl_t">
<code class="sig-name descname">drm_ioctl_t</code><a class="headerlink" href="#c.drm_ioctl_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: DRM ioctl function type.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">int</span> <span class="pre">drm_ioctl_t</span> <span class="pre">(struct</span> <span class="pre">drm_device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data,</span> <span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private pointer of the ioctl call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file this ioctl was made on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the DRM ioctl typedef. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a> has alrady copied <strong>data</strong>
into kernel-space, and will also copy it back, depending upon the read/write
settings in the ioctl command code.</p>
<dl class="c macro">
<dt id="c.drm_ioctl_compat_t">
<code class="sig-name descname">drm_ioctl_compat_t</code><a class="headerlink" href="#c.drm_ioctl_compat_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong>Typedef</strong>: compatibility DRM ioctl function type.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">int</span> <span class="pre">drm_ioctl_compat_t</span> <span class="pre">(struct</span> <span class="pre">file</span> <span class="pre">*filp,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>DRM file this ioctl was made on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just a typedef to make declaring an array of compatibility handlers easier.
New drivers shouldn’t screw up the structure layout for their ioctl
structures and hence never need this.</p>
<dl class="c enum">
<dt id="c.drm_ioctl_flags">
<em class="property">enum </em><code class="sig-name descname">drm_ioctl_flags</code><a class="headerlink" href="#c.drm_ioctl_flags" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM ioctl flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_AUTH</span></code></dt><dd><p>This is for ioctl which are used for rendering, and require that the
file descriptor is either for a render node, or if it’s a
legacy/primary node, then it must be authenticated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MASTER</span></code></dt><dd><p>This must be set for any ioctl which can change the modeset or
display state. Userspace must call the ioctl through a primary node,
while it is the active master.</p>
<p>Note that read-only modeset ioctl can also be called by
unauthenticated clients, or when a master is not the currently active
one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_ROOT_ONLY</span></code></dt><dd><p>Anything that could potentially wreak a master file descriptor needs
to have this flag set. Current that’s only for the SETMASTER and
DROPMASTER ioctl, which e.g. logind can call to force a non-behaving
master (display compositor) into compliance.</p>
<p>This is equivalent to callers with the SYSADMIN capability.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_UNLOCKED</span></code></dt><dd><p>Whether <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_ioctl_desc.func</span></code></a> should be called with the DRM BKL held
or not. Enforced as the default for all modern drivers, hence there
should never be a need to set this flag.</p>
<p>Do not use anywhere else than for the VBLANK_WAIT IOCTL, which is the
only legacy IOCTL which needs this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_RENDER_ALLOW</span></code></dt><dd><p>This is used for all ioctl needed for rendering only, for drivers
which support render nodes. This should be all new render drivers,
and hence it should be always set for any ioctl with DRM_AUTH set.
Note though that read-only query ioctl might have this set, but have
not set DRM_AUTH because they do not require authentication.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Various flags that can be set in <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_ioctl_desc.flags</span></code></a> to control how
userspace can use a given ioctl.</p>
<dl class="c struct">
<dt id="c.drm_ioctl_desc">
<em class="property">struct </em><code class="sig-name descname">drm_ioctl_desc</code><a class="headerlink" href="#c.drm_ioctl_desc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM driver ioctl entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_ioctl_desc {
  unsigned int cmd;
  enum drm_ioctl_flags flags;
  drm_ioctl_t *func;
  const char *name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>ioctl command number, without flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>handler for this ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>user-readable name for debug output</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For convenience it’s easier to create these using the <a class="reference internal" href="#c.DRM_IOCTL_DEF_DRV" title="DRM_IOCTL_DEF_DRV"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_IOCTL_DEF_DRV()</span></code></a>
macro.</p>
<dl class="c macro">
<dt id="c.DRM_IOCTL_DEF_DRV">
<code class="sig-name descname">DRM_IOCTL_DEF_DRV</code><a class="headerlink" href="#c.DRM_IOCTL_DEF_DRV" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_DEF_DRV</span> <span class="pre">(ioctl,</span> <span class="pre">_func,</span> <span class="pre">_flags)</span></code></p>
<blockquote>
<div><p>helper macro to fill out a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p>ioctl command suffix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_func</span></code></dt><dd><p>handler for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_flags</span></code></dt><dd><p>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Small helper macro to create a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> entry. The ioctl
command number is constructed by prepending <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL\_</span></code> and passing that
to DRM_IOCTL_NR().</p>
<dl class="c function">
<dt id="c.drm_noop">
int <code class="sig-name descname">drm_noop</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_noop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM no-op ioctl implemntation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we can’t return a failure code because existing userspace
checks the result of the ioctl, but doesn’t care about the action.</p>
<p>Always returns successfully with 0.</p>
<dl class="c function">
<dt id="c.drm_invalid_op">
int <code class="sig-name descname">drm_invalid_op</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em>, void *<em>data</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_invalid_op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DRM invalid ioctl implemntation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we really don’t want to allow userspace to call the ioctl
any more. This is the case for old ums interfaces for drivers that
transitioned to kms gradually and so kept the old legacy tables around. This
only applies to radeon and i915 kms drivers, other drivers shouldn’t need to
use this function.</p>
<p>Always fails with a return value of -EINVAL.</p>
<dl class="c function">
<dt id="c.drm_ioctl_permit">
int <code class="sig-name descname">drm_ioctl_permit</code><span class="sig-paren">(</span>u32 <em>flags</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_permit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check ioctl permissions against caller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>ioctl permission flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>Pointer to <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> identifying the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the caller is allowed to run an ioctl with the
indicated permissions.</p>
<p><strong>Return</strong></p>
<p>Zero if allowed, -EACCES otherwise.</p>
<dl class="c function">
<dt id="c.drm_ioctl">
long <code class="sig-name descname">drm_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ioctl callback implementation for DRM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file this ioctl is called on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>user argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the ioctl function in the DRM core and the driver dispatch table,
stored in <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.ioctls</span></code></a>. It checks for necessary permission by calling
<a class="reference internal" href="#c.drm_ioctl_permit" title="drm_ioctl_permit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl_permit()</span></code></a>, and dispatches to the respective function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="c function">
<dt>
bool <code class="sig-name descname">drm_ioctl_flags</code><span class="sig-paren">(</span>unsigned int <em>nr</em>, unsigned int *<em>flags</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check for core ioctl and return ioctl permission flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>ioctl number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*flags</span></code></dt><dd><p>where to return the ioctl permission flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This ioctl is only used by the vmwgfx driver to augment the access checks
done by the drm core and insofar a pretty decent layering violation. This
shouldn’t be used by any drivers.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>nr</strong> corresponds to a DRM core ioctl number, false otherwise.</p>
<dl class="c function">
<dt id="c.drm_compat_ioctl">
long <code class="sig-name descname">drm_compat_ioctl</code><span class="sig-paren">(</span><em class="property">struct</em> file *<em>filp</em>, unsigned int <em>cmd</em>, unsigned long <em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_compat_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>32bit IOCTL compatibility handler for DRM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file this ioctl is called on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>user argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility handler for 32 bit userspace running on 64 kernels. All actual
IOCTL handling is forwarded to <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a>, while marshalling structures as
appropriate. Note that this only handles DRM core IOCTLs, if the driver has
botched IOCTL itself, it must handle those by wrapping this function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
</div>
<div class="section" id="testing-and-validation">
<h2>Testing and validation<a class="headerlink" href="#testing-and-validation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-requirements-for-userspace-api">
<h3>Testing Requirements for userspace API<a class="headerlink" href="#testing-requirements-for-userspace-api" title="Permalink to this headline">¶</a></h3>
<p>New cross-driver userspace interface extensions, like new IOCTL, new KMS
properties, new files in sysfs or anything else that constitutes an API change
should have driver-agnostic testcases in IGT for that feature, if such a test
can be reasonably made using IGT for the target hardware.</p>
</div>
<div class="section" id="validating-changes-with-igt">
<h3>Validating changes with IGT<a class="headerlink" href="#validating-changes-with-igt" title="Permalink to this headline">¶</a></h3>
<p>There’s a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don’t regress existing functionality. This test suite is called IGT and
its code and instructions to build and run can be found in
<a class="reference external" href="https://gitlab.freedesktop.org/drm/igt-gpu-tools/">https://gitlab.freedesktop.org/drm/igt-gpu-tools/</a>.</p>
</div>
<div class="section" id="using-vkms-to-test-drm-api">
<h3>Using VKMS to test DRM API<a class="headerlink" href="#using-vkms-to-test-drm-api" title="Permalink to this headline">¶</a></h3>
<p>VKMS is a software-only model of a KMS driver that is useful for testing
and for running compositors. VKMS aims to enable a virtual display without
the need for a hardware display capability. These characteristics made VKMS
a perfect tool for validating the DRM core behavior and also support the
compositor developer. VKMS makes it possible to test DRM functions in a
virtual machine without display, simplifying the validation of some of the
core changes.</p>
<p>To Validate changes in DRM API with VKMS, start setting the kernel: make
sure to enable VKMS module; compile the kernel with the VKMS enabled and
install it in the target machine. VKMS can be run in a Virtual Machine
(QEMU, virtme or similar). It’s recommended the use of KVM with the minimum
of 1GB of RAM and four cores.</p>
<p>It’s possible to run the IGT-tests in a VM in two ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Use IGT inside a VM</p></li>
<li><p>Use IGT from the host machine and write the results in a shared directory.</p></li>
</ol>
</div></blockquote>
<p>As follow, there is an example of using a VM with a shared directory with
the host machine to run igt-tests. As an example it’s used virtme:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ virtme-run --rwdir /path/for/shared_dir --kdir=path/for/kernel/directory --mods=auto
</pre></div>
</div>
<p>Run the igt-tests in the guest machine, as example it’s ran the ‘kms_flip’
tests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ /path/for/igt-gpu-tools/scripts/run-tests.sh -p -s -t &quot;kms_flip.*&quot; -v
</pre></div>
</div>
<p>In this example, instead of build the igt_runner, Piglit is used
(-p option); it’s created html summary of the tests results and it’s saved
in the folder “igt-gpu-tools/results”; it’s executed only the igt-tests
matching the -t option.</p>
</div>
<div class="section" id="display-crc-support">
<h3>Display CRC Support<a class="headerlink" href="#display-crc-support" title="Permalink to this headline">¶</a></h3>
<p>DRM device drivers can provide to userspace CRC information of each frame as
it reached a given hardware component (a CRC sampling “source”).</p>
<p>Userspace can control generation of CRCs in a given CRTC by writing to the
file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
Accepted values are source names (which are driver-specific) and the “auto”
keyword, which will let the driver select a default source of frame CRCs
for this CRTC.</p>
<p>Once frame CRC generation is enabled, userspace can capture them by reading
the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
number in the first field and then a number of unsigned integer fields
containing the CRC data. Fields are separated by a single space and the number
of CRC fields is source-specific.</p>
<p>Note that though in some cases the CRC is computed in a specified way and on
the frame contents as supplied by userspace (eDP 1.3), in general the CRC
computation is performed in an unspecified way and on frame contents that have
been already processed in also an unspecified way and thus userspace cannot
rely on being able to generate matching CRC values for the frame contents that
it submits. In this general case, the maximum userspace can do is to compare
the reported CRCs of frames that should have the same contents.</p>
<p>On the driver side the implementation effort is minimal, drivers only need to
implement <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_crc_source</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.verify_crc_source</span></code></a>.
The debugfs files are automatically set up if those vfuncs are set. CRC samples
need to be captured in the driver by calling <a class="reference internal" href="#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_add_crc_entry()</span></code></a>.
Depending on the driver and HW requirements, <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_crc_source</span></code></a>
may result in a commit (even a full modeset).</p>
<p>CRC results must be reliable across non-full-modeset atomic commits, so if a
commit via DRM_IOCTL_MODE_ATOMIC would disable or otherwise interfere with
CRC generation, then the driver must mark that commit as a full modeset
(<a class="reference internal" href="drm-kms.html#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a> should return true). As a result, to ensure
consistent results, generic userspace must re-setup CRC generation after a
legacy SETCRTC or an atomic commit with DRM_MODE_ATOMIC_ALLOW_MODESET.</p>
<dl class="c function">
<dt id="c.drm_crtc_add_crc_entry">
int <code class="sig-name descname">drm_crtc_add_crc_entry</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>crtc</em>, bool <em>has_frame</em>, uint32_t <em>frame</em>, uint32_t *<em>crcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_add_crc_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add entry with CRC information for a frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to which the frame belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">has_frame</span></code></dt><dd><p>whether this entry has a frame number to go with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">frame</span></code></dt><dd><p>number of the frame these CRCs are about</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*crcs</span></code></dt><dd><p>array of CRC values, with length matching #drm_crtc_crc.values_cnt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each frame, the driver polls the source of CRCs for new data and calls
this function to add them to the buffer from where userspace reads.</p>
</div>
<div class="section" id="debugfs-support">
<h3>Debugfs Support<a class="headerlink" href="#debugfs-support" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.drm_info_list">
<em class="property">struct </em><code class="sig-name descname">drm_info_list</code><a class="headerlink" href="#c.drm_info_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>debugfs info list entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_info_list {
  const char *name;
  int (*show)(struct seq_file*, void*);
  u32 driver_features;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show</span></code></dt><dd><p>Show callback. <code class="xref c c-type docutils literal notranslate"><span class="pre">seq_file-&gt;private</span></code> will be set to the <a class="reference internal" href="#c.drm_info_node" title="drm_info_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_info_node</span></code></a> corresponding to the instance of this info on a given
<a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_features</span></code></dt><dd><p>Required driver features for this entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Driver-private data, should not be device-specific.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file to be created by the drm
core.</p>
<dl class="c struct">
<dt id="c.drm_info_node">
<em class="property">struct </em><code class="sig-name descname">drm_info_node</code><a class="headerlink" href="#c.drm_info_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Per-minor debugfs node structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_info_node {
  struct drm_minor *minor;
  const struct drm_info_list *info_ent;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a> for this node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info_ent</span></code></dt><dd><p>template for this node.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file, as an instantiation of a <a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_info_list</span></code></a> on a <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
<p>FIXME:</p>
<p>No it doesn’t make a hole lot of sense that we duplicate debugfs entries for
both the render and the primary nodes, but that’s how this has organically
grown. It should probably be fixed, with a compatibility link, if needed.</p>
<dl class="c function">
<dt id="c.drm_debugfs_create_files">
void <code class="sig-name descname">drm_debugfs_create_files</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.drm_info_list" title="drm_info_list">drm_info_list</a> *<em>files</em>, int <em>count</em>, <em class="property">struct</em> dentry *<em>root</em>, <em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor">drm_minor</a> *<em>minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_debugfs_create_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a given set of debugfs files for DRM minor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_info_list</span> <span class="pre">*files</span></code></dt><dd><p>The array of files to create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The number of files given</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*root</span></code></dt><dd><p>DRI debugfs dir entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*minor</span></code></dt><dd><p>device minor number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a given set of debugfs files represented by an array of
<a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_info_list</span></code></a> in the given root directory. These files will be removed
automatically on drm_debugfs_cleanup().</p>
</div>
</div>
<div class="section" id="sysfs-support">
<h2>Sysfs Support<a class="headerlink" href="#sysfs-support" title="Permalink to this headline">¶</a></h2>
<p>DRM provides very little additional support to drivers for sysfs
interactions, beyond just all the standard stuff. Drivers who want to expose
additional sysfs properties and property groups can attach them at either
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.dev</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.kdev</span></code></a>.</p>
<p>Registration is automatically handled when calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>, or
<a class="reference internal" href="drm-kms.html#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_register()</span></code></a> in case of hot-plugged connectors. Unregistration is
also automatically handled by <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a> and
<a class="reference internal" href="drm-kms.html#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_unregister()</span></code></a>.</p>
<dl class="c function">
<dt id="c.drm_sysfs_hotplug_event">
void <code class="sig-name descname">drm_sysfs_hotplug_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_hotplug_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generate a DRM uevent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM device specified by <strong>dev</strong>.  Currently we only
set HOTPLUG=1 in the uevent environment, but this could be expanded to
deal with other types of events.</p>
<p>Any new uapi should be using the <a class="reference internal" href="#c.drm_sysfs_connector_status_event" title="drm_sysfs_connector_status_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sysfs_connector_status_event()</span></code></a>
for uevents on connector status change.</p>
<dl class="c function">
<dt id="c.drm_sysfs_connector_status_event">
void <code class="sig-name descname">drm_sysfs_connector_status_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>connector</em>, <em class="property">struct</em> <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>property</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_connector_status_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generate a DRM uevent for connector property status change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector on which property status changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>connector property whose status changed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM device specified by <strong>dev</strong>.  Currently we
set HOTPLUG=1 and connector id along with the attached property id
related to the status change.</p>
<dl class="c function">
<dt id="c.drm_class_device_register">
int <code class="sig-name descname">drm_class_device_register</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register new device with the DRM sysfs class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a new <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> within the DRM sysfs class. Essentially only
used by ttm to have a place for its global settings. Drivers should never use
this.</p>
<dl class="c function">
<dt id="c.drm_class_device_unregister">
void <code class="sig-name descname">drm_class_device_unregister</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister device with the DRM sysfs class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> from the DRM sysfs class. Essentially only used
by ttm to have a place for its global settings. Drivers should never use
this.</p>
</div>
<div class="section" id="vblank-event-handling">
<h2>VBlank event handling<a class="headerlink" href="#vblank-event-handling" title="Permalink to this headline">¶</a></h2>
<p>The DRM core exposes two vertical blank related ioctls:</p>
<dl class="simple">
<dt>DRM_IOCTL_WAIT_VBLANK</dt><dd><p>This takes a struct drm_wait_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.</p>
</dd>
<dt>DRM_IOCTL_MODESET_CTL</dt><dd><p>This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.</p>
</dd>
</dl>
</div>
<div class="section" id="userspace-api-structures">
<h2>Userspace API Structures<a class="headerlink" href="#userspace-api-structures" title="Permalink to this headline">¶</a></h2>
<p>DRM exposes many UAPI and structure definition to have a consistent
and standardized interface with user.
Userspace can refer to these structure definitions and UAPI formats
to communicate to driver</p>
<dl class="c struct">
<dt id="c.hdr_metadata_infoframe">
<em class="property">struct </em><code class="sig-name descname">hdr_metadata_infoframe</code><a class="headerlink" href="#c.hdr_metadata_infoframe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>HDR Metadata Infoframe Data.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_metadata_infoframe {
  __u8 eotf;
  __u8 metadata_type;
  struct {
    __u16 x, y;
  } display_primaries[3];
  struct {
    __u16 x, y;
  } white_point;
  __u16 max_display_mastering_luminance;
  __u16 min_display_mastering_luminance;
  __u16 max_cll;
  __u16 max_fall;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eotf</span></code></dt><dd><p>Electro-Optical Transfer Function (EOTF)
used in the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">display_primaries</span></code></dt><dd><p>Color Primaries of the Data.
These are coded as unsigned 16-bit values in units of
0.00002, where 0x0000 represents zero and 0xC350
represents 1.0000.
<strong>display_primaries.x</strong>: X cordinate of color primary.
<strong>display_primaries.y</strong>: Y cordinate of color primary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">white_point</span></code></dt><dd><p>White Point of Colorspace Data.
These are coded as unsigned 16-bit values in units of
0.00002, where 0x0000 represents zero and 0xC350
represents 1.0000.
<strong>white_point.x</strong>: X cordinate of whitepoint of color primary.
<strong>white_point.y</strong>: Y cordinate of whitepoint of color primary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_display_mastering_luminance</span></code></dt><dd><p>Max Mastering Display Luminance.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_display_mastering_luminance</span></code></dt><dd><p>Min Mastering Display Luminance.
This value is coded as an unsigned 16-bit value in units of
0.0001 cd/m2, where 0x0001 represents 0.0001 cd/m2 and 0xFFFF
represents 6.5535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_cll</span></code></dt><dd><p>Max Content Light Level.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fall</span></code></dt><dd><p>Max Frame Average Light Level.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>HDR Metadata Infoframe as per CTA 861.G spec. This is expected
to match exactly with the spec.</p>
<p>Userspace is expected to pass the metadata information as per
the format described in this structure.</p>
<dl class="c struct">
<dt id="c.hdr_output_metadata">
<em class="property">struct </em><code class="sig-name descname">hdr_output_metadata</code><a class="headerlink" href="#c.hdr_output_metadata" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>HDR output metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_output_metadata {
  __u32 metadata_type;
  union {
    struct hdr_metadata_infoframe hdmi_metadata_type1;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdmi_metadata_type1</span></code></dt><dd><p>HDR Metadata Infoframe.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Metadata Information to be passed from userspace</p>
<dl class="c struct">
<dt id="c.drm_mode_create_blob">
<em class="property">struct </em><code class="sig-name descname">drm_mode_create_blob</code><a class="headerlink" href="#c.drm_mode_create_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create New block property</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_create_blob {
  __u64 data;
  __u32 length;
  __u32 blob_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Pointer to data to copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of data to copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blob_id</span></code></dt><dd><p>new property ID.
Create a new ‘blob’ data property, copying length bytes from data pointer,
and returning new blob ID.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_destroy_blob">
<em class="property">struct </em><code class="sig-name descname">drm_mode_destroy_blob</code><a class="headerlink" href="#c.drm_mode_destroy_blob" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroy user blob</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_destroy_blob {
  __u32 blob_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">blob_id</span></code></dt><dd><p>blob_id to destroy
Destroy a user-created blob property.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_create_lease">
<em class="property">struct </em><code class="sig-name descname">drm_mode_create_lease</code><a class="headerlink" href="#c.drm_mode_create_lease" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create lease</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_create_lease {
  __u64 object_ids;
  __u32 object_count;
  __u32 flags;
  __u32 lessee_id;
  __u32 fd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">object_ids</span></code></dt><dd><p>Pointer to array of object ids.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object_count</span></code></dt><dd><p>Number of object ids.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags for new FD.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>unique identifier for lessee.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fd</span></code></dt><dd><p>file descriptor to new drm_master file.
Lease mode resources, creating another drm_master.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_list_lessees">
<em class="property">struct </em><code class="sig-name descname">drm_mode_list_lessees</code><a class="headerlink" href="#c.drm_mode_list_lessees" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List lessees</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_list_lessees {
  __u32 count_lessees;
  __u32 pad;
  __u64 lessees_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count_lessees</span></code></dt><dd><p>Number of lessees.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessees_ptr</span></code></dt><dd><p>Pointer to lessess.
List lesses from a drm_master</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_get_lease">
<em class="property">struct </em><code class="sig-name descname">drm_mode_get_lease</code><a class="headerlink" href="#c.drm_mode_get_lease" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get Lease</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_get_lease {
  __u32 count_objects;
  __u32 pad;
  __u64 objects_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count_objects</span></code></dt><dd><p>Number of leased objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">objects_ptr</span></code></dt><dd><p>Pointer to objects.
Get leased objects</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_revoke_lease">
<em class="property">struct </em><code class="sig-name descname">drm_mode_revoke_lease</code><a class="headerlink" href="#c.drm_mode_revoke_lease" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Revoke lease</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_revoke_lease {
  __u32 lessee_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>Unique ID of lessee.
Revoke lease</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.drm_mode_rect">
<em class="property">struct </em><code class="sig-name descname">drm_mode_rect</code><a class="headerlink" href="#c.drm_mode_rect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Two dimensional rectangle.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_rect {
  __s32 x1;
  __s32 y1;
  __s32 x2;
  __s32 y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x1</span></code></dt><dd><p>Horizontal starting coordinate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y1</span></code></dt><dd><p>Vertical starting coordinate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x2</span></code></dt><dd><p>Horizontal ending coordinate (exclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y2</span></code></dt><dd><p>Vertical ending coordinate (exclusive).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>With drm subsystem using <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> to manage rectangular area this
export it to user-space.</p>
<p>Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-client.html" class="btn btn-neutral float-right" title="Kernel clients" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral float-left" title="Mode Setting Helper Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>