

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>fs-verity: read-only file-based authenticity protection &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="v9fs: Plan 9 Resource Sharing for Linux" href="9p.html" />
    <link rel="prev" title="Filesystem-level encryption (fscrypt)" href="fscrypt.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="journalling.html">The Linux Journalling API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fscrypt.html">Filesystem-level encryption (fscrypt)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">fs-verity: read-only file-based authenticity protection</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-cases">Use cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-api">User API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-verity-files">Accessing verity files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file-measurement-computation">File measurement computation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-signature-verification">Built-in signature verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filesystem-support">Filesystem support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-details">Implementation details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#userspace-utility">Userspace utility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests">Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faq">FAQ</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystems">Filesystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>fs-verity: read-only file-based authenticity protection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/fsverity.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fs-verity-read-only-file-based-authenticity-protection">
<span id="fsverity"></span><h1>fs-verity: read-only file-based authenticity protection<a class="headerlink" href="#fs-verity-read-only-file-based-authenticity-protection" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>fs-verity (<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code>) is a support layer that filesystems can
hook into to support transparent integrity and authenticity protection
of read-only files.  Currently, it is supported by the ext4 and f2fs
filesystems.  Like fscrypt, not too much filesystem-specific code is
needed to support fs-verity.</p>
<p>fs-verity is similar to <a class="reference external" href="https://www.kernel.org/doc/Documentation/device-mapper/verity.txt">dm-verity</a>
but works on files rather than block devices.  On regular files on
filesystems supporting fs-verity, userspace can execute an ioctl that
causes the filesystem to build a Merkle tree for the file and persist
it to a filesystem-specific location associated with the file.</p>
<p>After this, the file is made readonly, and all reads from the file are
automatically verified against the file’s Merkle tree.  Reads of any
corrupted data, including mmap reads, will fail.</p>
<p>Userspace can use another ioctl to retrieve the root hash (actually
the “file measurement”, which is a hash that includes the root hash)
that fs-verity is enforcing for the file.  This ioctl executes in
constant time, regardless of the file size.</p>
<p>fs-verity is essentially a way to hash a file in constant time,
subject to the caveat that reads which would violate the hash will
fail at runtime.</p>
</div>
<div class="section" id="use-cases">
<h2>Use cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>By itself, the base fs-verity feature only provides integrity
protection, i.e. detection of accidental (non-malicious) corruption.</p>
<p>However, because fs-verity makes retrieving the file hash extremely
efficient, it’s primarily meant to be used as a tool to support
authentication (detection of malicious modifications) or auditing
(logging file hashes before use).</p>
<p>Trusted userspace code (e.g. operating system code running on a
read-only partition that is itself authenticated by dm-verity) can
authenticate the contents of an fs-verity file by using the
<a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a> ioctl to retrieve its hash, then verifying a
digital signature of it.</p>
<p>A standard file hash could be used instead of fs-verity.  However,
this is inefficient if the file is large and only a small portion may
be accessed.  This is often the case for Android application package
(APK) files, for example.  These typically contain many translations,
classes, and other resources that are infrequently or even never
accessed on a particular device.  It would be slow and wasteful to
read and hash the entire file before starting the application.</p>
<p>Unlike an ahead-of-time hash, fs-verity also re-verifies data each
time it’s paged in.  This ensures that malicious disk firmware can’t
undetectably change the contents of the file at runtime.</p>
<p>fs-verity does not replace or obsolete dm-verity.  dm-verity should
still be used on read-only filesystems.  fs-verity is for files that
must live on a read-write filesystem because they are independently
updated and potentially user-installed, so dm-verity cannot be used.</p>
<p>The base fs-verity feature is a hashing mechanism only; actually
authenticating the files is up to userspace.  However, to meet some
users’ needs, fs-verity optionally supports a simple signature
verification mechanism where users can configure the kernel to require
that all fs-verity files be signed by a key loaded into a keyring; see
<a class="reference internal" href="#built-in-signature-verification">Built-in signature verification</a>.  Support for fs-verity file hashes
in IMA (Integrity Measurement Architecture) policies is also planned.</p>
</div>
<div class="section" id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fs-ioc-enable-verity">
<h3>FS_IOC_ENABLE_VERITY<a class="headerlink" href="#fs-ioc-enable-verity" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_ENABLE_VERITY ioctl enables fs-verity on a file.  It takes
in a pointer to a struct fsverity_enable_arg, defined as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_enable_arg {
        __u32 version;
        __u32 hash_algorithm;
        __u32 block_size;
        __u32 salt_size;
        __u64 salt_ptr;
        __u32 sig_size;
        __u32 __reserved1;
        __u64 sig_ptr;
        __u64 __reserved2[11];
};
</pre></div>
</div>
<p>This structure contains the parameters of the Merkle tree to build for
the file, and optionally contains a signature.  It must be initialized
as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> must be 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hash_algorithm</span></code> must be the identifier for the hash algorithm to
use for the Merkle tree, such as FS_VERITY_HASH_ALG_SHA256.  See
<code class="docutils literal notranslate"><span class="pre">include/uapi/linux/fsverity.h</span></code> for the list of possible values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_size</span></code> must be the Merkle tree block size.  Currently, this
must be equal to the system page size, which is usually 4096 bytes.
Other sizes may be supported in the future.  This value is not
necessarily the same as the filesystem block size.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">salt_size</span></code> is the size of the salt in bytes, or 0 if no salt is
provided.  The salt is a value that is prepended to every hashed
block; it can be used to personalize the hashing for a particular
file or device.  Currently the maximum salt size is 32 bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">salt_ptr</span></code> is the pointer to the salt, or NULL if no salt is
provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sig_size</span></code> is the size of the signature in bytes, or 0 if no
signature is provided.  Currently the signature is (somewhat
arbitrarily) limited to 16128 bytes.  See <a class="reference internal" href="#built-in-signature-verification">Built-in signature
verification</a> for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sig_ptr</span></code>  is the pointer to the signature, or NULL if no
signature is provided.</p></li>
<li><p>All reserved fields must be zeroed.</p></li>
</ul>
<p>FS_IOC_ENABLE_VERITY causes the filesystem to build a Merkle tree for
the file and persist it to a filesystem-specific location associated
with the file, then mark the file as a verity file.  This ioctl may
take a long time to execute on large files, and it is interruptible by
fatal signals.</p>
<p>FS_IOC_ENABLE_VERITY checks for write access to the inode.  However,
it must be executed on an O_RDONLY file descriptor and no processes
can have the file open for writing.  Attempts to open the file for
writing while this ioctl is executing will fail with ETXTBSY.  (This
is necessary to guarantee that no writable file descriptors will exist
after verity is enabled, and to guarantee that the file’s contents are
stable while the Merkle tree is being built over it.)</p>
<p>On success, FS_IOC_ENABLE_VERITY returns 0, and the file becomes a
verity file.  On failure (including the case of interruption by a
fatal signal), no changes are made to the file.</p>
<p>FS_IOC_ENABLE_VERITY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: the process does not have write access to the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBADMSG</span></code>: the signature is malformed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>: this ioctl is already running on the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EEXIST</span></code>: the file already has verity enabled</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: the caller provided inaccessible memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINTR</span></code>: the operation was interrupted by a fatal signal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: unsupported version, hash algorithm, or block size; or
reserved bits are set; or the file descriptor refers to neither a
regular file nor a directory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EISDIR</span></code>: the file descriptor refers to a directory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EKEYREJECTED</span></code>: the signature doesn’t match the file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EMSGSIZE</span></code>: the salt or signature is too long</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOKEY</span></code>: the fs-verity keyring doesn’t contain the certificate
needed to verify the signature</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOPKG</span></code>: fs-verity recognizes the hash algorithm, but it’s not
available in the kernel’s crypto API as currently configured (e.g.
for SHA-512, missing CONFIG_CRYPTO_SHA512).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement fs-verity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with fs-verity
support; or the filesystem superblock has not had the ‘verity’
feature enabled on it; or the filesystem does not support fs-verity
on this file.  (See <a class="reference internal" href="#filesystem-support">Filesystem support</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EPERM</span></code>: the file is append-only; or, a signature is required and
one was not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EROFS</span></code>: the filesystem is read-only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ETXTBSY</span></code>: someone has the file open for writing.  This can be the
caller’s file descriptor, another open file descriptor, or the file
reference held by a writable memory map.</p></li>
</ul>
</div>
<div class="section" id="fs-ioc-measure-verity">
<h3>FS_IOC_MEASURE_VERITY<a class="headerlink" href="#fs-ioc-measure-verity" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_MEASURE_VERITY ioctl retrieves the measurement of a verity
file.  The file measurement is a digest that cryptographically
identifies the file contents that are being enforced on reads.</p>
<p>This ioctl takes in a pointer to a variable-length structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_digest {
        __u16 digest_algorithm;
        __u16 digest_size; /* input/output */
        __u8 digest[];
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">digest_size</span></code> is an input/output field.  On input, it must be
initialized to the number of bytes allocated for the variable-length
<code class="docutils literal notranslate"><span class="pre">digest</span></code> field.</p>
<p>On success, 0 is returned and the kernel fills in the structure as
follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">digest_algorithm</span></code> will be the hash algorithm used for the file
measurement.  It will match <code class="docutils literal notranslate"><span class="pre">fsverity_enable_arg::hash_algorithm</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">digest_size</span></code> will be the size of the digest in bytes, e.g. 32
for SHA-256.  (This can be redundant with <code class="docutils literal notranslate"><span class="pre">digest_algorithm</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">digest</span></code> will be the actual bytes of the digest.</p></li>
</ul>
<p>FS_IOC_MEASURE_VERITY is guaranteed to execute in constant time,
regardless of the size of the file.</p>
<p>FS_IOC_MEASURE_VERITY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: the caller provided inaccessible memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENODATA</span></code>: the file is not a verity file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement fs-verity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with fs-verity
support, or the filesystem superblock has not had the ‘verity’
feature enabled on it.  (See <a class="reference internal" href="#filesystem-support">Filesystem support</a>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOVERFLOW</span></code>: the digest is longer than the specified
<code class="docutils literal notranslate"><span class="pre">digest_size</span></code> bytes.  Try providing a larger buffer.</p></li>
</ul>
</div>
<div class="section" id="fs-ioc-getflags">
<h3>FS_IOC_GETFLAGS<a class="headerlink" href="#fs-ioc-getflags" title="Permalink to this headline">¶</a></h3>
<p>The existing ioctl FS_IOC_GETFLAGS (which isn’t specific to fs-verity)
can also be used to check whether a file has fs-verity enabled or not.
To do so, check for FS_VERITY_FL (0x00100000) in the returned flags.</p>
<p>The verity flag is not settable via FS_IOC_SETFLAGS.  You must use
FS_IOC_ENABLE_VERITY instead, since parameters must be provided.</p>
</div>
<div class="section" id="statx">
<h3>statx<a class="headerlink" href="#statx" title="Permalink to this headline">¶</a></h3>
<p>Since Linux v5.5, the statx() system call sets STATX_ATTR_VERITY if
the file has fs-verity enabled.  This can perform better than
FS_IOC_GETFLAGS and FS_IOC_MEASURE_VERITY because it doesn’t require
opening the file, and opening verity files can be expensive.</p>
</div>
</div>
<div class="section" id="accessing-verity-files">
<h2>Accessing verity files<a class="headerlink" href="#accessing-verity-files" title="Permalink to this headline">¶</a></h2>
<p>Applications can transparently access a verity file just like a
non-verity one, with the following exceptions:</p>
<ul class="simple">
<li><p>Verity files are readonly.  They cannot be opened for writing or
truncate()d, even if the file mode bits allow it.  Attempts to do
one of these things will fail with EPERM.  However, changes to
metadata such as owner, mode, timestamps, and xattrs are still
allowed, since these are not measured by fs-verity.  Verity files
can also still be renamed, deleted, and linked to.</p></li>
<li><p>Direct I/O is not supported on verity files.  Attempts to use direct
I/O on such files will fall back to buffered I/O.</p></li>
<li><p>DAX (Direct Access) is not supported on verity files, because this
would circumvent the data verification.</p></li>
<li><p>Reads of data that doesn’t match the verity Merkle tree will fail
with EIO (for read()) or SIGBUS (for mmap() reads).</p></li>
<li><p>If the sysctl “fs.verity.require_signatures” is set to 1 and the
file’s verity measurement is not signed by a key in the fs-verity
keyring, then opening the file will fail.  See <a class="reference internal" href="#built-in-signature-verification">Built-in signature
verification</a>.</p></li>
</ul>
<p>Direct access to the Merkle tree is not supported.  Therefore, if a
verity file is copied, or is backed up and restored, then it will lose
its “verity”-ness.  fs-verity is primarily meant for files like
executables that are managed by a package manager.</p>
</div>
<div class="section" id="file-measurement-computation">
<h2>File measurement computation<a class="headerlink" href="#file-measurement-computation" title="Permalink to this headline">¶</a></h2>
<p>This section describes how fs-verity hashes the file contents using a
Merkle tree to produce the “file measurement” which cryptographically
identifies the file contents.  This algorithm is the same for all
filesystems that support fs-verity.</p>
<p>Userspace only needs to be aware of this algorithm if it needs to
compute the file measurement itself, e.g. in order to sign the file.</p>
<div class="section" id="merkle-tree">
<span id="fsverity-merkle-tree"></span><h3>Merkle tree<a class="headerlink" href="#merkle-tree" title="Permalink to this headline">¶</a></h3>
<p>The file contents is divided into blocks, where the block size is
configurable but is usually 4096 bytes.  The end of the last block is
zero-padded if needed.  Each block is then hashed, producing the first
level of hashes.  Then, the hashes in this first level are grouped
into ‘blocksize’-byte blocks (zero-padding the ends as needed) and
these blocks are hashed, producing the second level of hashes.  This
proceeds up the tree until only a single block remains.  The hash of
this block is the “Merkle tree root hash”.</p>
<p>If the file fits in one block and is nonempty, then the “Merkle tree
root hash” is simply the hash of the single data block.  If the file
is empty, then the “Merkle tree root hash” is all zeroes.</p>
<p>The “blocks” here are not necessarily the same as “filesystem blocks”.</p>
<p>If a salt was specified, then it’s zero-padded to the closest multiple
of the input size of the hash algorithm’s compression function, e.g.
64 bytes for SHA-256 or 128 bytes for SHA-512.  The padded salt is
prepended to every data or Merkle tree block that is hashed.</p>
<p>The purpose of the block padding is to cause every hash to be taken
over the same amount of data, which simplifies the implementation and
keeps open more possibilities for hardware acceleration.  The purpose
of the salt padding is to make the salting “free” when the salted hash
state is precomputed, then imported for each hash.</p>
<p>Example: in the recommended configuration of SHA-256 and 4K blocks,
128 hash values fit in each block.  Thus, each level of the Merkle
tree is approximately 128 times smaller than the previous, and for
large files the Merkle tree’s size converges to approximately 1/127 of
the original file size.  However, for small files, the padding is
significant, making the space overhead proportionally more.</p>
</div>
<div class="section" id="fs-verity-descriptor">
<span id="fsverity-descriptor"></span><h3>fs-verity descriptor<a class="headerlink" href="#fs-verity-descriptor" title="Permalink to this headline">¶</a></h3>
<p>By itself, the Merkle tree root hash is ambiguous.  For example, it
can’t a distinguish a large file from a small second file whose data
is exactly the top-level hash block of the first file.  Ambiguities
also arise from the convention of padding to the next block boundary.</p>
<p>To solve this problem, the verity file measurement is actually
computed as a hash of the following structure, which contains the
Merkle tree root hash as well as other fields such as the file size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_descriptor {
        __u8 version;           /* must be 1 */
        __u8 hash_algorithm;    /* Merkle tree hash algorithm */
        __u8 log_blocksize;     /* log2 of size of data and tree blocks */
        __u8 salt_size;         /* size of salt in bytes; 0 if none */
        __le32 sig_size;        /* must be 0 */
        __le64 data_size;       /* size of file the Merkle tree is built over */
        __u8 root_hash[64];     /* Merkle tree root hash */
        __u8 salt[32];          /* salt prepended to each hashed block */
        __u8 __reserved[144];   /* must be 0&#39;s */
};
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">sig_size</span></code> field must be set to 0 for the purpose of
computing the file measurement, even if a signature was provided (or
will be provided) to <a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a>.</p>
</div>
</div>
<div class="section" id="built-in-signature-verification">
<h2>Built-in signature verification<a class="headerlink" href="#built-in-signature-verification" title="Permalink to this headline">¶</a></h2>
<p>With CONFIG_FS_VERITY_BUILTIN_SIGNATURES=y, fs-verity supports putting
a portion of an authentication policy (see <a class="reference internal" href="#use-cases">Use cases</a>) in the
kernel.  Specifically, it adds support for:</p>
<ol class="arabic simple">
<li><p>At fs-verity module initialization time, a keyring “.fs-verity” is
created.  The root user can add trusted X.509 certificates to this
keyring using the add_key() system call, then (when done)
optionally use keyctl_restrict_keyring() to prevent additional
certificates from being added.</p></li>
<li><p><a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a> accepts a pointer to a PKCS#7 formatted
detached signature in DER format of the file measurement.  On
success, this signature is persisted alongside the Merkle tree.
Then, any time the file is opened, the kernel will verify the
file’s actual measurement against this signature, using the
certificates in the “.fs-verity” keyring.</p></li>
<li><p>A new sysctl “fs.verity.require_signatures” is made available.
When set to 1, the kernel requires that all verity files have a
correctly signed file measurement as described in (2).</p></li>
</ol>
<p>File measurements must be signed in the following format, which is
similar to the structure used by <a class="reference internal" href="#fs-ioc-measure-verity">FS_IOC_MEASURE_VERITY</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsverity_signed_digest {
        char magic[8];                  /* must be &quot;FSVerity&quot; */
        __le16 digest_algorithm;
        __le16 digest_size;
        __u8 digest[];
};
</pre></div>
</div>
<p>fs-verity’s built-in signature verification support is meant as a
relatively simple mechanism that can be used to provide some level of
authenticity protection for verity files, as an alternative to doing
the signature verification in userspace or using IMA-appraisal.
However, with this mechanism, userspace programs still need to check
that the verity bit is set, and there is no protection against verity
files being swapped around.</p>
</div>
<div class="section" id="filesystem-support">
<h2>Filesystem support<a class="headerlink" href="#filesystem-support" title="Permalink to this headline">¶</a></h2>
<p>fs-verity is currently supported by the ext4 and f2fs filesystems.
The CONFIG_FS_VERITY kconfig option must be enabled to use fs-verity
on either filesystem.</p>
<p><code class="docutils literal notranslate"><span class="pre">include/linux/fsverity.h</span></code> declares the interface between the
<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> support layer and filesystems.  Briefly, filesystems
must provide an <code class="docutils literal notranslate"><span class="pre">fsverity_operations</span></code> structure that provides
methods to read and write the verity metadata to a filesystem-specific
location, including the Merkle tree blocks and
<code class="docutils literal notranslate"><span class="pre">fsverity_descriptor</span></code>.  Filesystems must also call functions in
<code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> at certain times, such as when a file is opened or when
pages have been read into the pagecache.  (See <a class="reference internal" href="#verifying-data">Verifying data</a>.)</p>
<div class="section" id="ext4">
<h3>ext4<a class="headerlink" href="#ext4" title="Permalink to this headline">¶</a></h3>
<p>ext4 supports fs-verity since Linux v5.4 and e2fsprogs v1.45.2.</p>
<p>To create verity files on an ext4 filesystem, the filesystem must have
been formatted with <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">verity</span></code> or had <code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">verity</span></code> run on
it.  “verity” is an RO_COMPAT filesystem feature, so once set, old
kernels will only be able to mount the filesystem readonly, and old
versions of e2fsck will be unable to check the filesystem.  Moreover,
currently ext4 only supports mounting a filesystem with the “verity”
feature when its block size is equal to PAGE_SIZE (often 4096 bytes).</p>
<p>ext4 sets the EXT4_VERITY_FL on-disk inode flag on verity files.  It
can only be set by <a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a>, and it cannot be cleared.</p>
<p>ext4 also supports encryption, which can be used simultaneously with
fs-verity.  In this case, the plaintext data is verified rather than
the ciphertext.  This is necessary in order to make the file
measurement meaningful, since every file is encrypted differently.</p>
<p>ext4 stores the verity metadata (Merkle tree and fsverity_descriptor)
past the end of the file, starting at the first 64K boundary beyond
i_size.  This approach works because (a) verity files are readonly,
and (b) pages fully beyond i_size aren’t visible to userspace but can
be read/written internally by ext4 with only some relatively small
changes to ext4.  This approach avoids having to depend on the
EA_INODE feature and on rearchitecturing ext4’s xattr support to
support paging multi-gigabyte xattrs into memory, and to support
encrypting xattrs.  Note that the verity metadata <em>must</em> be encrypted
when the file is, since it contains hashes of the plaintext data.</p>
<p>Currently, ext4 verity only supports the case where the Merkle tree
block size, filesystem block size, and page size are all the same.  It
also only supports extent-based files.</p>
</div>
<div class="section" id="f2fs">
<h3>f2fs<a class="headerlink" href="#f2fs" title="Permalink to this headline">¶</a></h3>
<p>f2fs supports fs-verity since Linux v5.4 and f2fs-tools v1.11.0.</p>
<p>To create verity files on an f2fs filesystem, the filesystem must have
been formatted with <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">verity</span></code>.</p>
<p>f2fs sets the FADVISE_VERITY_BIT on-disk inode flag on verity files.
It can only be set by <a class="reference internal" href="#fs-ioc-enable-verity">FS_IOC_ENABLE_VERITY</a>, and it cannot be
cleared.</p>
<p>Like ext4, f2fs stores the verity metadata (Merkle tree and
fsverity_descriptor) past the end of the file, starting at the first
64K boundary beyond i_size.  See explanation for ext4 above.
Moreover, f2fs supports at most 4096 bytes of xattr entries per inode
which wouldn’t be enough for even a single Merkle tree block.</p>
<p>Currently, f2fs verity only supports a Merkle tree block size of 4096.
Also, f2fs doesn’t support enabling verity on files that currently
have atomic or volatile writes pending.</p>
</div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="verifying-data">
<h3>Verifying data<a class="headerlink" href="#verifying-data" title="Permalink to this headline">¶</a></h3>
<p>fs-verity ensures that all reads of a verity file’s data are verified,
regardless of which syscall is used to do the read (e.g. mmap(),
read(), pread()) and regardless of whether it’s the first read or a
later read (unless the later read can return cached data that was
already verified).  Below, we describe how filesystems implement this.</p>
<div class="section" id="pagecache">
<h4>Pagecache<a class="headerlink" href="#pagecache" title="Permalink to this headline">¶</a></h4>
<p>For filesystems using Linux’s pagecache, the <code class="docutils literal notranslate"><span class="pre">-&gt;readpage()</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;readpages()</span></code> methods must be modified to verify pages before they
are marked Uptodate.  Merely hooking <code class="docutils literal notranslate"><span class="pre">-&gt;read_iter()</span></code> would be
insufficient, since <code class="docutils literal notranslate"><span class="pre">-&gt;read_iter()</span></code> is not used for memory maps.</p>
<p>Therefore, fs/verity/ provides a function fsverity_verify_page() which
verifies a page that has been read into the pagecache of a verity
inode, but is still locked and not Uptodate, so it’s not yet readable
by userspace.  As needed to do the verification,
fsverity_verify_page() will call back into the filesystem to read
Merkle tree pages via fsverity_operations::read_merkle_tree_page().</p>
<p>fsverity_verify_page() returns false if verification failed; in this
case, the filesystem must not set the page Uptodate.  Following this,
as per the usual Linux pagecache behavior, attempts by userspace to
read() from the part of the file containing the page will fail with
EIO, and accesses to the page within a memory map will raise SIGBUS.</p>
<p>fsverity_verify_page() currently only supports the case where the
Merkle tree block size is equal to PAGE_SIZE (often 4096 bytes).</p>
<p>In principle, fsverity_verify_page() verifies the entire path in the
Merkle tree from the data page to the root hash.  However, for
efficiency the filesystem may cache the hash pages.  Therefore,
fsverity_verify_page() only ascends the tree reading hash pages until
an already-verified hash page is seen, as indicated by the PageChecked
bit being set.  It then verifies the path to that page.</p>
<p>This optimization, which is also used by dm-verity, results in
excellent sequential read performance.  This is because usually (e.g.
127 in 128 times for 4K blocks and SHA-256) the hash page from the
bottom level of the tree will already be cached and checked from
reading a previous data page.  However, random reads perform worse.</p>
</div>
<div class="section" id="block-device-based-filesystems">
<h4>Block device based filesystems<a class="headerlink" href="#block-device-based-filesystems" title="Permalink to this headline">¶</a></h4>
<p>Block device based filesystems (e.g. ext4 and f2fs) in Linux also use
the pagecache, so the above subsection applies too.  However, they
also usually read many pages from a file at once, grouped into a
structure called a “bio”.  To make it easier for these types of
filesystems to support fs-verity, fs/verity/ also provides a function
fsverity_verify_bio() which verifies all pages in a bio.</p>
<p>ext4 and f2fs also support encryption.  If a verity file is also
encrypted, the pages must be decrypted before being verified.  To
support this, these filesystems allocate a “post-read context” for
each bio and store it in <code class="docutils literal notranslate"><span class="pre">-&gt;bi_private</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bio_post_read_ctx {
       struct bio *bio;
       struct work_struct work;
       unsigned int cur_step;
       unsigned int enabled_steps;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">enabled_steps</span></code> is a bitmask that specifies whether decryption,
verity, or both is enabled.  After the bio completes, for each needed
postprocessing step the filesystem enqueues the bio_post_read_ctx on a
workqueue, and then the workqueue work does the decryption or
verification.  Finally, pages where no decryption or verity error
occurred are marked Uptodate, and the pages are unlocked.</p>
<p>Files on ext4 and f2fs may contain holes.  Normally, <code class="docutils literal notranslate"><span class="pre">-&gt;readpages()</span></code>
simply zeroes holes and sets the corresponding pages Uptodate; no bios
are issued.  To prevent this case from bypassing fs-verity, these
filesystems use fsverity_verify_page() to verify hole pages.</p>
<p>ext4 and f2fs disable direct I/O on verity files, since otherwise
direct I/O would bypass fs-verity.  (They also do the same for
encrypted files.)</p>
</div>
</div>
</div>
<div class="section" id="userspace-utility">
<h2>Userspace utility<a class="headerlink" href="#userspace-utility" title="Permalink to this headline">¶</a></h2>
<p>This document focuses on the kernel, but a userspace utility for
fs-verity can be found at:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/ebiggers/fsverity-utils.git">https://git.kernel.org/pub/scm/linux/kernel/git/ebiggers/fsverity-utils.git</a></p>
</div></blockquote>
<p>See the README.md file in the fsverity-utils source tree for details,
including examples of setting up fs-verity protected files.</p>
</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>To test fs-verity, use xfstests.  For example, using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/kvm-quickstart.md">kvm-xfstests</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4,f2fs -g verity
</pre></div>
</div>
</div>
<div class="section" id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h2>
<p>This section answers frequently asked questions about fs-verity that
weren’t already directly answered in other parts of this document.</p>
<dl class="field-list">
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why isn’t fs-verity part of IMA?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>fs-verity and IMA (Integrity Measurement Architecture) have
different focuses.  fs-verity is a filesystem-level mechanism for
hashing individual files using a Merkle tree.  In contrast, IMA
specifies a system-wide policy that specifies which files are
hashed and what to do with those hashes, such as log them,
authenticate them, or add them to a measurement list.</p>
<p>IMA is planned to support the fs-verity hashing mechanism as an
alternative to doing full file hashes, for people who want the
performance and security benefits of the Merkle tree based hash.
But it doesn’t make sense to force all uses of fs-verity to be
through IMA.  As a standalone filesystem feature, fs-verity
already meets many users’ needs, and it’s testable like other
filesystem features e.g. with xfstests.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Isn’t fs-verity useless because the attacker can just modify the
hashes in the Merkle tree, which is stored on-disk?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>To verify the authenticity of an fs-verity file you must verify
the authenticity of the “file measurement”, which is basically the
root hash of the Merkle tree.  See <a class="reference internal" href="#use-cases">Use cases</a>.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Isn’t fs-verity useless because the attacker can just replace a
verity file with a non-verity one?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>See <a class="reference internal" href="#use-cases">Use cases</a>.  In the initial use case, it’s really trusted
userspace code that authenticates the files; fs-verity is just a
tool to do this job efficiently and securely.  The trusted
userspace code will consider non-verity files to be inauthentic.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why does the Merkle tree need to be stored on-disk?  Couldn’t you
store just the root hash?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>If the Merkle tree wasn’t stored on-disk, then you’d have to
compute the entire tree when the file is first accessed, even if
just one byte is being read.  This is a fundamental consequence of
how Merkle tree hashing works.  To verify a leaf node, you need to
verify the whole path to the root hash, including the root node
(the thing which the root hash is a hash of).  But if the root
node isn’t stored on-disk, you have to compute it by hashing its
children, and so on until you’ve actually hashed the entire file.</p>
<p>That defeats most of the point of doing a Merkle tree-based hash,
since if you have to hash the whole file ahead of time anyway,
then you could simply do sha256(file) instead.  That would be much
simpler, and a bit faster too.</p>
<p>It’s true that an in-memory Merkle tree could still provide the
advantage of verification on every read rather than just on the
first read.  However, it would be inefficient because every time a
hash page gets evicted (you can’t pin the entire Merkle tree into
memory, since it may be very large), in order to restore it you
again need to hash everything below it in the tree.  This again
defeats most of the point of doing a Merkle tree-based hash, since
a single block read could trigger re-hashing gigabytes of data.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>But couldn’t you store just the leaf nodes and compute the rest?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>See previous answer; this really just moves up one level, since
one could alternatively interpret the data blocks as being the
leaf nodes of the Merkle tree.  It’s true that the tree can be
computed much faster if the leaf level is stored rather than just
the data, but that’s only because each level is less than 1% the
size of the level below (assuming the recommended settings of
SHA-256 and 4K blocks).  For the exact same reason, by storing
“just the leaf nodes” you’d already be storing over 99% of the
tree, so you might as well simply store the whole tree.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Can the Merkle tree be built ahead of time, e.g. distributed as
part of a package that is installed to many computers?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>This isn’t currently supported.  It was part of the original
design, but was removed to simplify the kernel UAPI and because it
wasn’t a critical use case.  Files are usually installed once and
used many times, and cryptographic hashing is somewhat fast on
most modern processors.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why doesn’t fs-verity support writes?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>Write support would be very difficult and would require a
completely different design, so it’s well outside the scope of
fs-verity.  Write support would require:</p>
<ul class="simple">
<li><p>A way to maintain consistency between the data and hashes,
including all levels of hashes, since corruption after a crash
(especially of potentially the entire file!) is unacceptable.
The main options for solving this are data journalling,
copy-on-write, and log-structured volume.  But it’s very hard to
retrofit existing filesystems with new consistency mechanisms.
Data journalling is available on ext4, but is very slow.</p></li>
<li><p>Rebuilding the Merkle tree after every write, which would be
extremely inefficient.  Alternatively, a different authenticated
dictionary structure such as an “authenticated skiplist” could
be used.  However, this would be far more complex.</p></li>
</ul>
<p>Compare it to dm-verity vs. dm-integrity.  dm-verity is very
simple: the kernel just verifies read-only data against a
read-only Merkle tree.  In contrast, dm-integrity supports writes
but is slow, is much more complex, and doesn’t actually support
full-device authentication since it authenticates each sector
independently, i.e. there is no “root hash”.  It doesn’t really
make sense for the same device-mapper target to support these two
very different cases; the same applies to fs-verity.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Since verity files are immutable, why isn’t the immutable bit set?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>The existing “immutable” bit (FS_IMMUTABLE_FL) already has a
specific set of semantics which not only make the file contents
read-only, but also prevent the file from being deleted, renamed,
linked to, or having its owner or mode changed.  These extra
properties are unwanted for fs-verity, so reusing the immutable
bit isn’t appropriate.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why does the API use ioctls instead of setxattr() and getxattr()?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>Abusing the xattr interface for basically arbitrary syscalls is
heavily frowned upon by most of the Linux filesystem developers.
An xattr should really just be an xattr on-disk, not an API to
e.g. magically trigger construction of a Merkle tree.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Does fs-verity support remote filesystems?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>Only ext4 and f2fs support is implemented currently, but in
principle any filesystem that can store per-file verity metadata
can support fs-verity, regardless of whether it’s local or remote.
Some filesystems may have fewer options of where to store the
verity metadata; one possibility is to store it past the end of
the file and “hide” it from userspace by manipulating i_size.  The
data verification functions provided by <code class="docutils literal notranslate"><span class="pre">fs/verity/</span></code> also assume
that the filesystem uses the Linux pagecache, but both local and
remote filesystems normally do so.</p>
</dd>
<dt class="field-odd">Q</dt>
<dd class="field-odd"><p>Why is anything filesystem-specific at all?  Shouldn’t fs-verity
be implemented entirely at the VFS level?</p>
</dd>
<dt class="field-even">A</dt>
<dd class="field-even"><p>There are many reasons why this is not possible or would be very
difficult, including the following:</p>
<ul>
<li><p>To prevent bypassing verification, pages must not be marked
Uptodate until they’ve been verified.  Currently, each
filesystem is responsible for marking pages Uptodate via
<code class="docutils literal notranslate"><span class="pre">-&gt;readpages()</span></code>.  Therefore, currently it’s not possible for
the VFS to do the verification on its own.  Changing this would
require significant changes to the VFS and all filesystems.</p></li>
<li><p>It would require defining a filesystem-independent way to store
the verity metadata.  Extended attributes don’t work for this
because (a) the Merkle tree may be gigabytes, but many
filesystems assume that all xattrs fit into a single 4K
filesystem block, and (b) ext4 and f2fs encryption doesn’t
encrypt xattrs, yet the Merkle tree <em>must</em> be encrypted when the
file contents are, because it stores hashes of the plaintext
file contents.</p>
<p>So the verity metadata would have to be stored in an actual
file.  Using a separate file would be very ugly, since the
metadata is fundamentally part of the file to be protected, and
it could cause problems where users could delete the real file
but not the metadata file or vice versa.  On the other hand,
having it be in the same file would break applications unless
filesystems’ notion of i_size were divorced from the VFS’s,
which would be complex and require changes to all filesystems.</p>
</li>
<li><p>It’s desirable that FS_IOC_ENABLE_VERITY uses the filesystem’s
transaction mechanism so that either the file ends up with
verity enabled, or no changes were made.  Allowing intermediate
states to occur after a crash may cause problems.</p></li>
</ul>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="9p.html" class="btn btn-neutral float-right" title="v9fs: Plan 9 Resource Sharing for Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fscrypt.html" class="btn btn-neutral float-left" title="Filesystem-level encryption (fscrypt)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>