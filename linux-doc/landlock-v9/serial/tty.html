

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Lockronomicon &mdash; The Linux Kernel 5.2.0-rc5+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.2.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The Lockronomicon</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/serial/tty.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-lockronomicon">
<h1>The Lockronomicon<a class="headerlink" href="#the-lockronomicon" title="Permalink to this headline">¶</a></h1>
<p>Your guide to the ancient and twisted locking policies of the tty layer and
the warped logic behind them. Beware all ye who read on.</p>
<div class="section" id="line-discipline">
<h2>Line Discipline<a class="headerlink" href="#line-discipline" title="Permalink to this headline">¶</a></h2>
<p>Line disciplines are registered with tty_register_ldisc() passing the
discipline number and the ldisc structure. At the point of registration the
discipline must be ready to use and it is possible it will get used before
the call returns success. If the call returns an error then it won’t get
called. Do not re-use ldisc numbers as they are part of the userspace ABI
and writing over an existing ldisc will cause demons to eat your computer.
After the return the ldisc data has been copied so you may free your own
copy of the structure. You must not re-register over the top of the line
discipline even with the same data or your computer again will be eaten by
demons.</p>
<p>In order to remove a line discipline call tty_unregister_ldisc().
In ancient times this always worked. In modern times the function will
return -EBUSY if the ldisc is currently in use. Since the ldisc referencing
code manages the module counts this should not usually be a concern.</p>
<p>Heed this warning: the reference count field of the registered copies of the
tty_ldisc structure in the ldisc table counts the number of lines using this
discipline. The reference count of the tty_ldisc structure within a tty
counts the number of active users of the ldisc at this instant. In effect it
counts the number of threads of execution within an ldisc method (plus those
about to enter and exit although this detail matters not).</p>
</div>
<div class="section" id="line-discipline-methods">
<h2>Line Discipline Methods<a class="headerlink" href="#line-discipline-methods" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tty-side-interfaces">
<h3>TTY side interfaces<a class="headerlink" href="#tty-side-interfaces" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>open()</td>
<td>Called when the line discipline is attached to
the terminal. No other call into the line
discipline for this tty will occur until it
completes successfully. Should initialize any
state needed by the ldisc, and set receive_room
in the tty_struct to the maximum amount of data
the line discipline is willing to accept from the
driver with a single call to receive_buf().
Returning an error will prevent the ldisc from
being attached. Can sleep.</td>
</tr>
<tr class="row-even"><td>close()</td>
<td>This is called on a terminal when the line
discipline is being unplugged. At the point of
execution no further users will enter the
ldisc code for this tty. Can sleep.</td>
</tr>
<tr class="row-odd"><td>hangup()</td>
<td>Called when the tty line is hung up.
The line discipline should cease I/O to the tty.
No further calls into the ldisc code will occur.
The return value is ignored. Can sleep.</td>
</tr>
<tr class="row-even"><td>read()</td>
<td>(optional) A process requests reading data from
the line. Multiple read calls may occur in parallel
and the ldisc must deal with serialization issues.
If not defined, the process will receive an EIO
error. May sleep.</td>
</tr>
<tr class="row-odd"><td>write()</td>
<td>(optional) A process requests writing data to the
line. Multiple write calls are serialized by the
tty layer for the ldisc. If not defined, the
process will receive an EIO error. May sleep.</td>
</tr>
<tr class="row-even"><td>flush_buffer()</td>
<td>(optional) May be called at any point between
open and close, and instructs the line discipline
to empty its input buffer.</td>
</tr>
<tr class="row-odd"><td>set_termios()</td>
<td>(optional) Called on termios structure changes.
The caller passes the old termios data and the
current data is in the tty. Called under the
termios semaphore so allowed to sleep. Serialized
against itself only.</td>
</tr>
<tr class="row-even"><td>poll()</td>
<td>(optional) Check the status for the poll/select
calls. Multiple poll calls may occur in parallel.
May sleep.</td>
</tr>
<tr class="row-odd"><td>ioctl()</td>
<td>(optional) Called when an ioctl is handed to the
tty layer that might be for the ldisc. Multiple
ioctl calls may occur in parallel. May sleep.</td>
</tr>
<tr class="row-even"><td>compat_ioctl()</td>
<td>(optional) Called when a 32 bit ioctl is handed
to the tty layer that might be for the ldisc.
Multiple ioctl calls may occur in parallel.
May sleep.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="driver-side-interfaces">
<h3>Driver Side Interfaces<a class="headerlink" href="#driver-side-interfaces" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>receive_buf()</td>
<td>(optional) Called by the low-level driver to hand
a buffer of received bytes to the ldisc for
processing. The number of bytes is guaranteed not
to exceed the current value of tty-&gt;receive_room.
All bytes must be processed.</td>
</tr>
<tr class="row-even"><td>receive_buf2()</td>
<td><p class="first">(optional) Called by the low-level driver to hand
a buffer of received bytes to the ldisc for
processing. Returns the number of bytes processed.</p>
<p class="last">If both receive_buf() and receive_buf2() are
defined, receive_buf2() should be preferred.</p>
</td>
</tr>
<tr class="row-odd"><td>write_wakeup()</td>
<td><p class="first">May be called at any point between open and close.
The TTY_DO_WRITE_WAKEUP flag indicates if a call
is needed but always races versus calls. Thus the
ldisc must be careful about setting order and to
handle unexpected calls. Must not sleep.</p>
<p class="last">The driver is forbidden from calling this directly
from the -&gt;write call from the ldisc as the ldisc
is permitted to call the driver write method from
this function. In such a situation defer it.</p>
</td>
</tr>
<tr class="row-even"><td>dcd_change()</td>
<td>Report to the tty line the current DCD pin status
changes and the relative timestamp. The timestamp
cannot be NULL.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="driver-access">
<h3>Driver Access<a class="headerlink" href="#driver-access" title="Permalink to this headline">¶</a></h3>
<p>Line discipline methods can call the following methods of the underlying
hardware driver through the function pointers within the tty-&gt;driver
structure:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>write()</td>
<td>Write a block of characters to the tty device.
Returns the number of characters accepted. The
character buffer passed to this method is already
in kernel space.</td>
</tr>
<tr class="row-even"><td>put_char()</td>
<td>Queues a character for writing to the tty device.
If there is no room in the queue, the character is
ignored.</td>
</tr>
<tr class="row-odd"><td>flush_chars()</td>
<td>(Optional) If defined, must be called after
queueing characters with put_char() in order to
start transmission.</td>
</tr>
<tr class="row-even"><td>write_room()</td>
<td>Returns the numbers of characters the tty driver
will accept for queueing to be written.</td>
</tr>
<tr class="row-odd"><td>ioctl()</td>
<td>Invoke device specific ioctl.
Expects data pointers to refer to userspace.
Returns ENOIOCTLCMD for unrecognized ioctl numbers.</td>
</tr>
<tr class="row-even"><td>set_termios()</td>
<td><p class="first">Notify the tty driver that the device’s termios
settings have changed. New settings are in
tty-&gt;termios. Previous settings should be passed in
the “old” argument.</p>
<p class="last">The API is defined such that the driver should return
the actual modes selected. This means that the
driver function is responsible for modifying any
bits in the request it cannot fulfill to indicate
the actual modes being used. A device with no
hardware capability for change (e.g. a USB dongle or
virtual port) can provide NULL for this method.</p>
</td>
</tr>
<tr class="row-odd"><td>throttle()</td>
<td>Notify the tty driver that input buffers for the
line discipline are close to full, and it should
somehow signal that no more characters should be
sent to the tty.</td>
</tr>
<tr class="row-even"><td>unthrottle()</td>
<td>Notify the tty driver that characters can now be
sent to the tty without fear of overrunning the
input buffers of the line disciplines.</td>
</tr>
<tr class="row-odd"><td>stop()</td>
<td>Ask the tty driver to stop outputting characters
to the tty device.</td>
</tr>
<tr class="row-even"><td>start()</td>
<td>Ask the tty driver to resume sending characters
to the tty device.</td>
</tr>
<tr class="row-odd"><td>hangup()</td>
<td>Ask the tty driver to hang up the tty device.</td>
</tr>
<tr class="row-even"><td>break_ctl()</td>
<td>(Optional) Ask the tty driver to turn on or off
BREAK status on the RS-232 port.  If state is -1,
then the BREAK status should be turned on; if
state is 0, then BREAK should be turned off.
If this routine is not implemented, use ioctls
TIOCSBRK / TIOCCBRK instead.</td>
</tr>
<tr class="row-odd"><td>wait_until_sent()</td>
<td>Waits until the device has written out all of the
characters in its transmitter FIFO.</td>
</tr>
<tr class="row-even"><td>send_xchar()</td>
<td>Send a high-priority XON/XOFF character to the device.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="flags">
<h3>Flags<a class="headerlink" href="#flags" title="Permalink to this headline">¶</a></h3>
<p>Line discipline methods have access to tty-&gt;flags field containing the
following interesting flags:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>TTY_THROTTLED</td>
<td>Driver input is throttled. The ldisc should call
tty-&gt;driver-&gt;unthrottle() in order to resume
reception when it is ready to process more data.</td>
</tr>
<tr class="row-even"><td>TTY_DO_WRITE_WAKEUP</td>
<td>If set, causes the driver to call the ldisc’s
write_wakeup() method in order to resume
transmission when it can accept more data
to transmit.</td>
</tr>
<tr class="row-odd"><td>TTY_IO_ERROR</td>
<td>If set, causes all subsequent userspace read/write
calls on the tty to fail, returning -EIO.</td>
</tr>
<tr class="row-even"><td>TTY_OTHER_CLOSED</td>
<td>Device is a pty and the other side has closed.</td>
</tr>
<tr class="row-odd"><td>TTY_NO_WRITE_SPLIT</td>
<td>Prevent driver from splitting up writes into
smaller chunks.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h3>
<p>Callers to the line discipline functions from the tty layer are required to
take line discipline locks. The same is true of calls from the driver side
but not yet enforced.</p>
<p>Three calls are now provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ldisc = tty_ldisc_ref(tty);
</pre></div>
</div>
<p>takes a handle to the line discipline in the tty and returns it. If no ldisc
is currently attached or the ldisc is being closed and re-opened at this
point then NULL is returned. While this handle is held the ldisc will not
change or go away:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tty_ldisc_deref(ldisc)
</pre></div>
</div>
<p>Returns the ldisc reference and allows the ldisc to be closed. Returning the
reference takes away your right to call the ldisc functions until you take
a new reference:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ldisc = tty_ldisc_ref_wait(tty);
</pre></div>
</div>
<p>Performs the same function as tty_ldisc_ref except that it will wait for an
ldisc change to complete and then return a reference to the new ldisc.</p>
<p>While these functions are slightly slower than the old code they should have
minimal impact as most receive logic uses the flip buffers and they only
need to take a reference when they push bits up through the driver.</p>
<p>A caution: The ldisc-&gt;open(), ldisc-&gt;close() and driver-&gt;set_ldisc
functions are called with the ldisc unavailable. Thus tty_ldisc_ref will
fail in this situation if used within these functions. Ldisc and driver
code calling its own functions must be careful in this case.</p>
</div>
</div>
<div class="section" id="driver-interface">
<h2>Driver Interface<a class="headerlink" href="#driver-interface" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>open()</td>
<td>Called when a device is opened. May sleep</td>
</tr>
<tr class="row-even"><td>close()</td>
<td>Called when a device is closed. At the point of
return from this call the driver must make no
further ldisc calls of any kind. May sleep</td>
</tr>
<tr class="row-odd"><td>write()</td>
<td>Called to write bytes to the device. May not
sleep. May occur in parallel in special cases.
Because this includes panic paths drivers generally
shouldn’t try and do clever locking here.</td>
</tr>
<tr class="row-even"><td>put_char()</td>
<td>Stuff a single character onto the queue. The
driver is guaranteed following up calls to
flush_chars.</td>
</tr>
<tr class="row-odd"><td>flush_chars()</td>
<td>Ask the kernel to write put_char queue</td>
</tr>
<tr class="row-even"><td>write_room()</td>
<td>Return the number of characters that can be stuffed
into the port buffers without overflow (or less).
The ldisc is responsible for being intelligent
about multi-threading of write_room/write calls</td>
</tr>
<tr class="row-odd"><td>ioctl()</td>
<td>Called when an ioctl may be for the driver</td>
</tr>
<tr class="row-even"><td>set_termios()</td>
<td>Called on termios change, serialized against
itself by a semaphore. May sleep.</td>
</tr>
<tr class="row-odd"><td>set_ldisc()</td>
<td>Notifier for discipline change. At the point this
is done the discipline is not yet usable. Can now
sleep (I think)</td>
</tr>
<tr class="row-even"><td>throttle()</td>
<td>Called by the ldisc to ask the driver to do flow
control.  Serialization including with unthrottle
is the job of the ldisc layer.</td>
</tr>
<tr class="row-odd"><td>unthrottle()</td>
<td>Called by the ldisc to ask the driver to stop flow
control.</td>
</tr>
<tr class="row-even"><td>stop()</td>
<td>Ldisc notifier to the driver to stop output. As with
throttle the serializations with start() are down
to the ldisc layer.</td>
</tr>
<tr class="row-odd"><td>start()</td>
<td>Ldisc notifier to the driver to start output.</td>
</tr>
<tr class="row-even"><td>hangup()</td>
<td>Ask the tty driver to cause a hangup initiated
from the host side. [Can sleep ??]</td>
</tr>
<tr class="row-odd"><td>break_ctl()</td>
<td>Send RS232 break. Can sleep. Can get called in
parallel, driver must serialize (for now), and
with write calls.</td>
</tr>
<tr class="row-even"><td>wait_until_sent()</td>
<td>Wait for characters to exit the hardware queue
of the driver. Can sleep</td>
</tr>
<tr class="row-odd"><td>send_xchar()</td>
<td>Send XON/XOFF and if possible jump the queue with
it in order to get fast flow control responses.
Cannot sleep ??</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>