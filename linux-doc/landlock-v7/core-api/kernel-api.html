

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux Kernel API &mdash; The Linux Kernel 4.13.0-rc5+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.13.0-rc5+ documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="Generic Associative Array Implementation" href="assoc_array.html"/>
        <link rel="prev" title="Core API Documentation" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.13.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Linux Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-types">Data Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-c-library-functions">Basic C Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-kernel-library-functions">Basic Kernel Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-management-in-linux">Memory Management in Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-ipc-facilities">Kernel IPC facilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fifo-buffer">FIFO Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relay-interface-support">relay interface support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-support">Module Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interfaces">Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security-framework">Security Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audit-interfaces">Audit Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accounting-framework">Accounting Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-devices">Block Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#char-devices">Char devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-framework">Clock Framework</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>The Linux Kernel API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/kernel-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-kernel-api">
<h1>The Linux Kernel API<a class="headerlink" href="#the-linux-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="data-types">
<h2>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="doubly-linked-lists">
<h3>Doubly Linked Lists<a class="headerlink" href="#doubly-linked-lists" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.list_add">
void <code class="descname">list_add</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it after</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<dl class="function">
<dt id="c.list_add_tail">
void <code class="descname">list_add_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it before</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<dl class="function">
<dt id="c.__list_del_entry">
void <code class="descname">__list_del_entry</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_del_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
<dl class="function">
<dt id="c.list_replace">
void <code class="descname">list_replace</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;old</em>, struct list_head *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
<dl class="function">
<dt id="c.list_del_init">
void <code class="descname">list_del_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<dl class="function">
<dt id="c.list_move">
void <code class="descname">list_move</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another&#8217;s head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will precede our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_move_tail">
void <code class="descname">list_move_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another&#8217;s tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will follow our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_is_last">
int <code class="descname">list_is_last</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_empty">
int <code class="descname">list_empty</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_empty_careful">
int <code class="descname">list_empty_careful</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></a> it.</p>
<dl class="function">
<dt id="c.list_rotate_left">
void <code class="descname">list_rotate_left</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_is_singular">
int <code class="descname">list_is_singular</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_cut_position">
void <code class="descname">list_cut_position</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>a new list to add all removed entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>a list with entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>an entry within head, could be the head itself
and if so we won&#8217;t cut the list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
<dl class="function">
<dt id="c.list_splice">
void <code class="descname">list_splice</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail">
void <code class="descname">list_splice_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_init">
void <code class="descname">list_splice_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_splice_tail_init">
void <code class="descname">list_splice_tail_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_entry">
<code class="descname">list_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_first_entry">
<code class="descname">list_first_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_last_entry">
<code class="descname">list_last_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_last_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_first_entry_or_null">
<code class="descname">list_first_entry_or_null</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry_or_null" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<dl class="function">
<dt id="c.list_next_entry">
<code class="descname">list_next_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prev_entry">
<code class="descname">list_prev_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prev_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prev element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each">
<code class="descname">list_for_each</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev">
<code class="descname">list_for_each_prev</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_safe">
<code class="descname">list_for_each_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev_safe">
<code class="descname">list_for_each_prev_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry">
<code class="descname">list_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_reverse">
<code class="descname">list_for_each_entry_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prepare_entry">
<code class="descname">list_prepare_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prepare_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a start point</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue">
<code class="descname">list_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_reverse">
<code class="descname">list_for_each_entry_continue_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards from the given point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from">
<code class="descname">list_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_reverse">
<code class="descname">list_for_each_entry_from_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe">
<code class="descname">list_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_safe_continue">
<code class="descname">list_for_each_entry_safe_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue list iteration safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_from">
<code class="descname">list_for_each_entry_safe_from</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list from current point safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_reverse">
<code class="descname">list_for_each_entry_safe_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
<dl class="function">
<dt id="c.list_safe_reset_next">
<code class="descname">list_safe_reset_next</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_safe_reset_next" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a stale list_for_each_entry_safe loop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the loop cursor used in the list_for_each_entry_safe loop</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>temporary storage used in list_for_each_entry_safe</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry">
<code class="descname">hlist_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue">
<code class="descname">hlist_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from">
<code class="descname">hlist_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_safe">
<code class="descname">hlist_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
</div>
</div>
<div class="section" id="basic-c-library-functions">
<h2>Basic C Library Functions<a class="headerlink" href="#basic-c-library-functions" title="Permalink to this headline">¶</a></h2>
<p>When writing drivers, you cannot in general use routines which are from
the C Library. Some of the functions have been found generally useful
and they are listed below. The behaviour of these functions may vary
slightly from those defined by ANSI, and these deviations are noted in
the text.</p>
<div class="section" id="string-conversions">
<h3>String Conversions<a class="headerlink" href="#string-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.simple_strtoull">
unsigned long long <code class="descname">simple_strtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoull instead.</p>
<dl class="function">
<dt id="c.simple_strtoul">
unsigned long <code class="descname">simple_strtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoul instead.</p>
<dl class="function">
<dt id="c.simple_strtol">
long <code class="descname">simple_strtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtol instead.</p>
<dl class="function">
<dt id="c.simple_strtoll">
long long <code class="descname">simple_strtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoll instead.</p>
<dl class="function">
<dt id="c.vsnprintf">
int <code class="descname">vsnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function generally follows C99 vsnprintf, but has some
extensions and a few limitations:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">``n``</span></code> is unsupported</li>
<li><code class="docutils literal"><span class="pre">``p``*</span></code> is handled by <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code></li>
</ul>
</div></blockquote>
<p>See <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code> or Documentation/printk-formats.txt for more
extensive description.</p>
<p><strong>Please update the documentation in both places when making changes</strong></p>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
&#8216;0&#8217;, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing &#8216;0&#8217;), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a>.</p>
<dl class="function">
<dt id="c.vscnprintf">
int <code class="descname">vscnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vscnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which have been written into
the <strong>buf</strong> not including the trailing &#8216;0&#8217;. If <strong>size</strong> is == 0 the function
returns 0.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.snprintf">
int <code class="descname">snprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
<strong>size</strong>, the resulting string is truncated.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.scnprintf">
int <code class="descname">scnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.scnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters written into <strong>buf</strong> not including
the trailing &#8216;0&#8217;. If <strong>size</strong> is == 0 the function returns 0.</p>
<dl class="function">
<dt id="c.vsprintf">
int <code class="descname">vsprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> or <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.sprintf">
int <code class="descname">sprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a> or <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.vbin_printf">
int <code class="descname">vbin_printf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vbin_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args&#8217; binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args&#8217; binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format follows C99 vsnprintf, except <code class="docutils literal"><span class="pre">n</span></code> is ignored, and its argument
is skipped.</p>
<p>The return value is the number of words(32bits) which would be generated for
the given input.</p>
<p><strong>NOTE</strong></p>
<p>If the return value is greater than <strong>size</strong>, the resulting bin_buf is NOT
valid for <a class="reference internal" href="#c.bstr_printf" title="bstr_printf"><code class="xref c c-func docutils literal"><span class="pre">bstr_printf()</span></code></a>.</p>
<dl class="function">
<dt id="c.bstr_printf">
int <code class="descname">bstr_printf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, const u32 *<em>&nbsp;bin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bstr_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string from binary arguments and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>Binary arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function like C99 vsnprintf, but the difference is that vsnprintf gets
arguments from stack, and bstr_printf gets arguments from <strong>bin_buf</strong> which is
a binary buffer that generated by vbin_printf.</p>
<dl class="docutils">
<dt>The format follows C99 vsnprintf, but has some extensions:</dt>
<dd>see vsnprintf comment for details.</dd>
</dl>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
&#8216;0&#8217;, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing &#8216;0&#8217;), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<dl class="function">
<dt id="c.bprintf">
int <code class="descname">bprintf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.bprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args&#8217; binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args&#8217; binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of words(u32) written
into <strong>bin_buf</strong>.</p>
<dl class="function">
<dt id="c.vsscanf">
int <code class="descname">vsscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format of buffer</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>arguments</dd>
</dl>
<dl class="function">
<dt id="c.sscanf">
int <code class="descname">sscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>formatting of buffer</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>resulting arguments</dd>
</dl>
<dl class="function">
<dt id="c.kstrtol">
int <code class="descname">kstrtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoul">
int <code class="descname">kstrtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoull">
int <code class="descname">kstrtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoll">
int <code class="descname">kstrtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtouint">
int <code class="descname">kstrtouint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtouint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoint">
int <code class="descname">kstrtoint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtobool">
int <code class="descname">kstrtobool</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, bool *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtobool" title="Permalink to this definition">¶</a></dt>
<dd><p>convert common user inputs into boolean values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>input string</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>result</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns 0 iff the first character is one of &#8216;Yy1Nn0&#8217;, or
[oO][NnFf] for &#8220;on&#8221; and &#8220;off&#8221;. Otherwise it will return -EINVAL.  Value
pointed to by res is updated upon finding a match.</p>
</div>
<div class="section" id="string-manipulation">
<h3>String Manipulation<a class="headerlink" href="#string-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.strncasecmp">
int <code class="descname">strncasecmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncasecmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Case insensitive, length-limited string comparison</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The other string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to compare</dd>
</dl>
<dl class="function">
<dt id="c.strcpy">
char * <code class="descname">strcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
</dl>
<dl class="function">
<dt id="c.strncpy">
char * <code class="descname">strncpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a length-limited, C-string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>The result is not <code class="docutils literal"><span class="pre">NUL-terminated</span></code> if the source exceeds
<strong>count</strong> bytes.</p>
<p>In the case where the length of <strong>src</strong> is less than  that  of
count, the remainder of <strong>dest</strong> will be padded with <code class="docutils literal"><span class="pre">NUL</span></code>.</p>
<dl class="function">
<dt id="c.strlcpy">
size_t <code class="descname">strlcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatible with <code class="docutils literal"><span class="pre">*BSD</span></code>: the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> does.</p>
<dl class="function">
<dt id="c.strscpy">
ssize_t <code class="descname">strscpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.
The routine returns the number of characters copied (not including
the trailing NUL) or -E2BIG if the destination buffer wasn&#8217;t big enough.
The behavior is undefined if the string buffers overlap.
The destination buffer is always NUL terminated, unless it&#8217;s zero-sized.</p>
<p>Preferred to <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> since the API doesn&#8217;t require reading memory
from the src string beyond the specified &#8220;count&#8221; bytes, and since
the return value is easier to error-check than <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a>&#8216;s.
In addition, the implementation is robust to the string changing out
from underneath it, unlike the current <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> implementation.</p>
<p>Preferred to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> since it always returns a valid string, and
doesn&#8217;t unnecessarily force the tail of the destination buffer to be
zeroed.  If the zeroing is desired, it&#8217;s likely cleaner to use <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal"><span class="pre">strscpy()</span></code></a>
with an overflow test, then just <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> the tail of the dest buffer.</p>
<dl class="function">
<dt id="c.strcat">
char * <code class="descname">strcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append one <code class="docutils literal"><span class="pre">NUL-terminated</span></code> string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
</dl>
<dl class="function">
<dt id="c.strncat">
char * <code class="descname">strncat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum numbers of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that in contrast to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a>, <a class="reference internal" href="#c.strncat" title="strncat"><code class="xref c c-func docutils literal"><span class="pre">strncat()</span></code></a> ensures the result is
terminated.</p>
<dl class="function">
<dt id="c.strlcat">
size_t <code class="descname">strlcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the destination buffer.</dd>
</dl>
<dl class="function">
<dt id="c.strcmp">
int <code class="descname">strcmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
</dl>
<dl class="function">
<dt id="c.strncmp">
int <code class="descname">strncmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two length-limited strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to compare</dd>
</dl>
<dl class="function">
<dt id="c.strchr">
char * <code class="descname">strchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strchrnul">
char * <code class="descname">strchrnul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchrnul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return a character in a string, or end of string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to first occurrence of &#8216;c&#8217; in s. If c is not found, then
return a pointer to the null byte at the end of s.</p>
<dl class="function">
<dt id="c.strrchr">
char * <code class="descname">strrchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strrchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the last occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnchr">
char * <code class="descname">strnchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in a length limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of characters to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.skip_spaces">
char * <code class="descname">skip_spaces</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skip_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading whitespace from <strong>str</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the first non-whitespace character in <strong>str</strong>.</p>
<dl class="function">
<dt id="c.strim">
char * <code class="descname">strim</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strim" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading and trailing whitespace from <strong>s</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the first trailing whitespace is replaced with a <code class="docutils literal"><span class="pre">NUL-terminator</span></code>
in the given string <strong>s</strong>. Returns a pointer to the first non-whitespace
character in <strong>s</strong>.</p>
<dl class="function">
<dt id="c.strlen">
size_t <code class="descname">strlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
</dl>
<dl class="function">
<dt id="c.strnlen">
size_t <code class="descname">strnlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to search</dd>
</dl>
<dl class="function">
<dt id="c.strspn">
size_t <code class="descname">strspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;accept</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which only contain letters in <strong>accept</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">accept</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strcspn">
size_t <code class="descname">strcspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;reject</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which does not contain letters in <strong>reject</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">reject</span></code></dt>
<dd>The string to avoid</dd>
</dl>
<dl class="function">
<dt id="c.strpbrk">
char * <code class="descname">strpbrk</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strpbrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a set of characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<dl class="function">
<dt id="c.strsep">
char * <code class="descname">strsep</code><span class="sig-paren">(</span>char **<em>&nbsp;s</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strsep" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string into tokens</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.strsep" title="strsep"><code class="xref c c-func docutils literal"><span class="pre">strsep()</span></code></a> updates <strong>s</strong> to point after the token, ready for the next call.</p>
<p>It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)</p>
<dl class="function">
<dt id="c.sysfs_streq">
bool <code class="descname">sysfs_streq</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_streq" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if strings are equal, modulo trailing newline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>one string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>another string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns true iff two strings are equal, treating both
NUL and newline-then-NUL as equivalent string terminations.  It&#8217;s
geared for use with sysfs input strings, which generally terminate
with newlines but are compared against values without newlines.</p>
<dl class="function">
<dt id="c.match_string">
int <code class="descname">match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">string</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Return</strong></p>
<p>index of a <strong>string</strong> in the <strong>array</strong> if matches, or <code class="docutils literal"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__sysfs_match_string">
int <code class="descname">__sysfs_match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sysfs_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns index of <strong>str</strong> in the <strong>array</strong> or -EINVAL, just like <a class="reference internal" href="#c.match_string" title="match_string"><code class="xref c c-func docutils literal"><span class="pre">match_string()</span></code></a>.
Uses sysfs_streq instead of strcmp for matching.</p>
<dl class="function">
<dt id="c.memset">
void * <code class="descname">memset</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory with the given value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> to access IO space, use <a class="reference internal" href="../driver-api/device-io.html#c.memset_io" title="memset_io"><code class="xref c c-func docutils literal"><span class="pre">memset_io()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.memzero_explicit">
void <code class="descname">memzero_explicit</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memzero_explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory (e.g. sensitive keying data) with 0s.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Note</strong></p>
<p>usually using <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> is just fine (!), but in cases
where clearing out _local_ data at the end of a scope is
necessary, <a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> should be used instead in
order to prevent the compiler from optimising away zeroing.</p>
<p><a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> doesn&#8217;t need an arch-specific version as
it just invokes the one of <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> implicitly.</p>
<dl class="function">
<dt id="c.memcpy">
void * <code class="descname">memcpy</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>You should not use this function to access IO space, use <a class="reference internal" href="../driver-api/device-io.html#c.memcpy_toio" title="memcpy_toio"><code class="xref c c-func docutils literal"><span class="pre">memcpy_toio()</span></code></a>
or <a class="reference internal" href="../driver-api/device-io.html#c.memcpy_fromio" title="memcpy_fromio"><code class="xref c c-func docutils literal"><span class="pre">memcpy_fromio()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.memmove">
void * <code class="descname">memmove</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memmove" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code></a>, <a class="reference internal" href="#c.memmove" title="memmove"><code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code></a> copes with overlapping areas.</p>
<dl class="function">
<dt id="c.memcmp">
__visible int <code class="descname">memcmp</code><span class="sig-paren">(</span>const void *<em>&nbsp;cs</em>, const void *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two areas of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One area of memory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another area of memory</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<dl class="function">
<dt id="c.memscan">
void * <code class="descname">memscan</code><span class="sig-paren">(</span>void *<em>&nbsp;addr</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memscan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or 1 byte past
the area if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.strstr">
char * <code class="descname">strstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnstr">
char * <code class="descname">strnstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to search</dd>
</dl>
<dl class="function">
<dt id="c.memchr">
void * <code class="descname">memchr</code><span class="sig-paren">(</span>const void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.memchr_inv">
void * <code class="descname">memchr_inv</code><span class="sig-paren">(</span>const void *<em>&nbsp;start</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an unmatching character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>Find a character other than c</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first character other than <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if the whole buffer contains just <strong>c</strong>.</p>
<dl class="function">
<dt id="c.strreplace">
char * <code class="descname">strreplace</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em>, char<em>&nbsp;old</em>, char<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all occurrences of character in string.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to operate on.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">old</span></code></dt>
<dd>The character being replaced.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">new</span></code></dt>
<dd>The character <strong>old</strong> is replaced with.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to the nul byte at the end of <strong>s</strong>.</p>
</div>
<div class="section" id="bit-operations">
<h3>Bit Operations<a class="headerlink" href="#bit-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.set_bit">
void <code class="descname">set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is atomic and may not be reordered.  See <a class="reference internal" href="#c.__set_bit" title="__set_bit"><code class="xref c c-func docutils literal"><span class="pre">__set_bit()</span></code></a>
if you do not require the atomic guarantees.</p>
<p><strong>Note</strong></p>
<p>there are no guarantees that this function will not be reordered
on non x86 architectures, so if you are writing portable code,
make sure not to rely on its reordering guarantees.</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.__set_bit">
void <code class="descname">__set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal"><span class="pre">set_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it&#8217;s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.clear_bit">
void <code class="descname">clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal"><span class="pre">clear_bit()</span></code></a> is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call <code class="xref c c-func docutils literal"><span class="pre">smp_mb__before_atomic()</span></code> and/or <code class="xref c c-func docutils literal"><span class="pre">smp_mb__after_atomic()</span></code>
in order to ensure changes are visible on other processors.</p>
<dl class="function">
<dt id="c.__change_bit">
void <code class="descname">__change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it&#8217;s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.change_bit">
void <code class="descname">change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a> is atomic and may not be reordered.
Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.test_and_set_bit">
bool <code class="descname">test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_and_set_bit_lock">
bool <code class="descname">test_and_set_bit_lock</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value for lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as test_and_set_bit on x86.</p>
<dl class="function">
<dt id="c.__test_and_set_bit">
bool <code class="descname">__test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<dl class="function">
<dt id="c.test_and_clear_bit">
bool <code class="descname">test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.__test_and_clear_bit">
bool <code class="descname">__test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<p><strong>Note</strong></p>
<p>the operation is performed atomically with respect to
the local CPU, but not other CPUs. Portable code should not
rely on this behaviour.
KVM relies on this behaviour on x86 for modifying memory that is also
accessed from a hypervisor on the same CPU if running in a VM: don&#8217;t change
this without also updating arch/x86/kernel/kvm.c</p>
<dl class="function">
<dt id="c.test_and_change_bit">
bool <code class="descname">test_and_change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_bit">
bool <code class="descname">test_bit</code><span class="sig-paren">(</span>int<em>&nbsp;nr</em>, const volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a bit is set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>bit number to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<dl class="function">
<dt id="c.__ffs">
unsigned long <code class="descname">__ffs</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no bit exists, so code should check against 0 first.</p>
<dl class="function">
<dt id="c.ffz">
unsigned long <code class="descname">ffz</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffz" title="Permalink to this definition">¶</a></dt>
<dd><p>find first zero bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no zero exists, so code should check against ~0UL first.</p>
<dl class="function">
<dt id="c.ffs">
int <code class="descname">ffs</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined the same way as the libc and compiler builtin ffs
routines, therefore differs in spirit from the other bitops.</p>
<p>ffs(value) returns 0 if value is 0 or the position of the first
set bit if value is nonzero. The first (least significant) bit
is at position 1.</p>
<dl class="function">
<dt id="c.fls">
int <code class="descname">fls</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffs, but returns the position of the most significant set bit.</p>
<p>fls(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 32.</p>
<dl class="function">
<dt id="c.fls64">
int <code class="descname">fls64</code><span class="sig-paren">(</span>__u64<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls64" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in a 64-bit word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffsll, but returns the position of the most significant set bit.</p>
<p>fls64(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 64.</p>
</div>
</div>
<div class="section" id="basic-kernel-library-functions">
<h2>Basic Kernel Library Functions<a class="headerlink" href="#basic-kernel-library-functions" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides more basic utility functions.</p>
<div class="section" id="bitmap-operations">
<h3>Bitmap Operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__bitmap_shift_right">
void <code class="descname">__bitmap_shift_right</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned<em>&nbsp;shift</em>, unsigned<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_right" title="Permalink to this definition">¶</a></dt>
<dd><p>logical right shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting right (dividing) means moving bits in the MS -&gt; LS bit
direction.  Zeros are fed into the vacated MS positions and the
LS bits shifted off the bottom are lost.</p>
<dl class="function">
<dt id="c.__bitmap_shift_left">
void <code class="descname">__bitmap_shift_left</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;shift</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_left" title="Permalink to this definition">¶</a></dt>
<dd><p>logical left shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting left (multiplying) means moving bits in the LS -&gt; MS
direction.  Zeros are fed into the vacated LS bit positions
and those MS bits shifted off the top are lost.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area_off">
unsigned long <code class="descname">bitmap_find_next_zero_area_off</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;map</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;start</em>, unsigned int<em>&nbsp;nr</em>, unsigned long<em>&nbsp;align_mask</em>, unsigned long<em>&nbsp;align_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area_off" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt>
<dd>The address to base the search on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>The bitmap size in bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>The bitnumber to start searching at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>The number of zeroed bits we&#8217;re looking for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt>
<dd>Alignment mask for zero area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_offset</span></code></dt>
<dd>Alignment offset for zero area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus <strong>align_offset</strong>
is multiple of that power of 2.</p>
<dl class="function">
<dt id="c.__bitmap_parse">
int <code class="descname">__bitmap_parse</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string into a bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (<code class="docutils literal"><span class="pre">-EOVERFLOW</span></code>), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  <code class="docutils literal"><span class="pre">-EINVAL</span></code> is returned for illegal
characters and for grouping errors such as &#8220;1,,5&#8221;, &#8221;,44&#8221;, &#8221;,&#8221; and &#8220;&#8221;.
Leading and trailing whitespace accepted, but not embedded whitespace.</p>
<dl class="function">
<dt id="c.bitmap_parse_user">
int <code class="descname">bitmap_parse_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse_user" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string in a user buffer into a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <a class="reference internal" href="#c.__bitmap_parse" title="__bitmap_parse"><code class="xref c c-func docutils literal"><span class="pre">__bitmap_parse()</span></code></a>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_print_to_pagebuf">
int <code class="descname">bitmap_print_to_pagebuf</code><span class="sig-paren">(</span>bool<em>&nbsp;list</em>, char *<em>&nbsp;buf</em>, const unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_pagebuf" title="Permalink to this definition">¶</a></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">list</span></code></dt>
<dd>indicates whether the bitmap must be list</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>page aligned buffer into which string is placed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap to convert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Output format is a comma-separated list of decimal numbers and
ranges if list is specified or hex digits grouped into comma-separated
sets of 8 digits/set. Returns the number of characters written to buf.</p>
<p>It is assumed that <strong>buf</strong> is a pointer into a PAGE_SIZE area and that
sufficient storage remains at <strong>buf</strong> to accommodate the
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> output.</p>
<dl class="function">
<dt id="c.bitmap_parselist_user">
int <code class="descname">bitmap_parselist_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist_user" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <code class="xref c c-func docutils literal"><span class="pre">bitmap_parselist()</span></code>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_remap">
void <code class="descname">bitmap_remap</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to another bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>remapped result</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>subset to be remapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight &#8216;w&#8217; of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>If either of the <strong>old</strong> and <strong>new</strong> bitmaps are empty, or if <strong>src</strong> and
<strong>dst</strong> point to the same location, then this routine copies <strong>src</strong>
to <strong>dst</strong>.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to <strong>src</strong>, placing the result in
<strong>dst</strong>, clearing any bits previously set in <strong>dst</strong>.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>src</strong> comes into this routine
with bits 1, 5 and 7 set, then <strong>dst</strong> should leave with bits 1,
13 and 15 set.</p>
<dl class="function">
<dt id="c.bitmap_bitremap">
int <code class="descname">bitmap_bitremap</code><span class="sig-paren">(</span>int<em>&nbsp;oldbit</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_bitremap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to a single bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oldbit</span></code></dt>
<dd>bit position to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight &#8216;w&#8217; of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to bit position <strong>oldbit</strong>, returning
the new bit position.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>oldbit</strong> is 5, then this routine
returns 13.</p>
<dl class="function">
<dt id="c.bitmap_onto">
void <code class="descname">bitmap_onto</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, const unsigned long *<em>&nbsp;relmap</em>, unsigned int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_onto" title="Permalink to this definition">¶</a></dt>
<dd><p>translate one bitmap relative to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting translated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original untranslated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">relmap</span></code></dt>
<dd>bitmap relative to which translated</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff there exists some m such that the
n-th bit of <strong>relmap</strong> is set, the m-th bit of <strong>orig</strong> is set, and
the n-th bit of <strong>relmap</strong> is also the m-th _set_ bit of <strong>relmap</strong>.
(If you understood the previous sentence the first time your
read it, you&#8217;re overqualified for your current job.)</p>
<p>In other words, <strong>orig</strong> is mapped onto (surjectively) <strong>dst</strong>,
using the map { &lt;n, m&gt; | the n-th bit of <strong>relmap</strong> is the
m-th set bit of <strong>relmap</strong> }.</p>
<p>Any set bits in <strong>orig</strong> above bit number W, where W is the
weight of (number of set bits in) <strong>relmap</strong> are mapped nowhere.
In particular, if for all bits m set in <strong>orig</strong>, m &gt;= W, then
<strong>dst</strong> will end up empty.  In situations where the possibility
of such an empty result is not desired, one way to avoid it is
to use the <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator, below, to first fold the
<strong>orig</strong> bitmap over itself so that all its set bits x are in the
range 0 &lt;= x &lt; W.  The <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator does this by
setting the bit (m % W) in <strong>dst</strong>, for each bit (m) set in <strong>orig</strong>.</p>
<dl class="docutils">
<dt>Example [1] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let&#8217;s say <strong>relmap</strong> has bits 30-39 set, and <strong>orig</strong> has bits
1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
<strong>dst</strong> will have bits 31, 33, 35, 37 and 39 set.</p>
<p>When bit 0 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the first bit (if any)
that is turned on in <strong>relmap</strong>.  Since bit 0 was off in the
above example, we leave off that bit (bit 30) in <strong>dst</strong>.</p>
<p>When bit 1 is set in <strong>orig</strong> (as in the above example), it
means turn on the bit in <strong>dst</strong> corresponding to whatever
is the second bit that is turned on in <strong>relmap</strong>.  The second
bit in <strong>relmap</strong> that was turned on in the above example was
bit 31, so we turned on bit 31 in <strong>dst</strong>.</p>
<p>Similarly, we turned on bits 33, 35, 37 and 39 in <strong>dst</strong>,
because they were the 4th, 6th, 8th and 10th set bits
set in <strong>relmap</strong>, and the 4th, 6th, 8th and 10th bits of
<strong>orig</strong> (i.e. bits 3, 5, 7 and 9) were also set.</p>
<p class="last">When bit 11 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the twelfth bit that is
turned on in <strong>relmap</strong>.  In the above example, there were
only ten bits turned on in <strong>relmap</strong> (30..39), so that bit
11 was set in <strong>orig</strong> had no affect on <strong>dst</strong>.</p>
</dd>
<dt>Example [2] for <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> + <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let&#8217;s say <strong>relmap</strong> has these ten bits set:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>40 41 42 43 45 48 53 61 74 95
</pre></div>
</div>
<p>(for the curious, that&#8217;s 40 plus the first ten terms of the
Fibonacci sequence.)</p>
<p>Further lets say we use the following code, invoking
<a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> then bitmap_onto, as suggested above to
avoid the possibility of an empty <strong>dst</strong> result:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>unsigned long *tmp;     // a temporary bitmap&#39;s bits

bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
bitmap_onto(dst, tmp, relmap, bits);
</pre></div>
</div>
<p>Then this table shows what various values of <strong>dst</strong> would be, for
various <strong>orig</strong>&#8216;s.  I list the zero-based positions of each set bit.
The tmp column shows the intermediate result, as computed by
using <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> to fold the <strong>orig</strong> bitmap modulo ten
(the weight of <strong>relmap</strong>):</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="30%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>orig</strong></td>
<td>tmp</td>
<td><strong>dst</strong></td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>41</td>
</tr>
<tr class="row-even"><td>9</td>
<td>9</td>
<td>95</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>0</td>
<td>40 <a class="footnote-reference" href="#f1" id="id1">[1]</a></td>
</tr>
<tr class="row-even"><td>1 3 5 7</td>
<td>1 3 5 7</td>
<td>41 43 48 61</td>
</tr>
<tr class="row-odd"><td>0 1 2 3 4</td>
<td>0 1 2 3 4</td>
<td>40 41 42 43 45</td>
</tr>
<tr class="row-even"><td>0 9 18 27</td>
<td>0 9 8 7</td>
<td>40 61 74 95</td>
</tr>
<tr class="row-odd"><td>0 10 20 30</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-even"><td>0 11 22 33</td>
<td>0 1 2 3</td>
<td>40 41 42 43</td>
</tr>
<tr class="row-odd"><td>0 12 24 36</td>
<td>0 2 4 6</td>
<td>40 42 45 53</td>
</tr>
<tr class="row-even"><td>78 102 211</td>
<td>1 2 8</td>
<td>41 42 74 <a class="footnote-reference" href="#f1" id="id2">[1]</a></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> For these marked lines, if we hadn&#8217;t first done <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a>
into tmp, then the <strong>dst</strong> result would have been empty.</td></tr>
</tbody>
</table>
<p>If either of <strong>orig</strong> or <strong>relmap</strong> is empty (no set bits), then <strong>dst</strong>
will be returned empty.</p>
<p>If (as explained above) the only set bits in <strong>orig</strong> are in positions
m where m &gt;= W, (where W is the weight of <strong>relmap</strong>) then <strong>dst</strong> will
once again be returned empty.</p>
<p>All bits in <strong>dst</strong> not set by the above rule are cleared.</p>
<dl class="function">
<dt id="c.bitmap_fold">
void <code class="descname">bitmap_fold</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, unsigned int<em>&nbsp;sz</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_fold" title="Permalink to this definition">¶</a></dt>
<dd><p>fold larger bitmap into smaller, modulo specified size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting smaller bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original larger bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt>
<dd>specified size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each bit oldbit in <strong>orig</strong>, set bit oldbit mod <strong>sz</strong> in <strong>dst</strong>.
Clear all other bits in <strong>dst</strong>.  See further the comment and
Example [2] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a> for why and how to use this.</p>
<dl class="function">
<dt id="c.bitmap_find_free_region">
int <code class="descname">bitmap_find_free_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;bits</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_free_region" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned mem region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a region of free (zero) bits in a <strong>bitmap</strong> of <strong>bits</strong> bits and
allocate them (set them to one).  Only consider regions of length
a power (<strong>order</strong>) of two, aligned to that power of two, which
makes the search algorithm much faster.</p>
<p>Return the bit offset in bitmap of the allocated region,
or -errno on failure.</p>
<dl class="function">
<dt id="c.bitmap_release_region">
void <code class="descname">bitmap_release_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release allocated bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to release</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the complement to <code class="xref c c-func docutils literal"><span class="pre">__bitmap_find_free_region()</span></code> and releases
the found region (by clearing it in the bitmap).</p>
<p>No return value.</p>
<dl class="function">
<dt id="c.bitmap_allocate_region">
int <code class="descname">bitmap_allocate_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_allocate_region" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate (set bits in) a specified region of a bitmap.</p>
<p>Return 0 on success, or <code class="docutils literal"><span class="pre">-EBUSY</span></code> if specified region wasn&#8217;t
free (not all bits were zero).</p>
<dl class="function">
<dt id="c.bitmap_from_u32array">
unsigned int <code class="descname">bitmap_from_u32array</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;nbits</em>, const u32 *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;nwords</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_u32array" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of a u32 array of bits to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the destination bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the source bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nwords</span></code></dt>
<dd>number of u32 words in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>copy min(nbits, 32*nwords) bits from <strong>buf</strong> to <strong>bitmap</strong>, remaining
bits between nword and nbits in <strong>bitmap</strong> (if any) are cleared. In
last word of <strong>bitmap</strong>, the bits beyond nbits (if any) are kept
unchanged.</p>
<p>Return the number of bits effectively copied.</p>
<dl class="function">
<dt id="c.bitmap_to_u32array">
unsigned int <code class="descname">bitmap_to_u32array</code><span class="sig-paren">(</span>u32 *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;nwords</em>, const unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_u32array" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of bitmap to a u32 array of bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the dest bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nwords</span></code></dt>
<dd>number of u32 words in <strong>buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the source bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>copy min(nbits, 32*nwords) bits from <strong>bitmap</strong> to <strong>buf</strong>. Remaining
bits after nbits in <strong>buf</strong> (if any) are cleared.</p>
<p>Return the number of bits effectively copied.</p>
<dl class="function">
<dt id="c.bitmap_copy_le">
void <code class="descname">bitmap_copy_le</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_copy_le" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a bitmap, putting the bits into little-endian order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>bitmap to copy</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in the bitmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Require nbits % BITS_PER_LONG == 0.</p>
<dl class="function">
<dt id="c.__bitmap_parselist">
int <code class="descname">__bitmap_parselist</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parselist" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list format ASCII string to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>read nul-terminated user string from this buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>write resulting mask here</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>number of bits in mask to be written</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.
Optionally each range can be postfixed to denote that only parts of it
should be set. The range will divided to groups of specific size.
From each group will be used only defined amount of bits.
Syntax: range:used_size/group_size</p>
<p><strong>Example</strong></p>
<p>0-1023:2/256 ==&gt; 0,1,256,257,512,513,768,769</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on invalid input strings. Error values:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: second number in range smaller than first</li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: invalid character in string</li>
<li><code class="docutils literal"><span class="pre">-ERANGE</span></code>: bit number specified too large for mask</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.bitmap_pos_to_ord">
int <code class="descname">bitmap_pos_to_ord</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;pos</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_pos_to_ord" title="Permalink to this definition">¶</a></dt>
<dd><p>find ordinal of set bit at given position in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to a bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>a bit position in <strong>buf</strong> (0 &lt;= <strong>pos</strong> &lt; <strong>nbits</strong>)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the bit at position <strong>pos</strong> in <strong>buf</strong> (of length <strong>nbits</strong>) to the
ordinal of which set bit it is.  If it is not set or if <strong>pos</strong>
is not a valid bit position, map to -1.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>pos</strong>
values 4 through 7 will get mapped to 0 through 3, respectively,
and other <strong>pos</strong> values will get mapped to -1.  When <strong>pos</strong> value 7
gets mapped to (returns) <strong>ord</strong> value 3 in this example, that means
that bit 7 is the 3rd (starting with 0th) set bit in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>bits</strong> are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_ord_to_pos">
unsigned int <code class="descname">bitmap_ord_to_pos</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;ord</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_ord_to_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find position of n-th set bit in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ord</span></code></dt>
<dd>ordinal bit position (n-th set bit, n &gt;= 0)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the ordinal offset of bit <strong>ord</strong> in <strong>buf</strong> to its position in <strong>buf</strong>.
Value of <strong>ord</strong> should be in range 0 &lt;= <strong>ord</strong> &lt; weight(buf). If <strong>ord</strong>
&gt;= weight(buf), returns <strong>nbits</strong>.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>ord</strong>
values 0 through 3 will get mapped to 4 through 7, respectively,
and all other <strong>ord</strong> values returns <strong>nbits</strong>.  When <strong>ord</strong> value 3
gets mapped to (returns) <strong>pos</strong> value 7 in this example, that means
that the 3rd set bit (starting with 0th) is at position 7 in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>nbits</strong>-1 are valid positions in <strong>buf</strong>.</p>
</div>
<div class="section" id="command-line-parsing">
<h3>Command-line Parsing<a class="headerlink" href="#command-line-parsing" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.get_option">
int <code class="descname">get_option</code><span class="sig-paren">(</span>char **<em>&nbsp;str</em>, int *<em>&nbsp;pint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse integer from an option string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt>
<dd>option string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">pint</span></code></dt>
<dd>(output) integer value parsed from <strong>str</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read an int from an option string; if available accept a subsequent
comma as well.</p>
<p>Return values:
0 - no int in string
1 - int found, no subsequent comma
2 - int found including a subsequent comma
3 - hyphen found to denote a range</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_options">
char * <code class="descname">get_options</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em>, int<em>&nbsp;nints</em>, int *<em>&nbsp;ints</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a string into a list of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>String to be parsed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nints</span></code></dt>
<dd>size of integer array</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ints</span></code></dt>
<dd>integer array</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function parses a string containing a comma-separated
list of integers, a hyphen-separated range of _positive_ integers,
or a combination of both.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.</p>
<p>Return value is the character in the string which caused
the parse to end (typically a null terminator, if <strong>str</strong> is
completely parseable).</p>
</div></blockquote>
<dl class="function">
<dt id="c.memparse">
unsigned long long <code class="descname">memparse</code><span class="sig-paren">(</span>const char *<em>&nbsp;ptr</em>, char **<em>&nbsp;retptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memparse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string with mem suffixes into a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Where parse begins</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">retptr</span></code></dt>
<dd>(output) Optional pointer to next char after parse completes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Parses a string into a number.  The number stored at <strong>ptr</strong> is
potentially suffixed with K, M, G, T, P, E.</div></blockquote>
</div>
<div class="section" id="crc-functions">
<h3>CRC Functions<a class="headerlink" href="#crc-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.crc7_be">
u8 <code class="descname">crc7_be</code><span class="sig-paren">(</span>u8<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc7_be" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CRC7 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC7 value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Context</strong></p>
<p>any</p>
<p><strong>Description</strong></p>
<p>Returns the updated CRC7 value.
The CRC7 is left-aligned in the byte (the lsbit is always 0), as that
makes the computation easier, and all callers want it in that form.</p>
<dl class="function">
<dt id="c.crc16">
u16 <code class="descname">crc16</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the CRC-16 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value.</p>
<dl class="function">
<dt id="c.crc_itu_t">
u16 <code class="descname">crc_itu_t</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_itu_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the CRC-ITU-T for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value</p>
<dl class="function">
<dt id="c.crc32_le_generic">
u32 __pure <code class="descname">crc32_le_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_le_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise little-endian Ethernet AUTODIN II CRC32/CRC32C</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for other
uses, or the previous crc32/crc32c value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32/CRC32C is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>little-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32/CRC32c LE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc32_generic_shift">
u32 __attribute_const__ <code class="descname">crc32_generic_shift</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, size_t<em>&nbsp;len</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_generic_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Append len 0 bytes to crc, in logarithmic time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>The original little-endian CRC (i.e. lsbit is x^31 coefficient)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The number of bytes. <strong>crc</strong> is multiplied by x^(8***len**)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>The modulus used to reduce the result to 32 bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible to parallelize CRC computations by computing a CRC
over separate ranges of a buffer, then summing them.
This shifts the given CRC by 8*len bits (i.e. produces the same effect
as appending len bytes of zero to the data), in time proportional
to log(len).</p>
<dl class="function">
<dt id="c.crc32_be_generic">
u32 __pure <code class="descname">crc32_be_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_be_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise big-endian Ethernet AUTODIN II CRC32</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32 is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>big-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32 BE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt">
u16 <code class="descname">crc_ccitt</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
</div>
<div class="section" id="idr-ida-functions">
<h3>idr/ida Functions<a class="headerlink" href="#idr-ida-functions" title="Permalink to this headline">¶</a></h3>
<p>idr synchronization (stolen from radix-tree.h)</p>
<p><code class="xref c c-func docutils literal"><span class="pre">idr_find()</span></code> is able to be called locklessly, using RCU. The caller must
ensure calls to this function are made within <code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code> regions.
Other readers (lock-free or otherwise) and modifications may be running
concurrently.</p>
<p>It is still required that the caller manage the synchronization and
lifetimes of the items. So if RCU lock-free lookups are used, typically
this would mean that the items have their own locks, or are amenable to
lock-free access; and that the items are freed by RCU (or only freed after
having been deleted from the idr tree <em>and</em> a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> grace
period).</p>
<p>The IDA is an ID allocator which does not provide the ability to
associate an ID with a pointer.  As such, it only needs to store one
bit per ID, and so is more space efficient than an IDR.  To use an IDA,
define it using <code class="xref c c-func docutils literal"><span class="pre">DEFINE_IDA()</span></code> (or embed a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">ida</span></code> in a data structure,
then initialise it using <code class="xref c c-func docutils literal"><span class="pre">ida_init()</span></code>).  To allocate a new ID, call
<a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a>.  To free an ID, call <a class="reference internal" href="#c.ida_simple_remove" title="ida_simple_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_remove()</span></code></a>.</p>
<p>If you have more complex locking requirements, use a loop around
<code class="xref c c-func docutils literal"><span class="pre">ida_pre_get()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> to allocate a new ID.  Then use
<a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> to free an ID.  You must make sure that <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> and
<a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> cannot be called at the same time as each other for the
same IDA.</p>
<p>You can also use <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> if you need an ID to be allocated
above a particular number.  <a class="reference internal" href="#c.ida_destroy" title="ida_destroy"><code class="xref c c-func docutils literal"><span class="pre">ida_destroy()</span></code></a> can be used to dispose of an
IDA without needing to free the individual IDs in it.  You can use
<code class="xref c c-func docutils literal"><span class="pre">ida_is_empty()</span></code> to find out whether the IDA has any IDs currently allocated.</p>
<p>IDs are currently limited to the range [0-INT_MAX].  If this is an awkward
limitation, it should be quite straightforward to raise the maximum.</p>
<dl class="function">
<dt id="c.idr_alloc">
int <code class="descname">idr_alloc</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;start</em>, int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>pointer to be associated with the new id</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>the minimum id (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>the maximum id (exclusive)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range [start, end).  Returns -ENOSPC
if there are no unused IDs in that range.</p>
<p>Note that <strong>end</strong> is treated as max when &lt;= 0.  This is to always allow
using <strong>start</strong> + N as <strong>end</strong> as long as N is inside integer range.</p>
<p>Simultaneous modifications to the <strong>idr</strong> are not allowed and should be
prevented by the user, usually with a lock.  <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal"><span class="pre">idr_alloc()</span></code></a> may be called
concurrently with read-only accesses to the <strong>idr</strong>, such as <code class="xref c c-func docutils literal"><span class="pre">idr_find()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">idr_for_each_entry()</span></code>.</p>
<dl class="function">
<dt id="c.idr_alloc_cyclic">
int <code class="descname">idr_alloc_cyclic</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;start</em>, int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate new idr entry in a cyclical fashion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>pointer to be associated with the new id</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>the minimum id (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>the maximum id (exclusive)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an ID larger than the last ID allocated if one is available.
If not, it will attempt to allocate the smallest ID that is larger or
equal to <strong>start</strong>.</p>
<dl class="function">
<dt id="c.idr_for_each">
int <code class="descname">idr_for_each</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em>, int (*fn) (int<em>&nbsp;id</em>, void<em>&nbsp;*p</em>, void<em>&nbsp;*data</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through all stored pointers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(int</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*p,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each pointer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data passed to callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be called for each entry in <strong>idr</strong>, passing
the id, the pointer and the data pointer passed to this function.</p>
<p>If <strong>fn</strong> returns anything other than <code class="docutils literal"><span class="pre">0</span></code>, the iteration stops and that
value is returned from this function.</p>
<p><a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal"><span class="pre">idr_for_each()</span></code></a> can be called concurrently with <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal"><span class="pre">idr_alloc()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">idr_remove()</span></code> if protected by RCU.  Newly added entries may not be
seen and deleted entries may be seen, but adding and removing entries
will not cause other entries to be skipped, nor spurious ones to be seen.</p>
<dl class="function">
<dt id="c.idr_get_next">
void * <code class="descname">idr_get_next</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, int *<em>&nbsp;nextid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Find next populated entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">nextid</span></code></dt>
<dd>Pointer to lowest possible ID to return</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
<dl class="function">
<dt id="c.idr_replace">
void * <code class="descname">idr_replace</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace pointer for given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>New pointer to associate with the ID</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>Lookup key</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace the pointer registered with an ID and return the old value.
This function can be called under the RCU read lock concurrently with
<a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal"><span class="pre">idr_alloc()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">idr_remove()</span></code> (as long as the ID being removed is not
the one being replaced!).</p>
<p><strong>Return</strong></p>
<p>0 on success.  <code class="docutils literal"><span class="pre">-ENOENT</span></code> indicates that <strong>id</strong> was not found.
<code class="docutils literal"><span class="pre">-EINVAL</span></code> indicates that <strong>id</strong> or <strong>ptr</strong> were not valid.</p>
<dl class="function">
<dt id="c.ida_get_new_above">
int <code class="descname">ida_get_new_above</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, int<em>&nbsp;start</em>, int *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_get_new_above" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate new ID above or equal to a start id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>id to start search at</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to the allocated handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate new ID above or equal to <strong>start</strong>.  It should be called
with any required locks to ensure that concurrent calls to
<a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> / <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> / <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> are not allowed.
Consider using <a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a> if you do not have complex locking
requirements.</p>
<p>If memory is required, it will return <code class="docutils literal"><span class="pre">-EAGAIN</span></code>, you should unlock
and go back to the <code class="xref c c-func docutils literal"><span class="pre">ida_pre_get()</span></code> call.  If the ida is full, it will
return <code class="docutils literal"><span class="pre">-ENOSPC</span></code>.  On success, it will return 0.</p>
<p><strong>id</strong> returns a value in the range <strong>start</strong> ... <code class="docutils literal"><span class="pre">0x7fffffff</span></code>.</p>
<dl class="function">
<dt id="c.ida_remove">
void <code class="descname">ida_remove</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the given ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ID to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be called at the same time as <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a>.</p>
<dl class="function">
<dt id="c.ida_destroy">
void <code class="descname">ida_destroy</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the contents of an ida</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function releases all resources associated with an IDA.  When
this call returns, the IDA is empty and can be reused or freed.  The caller
should not allow <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> or <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> to be called at the
same time.</p>
<dl class="function">
<dt id="c.ida_simple_get">
int <code class="descname">ida_simple_get</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;start</em>, unsigned int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_simple_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new id.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>the (initialized) ida.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>the minimum id (inclusive, &lt; 0x8000000)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>the maximum id (exclusive, &lt; 0x8000000 or 0)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an id in the range start &lt;= id &lt; end, or returns -ENOSPC.
On memory allocation failure, returns -ENOMEM.</p>
<p>Compared to <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> this function does its own locking, and
should be used unless there are special requirements.</p>
<p>Use <a class="reference internal" href="#c.ida_simple_remove" title="ida_simple_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_remove()</span></code></a> to get rid of an id.</p>
<dl class="function">
<dt id="c.ida_simple_remove">
void <code class="descname">ida_simple_remove</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_simple_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an allocated id.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>the (initialized) ida.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>the id returned by ida_simple_get.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use to release an id allocated with <a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a>.</p>
<p>Compared to <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> this function does its own locking, and should be
used unless there are special requirements.</p>
</div>
</div>
<div class="section" id="memory-management-in-linux">
<h2>Memory Management in Linux<a class="headerlink" href="#memory-management-in-linux" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-slab-cache">
<h3>The Slab Cache<a class="headerlink" href="#the-slab-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.kmalloc">
void * <code class="descname">kmalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate.</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc is the normal method of allocating memory
for objects smaller than page size in the kernel.</p>
<p>The <strong>flags</strong> argument may be one of:</p>
<p><code class="docutils literal"><span class="pre">GFP_USER</span></code> - Allocate memory on behalf of user.  May sleep.</p>
<p><code class="docutils literal"><span class="pre">GFP_KERNEL</span></code> - Allocate normal kernel ram.  May sleep.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> - Allocation will not sleep.  May use emergency pools.</dt>
<dd>For example, use this inside interrupt handlers.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">GFP_HIGHUSER</span></code> - Allocate pages from high memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOIO</span></code> - Do not do any I/O at all while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOFS</span></code> - Do not make any fs calls while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOWAIT</span></code> - Allocation will not sleep.</p>
<p><code class="docutils literal"><span class="pre">__GFP_THISNODE</span></code> - Allocate node-local memory only.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_DMA</span></code> - Allocation suitable for DMA.</dt>
<dd>Should only be used for <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> caches. Otherwise, use a
slab created with SLAB_DMA.</dd>
</dl>
<p>Also it is possible to set different flags by OR&#8217;ing
in one or more of the following additional <strong>flags</strong>:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_COLD</span></code> - Request cache-cold pages instead of</dt>
<dd>trying to return cache-warm pages.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">__GFP_HIGH</span></code> - This allocation has high priority and may use emergency pools.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_NOFAIL</span></code> - Indicate that this allocation is in no way allowed to fail</dt>
<dd>(think twice before using).</dd>
<dt><code class="docutils literal"><span class="pre">__GFP_NORETRY</span></code> - If memory is not immediately available,</dt>
<dd>then give up at once.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">__GFP_NOWARN</span></code> - If allocation fails, don&#8217;t issue any warnings.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_RETRY_MAYFAIL</span></code> - Try really hard to succeed the allocation but fail</dt>
<dd>eventually.</dd>
</dl>
<p>There are other flags available as well, but these are not intended
for general use, and so are not documented here. For a full list of
potential flags, always refer to linux/gfp.h.</p>
<dl class="function">
<dt id="c.kmalloc_array">
void * <code class="descname">kmalloc_array</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_array" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kcalloc">
void * <code class="descname">kcalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kcalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc">
void * <code class="descname">kzalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc_node">
void * <code class="descname">kzalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed memory from a particular memory node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>memory node from which to allocate</dd>
</dl>
<dl class="function">
<dt id="c.kmem_cache_alloc">
void * <code class="descname">kmem_cache_alloc</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an object from this cache.  The flags are only relevant
if the cache has no available objects.</p>
<dl class="function">
<dt id="c.kmem_cache_alloc_node">
void * <code class="descname">kmem_cache_alloc_node</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;nodeid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object on the specified node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nodeid</span></code></dt>
<dd>node number of the target node.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identical to kmem_cache_alloc but it will allocate memory on the given
node, which can improve the performance for cpu bound structures.</p>
<p>Fallback to other node is possible if __GFP_THISNODE is not set.</p>
<dl class="function">
<dt id="c.kmem_cache_free">
void <code class="descname">kmem_cache_free</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache the allocation was from.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>The previously allocated object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free an object which was previously allocated from this
cache.</p>
<dl class="function">
<dt id="c.kfree">
void <code class="descname">kfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree" title="Permalink to this definition">¶</a></dt>
<dd><p>free previously allocated memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>pointer returned by kmalloc.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>objp</strong> is NULL, no operation is performed.</p>
<p>Don&#8217;t free memory not originally allocated by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>
or you will run into trouble.</p>
<dl class="function">
<dt id="c.ksize">
size_t <code class="descname">ksize</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ksize" title="Permalink to this definition">¶</a></dt>
<dd><p>get the actual amount of memory allocated for a given object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>Pointer to the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc may internally round up allocations and return more memory
than requested. <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal"><span class="pre">ksize()</span></code></a> can be used to determine the actual amount of
memory allocated. The caller may use this additional memory, even though
a smaller amount of memory was initially specified with the kmalloc call.
The caller must guarantee that objp points to a valid object previously
allocated with either <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal"><span class="pre">kmem_cache_alloc()</span></code></a>. The object
must not be freed during the duration of the call.</p>
<dl class="function">
<dt id="c.kfree_const">
void <code class="descname">kfree_const</code><span class="sig-paren">(</span>const void *<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">x</span></code></dt>
<dd>pointer to the memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function calls kfree only if <strong>x</strong> is not in .rodata section.</p>
<dl class="function">
<dt id="c.kstrdup">
char * <code class="descname">kstrdup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.kstrdup_const">
const char * <code class="descname">kstrdup_const</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally duplicate an existing const string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns source string if it is in .rodata section otherwise it
fallbacks to kstrdup.
Strings allocated by kstrdup_const should be freed by kfree_const.</p>
<dl class="function">
<dt id="c.kstrndup">
char * <code class="descname">kstrndup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrndup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>read at most <strong>max</strong> chars from <strong>s</strong></dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Note</strong></p>
<p>Use <a class="reference internal" href="#c.kmemdup_nul" title="kmemdup_nul"><code class="xref c c-func docutils literal"><span class="pre">kmemdup_nul()</span></code></a> instead if the size is known exactly.</p>
<dl class="function">
<dt id="c.kmemdup">
void * <code class="descname">kmemdup</code><span class="sig-paren">(</span>const void *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate region of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>memory region to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>memory region length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP mask to use</dd>
</dl>
<dl class="function">
<dt id="c.kmemdup_nul">
char * <code class="descname">kmemdup_nul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a NUL-terminated string from unterminated data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The data to stringify</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The size of the data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.memdup_user">
void * <code class="descname">memdup_user</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.</p>
<dl class="function">
<dt id="c.memdup_user_nul">
void * <code class="descname">memdup_user_nul</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space and NUL-terminate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.</p>
<dl class="function">
<dt id="c.get_user_pages_fast">
int <code class="descname">get_user_pages_fast</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, int<em>&nbsp;nr_pages</em>, int<em>&nbsp;write</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user_pages_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>pin user pages in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>starting user address</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>number of pages from start to pin</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd>whether pages will be written to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array that receives pointers to the pages pinned.
Should be at least nr_pages long.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of pages pinned. This may be fewer than the number
requested. If nr_pages is 0 or negative, returns 0. If no pages
were pinned, returns -errno.</p>
<p>get_user_pages_fast provides equivalent functionality to get_user_pages,
operating on current and current-&gt;mm, with force=0 and vma=NULL. However
unlike get_user_pages, it must be called without mmap_sem held.</p>
<p>get_user_pages_fast may take mmap_sem and page table locks, so no
assumptions can be made about lack of locking. get_user_pages_fast is to be
implemented in a way that is advantageous (vs <code class="xref c c-func docutils literal"><span class="pre">get_user_pages()</span></code>) when the
user memory area is already faulted in and present in ptes. However if the
pages have to be faulted in, it may turn out to be slightly slower so
callers need to carefully consider what to use. On many architectures,
get_user_pages_fast simply falls back to get_user_pages.</p>
<dl class="function">
<dt id="c.kvmalloc_node">
void * <code class="descname">kvmalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kvmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the request.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses kmalloc to get the memory but if the allocation fails then falls back
to the vmalloc allocator. Use kvfree for freeing the memory.</p>
<p>Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.
__GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is
preferable to the vmalloc fallback, due to visible performance drawbacks.</p>
<p>Any use of gfp flags outside of GFP_KERNEL should be consulted with mm people.</p>
</div>
<div class="section" id="user-space-memory-access">
<h3>User Space Memory Access<a class="headerlink" href="#user-space-memory-access" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.access_ok">
<code class="descname">access_ok</code><span class="sig-paren">(</span><em>type</em>, <em>addr</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.access_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a user space pointer is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of access: <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> or <code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code>.  Note that
<code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code> is a superset of <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> - if it is safe
to write to a block, it is always safe to read from it.</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>User space pointer to start of block to check</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of block to check</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>Checks if a pointer to a block of memory in user space is valid.</p>
<p>Returns true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.</p>
<p>Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.</p>
<dl class="function">
<dt id="c.get_user">
<code class="descname">get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.put_user">
<code class="descname">put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.__get_user">
<code class="descname">__get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.__put_user">
<code class="descname">__put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.clear_user">
unsigned long <code class="descname">clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="function">
<dt id="c.__clear_user">
unsigned long <code class="descname">__clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.  Caller must check
the specified block with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this function.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
</div>
<div class="section" id="more-memory-management-functions">
<h3>More Memory Management Functions<a class="headerlink" href="#more-memory-management-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.read_cache_pages">
int <code class="descname">read_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct list_head *<em>&nbsp;pages</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>populate an address space with some pages &amp; start reads against them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>callback routine for filling a single page.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data for the callback routine.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hides the details of the LRU cache etc from the filesystems.</p>
<dl class="function">
<dt id="c.page_cache_sync_readahead">
void <code class="descname">page_cache_sync_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_sync_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>generic file readahead</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_sync_readahead()</span></code></a> should be called when a cache miss happened:
it will submit the read.  The readahead logic may decide to piggyback more
pages onto the read request if access patterns suggest it will improve
performance.</p>
<dl class="function">
<dt id="c.page_cache_async_readahead">
void <code class="descname">page_cache_async_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, struct page *<em>&nbsp;page</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_async_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>file readahead for marked pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page at <strong>offset</strong> which has the PG_readahead flag set</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_async_readahead()</span></code></a> should be called when a page is used which
has the PG_readahead flag; this is a marker to suggest that the application
has used up enough of the readahead window that we should start pulling in
more pages.</p>
<dl class="function">
<dt id="c.delete_from_page_cache">
void <code class="descname">delete_from_page_cache</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.delete_from_page_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>delete page from page cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to remove from page cache</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called only on pages that have been verified to be in the page
cache and locked.  It will never put the page into the free list, the caller
has a reference on the page.</p>
<dl class="function">
<dt id="c.filemap_flush">
int <code class="descname">filemap_flush</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>mostly a non-blocking flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>target address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a mostly non-blocking flush.  Not suitable for data-integrity
purposes - I/O may not be started against all dirty pages.</p>
<dl class="function">
<dt id="c.filemap_range_has_page">
bool <code class="descname">filemap_range_has_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_has_page" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a page exists in range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space within which to check</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_range">
int <code class="descname">filemap_fdatawait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
in the given range and wait for all of them.  Check error status of
the address space and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_keep_errors">
int <code class="descname">filemap_fdatawait_keep_errors</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_keep_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback without clearing errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Unlike <a class="reference internal" href="#c.filemap_fdatawait" title="filemap_fdatawait"><code class="xref c c-func docutils literal"><span class="pre">filemap_fdatawait()</span></code></a>, this function
does not clear error status of the address space.</p>
<p>Use this function if callers don&#8217;t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<dl class="function">
<dt id="c.filemap_fdatawait">
int <code class="descname">filemap_fdatawait</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for all under-writeback pages to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Check error status of the address space
and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.filemap_write_and_wait_range">
int <code class="descname">filemap_write_and_wait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space for the pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<dl class="function">
<dt id="c.file_check_and_advance_wb_err">
int <code class="descname">file_check_and_advance_wb_err</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_check_and_advance_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report wb error (if any) that was previously and advance wb_err to current one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>struct file on which the error is being reported</dd>
</dl>
<p><strong>Description</strong></p>
<p>When userland calls fsync (or something like nfsd does the equivalent), we
want to report any writeback errors that occurred since the last fsync (or
since the file was opened if there haven&#8217;t been any).</p>
<p>Grab the wb_err from the mapping. If it matches what we have in the file,
then just quickly return 0. The file is all caught up.</p>
<p>If it doesn&#8217;t match, then take the mapping value, set the &#8220;seen&#8221; flag in
it and try to swap it into place. If it works, or another task beat us
to it with the new value, then update the f_wb_err and return the error
portion. The error at this point must be reported via proper channels
(a&#8217;la fsync, or NFS COMMIT operation, etc.).</p>
<p>While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
value is protected by the f_lock since we must ensure that it reflects
the latest value swapped in for this file descriptor.</p>
<dl class="function">
<dt id="c.file_write_and_wait_range">
int <code class="descname">file_write_and_wait_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file pointing to address_space with pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p>After writing out and waiting on the data, we check and advance the
f_wb_err cursor to the latest value, and return any errors detected there.</p>
<dl class="function">
<dt id="c.replace_page_cache_page">
int <code class="descname">replace_page_cache_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;old</em>, struct page *<em>&nbsp;new</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.replace_page_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>replace a pagecache page with a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>page to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>page to replace with</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function replaces a page in the pagecache with a new one.  On
success it acquires the pagecache reference for the new page and
drops it for the old page.  Both the old and new pages must be
locked.  This function does not add the new page to the LRU, the
caller must do that.</p>
<p>The remove + add is atomic.  The only way this function can fail is
memory allocation failure.</p>
<dl class="function">
<dt id="c.add_to_page_cache_locked">
int <code class="descname">add_to_page_cache_locked</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_to_page_cache_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>add a locked page to the pagecache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>page allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to add a page to the pagecache. It must be locked.
This function does not add the page to the LRU.  The caller must do that.</p>
<dl class="function">
<dt id="c.add_page_wait_queue">
void <code class="descname">add_page_wait_queue</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, wait_queue_entry_t *<em>&nbsp;waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_page_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an arbitrary waiter to a page&#8217;s wait queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>Page defining the wait queue of interest</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue_entry_t</span> <span class="pre">*</span> <span class="pre">waiter</span></code></dt>
<dd>Waiter to add to the queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an arbitrary <strong>waiter</strong> to the wait queue for the nominated <strong>page</strong>.</p>
<dl class="function">
<dt id="c.unlock_page">
void <code class="descname">unlock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a locked page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the page and wakes up sleepers in <code class="xref c c-func docutils literal"><span class="pre">___wait_on_page_locked()</span></code>.
Also wakes sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> because the wakeup
mechanism between PageLocked pages and PageWriteback pages is shared.
But that&#8217;s OK - sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> just go back to sleep.</p>
<p>Note that this depends on PG_waiters being the sign bit in the byte
that contains PG_locked - thus the <code class="xref c c-func docutils literal"><span class="pre">BUILD_BUG_ON()</span></code>. That allows us to
clear the PG_locked bit and test PG_waiters at the same time fairly
portably (architectures that do LL/SC can test any bit, while x86 can
test the sign bit).</p>
<dl class="function">
<dt id="c.end_page_writeback">
void <code class="descname">end_page_writeback</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.end_page_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>end writeback against a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<dl class="function">
<dt id="c.__lock_page">
void <code class="descname">__lock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;__page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__lock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>get a lock on the page, assuming we need to sleep to get it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">__page</span></code></dt>
<dd>the page to lock</dd>
</dl>
<dl class="function">
<dt id="c.page_cache_next_hole">
pgoff_t <code class="descname">page_cache_next_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_next_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the set [index, min(index+max_scan-1, MAX_INDEX)] for the
lowest indexed hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case &#8216;return - index &gt;=
max_scan&#8217; will be true). In rare cases of index wrap-around, 0 will
be returned.</p>
<p>page_cache_next_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 5, then subsequently a hole is created at
index 10, page_cache_next_hole covering both indexes may return 10
if called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.page_cache_prev_hole">
pgoff_t <code class="descname">page_cache_prev_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_prev_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the prev hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search backwards in the range [max(index-max_scan+1, 0), index] for
the first hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case &#8216;index - return &gt;=
max_scan&#8217; will be true). In rare cases of wrap-around, ULONG_MAX
will be returned.</p>
<p>page_cache_prev_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 10, then subsequently a hole is created at
index 5, page_cache_prev_hole covering both indexes may return 5 if
called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.find_get_entry">
struct page * <code class="descname">find_get_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned with an increased refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.find_lock_entry">
struct page * <code class="descname">find_lock_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_lock_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>locate, pin and lock a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<p><a class="reference internal" href="#c.find_lock_entry" title="find_lock_entry"><code class="xref c c-func docutils literal"><span class="pre">find_lock_entry()</span></code></a> may sleep.</p>
<dl class="function">
<dt id="c.pagecache_get_page">
struct page * <code class="descname">pagecache_get_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, int<em>&nbsp;fgp_flags</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fgp_flags</span></code></dt>
<dd>PCG flags</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>gfp mask to use for the page cache data page allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.</p>
<p>PCG flags modify how the page is returned.</p>
<p><strong>fgp_flags</strong> can be:</p>
<ul class="simple">
<li>FGP_ACCESSED: the page will be marked accessed</li>
<li>FGP_LOCK: Page is return locked</li>
<li>FGP_CREAT: If page is not present then a new page is allocated using
<strong>gfp_mask</strong> and added to the page cache and the VM&#8217;s LRU
list. The page is returned locked and with an increased
refcount. Otherwise, NULL is returned.</li>
</ul>
<p>If FGP_LOCK or FGP_CREAT are specified then the function may sleep even
if the GFP flags specified for FGP_CREAT are atomic.</p>
<p>If there is a page cache page, it is returned with an increased refcount.</p>
<dl class="function">
<dt id="c.find_get_pages_contig">
unsigned <code class="descname">find_get_pages_contig</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_contig" title="Permalink to this definition">¶</a></dt>
<dd><p>gang contiguous pagecache lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>The address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>The starting page index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>The maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>Where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> works exactly like <code class="xref c c-func docutils literal"><span class="pre">find_get_pages()</span></code>, except
that the returned number of pages are guaranteed to be contiguous.</p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> returns the number of pages which were found.</p>
<dl class="function">
<dt id="c.find_get_pages_tag">
unsigned <code class="descname">find_get_pages_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t *<em>&nbsp;index</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return pages that match <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">index</span></code></dt>
<dd>the starting page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>the maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_pages, except we only return pages which are tagged with
<strong>tag</strong>.   We update <strong>index</strong> to index the next page for the traversal.</p>
<dl class="function">
<dt id="c.find_get_entries_tag">
unsigned <code class="descname">find_get_entries_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_entries</em>, struct page **<em>&nbsp;entries</em>, pgoff_t *<em>&nbsp;indices</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entries_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return entries that match <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the starting page cache index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_entries</span></code></dt>
<dd>the maximum number of entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">entries</span></code></dt>
<dd>where the resulting entries are placed</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">indices</span></code></dt>
<dd>the cache indices corresponding to the entries in <strong>entries</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_entries, except we only return entries which are tagged with
<strong>tag</strong>.</p>
<dl class="function">
<dt id="c.generic_file_read_iter">
ssize_t <code class="descname">generic_file_read_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_read_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>generic filesystem read routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>kernel I/O control block</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>destination for the data read</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the &#8220;<code class="xref c c-func docutils literal"><span class="pre">read_iter()</span></code>&#8221; routine for all filesystems
that can use the page cache directly.</p>
<dl class="function">
<dt id="c.filemap_fault">
int <code class="descname">filemap_fault</code><span class="sig-paren">(</span>struct vm_fault *<em>&nbsp;vmf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>read in file data for page fault handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*</span> <span class="pre">vmf</span></code></dt>
<dd>struct vm_fault containing details of the fault</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal"><span class="pre">filemap_fault()</span></code></a> is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.</p>
<p>The goto&#8217;s are kind of ugly, but this streamlines the normal case of having
it in the page cache, and handles the special cases reasonably without
having a lot of duplicated code.</p>
<p>vma-&gt;vm_mm-&gt;mmap_sem must be held on entry.</p>
<p>If our return value has VM_FAULT_RETRY set, it&#8217;s because
<code class="xref c c-func docutils literal"><span class="pre">lock_page_or_retry()</span></code> returned 0.
The mmap_sem has usually been released in this case.
See <code class="xref c c-func docutils literal"><span class="pre">__lock_page_or_retry()</span></code> for the exception.</p>
<p>If our return value does not have VM_FAULT_RETRY set, the mmap_sem
has not been released.</p>
<p>We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.</p>
<dl class="function">
<dt id="c.read_cache_page">
struct page * <code class="descname">read_cache_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, fill it if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>function to perform the read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>first arg to filler(data, page) function, often left as NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read into the page cache. If a page already exists, and <code class="xref c c-func docutils literal"><span class="pre">PageUptodate()</span></code> is
not set, try to fill the page and wait for it to become unlocked.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.read_cache_page_gfp">
struct page * <code class="descname">read_cache_page_gfp</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the page allocator flags to use if allocating</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as &#8220;read_mapping_page(mapping, index, NULL)&#8221;, but with
any new page allocations done using the specified allocation flags.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.__generic_file_write_iter">
ssize_t <code class="descname">__generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure (file, offset, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the work needed for actually writing data to a
file. It does all basic checks, removes SUID from the file, updates
modification times and calls proper subroutines depending on whether we
do direct IO or a standard buffered write.</p>
<p>It expects i_mutex to be grabbed unless we work on a block device or similar
object which does not need locking at all.</p>
<p>This function does <em>not</em> take care of syncing data in case of O_SYNC write.
A caller has to handle it. This is mainly due to the fact that we want to
avoid syncing under i_mutex.</p>
<dl class="function">
<dt id="c.generic_file_write_iter">
ssize_t <code class="descname">generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.__generic_file_write_iter" title="__generic_file_write_iter"><code class="xref c c-func docutils literal"><span class="pre">__generic_file_write_iter()</span></code></a> to be used by most
filesystems. It takes care of syncing the file in case of O_SYNC file
and acquires i_mutex as needed.</p>
<dl class="function">
<dt id="c.try_to_release_page">
int <code class="descname">try_to_release_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_release_page" title="Permalink to this definition">¶</a></dt>
<dd><p>release old fs-specific metadata on a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to free</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (and I/O mode)</dd>
</dl>
<p><strong>Description</strong></p>
<p>The address_space is to try to release any data against the page
(presumably at page-&gt;private).  If the release was successful, return &#8216;1&#8217;.
Otherwise return zero.</p>
<p>This may also be called if PG_fscache is set on a page, indicating that the
page is known to the local caching routines.</p>
<p>The <strong>gfp_mask</strong> argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM &amp; __GFP_FS).</p>
<dl class="function">
<dt id="c.zap_vma_ptes">
int <code class="descname">zap_vma_ptes</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zap_vma_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ptes mapping the vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct holding ptes to be zapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>starting address of pages to zap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to zap</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only unmaps ptes assigned to VM_PFNMAP vmas.</p>
<p>The entire address range must be fully contained within the vma.</p>
<p>Returns 0 if successful.</p>
<dl class="function">
<dt id="c.vm_insert_page">
int <code class="descname">vm_insert_page</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_page" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single page into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>source kernel page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows drivers to insert individual pages they&#8217;ve allocated
into a user vma.</p>
<p>The page has to be a nice clean _individual_ kernel allocation.
If you allocate a compound page, you need to have marked it as
such (__GFP_COMP), or manually just split the page up yourself
(see <code class="xref c c-func docutils literal"><span class="pre">split_page()</span></code>).</p>
<p>NOTE! Traditionally this was done with &#8220;<a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a>&#8221; which
took an arbitrary page protection parameter. This doesn&#8217;t allow
that. Your vma protection will have to be set up correctly, which
means that if you want a shared writable mapping, you&#8217;d better
ask for a shared writable mapping!</p>
<p>The page does not need to be reserved.</p>
<p>Usually this function is called from f_op-&gt;:c:func:<cite>mmap()</cite> handler
under mm-&gt;mmap_sem write-lock, so it can change vma-&gt;vm_flags.
Caller must set VM_MIXEDMAP on vma if it wants to call this
function from other places, for example from page-fault handler.</p>
<dl class="function">
<dt id="c.vm_insert_pfn">
int <code class="descname">vm_insert_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to vm_insert_page, this allows drivers to insert individual pages
they&#8217;ve allocated into a user vma. Same comments apply.</p>
<p>This function should only be called from a vm_ops-&gt;fault handler, and
in that case the handler should return NULL.</p>
<p>vma cannot be a COW mapping.</p>
<p>As this is called only for pages that do not currently exist, we
do not need to flush old virtual caches or the TLB.</p>
<dl class="function">
<dt id="c.vm_insert_pfn_prot">
int <code class="descname">vm_insert_pfn_prot</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, pgprot_t<em>&nbsp;pgprot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn_prot" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt>
<dd>pgprot flags for the inserted page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like vm_insert_pfn, except that it allows drivers to
to override pgprot on a per-page basis.</p>
<p>This only makes sense for IO mappings, and it makes no sense for
cow mappings.  In general, using multiple vmas is preferable;
vm_insert_pfn_prot should only be used if using multiple VMAs is
impractical.</p>
<dl class="function">
<dt id="c.remap_pfn_range">
int <code class="descname">remap_pfn_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;size</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_pfn_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remap kernel memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>physical address of kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection flags for this mapping</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
<dl class="function">
<dt id="c.vm_iomap_memory">
int <code class="descname">vm_iomap_memory</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, phys_addr_t<em>&nbsp;start</em>, unsigned long<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_iomap_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>remap memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">start</span></code></dt>
<dd>start of area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt>
<dd>size of area</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified <code class="xref c c-func docutils literal"><span class="pre">io_remap_pfn_range()</span></code> for common driver use. The
driver just needs to give us the physical memory range to be mapped,
we&#8217;ll figure out the rest from the vma information.</p>
<p>NOTE! Some drivers might want to tweak vma-&gt;vm_page_prot first to get
whatever write-combining details or similar.</p>
<dl class="function">
<dt id="c.unmap_mapping_range">
void <code class="descname">unmap_mapping_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t const<em>&nbsp;holebegin</em>, loff_t const<em>&nbsp;holelen</em>, int<em>&nbsp;even_cows</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap the portion of all mmaps in the specified address_space corresponding to the specified page range in the underlying file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address space containing mmaps to be unmapped.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holebegin</span></code></dt>
<dd>byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from <a class="reference internal" href="#c.truncate_pagecache" title="truncate_pagecache"><code class="xref c c-func docutils literal"><span class="pre">truncate_pagecache()</span></code></a>, which
must keep the partial page.  In contrast, we must get rid of
partial pages.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holelen</span></code></dt>
<dd>size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">even_cows</span></code></dt>
<dd>1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don&#8217;t throw away private data.</dd>
</dl>
<dl class="function">
<dt id="c.follow_pfn">
int <code class="descname">follow_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>look up PFN at a user virtual address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>memory mapping</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>user virtual address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>location to store found PFN</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only IO mappings and raw PFN mappings are allowed.</p>
<p>Returns zero and the pfn at <strong>pfn</strong> on success, -ve otherwise.</p>
<dl class="function">
<dt id="c.vm_unmap_aliases">
void <code class="descname">vm_unmap_aliases</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap outstanding lazy aliases in the vmap layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
to amortize TLB flushing overheads. What this means is that any page you
have now, may, in a former life, have been mapped into kernel virtual
address by the vmap layer and so there might be some CPUs with TLB entries
still referencing that page (additional to the regular 1:1 kernel mapping).</p>
<p>vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
be sure that none of the pages we have control over will have any aliases
from the vmap layer.</p>
<dl class="function">
<dt id="c.vm_unmap_ram">
void <code class="descname">vm_unmap_ram</code><span class="sig-paren">(</span>const void *<em>&nbsp;mem</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap linear kernel address space set up by vm_map_ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">mem</span></code></dt>
<dd>the pointer returned by vm_map_ram</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the count passed to that vm_map_ram call (cannot unmap partial)</dd>
</dl>
<dl class="function">
<dt id="c.vm_map_ram">
void * <code class="descname">vm_map_ram</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, int<em>&nbsp;node</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>map pages linearly into kernel virtual address (vmalloc space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>an array of pointers to the pages to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>prefer to allocate data structures on this node</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>memory protection to use. PAGE_KERNEL for regular RAM</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you use this function for less than VMAP_MAX_ALLOC pages, it could be
faster than vmap so it&#8217;s good.  But if you mix long-life and short-life
objects with <a class="reference internal" href="#c.vm_map_ram" title="vm_map_ram"><code class="xref c c-func docutils literal"><span class="pre">vm_map_ram()</span></code></a>, it could consume lots of address space through
fragmentation (especially on a 32bit machine).  You could see failures in
the end.  Please use this function for short-lived objects.</p>
<p><strong>Return</strong></p>
<p>a pointer to the address that has been mapped, or <code class="docutils literal"><span class="pre">NULL</span></code> on failure</p>
<dl class="function">
<dt id="c.unmap_kernel_range_noflush">
void <code class="descname">unmap_kernel_range_noflush</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range_noflush" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap PFN_UP(<strong>size</strong>) pages at <strong>addr</strong>.  The VM area <strong>addr</strong> and <strong>size</strong>
specify should have been allocated using <code class="xref c c-func docutils literal"><span class="pre">get_vm_area()</span></code> and its
friends.</p>
<p><strong>NOTE</strong></p>
<p>This function does NOT do any cache flushing.  The caller is
responsible for calling <code class="xref c c-func docutils literal"><span class="pre">flush_cache_vunmap()</span></code> on to-be-mapped areas
before calling this function and <code class="xref c c-func docutils literal"><span class="pre">flush_tlb_kernel_range()</span></code> after.</p>
<dl class="function">
<dt id="c.unmap_kernel_range">
void <code class="descname">unmap_kernel_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area and flush cache and TLB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.unmap_kernel_range_noflush" title="unmap_kernel_range_noflush"><code class="xref c c-func docutils literal"><span class="pre">unmap_kernel_range_noflush()</span></code></a> but flushes vcache before
the unmapping and tlb after.</p>
<dl class="function">
<dt id="c.vfree">
void <code class="descname">vfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfree" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory allocated by <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually continuous memory area starting at <strong>addr</strong>, as
obtained from <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a>, <a class="reference internal" href="#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal"><span class="pre">vmalloc_32()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code>. If <strong>addr</strong> is
NULL, no operation is performed.</p>
<p>Must not be called in NMI context (strictly speaking, only if we don&#8217;t
have CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG, but making the calling
conventions for <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code></a> arch-depenedent would be a really bad idea)</p>
</div></blockquote>
<p><strong>NOTE</strong></p>
<p>assumes that the object at <strong>addr</strong> has a size &gt;= sizeof(llist_node)</p>
<dl class="function">
<dt id="c.vunmap">
void <code class="descname">vunmap</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>release virtual mapping obtained by <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually contiguous memory area starting at <strong>addr</strong>,
which was created from the page array passed to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a>.</p>
<p>Must not be called in interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vmap">
void * <code class="descname">vmap</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, unsigned long<em>&nbsp;flags</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an array of pages into virtually contiguous space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array of page pointers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages to map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>vm_area-&gt;flags</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection for the mapping</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Maps <strong>count</strong> pages from <strong>pages</strong> into contiguous kernel virtual
space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc">
void * <code class="descname">vmalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vzalloc">
void * <code class="descname">vzalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_user">
void * <code class="descname">vmalloc_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous memory for userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is zeroed so it can be mapped to userspace
without leaking data.</p>
<dl class="function">
<dt id="c.vmalloc_node">
void * <code class="descname">vmalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vzalloc_node">
void * <code class="descname">vzalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc_node()</span></code> instead.</p>
<dl class="function">
<dt id="c.vmalloc_32">
void * <code class="descname">vmalloc_32</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory (32bit addressable)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allocate enough 32bit PA addressable pages to cover <strong>size</strong> from the
page level allocator and map them into contiguous kernel virtual space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_32_user">
void * <code class="descname">vmalloc_32_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous 32bit memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is 32bit addressable and zeroed so it can be
mapped to userspace without leaking data.</p>
<dl class="function">
<dt id="c.remap_vmalloc_range_partial">
int <code class="descname">remap_vmalloc_range_partial</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;uaddr</em>, void *<em>&nbsp;kaddr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">uaddr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kaddr</span></code></dt>
<dd>virtual address of vmalloc kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that <strong>kaddr</strong> is a valid vmalloc&#8217;ed area,
and that it is big enough to cover the range starting at
<strong>uaddr</strong> in <strong>vma</strong>. Will return failure if that criteria isn&#8217;t
met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.remap_vmalloc_range">
int <code class="descname">remap_vmalloc_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, void *<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pgoff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover (map full range of vma)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>vmalloc memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>number of pages into addr before first page to map</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that addr is a valid vmalloc&#8217;ed area, and
that it is big enough to cover the vma. Will return failure if
that criteria isn&#8217;t met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.alloc_vm_area">
struct vm_struct * <code class="descname">alloc_vm_area</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, pte_t **<em>&nbsp;ptes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_vm_area" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a range of kernel address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the area</dd>
<dt><code class="docutils literal"><span class="pre">pte_t</span> <span class="pre">**</span> <span class="pre">ptes</span></code></dt>
<dd>returns the PTEs for the address space</dd>
</dl>
<p><strong>Return</strong></p>
<p>NULL on failure, vm_struct on success</p>
<blockquote>
<div><p>This function reserves a range of kernel address space, and
allocates pagetables to map that range.  No actual mappings
are created.</p>
<p>If <strong>ptes</strong> is non-NULL, pointers to the PTEs (in init_mm)
allocated for the VM area are returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__get_pfnblock_flags_mask">
unsigned long <code class="descname">__get_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the requested group of flags for the pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<p><strong>Return</strong></p>
<p>pageblock_bits flags</p>
<dl class="function">
<dt id="c.set_pfnblock_flags_mask">
void <code class="descname">set_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the requested group of flags for a pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>The flags to set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<dl class="function">
<dt id="c.alloc_pages_exact_nid">
void * <code class="descname">alloc_pages_exact_nid</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an exact number of physically-contiguous pages on a node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>the preferred node ID where memory should be allocated</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the number of bytes to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP flags for the allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <code class="xref c c-func docutils literal"><span class="pre">alloc_pages_exact()</span></code>, but try to allocate on node nid first before falling
back.</p>
<dl class="function">
<dt id="c.nr_free_zone_pages">
unsigned long <code class="descname">nr_free_zone_pages</code><span class="sig-paren">(</span>int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_zone_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>The zone index of the highest zone</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_zone_pages" title="nr_free_zone_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_zone_pages()</span></code></a> counts the number of counts pages which are beyond the
high watermark within all zones at or below a given zone index.  For each
zone, the number of pages is calculated as:</p>
<blockquote>
<div>nr_free_zone_pages = managed_pages - high_pages</div></blockquote>
<dl class="function">
<dt id="c.nr_free_pagecache_pages">
unsigned long <code class="descname">nr_free_pagecache_pages</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_pagecache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_pagecache_pages" title="nr_free_pagecache_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_pagecache_pages()</span></code></a> counts the number of pages which are beyond the
high watermark within all zones.</p>
<dl class="function">
<dt id="c.find_next_best_node">
int <code class="descname">find_next_best_node</code><span class="sig-paren">(</span>int<em>&nbsp;node</em>, nodemask_t *<em>&nbsp;used_node_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_best_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next node that should appear in a given node&#8217;s fallback list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>node whose fallback list we&#8217;re appending</dd>
<dt><code class="docutils literal"><span class="pre">nodemask_t</span> <span class="pre">*</span> <span class="pre">used_node_mask</span></code></dt>
<dd>nodemask_t of already used nodes</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use a number of factors to determine which is the next node that should
appear on a given node&#8217;s fallback list.  The node should not have appeared
already in <strong>node</strong>&#8216;s fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they&#8217;ll have very little allocation pressure
on them otherwise.
It returns -1 if no node is found.</p>
<dl class="function">
<dt id="c.free_bootmem_with_active_regions">
void <code class="descname">free_bootmem_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, unsigned long<em>&nbsp;max_low_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memblock_free_early_nid for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to free memory on. If MAX_NUMNODES, all nodes are freed.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_low_pfn</span></code></dt>
<dd>The highest PFN that will be passed to memblock_free_early_nid</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes
and may be freed, this this function may be used instead of calling
<code class="xref c c-func docutils literal"><span class="pre">memblock_free_early_nid()</span></code> manually.</p>
<dl class="function">
<dt id="c.sparse_memory_present_with_active_regions">
void <code class="descname">sparse_memory_present_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_memory_present_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memory_present for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to call memory_present for. If MAX_NUMNODES, all nodes will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes and may
be freed, this function may be used instead of calling <code class="xref c c-func docutils literal"><span class="pre">memory_present()</span></code> manually.</p>
<dl class="function">
<dt id="c.get_pfn_range_for_nid">
void <code class="descname">get_pfn_range_for_nid</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nid</em>, unsigned long *<em>&nbsp;start_pfn</em>, unsigned long *<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfn_range_for_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start and end page frames for a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">start_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node start_pfn.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">end_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node end_pfn.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the start and end page frame of a node based on information
provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>. If called for a node
with no available memory, a warning is printed and the start and end
PFNs will be 0.</p>
<dl class="function">
<dt id="c.absent_pages_in_range">
unsigned long <code class="descname">absent_pages_in_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start_pfn</em>, unsigned long<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.absent_pages_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of page frames in holes within a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_pfn</span></code></dt>
<dd>The start PFN to start searching for holes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_pfn</span></code></dt>
<dd>The end PFN to stop searching for holes</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the number of pages frames in memory holes within a range.</p>
<dl class="function">
<dt id="c.node_map_pfn_alignment">
unsigned long <code class="descname">node_map_pfn_alignment</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.node_map_pfn_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the maximum internode alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after node map is populated and sorted.
It calculates the maximum power of two alignment which can distinguish
all the nodes.</p>
<p>For example, if all nodes are 1GiB and aligned to 1GiB, the return value
would indicate 1GiB alignment with (1 &lt;&lt; (30 - PAGE_SHIFT)).  If the
nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is
shifted, 1GiB is enough and this function will indicate so.</p>
<p>This is used to test whether pfn -&gt; nid mapping of the chosen memory
model has fine enough granularity to avoid incorrect mapping for the
populated node map.</p>
<p>Returns the determined alignment in pfn&#8217;s.  0 if there is no alignment
requirement (single node).</p>
<dl class="function">
<dt id="c.find_min_pfn_with_active_regions">
unsigned long <code class="descname">find_min_pfn_with_active_regions</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.find_min_pfn_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum PFN registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the minimum PFN based on information provided via
<code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>.</p>
<dl class="function">
<dt id="c.free_area_init_nodes">
void <code class="descname">free_area_init_nodes</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;max_zone_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_area_init_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise all pg_data_t and zone data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">max_zone_pfn</span></code></dt>
<dd>an array of max PFNs for each zone</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will call <code class="xref c c-func docutils literal"><span class="pre">free_area_init_node()</span></code> for each active node in the system.
Using the page ranges provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>, the size of each
zone in each node and their holes is calculated. If the maximum PFN
between two adjacent zones match, it is assumed that the zone is empty.
For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed
that arch_max_dma32_pfn has no pages. It is also assumed that a zone
starts where the previous one ended. For example, ZONE_DMA32 starts
at arch_max_dma_pfn.</p>
<dl class="function">
<dt id="c.set_dma_reserve">
void <code class="descname">set_dma_reserve</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;new_dma_reserve</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_dma_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>set the specified number of pages reserved in the first zone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">new_dma_reserve</span></code></dt>
<dd>The number of pages to mark reserved</dd>
</dl>
<p><strong>Description</strong></p>
<p>The per-cpu batchsize and zone watermarks are determined by managed_pages.
In the DMA zone, a significant percentage may be consumed by kernel image
and other unfreeable allocations which can skew the watermarks badly. This
function may optionally be used to account for unfreeable pages in the
first zone (e.g., ZONE_DMA). The effect will be lower watermarks and
smaller per-cpu batchsize.</p>
<dl class="function">
<dt id="c.setup_per_zone_wmarks">
void <code class="descname">setup_per_zone_wmarks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.setup_per_zone_wmarks" title="Permalink to this definition">¶</a></dt>
<dd><p>called when min_free_kbytes changes or when memory is hot-{added|removed}</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures that the watermark[min,low,high] values for each zone are set
correctly with respect to min_free_kbytes.</p>
<dl class="function">
<dt id="c.alloc_contig_range">
int <code class="descname">alloc_contig_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em>, unsigned<em>&nbsp;migratetype</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_range" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>tries to allocate given range of pages</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>one-past-the-last PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">migratetype</span></code></dt>
<dd>migratetype of the underlaying pageblocks (either
#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
in range must have the same migratetype and it must
be either of the two.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask to use during compaction</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES
aligned, however it&#8217;s the caller&#8217;s responsibility to guarantee that
we are the only thread that changes migrate type of pageblocks the
pages fall in.</p>
<p>The PFN range must belong to a single zone.</p>
<p>Returns zero on success or negative error code.  On success all
pages which PFN is in [start, end) are allocated for the caller and
need to be freed with <code class="xref c c-func docutils literal"><span class="pre">free_contig_range()</span></code>.</p>
<dl class="function">
<dt id="c.mempool_destroy">
void <code class="descname">mempool_destroy</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.mempool_create">
mempool_t * <code class="descname">mempool_create</code><span class="sig-paren">(</span>int<em>&nbsp;min_nr</em>, mempool_alloc_t *<em>&nbsp;alloc_fn</em>, mempool_free_t *<em>&nbsp;free_fn</em>, void *<em>&nbsp;pool_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt>
<dd>the minimum number of elements guaranteed to be
allocated for this pool.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_alloc_t</span> <span class="pre">*</span> <span class="pre">alloc_fn</span></code></dt>
<dd>user-defined element-allocation function.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_free_t</span> <span class="pre">*</span> <span class="pre">free_fn</span></code></dt>
<dd>user-defined element-freeing function.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pool_data</span></code></dt>
<dd>optional private data available to the user-defined functions.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function creates and allocates a guaranteed size, preallocated
memory pool. The pool can be used from the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> and <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
functions. This function might sleep. Both the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code>
functions might sleep - as long as the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> function is not called
from IRQ contexts.</p>
<dl class="function">
<dt id="c.mempool_resize">
int <code class="descname">mempool_resize</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, int<em>&nbsp;new_min_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>resize an existing memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_min_nr</span></code></dt>
<dd>the new minimum number of elements guaranteed to be
allocated for this pool.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a> calls will refill it.
This function may sleep.</p>
<p>Note, the caller must guarantee that no mempool_destroy is called
while this function is running. <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> &amp; <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
might be called (eg. from IRQ contexts) while this function executes.</p>
<dl class="function">
<dt id="c.mempool_alloc">
void * <code class="descname">mempool_alloc</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an element from a specific memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the usual allocation bitmask.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> function sleeps or
returns NULL. Note that due to preallocation, this function
<em>never</em> fails when called from process contexts. (it might
fail if called from an IRQ context.)</p>
<p><strong>Note</strong></p>
<p>using __GFP_ZERO is not supported.</p>
<dl class="function">
<dt id="c.mempool_free">
void <code class="descname">mempool_free</code><span class="sig-paren">(</span>void *<em>&nbsp;element</em>, mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>return an element to the pool.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">element</span></code></dt>
<dd>pool element pointer.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.dma_pool_create">
struct dma_pool * <code class="descname">dma_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a pool of consistent memory blocks, for dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">boundary</span></code></dt>
<dd>returned blocks won&#8217;t cross this power of two boundary</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Returns a dma allocation pool with the requested characteristics, or
null if one can&#8217;t be created.  Given one of these pools, <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a>
may be used to allocate memory.  Such memory will all have &#8220;consistent&#8221;
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.</p>
<p>If <strong>boundary</strong> is nonzero, objects returned from <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a> won&#8217;t
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.</p>
<dl class="function">
<dt id="c.dma_pool_destroy">
void <code class="descname">dma_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a pool of dma memory blocks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.</p>
<dl class="function">
<dt id="c.dma_pool_alloc">
void * <code class="descname">dma_pool_alloc</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;mem_flags</em>, dma_addr_t *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>get a block of consistent memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will produce the block</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt>
<dd>GFP_* bitmask</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>pointer to dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can&#8217;t be allocated, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.dma_pool_free">
void <code class="descname">dma_pool_free</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>put block back into dma pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the dma pool holding the block</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address of block</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt>
<dd>dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.</p>
<dl class="function">
<dt id="c.dmam_pool_create">
struct dma_pool * <code class="descname">dmam_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;allocation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">allocation</span></code></dt>
<dd>returned blocks won&#8217;t cross this boundary (or zero)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a>.  DMA pool created with this function is
automatically destroyed on driver detach.</p>
<dl class="function">
<dt id="c.dmam_pool_destroy">
void <code class="descname">dmam_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a>.</p>
<dl class="function">
<dt id="c.balance_dirty_pages_ratelimited">
void <code class="descname">balance_dirty_pages_ratelimited</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited" title="Permalink to this definition">¶</a></dt>
<dd><p>balance dirty memory state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which was dirtied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system&#8217;s
dirty state and will initiate writeback if needed.</p>
<p>On really big machines, get_writeback_state is expensive, so try to avoid
calling it too often (ratelimiting).  But once we&#8217;re over the dirty memory
limit we decrease the ratelimiting by a lot, to prevent individual processes
from overshooting the limit by (ratelimit_pages) each.</p>
<dl class="function">
<dt id="c.tag_pages_for_writeback">
void <code class="descname">tag_pages_for_writeback</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tag_pages_for_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>tag pages to be written by write_cache_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>starting page index</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>ending page index (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the page range from <strong>start</strong> to <strong>end</strong> (inclusive) and tags
all pages that have DIRTY tag set with a special TOWRITE tag. The idea is
that write_cache_pages (or whoever calls this function) will then use
TOWRITE tag to identify pages eligible for writeback.  This mechanism is
used to avoid livelocking of writeback by a process steadily creating new
dirty pages in the file (thus it is important for this function to be quick
so that it can tag pages faster than a dirtying process can create them).</p>
<dl class="function">
<dt id="c.write_cache_pages">
int <code class="descname">write_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em>, writepage_t<em>&nbsp;writepage</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and write all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
<dt><code class="docutils literal"><span class="pre">writepage_t</span> <span class="pre">writepage</span></code></dt>
<dd>function called for each page</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data passed to writepage function</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a page is already under I/O, <a class="reference internal" href="#c.write_cache_pages" title="write_cache_pages"><code class="xref c c-func docutils literal"><span class="pre">write_cache_pages()</span></code></a> skips it, even
if it&#8217;s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.  <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">msync()</span></code> need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<p>To avoid livelocks (when other process dirties new pages), we first tag
pages which should be written back with TOWRITE tag and only then start
writing them. For data-integrity sync we have to be careful so that we do
not miss some pages (e.g., because some other process has cleared TOWRITE
tag we set). The rule we follow is that TOWRITE tag can be cleared only
by the process clearing the DIRTY tag (and submitting the page for IO).</p>
<dl class="function">
<dt id="c.generic_writepages">
int <code class="descname">generic_writepages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and <code class="xref c c-func docutils literal"><span class="pre">writepage()</span></code> all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the <code class="xref c c-func docutils literal"><span class="pre">writepages()</span></code>
address_space_operation.</p>
<dl class="function">
<dt id="c.write_one_page">
int <code class="descname">write_one_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_one_page" title="Permalink to this definition">¶</a></dt>
<dd><p>write out a single page and wait on I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page must be locked by the caller and will be unlocked upon return.</p>
<p>Note that the mapping&#8217;s AS_EIO/AS_ENOSPC flags will be cleared when this
function returns.</p>
<dl class="function">
<dt id="c.wait_for_stable_page">
void <code class="descname">wait_for_stable_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_stable_page" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to finish, if necessary.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page to wait on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines if the given page is related to a backing device
that requires page contents to be held stable during writeback.  If so, then
it will wait for any pending writeback to complete.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_range">
void <code class="descname">truncate_inode_pages_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_range" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate range of pages specified by start &amp; end byte offsets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset to which to truncate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate the page cache, removing the pages that are between
specified offsets (and zeroing out partial pages
if lstart or lend + 1 is not page aligned).</p>
<p>Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.</p>
<p>We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.</p>
<p>Note that since -&gt;:c:func:<cite>invalidatepage()</cite> accepts range to invalidate
truncate_inode_pages_range is able to handle cases where lend + 1 is not
page aligned properly.</p>
<dl class="function">
<dt id="c.truncate_inode_pages">
void <code class="descname">truncate_inode_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> the pages from an offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialised by) inode-&gt;i_mutex.</p>
<p><strong>Note</strong></p>
<p>When this function returns, there can be a page in the process of
deletion (inside <code class="xref c c-func docutils literal"><span class="pre">__delete_from_page_cache()</span></code>) in the specified range.  Thus
mapping-&gt;nrpages can be non-zero when this function returns even after
truncation of the whole mapping.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_final">
void <code class="descname">truncate_inode_pages_final</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_final" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> pages before inode dies</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialized by) inode-&gt;i_mutex.</p>
<p>Filesystems have to use this in the .evict_inode path to inform the
VM that this is the final truncate and the inode is going away.</p>
<dl class="function">
<dt id="c.invalidate_mapping_pages">
unsigned long <code class="descname">invalidate_mapping_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_mapping_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate all the unlocked pages of one inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space which holds the pages to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the offset &#8216;from&#8217; which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the offset &#8216;to&#8217; which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only removes the unlocked pages, if you want to
remove all the pages of one inode, you must call truncate_inode_pages.</p>
<p><a class="reference internal" href="#c.invalidate_mapping_pages" title="invalidate_mapping_pages"><code class="xref c c-func docutils literal"><span class="pre">invalidate_mapping_pages()</span></code></a> will not block on IO activity. It will not
invalidate pages which are dirty, locked, under writeback or mapped into
pagetables.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2_range">
int <code class="descname">invalidate_inode_pages2_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remove range of pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the page offset &#8216;from&#8217; which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the page offset &#8216;to&#8217; which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2">
int <code class="descname">invalidate_inode_pages2</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.truncate_pagecache">
void <code class="descname">truncate_pagecache</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that has been truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode&#8217;s new i_size must already be written before truncate_pagecache
is called.</p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
<dl class="function">
<dt id="c.truncate_setsize">
void <code class="descname">truncate_setsize</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_setsize" title="Permalink to this definition">¶</a></dt>
<dd><p>update inode and pagecache for a new file size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>truncate_setsize updates i_size and performs pagecache truncation (if
necessary) to <strong>newsize</strong>. It will be typically be called from the filesystem&#8217;s
setattr function when ATTR_SIZE is passed in.</p>
<p>Must be called with a lock serializing truncates and writes (generally
i_mutex but e.g. xfs uses a different lock) and before all filesystem
specific block truncation has been performed.</p>
<dl class="function">
<dt id="c.pagecache_isize_extended">
void <code class="descname">pagecache_isize_extended</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;from</em>, loff_t<em>&nbsp;to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_isize_extended" title="Permalink to this definition">¶</a></dt>
<dd><p>update pagecache after extension of i_size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode for which i_size was extended</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>original inode size</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>new inode size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle extension of inode size either caused by extending truncate or by
write starting after current i_size. We mark the page straddling current
i_size RO so that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on the nearest write access to
the page.  This way filesystem can be sure that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on
the page before user writes to the page via mmap after the i_size has been
changed.</p>
<p>The function must be called after i_size is updated so that page fault
coming after we unlock the page will already see the new i_size.
The function must be called while we still hold i_mutex - this not only
makes sure i_size is stable but also that userspace cannot observe new
i_size value before we are prepared to store mmap writes at new inode size.</p>
<dl class="function">
<dt id="c.truncate_pagecache_range">
void <code class="descname">truncate_pagecache_range</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that is hole-punched</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset of beginning of hole</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset of last byte of hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
</div>
</div>
<div class="section" id="kernel-ipc-facilities">
<h2>Kernel IPC facilities<a class="headerlink" href="#kernel-ipc-facilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ipc-utilities">
<h3>IPC utilities<a class="headerlink" href="#ipc-utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.ipc_init">
int <code class="descname">ipc_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The various sysv ipc resources (semaphores, messages and shared
memory) are initialised.</p>
<p>A callback routine is registered into the memory hotplug notifier
chain: since msgmni scales to lowmem this callback routine will be
called upon successful memory add / remove to recompute msmgni.</p>
<dl class="function">
<dt id="c.ipc_init_ids">
void <code class="descname">ipc_init_ids</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc identifiers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the sequence range to use for the ipc identifier range (limited
below IPCMNI) then initialise the ids idr.</p>
<dl class="function">
<dt id="c.ipc_init_proc_interface">
void <code class="descname">ipc_init_proc_interface</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, const char *<em>&nbsp;header</em>, int<em>&nbsp;ids</em>, int (*show) (struct seq_file<em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_proc_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>create a proc interface for sysipc types using a seq_file interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>Path in procfs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>Banner to be printed at the beginning of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ids</span></code></dt>
<dd>ipc id table to iterate.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">show</span></code></dt>
<dd>show routine.</dd>
</dl>
<dl class="function">
<dt id="c.ipc_findkey">
struct kern_ipc_perm * <code class="descname">ipc_findkey</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, key_t<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_findkey" title="Permalink to this definition">¶</a></dt>
<dd><p>find a key in an ipc identifier set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">key_t</span> <span class="pre">key</span></code></dt>
<dd>key to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked pointer to the ipc structure if found or NULL
otherwise. If key is found ipc points to the owning ipc structure</p>
<p>Called with ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_get_maxid">
int <code class="descname">ipc_get_maxid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_get_maxid" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last assigned id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called with ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_addid">
int <code class="descname">ipc_addid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;new</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_addid" title="Permalink to this definition">¶</a></dt>
<dd><p>add an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>limit for the number of used ids</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry &#8216;new&#8217; to the ipc ids idr. The permissions object is
initialised and the first free entry is set up and the id assigned
is returned. The &#8216;new&#8217; entry is returned in a locked state on success.
On failure the entry is not locked and a negative err-code is returned.</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipcget_new">
int <code class="descname">ipcget_new</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is IPC_PRIVATE.</p>
<dl class="function">
<dt id="c.ipc_check_perms">
int <code class="descname">ipc_check_perms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_check_perms" title="Permalink to this definition">¶</a></dt>
<dd><p>check security and permissions for an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual security routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE and that key already exists in the
ds IDR.</p>
<p>On success, the ipc id is returned.</p>
<p>It is called with ipc_ids.rwsem and ipcp-&gt;lock held.</p>
<dl class="function">
<dt id="c.ipcget_public">
int <code class="descname">ipcget_public</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_public" title="Permalink to this definition">¶</a></dt>
<dd><p>get an ipc object or create a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE.
It adds a new entry if the key is not found and does some permission
/ security checkings if the key is found.</p>
<p>On success, the ipc id is returned.</p>
<dl class="function">
<dt id="c.ipc_rmid">
void <code class="descname">ipc_rmid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the identifier to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipcperms">
int <code class="descname">ipcperms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, short<em>&nbsp;flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcperms" title="Permalink to this definition">¶</a></dt>
<dd><p>check ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">short</span> <span class="pre">flag</span></code></dt>
<dd>desired permission set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check user, group, other permissions for access
to ipc resources. return 0 if allowed</p>
<p><strong>flag</strong> will most probably be 0 or <code class="docutils literal"><span class="pre">S_...UGO</span></code> from &lt;linux/stat.h&gt;</p>
<dl class="function">
<dt id="c.kernel_to_ipc64_perm">
void <code class="descname">kernel_to_ipc64_perm</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;in</em>, struct ipc64_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_to_ipc64_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert kernel ipc permissions to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>kernel permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>new style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the kernel object <strong>in</strong> into a set of permissions descriptions
for returning to userspace (<strong>out</strong>).</p>
<dl class="function">
<dt id="c.ipc64_perm_to_ipc_perm">
void <code class="descname">ipc64_perm_to_ipc_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc64_perm_to_ipc_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert new ipc permissions to old</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>new style ipc permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>old style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the new style permissions object <strong>in</strong> into a compatibility
object and store it into the <strong>out</strong> pointer.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_idr">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_idr</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_idr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and return associated ipc object.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipc_lock">
struct kern_ipc_perm * <code class="descname">ipc_lock</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock an ipc structure without rwsem held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and lock the associated ipc object.</p>
<p>The ipc object is locked on successful exit.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_check">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_check</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_check" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.ipc_obtain_object_idr" title="ipc_obtain_object_idr"><code class="xref c c-func docutils literal"><span class="pre">ipc_obtain_object_idr()</span></code></a> but also checks
the ipc object reference counter.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipcget">
int <code class="descname">ipcget</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget" title="Permalink to this definition">¶</a></dt>
<dd><p>Common sys_*:c:func:<cite>get()</cite> code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>operations to be called on ipc object creation, permission checks
and further checks</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the parameters needed by the previous operations.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common routine called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>.</p>
<dl class="function">
<dt id="c.ipc_update_perm">
int <code class="descname">ipc_update_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct kern_ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_update_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>update the permissions of an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>the permission given as input.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>the permission of the ipc to set.</dd>
</dl>
<dl class="function">
<dt id="c.ipcctl_pre_down_nolock">
struct kern_ipc_perm * <code class="descname">ipcctl_pre_down_nolock</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em>, int<em>&nbsp;cmd</em>, struct ipc64_perm *<em>&nbsp;perm</em>, int<em>&nbsp;extra_perm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcctl_pre_down_nolock" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve an ipc and check permissions for some IPC_XXX cmd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>the table of ids where to look for the ipc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>the id of the ipc to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>the cmd to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">perm</span></code></dt>
<dd>the permission to set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">extra_perm</span></code></dt>
<dd>one extra permission parameter used by msq</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does some common audit and permissions check for some IPC_XXX
cmd and is called from semctl_down, shmctl_down and msgctl_down.
It must be called without any lock held and:</p>
<blockquote>
<div><ul class="simple">
<li>retrieves the ipc with the given id in the given table.</li>
<li>performs some audit and permission check, depending on the given cmd</li>
<li>returns a pointer to the ipc object or otherwise, the corresponding
error.</li>
</ul>
</div></blockquote>
<p>Call holding the both the rwsem and the rcu read lock.</p>
<dl class="function">
<dt id="c.ipc_parse_version">
int <code class="descname">ipc_parse_version</code><span class="sig-paren">(</span>int *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>ipc call version</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>pointer to command</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
The <strong>cmd</strong> value is turned from an encoding command and version into
just the command code.</p>
</div>
</div>
<div class="section" id="fifo-buffer">
<h2>FIFO Buffer<a class="headerlink" href="#fifo-buffer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo-interface">
<h3>kfifo interface<a class="headerlink" href="#kfifo-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.DECLARE_KFIFO_PTR">
<code class="descname">DECLARE_KFIFO_PTR</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO_PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo pointer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
</dl>
<dl class="function">
<dt id="c.DECLARE_KFIFO">
<code class="descname">DECLARE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<dl class="function">
<dt id="c.INIT_KFIFO">
<code class="descname">INIT_KFIFO</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a fifo declared by DECLARE_KFIFO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
</dl>
<dl class="function">
<dt id="c.DEFINE_KFIFO">
<code class="descname">DEFINE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to define and initialize a fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<p><strong>Note</strong></p>
<p>the macro can be used for global and local fifo data type variables.</p>
<dl class="function">
<dt id="c.kfifo_initialized">
<code class="descname">kfifo_initialized</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the fifo is initialized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal"><span class="pre">true</span></code> if fifo is initialized, otherwise <code class="docutils literal"><span class="pre">false</span></code>.
Assumes the fifo was 0 before.</p>
<dl class="function">
<dt id="c.kfifo_esize">
<code class="descname">kfifo_esize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_esize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the element managed by the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_recsize">
<code class="descname">kfifo_recsize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_recsize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the record length field</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_size">
<code class="descname">kfifo_size</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the fifo in elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_reset">
<code class="descname">kfifo_reset</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>removes the entire fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>usage of <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a> is dangerous. It should be only called when the
fifo is exclusived locked or when it is secured that no other thread is
accessing the fifo.</p>
<dl class="function">
<dt id="c.kfifo_reset_out">
<code class="descname">kfifo_reset_out</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset_out" title="Permalink to this definition">¶</a></dt>
<dd><p>skip fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>The usage of <a class="reference internal" href="#c.kfifo_reset_out" title="kfifo_reset_out"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset_out()</span></code></a> is safe until it will be only called
from the reader thread and there is only one concurrent reader. Otherwise
it is dangerous and must be handled in the same way as <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a>.</p>
<dl class="function">
<dt id="c.kfifo_len">
<code class="descname">kfifo_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_len" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of used elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty">
<code class="descname">kfifo_is_empty</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_full">
<code class="descname">kfifo_is_full</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is full</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_avail">
<code class="descname">kfifo_avail</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of unused elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_skip">
<code class="descname">kfifo_skip</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_skip" title="Permalink to this definition">¶</a></dt>
<dd><p>skip output data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_peek_len">
<code class="descname">kfifo_peek_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek_len" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the size of the next fifo record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the size of the next fifo record in number of bytes.</p>
<dl class="function">
<dt id="c.kfifo_alloc">
<code class="descname">kfifo_alloc</code><span class="sig-paren">(</span><em>fifo</em>, <em>size</em>, <em>gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>dynamically allocates a new fifo buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>pointer to the fifo</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
<dt><code class="docutils literal"><span class="pre">gfp_mask</span></code></dt>
<dd>get_free_pages mask, passed to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro dynamically allocates a new fifo buffer.</p>
<p>The numer of elements will be rounded-up to a power of 2.
The fifo will be release with <a class="reference internal" href="#c.kfifo_free" title="kfifo_free"><code class="xref c c-func docutils literal"><span class="pre">kfifo_free()</span></code></a>.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_free">
<code class="descname">kfifo_free</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to be freed</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_init">
<code class="descname">kfifo_init</code><span class="sig-paren">(</span><em>fifo</em>, <em>buffer</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a fifo using a preallocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to assign the buffer</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>the preallocated buffer to be used</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the size of the internal buffer, this have to be a power of 2</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initialize a fifo using a preallocated buffer.</p>
<p>The numer of elements will be rounded-up to a power of 2.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_put">
<code class="descname">kfifo_put</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>the data to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given value into the fifo.
It returns 0 if the fifo was full. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_get">
<code class="descname">kfifo_get</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro reads the data from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_peek">
<code class="descname">kfifo_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo without removing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the data from the fifo without removing it from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in">
<code class="descname">kfifo_in</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given buffer into the fifo and returns the
number of copied elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in_spinlocked">
<code class="descname">kfifo_in_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given values buffer into the fifo and returns the
number of copied elements.</p>
<dl class="function">
<dt id="c.kfifo_out">
<code class="descname">kfifo_out</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get some data from the fifo and return the numbers of elements
copied.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_out_spinlocked">
<code class="descname">kfifo_out_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied.</p>
<dl class="function">
<dt id="c.kfifo_from_user">
<code class="descname">kfifo_from_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>from</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>puts some data from user space into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">from</span></code></dt>
<dd>pointer to the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the length of the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the <strong>from</strong> into the
fifo, depending of the available space and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_to_user">
<code class="descname">kfifo_to_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>to</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_to_user" title="Permalink to this definition">¶</a></dt>
<dd><p>copies data from the fifo into user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">to</span></code></dt>
<dd>where the data must be copied</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the size of the destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the fifo into the
<strong>to</strong> buffer and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_prepare">
<code class="descname">kfifo_dma_in_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA input.
It returns the number entries in the scatterlist array.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_finish">
<code class="descname">kfifo_dma_in_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA IN operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes to received</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA IN operation. The in counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_prepare">
<code class="descname">kfifo_dma_out_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA output which at most <strong>len</strong> bytes
to transfer.
It returns the number entries in the scatterlist array.
A zero means there is no space available and the scatterlist is not filled.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_finish">
<code class="descname">kfifo_dma_out_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA OUT operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes transferred</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA OUT operation. The out counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_out_peek">
<code class="descname">kfifo_out_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>gets some data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied. The data is not removed from the fifo.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
</div>
</div>
<div class="section" id="relay-interface-support">
<h2>relay interface support<a class="headerlink" href="#relay-interface-support" title="Permalink to this headline">¶</a></h2>
<p>Relay interface support is designed to provide an efficient mechanism
for tools and facilities to relay large amounts of data from kernel
space to user space.</p>
<div class="section" id="relay-interface">
<h3>relay interface<a class="headerlink" href="#relay-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.relay_buf_full">
int <code class="descname">relay_buf_full</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_full" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer full?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is full, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_reset">
void <code class="descname">relay_reset</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.</p>
<p>NOTE. Care should be taken that the channel isn&#8217;t actually
being used by anything when this call is made.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_open">
struct rchan * <code class="descname">relay_open</code><span class="sig-paren">(</span>const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em>, size_t<em>&nbsp;subbuf_size</em>, size_t<em>&nbsp;n_subbufs</em>, struct rchan_callbacks *<em>&nbsp;cb</em>, void *<em>&nbsp;private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_open" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new relay channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create, <code class="docutils literal"><span class="pre">NULL</span></code> for buffering only</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory or buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbuf_size</span></code></dt>
<dd>size of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n_subbufs</span></code></dt>
<dd>number of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_callbacks</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>client callback functions</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>user-defined data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns channel pointer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<p>Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0...base_filenameN-1.  File
permissions will be <code class="docutils literal"><span class="pre">S_IRUSR</span></code>.</p>
<p>If opening a buffer (<strong>parent</strong> = NULL) that you later wish to register
in a filesystem, call <a class="reference internal" href="#c.relay_late_setup_files" title="relay_late_setup_files"><code class="xref c c-func docutils literal"><span class="pre">relay_late_setup_files()</span></code></a> once the <strong>parent</strong> dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_late_setup_files">
int <code class="descname">relay_late_setup_files</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_late_setup_files" title="Permalink to this definition">¶</a></dt>
<dd><p>triggers file creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>channel to operate on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if successful, non-zero otherwise.</p>
<p>Use to setup files for a previously buffer-only channel created
by <a class="reference internal" href="#c.relay_open" title="relay_open"><code class="xref c c-func docutils literal"><span class="pre">relay_open()</span></code></a> with a NULL parent dentry.</p>
<p>For example, this is useful for perfomring early tracing in kernel,
before VFS is up and then exposing the early results once the dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_switch_subbuf">
size_t <code class="descname">relay_switch_subbuf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_switch_subbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch to a new sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>size of current event</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns either the length passed in or 0 if full.</p>
<p>Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_subbufs_consumed">
void <code class="descname">relay_subbufs_consumed</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, unsigned int<em>&nbsp;cpu</em>, size_t<em>&nbsp;subbufs_consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_subbufs_consumed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the buffer&#8217;s sub-buffers-consumed count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the cpu associated with the channel buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbufs_consumed</span></code></dt>
<dd>number of sub-buffers to add to current buf&#8217;s count</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adds to the channel buffer&#8217;s consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.</p>
<p>NOTE. Kernel clients don&#8217;t need to call this function if the channel
mode is &#8216;overwrite&#8217;.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_close">
void <code class="descname">relay_close</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Closes all channel buffers and frees the channel.</div></blockquote>
<dl class="function">
<dt id="c.relay_flush">
void <code class="descname">relay_flush</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flushes all channel buffers, i.e. forces buffer switch.</div></blockquote>
<dl class="function">
<dt id="c.relay_mmap_buf">
int <code class="descname">relay_mmap_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_mmap_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap channel buffer to process address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct describing memory to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if ok, negative on error</p>
<p>Caller should already have grabbed mmap_sem.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_alloc_buf">
void * <code class="descname">relay_alloc_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_alloc_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>total size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a pointer to the resulting buffer, <code class="docutils literal"><span class="pre">NULL</span></code> if unsuccessful. The
passed in size will get page aligned, if it isn&#8217;t already.</div></blockquote>
<dl class="function">
<dt id="c.relay_create_buf">
struct rchan_buf * <code class="descname">relay_create_buf</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_create_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns channel buffer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_channel">
void <code class="descname">relay_destroy_channel</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>free the channel struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Should only be called from <code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_buf">
void <code class="descname">relay_destroy_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy an rchan_buf struct and associated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
</dl>
<dl class="function">
<dt id="c.relay_remove_buf">
void <code class="descname">relay_remove_buf</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_remove_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Removes the file from the filesystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
<code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_buf_empty">
int <code class="descname">relay_buf_empty</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer empty?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is empty, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.wakeup_readers">
void <code class="descname">wakeup_readers</code><span class="sig-paren">(</span>struct irq_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeup_readers" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up readers waiting on a channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>contains the channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is the function used to defer reader waking</div></blockquote>
<dl class="function">
<dt id="c.__relay_reset">
void <code class="descname">__relay_reset</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;init</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">init</span></code></dt>
<dd>1 if this is a first-time initialization</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <a class="reference internal" href="#c.relay_reset" title="relay_reset"><code class="xref c c-func docutils literal"><span class="pre">relay_reset()</span></code></a> for description of effect.</div></blockquote>
<dl class="function">
<dt id="c.relay_close_buf">
void <code class="descname">relay_close_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>close a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_open">
int <code class="descname">relay_file_open</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_open" title="Permalink to this definition">¶</a></dt>
<dd><p>open file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Increments the channel buffer refcount.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_mmap">
int <code class="descname">relay_file_mmap</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>the vma describing what to map</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Calls upon <a class="reference internal" href="#c.relay_mmap_buf" title="relay_mmap_buf"><code class="xref c c-func docutils literal"><span class="pre">relay_mmap_buf()</span></code></a> to map the file into user space.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_poll">
unsigned int <code class="descname">relay_file_poll</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>poll file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>poll table</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Poll implemention.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_release">
int <code class="descname">relay_file_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Decrements the channel refcount, as the filesystem is
no longer using it.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_subbuf_avail">
size_t <code class="descname">relay_file_read_subbuf_avail</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_subbuf_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>return bytes available in sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<dl class="function">
<dt id="c.relay_file_read_start_pos">
size_t <code class="descname">relay_file_read_start_pos</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_start_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find the first available byte to read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If the <strong>read_pos</strong> is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_end_pos">
size_t <code class="descname">relay_file_read_end_pos</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;read_pos</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_end_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>return the new read position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to be read</dd>
</dl>
</div>
</div>
<div class="section" id="module-support">
<h2>Module Support<a class="headerlink" href="#module-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-loading">
<h3>Module Loading<a class="headerlink" href="#module-loading" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__request_module">
int <code class="descname">__request_module</code><span class="sig-paren">(</span>bool<em>&nbsp;wait</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.__request_module" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load a kernel module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wait</span></code></dt>
<dd>wait (or not) for the operation to complete</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>printf style format string for the name of the module</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>arguments as specified in the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load a module using the user mode module loader. The function returns
zero on success or a negative errno code or positive exit code from
&#8220;modprobe&#8221; on failure. Note that a successful module load does not mean
the module did not then unload and exit on an error of its own. Callers
must check that the service they requested is now available not blindly
invoke it.</p>
<p>If module auto-loading support is disabled then this function
becomes a no-operation.</p>
<dl class="function">
<dt id="c.call_usermodehelper_setup">
struct subprocess_info * <code class="descname">call_usermodehelper_setup</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, char **<em>&nbsp;argv</em>, char **<em>&nbsp;envp</em>, gfp_t<em>&nbsp;gfp_mask</em>, int (*init) (struct subprocess_info<em>&nbsp;*info</em>, struct cred<em>&nbsp;*new</em>, void (*cleanup) (struct subprocess_info<em>&nbsp;*info</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_usermodehelper_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare to call a usermode helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to usermode executable</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">argv</span></code></dt>
<dd>arg vector for process</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">envp</span></code></dt>
<dd>environment for process</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>gfp mask for memory allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">subprocess_info</span> <span class="pre">*info,</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new)</span> <span class="pre">init</span></code></dt>
<dd>an init function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">subprocess_info</span> <span class="pre">*info)</span> <span class="pre">cleanup</span></code></dt>
<dd>a cleanup function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>arbitrary context sensitive data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns either <code class="docutils literal"><span class="pre">NULL</span></code> on allocation failure, or a subprocess_info
structure.  This should be passed to call_usermodehelper_exec to
exec the process and free the structure.</p>
<p>The init function is used to customize the helper process prior to
exec.  A non-zero return code causes the process to error out, exit,
and return the failure to the calling process</p>
<p>The cleanup function is just before ethe subprocess_info is about to
be freed.  This can be used for freeing the argv and envp.  The
Function must be runnable in either a process context or the
context in which call_usermodehelper_exec is called.</p>
<dl class="function">
<dt id="c.call_usermodehelper_exec">
int <code class="descname">call_usermodehelper_exec</code><span class="sig-paren">(</span>struct subprocess_info *<em>&nbsp;sub_info</em>, int<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_usermodehelper_exec" title="Permalink to this definition">¶</a></dt>
<dd><p>start a usermode application</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">subprocess_info</span> <span class="pre">*</span> <span class="pre">sub_info</span></code></dt>
<dd>information about the subprocessa</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">wait</span></code></dt>
<dd>wait for the application to finish and return status.
when UMH_NO_WAIT don&#8217;t wait at all, but you get no useful error back
when the program couldn&#8217;t be exec&#8217;ed. This makes it safe to call
from interrupt context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Runs a user-space application.  The application is started
asynchronously if wait is not set, and runs as a child of system workqueues.
(ie. it runs with full root capabilities and optimized affinity).</p>
<dl class="function">
<dt id="c.call_usermodehelper">
int <code class="descname">call_usermodehelper</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, char **<em>&nbsp;argv</em>, char **<em>&nbsp;envp</em>, int<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_usermodehelper" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare and start a usermode application</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to usermode executable</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">argv</span></code></dt>
<dd>arg vector for process</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">envp</span></code></dt>
<dd>environment for process</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">wait</span></code></dt>
<dd>wait for the application to finish and return status.
when UMH_NO_WAIT don&#8217;t wait at all, but you get no useful error back
when the program couldn&#8217;t be exec&#8217;ed. This makes it safe to call
from interrupt context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is the equivalent to use <a class="reference internal" href="#c.call_usermodehelper_setup" title="call_usermodehelper_setup"><code class="xref c c-func docutils literal"><span class="pre">call_usermodehelper_setup()</span></code></a> and
<a class="reference internal" href="#c.call_usermodehelper_exec" title="call_usermodehelper_exec"><code class="xref c c-func docutils literal"><span class="pre">call_usermodehelper_exec()</span></code></a>.</p>
</div>
<div class="section" id="inter-module-support">
<h3>Inter Module support<a class="headerlink" href="#inter-module-support" title="Permalink to this headline">¶</a></h3>
<p>Refer to the file kernel/module.c for more information.</p>
</div>
</div>
<div class="section" id="hardware-interfaces">
<h2>Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.synchronize_hardirq">
bool <code class="descname">synchronize_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending hard IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this
function while holding a resource the IRQ handler may need you
will deadlock. It does not take associated threaded handlers
into account.</p>
<p>Do not use this for shutdown scenarios where you must be sure
that all parts (hardirq and threaded handler) have completed.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.synchronize_irq">
void <code class="descname">synchronize_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_affinity_notifier">
int <code class="descname">irq_set_affinity_notifier</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irq_affinity_notify" title="irq_affinity_notify">irq_affinity_notify</a> *<em>&nbsp;notify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>control notification of IRQ affinity changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt for which to enable/disable notification</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_affinity_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt>
<dd>Context for notification, or <code class="docutils literal"><span class="pre">NULL</span></code> to disable
notification.  Function pointers must be initialised;
the other fields will be initialised by this function.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called in process context.  Notification may only be enabled
after the IRQ is allocated and must be disabled before the IRQ is
freed using <a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.irq_set_vcpu_affinity">
int <code class="descname">irq_set_vcpu_affinity</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_vcpu_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity for the interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to set affinity</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vcpu_info</span></code></dt>
<dd>vCPU specific data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function uses the vCPU specific data to set the vCPU
affinity for an irq. The vCPU specific data is passed from
outside, such as KVM. One example code path is as below:
KVM -&gt; IOMMU -&gt; <a class="reference internal" href="#c.irq_set_vcpu_affinity" title="irq_set_vcpu_affinity"><code class="xref c c-func docutils literal"><span class="pre">irq_set_vcpu_affinity()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.disable_irq_nosync">
void <code class="descname">disable_irq_nosync</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq without waiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>, this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
<p>This function may be called from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_irq">
void <code class="descname">disable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq and wait for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_hardirq">
bool <code class="descname">disable_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>disables an irq and waits for hardirq completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this function while
holding a resource the hard IRQ handler may need you will deadlock.</p>
<p>When used to optimistically disable an interrupt from atomic context
the return value must be checked.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.enable_irq">
void <code class="descname">enable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to enable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Undoes the effect of one call to <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
<p>This function may be called from IRQ context only when
desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irq_wake">
int <code class="descname">irq_set_irq_wake</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, unsigned int<em>&nbsp;on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>control irq power management wakeup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt to control</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt>
<dd>enable/disable power management wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enable/disable power management wakeup mode, which is
disabled by default.  Enables and disables must match,
just as they match for non-wakeup mode support.</p>
<p>Wakeup mode lets this IRQ wake the system from sleep
states like &#8220;suspend to RAM&#8221;.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_wake_thread">
void <code class="descname">irq_wake_thread</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_wake_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the irq thread for the action identified by dev_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity for which the thread should be woken</dd>
</dl>
<dl class="function">
<dt id="c.setup_irq">
int <code class="descname">setup_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>setup an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to statically setup interrupts in the early boot process.</p>
<dl class="function">
<dt id="c.remove_irq">
void <code class="descname">remove_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to remove interrupts statically setup by the early boot process.</p>
<dl class="function">
<dt id="c.free_irq">
const void * <code class="descname">free_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<p>Returns the devname argument passed to request_irq.</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_threaded_irq">
int <code class="descname">request_threaded_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, irq_handler_t<em>&nbsp;thread_fn</em>, unsigned long<em>&nbsp;irqflags</em>, const char *<em>&nbsp;devname</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_threaded_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts
If NULL and thread_fn != NULL the default
primary handler is installed</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt>
<dd>Function called from the irq handler thread
If NULL, no irq thread is created</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.</p>
<p>If you want to set up a threaded irq handler for your device
then you need to supply <strong>handler</strong> and <strong>thread_fn</strong>. <strong>handler</strong> is
still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it
needs to disable the interrupt on the device and return
IRQ_WAKE_THREAD which will wake up the handler thread and run
<strong>thread_fn</strong>. This split handler design is necessary to support
shared interrupts.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.</p>
<p>Flags:</p>
<p>IRQF_SHARED             Interrupt is shared
IRQF_TRIGGER_*          Specify active edge(s) or level</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_any_context_irq">
int <code class="descname">request_any_context_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_any_context_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It selects either a
hardirq or threaded handling method depending on the
context.</p>
<p>On failure, it returns a negative value. On success,
it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_percpu_is_enabled">
bool <code class="descname">irq_percpu_is_enabled</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_percpu_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the per cpu irq is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Linux irq number to check for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called from a non migratable context. Returns the enable
state of a per cpu interrupt on the current cpu.</p>
<dl class="function">
<dt id="c.free_percpu_irq">
void <code class="descname">free_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_percpu_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a percpu interrupt handler. The handler is removed, but
the interrupt line is not disabled. This must be done on each
CPU before calling this function. The function does not return
until any executing interrupts for this IRQ have completed.</p>
<p>This function must not be called from interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__request_percpu_irq">
int <code class="descname">__request_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;devname</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags (IRQF_TIMER only)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A percpu cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt on the local CPU. If the interrupt is supposed to be
enabled on other CPUs, it has to be done on each CPU using
<code class="xref c c-func docutils literal"><span class="pre">enable_percpu_irq()</span></code>.</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU&#8217;s instance of
that variable.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_get_irqchip_state">
int <code class="descname">irq_get_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the irqchip state of a interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>One of IRQCHIP_STATE_* the caller wants to know about</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>a pointer to a boolean where the state is to be storeed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call snapshots the internal irqchip state of an
interrupt, returning into <strong>state</strong> the bit corresponding to
stage <strong>which</strong></p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irqchip_state">
int <code class="descname">irq_set_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a forwarded interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>State to be restored (one of IRQCHIP_STATE_*)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">val</span></code></dt>
<dd>Value corresponding to <strong>which</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call sets the internal irqchip state of an interrupt,
depending on the value of <strong>which</strong>.</p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
</div>
<div class="section" id="dma-channels">
<h3>DMA Channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_dma">
int <code class="descname">request_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em>, const char *<em>&nbsp;device_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve a system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">device_id</span></code></dt>
<dd>reserving device ID string, used in /proc/dma</dd>
</dl>
<dl class="function">
<dt id="c.free_dma">
void <code class="descname">free_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>free a reserved system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
</dl>
</div>
<div class="section" id="resources-management">
<h3>Resources Management<a class="headerlink" href="#resources-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_resource_conflict">
struct resource * <code class="descname">request_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, conflict resource on error.</p>
<dl class="function">
<dt id="c.reallocate_resource">
int <code class="descname">reallocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;old</em>, resource_size_t<em>&nbsp;newsize</em>, struct resource_constraint *<em>&nbsp;constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reallocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a slot in the resource tree given range &amp; alignment. The resource will be relocated if the new size cannot be reallocated in the current location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">newsize</span></code></dt>
<dd>new size of the resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource_constraint</span> <span class="pre">*</span> <span class="pre">constraint</span></code></dt>
<dd>the size and alignment constraints to be met.</dd>
</dl>
<dl class="function">
<dt id="c.lookup_resource">
struct resource * <code class="descname">lookup_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, resource_size_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>find an existing resource by a resource start address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the resource if found, NULL otherwise</p>
<dl class="function">
<dt id="c.insert_resource_conflict">
struct resource * <code class="descname">insert_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, conflict resource if the resource can&#8217;t be inserted.</p>
<p>This function is equivalent to request_resource_conflict when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become children of
the new resource.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.insert_resource_expand_to_fit">
void <code class="descname">insert_resource_expand_to_fit</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_expand_to_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a resource into the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a resource into the resource tree, possibly expanding it in order
to make it encompass any conflicting resources.</p>
<dl class="function">
<dt id="c.resource_alignment">
resource_size_t <code class="descname">resource_alignment</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.resource_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate resource&#8217;s alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns alignment on success, 0 (invalid alignment) on failure.</p>
<dl class="function">
<dt id="c.release_mem_region_adjustable">
int <code class="descname">release_mem_region_adjustable</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_mem_region_adjustable" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hot-delete.  The requested region
is released from a currently busy memory resource.  The requested region
must either match exactly or fit into a single busy resource entry.  In
the latter case, the remaining resource is adjusted accordingly.
Existing children of the busy memory resource must be immutable in the
request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li>Additional release conditions, such as overlapping region, can be
supported after they are confirmed as valid cases.</li>
<li>When a busy memory resource gets split into two entries, the code
assumes that all children remain in the lower address entry for
simplicity.  Enhance this logic when necessary.</li>
</ul>
<dl class="function">
<dt id="c.request_resource">
int <code class="descname">request_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code on error.</p>
<dl class="function">
<dt id="c.release_resource">
int <code class="descname">release_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource pointer</dd>
</dl>
<dl class="function">
<dt id="c.region_intersects">
int <code class="descname">region_intersects</code><span class="sig-paren">(</span>resource_size_t<em>&nbsp;start</em>, size_t<em>&nbsp;size</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.region_intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>determine intersection of region with known resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>region start address</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>flags of resource (in iomem_resource)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt>
<dd>descriptor of resource (in iomem_resource) or IORES_DESC_NONE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the specified region partially overlaps or fully eclipses a
resource identified by <strong>flags</strong> and <strong>desc</strong> (optional with IORES_DESC_NONE).
Return REGION_DISJOINT if the region does not overlap <strong>flags</strong>/<strong>desc</strong>,
return REGION_MIXED if the region overlaps <strong>flags</strong>/<strong>desc</strong> and another
resource, and return REGION_INTERSECTS if the region overlaps <strong>flags</strong>/<strong>desc</strong>
and no other defined resource. Note that REGION_INTERSECTS is also
returned in the case when the specified region overlaps RAM and undefined
memory holes.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">region_intersect()</span></code> is used by memory remapping functions to ensure
the user is not remapping RAM and is a vast speed up over walking
through the resource table page by page.</p>
<dl class="function">
<dt id="c.allocate_resource">
int <code class="descname">allocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em>, resource_size_t<em>&nbsp;size</em>, resource_size_t<em>&nbsp;min</em>, resource_size_t<em>&nbsp;max</em>, resource_size_t<em>&nbsp;align</em>, resource_size_t (*alignf) (void<em>&nbsp;*</em>, const struct resource<em>&nbsp;*</em>, resource_size_t, resource_size_t, void *<em>&nbsp;alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate empty slot in the resource tree given range &amp; alignment. The resource will be reallocated with a new size if it was already allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>requested resource region size</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt>
<dd>minimum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">max</span></code></dt>
<dd>maximum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requested, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span> <span class="pre">alignf</span></code></dt>
<dd>alignment function, optional, called if not NULL</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">alignf_data</span></code></dt>
<dd>arbitrary data to pass to the <strong>alignf</strong> function</dd>
</dl>
<dl class="function">
<dt id="c.insert_resource">
int <code class="descname">insert_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EBUSY if the resource can&#8217;t be inserted.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.remove_resource">
int <code class="descname">remove_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EINVAL if the resource is not valid.</p>
<p>This function removes a resource previously inserted by <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>
or <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>, and moves the children (if any) up to
where they were before.  <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a> and <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>
insert a new resource, and move any conflicting resources down to the
children of the new resource.</p>
<p><a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>, <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a> and <a class="reference internal" href="#c.remove_resource" title="remove_resource"><code class="xref c c-func docutils literal"><span class="pre">remove_resource()</span></code></a> are
intended for producers of resources, such as FW modules and bus drivers.</p>
<dl class="function">
<dt id="c.adjust_resource">
int <code class="descname">adjust_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.adjust_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a resource&#8217;s start and size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource to modify</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>new start value</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>new size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an existing resource, change its start and size to match the
arguments.  Returns 0 on success, -EBUSY if it can&#8217;t fit.
Existing children of the resource are assumed to be immutable.</p>
<dl class="function">
<dt id="c.__request_region">
struct resource * <code class="descname">__request_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new busy resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>reserving caller&#8217;s ID string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>IO resource flags</dd>
</dl>
<dl class="function">
<dt id="c.__release_region">
void <code class="descname">__release_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The described resource region must match a currently busy region.</p>
<dl class="function">
<dt id="c.devm_request_resource">
int <code class="descname">devm_request_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root of the resource tree from which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a device-managed version of <a class="reference internal" href="#c.request_resource" title="request_resource"><code class="xref c c-func docutils literal"><span class="pre">request_resource()</span></code></a>. There is usually
no need to release resources requested by this function explicitly since
that will be taken care of when the device is unbound from its driver.
If for some reason the resource needs to be released explicitly, because
of ordering issues for example, drivers must call <a class="reference internal" href="#c.devm_release_resource" title="devm_release_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_release_resource()</span></code></a>
rather than the regular <a class="reference internal" href="#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal"><span class="pre">release_resource()</span></code></a>.</p>
<p>When a conflict is detected between any existing resources and the newly
requested resource, an error message will be printed.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.devm_release_resource">
void <code class="descname">devm_release_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously requested resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to release the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a resource previously requested using <a class="reference internal" href="#c.devm_request_resource" title="devm_request_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_request_resource()</span></code></a>.</p>
</div>
<div class="section" id="mtrr-handling">
<h3>MTRR Handling<a class="headerlink" href="#mtrr-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.arch_phys_wc_add">
int <code class="descname">arch_phys_wc_add</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;base</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_phys_wc_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a WC MTRR and handle errors if PAT is unavailable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt>
<dd>Physical base address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of region</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PAT is available, this does nothing.  If PAT is unavailable, it
attempts to add a WC MTRR covering size bytes starting at base and
logs an error if this fails.</p>
<p>The called should provide a power of two size on an equivalent
power of two boundary.</p>
<p>Drivers must store the return value to pass to mtrr_del_wc_if_needed,
but drivers should not try to interpret that return value.</p>
</div>
</div>
<div class="section" id="security-framework">
<h2>Security Framework<a class="headerlink" href="#security-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.security_init">
int <code class="descname">security_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.security_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the security framework</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called early in the kernel initialization sequence.</p>
<dl class="function">
<dt id="c.security_module_enable">
int <code class="descname">security_module_enable</code><span class="sig-paren">(</span>const char *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_module_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Load given security module on boot ?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>the name of the module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM must pass this method before registering its own operations
to avoid security registration races. This method may also be used
to check if your LSM is currently loaded during kernel initialization.</p>
<p><strong>Return</strong></p>
<p>true if:</p>
<ul class="simple">
<li>The passed LSM is the one chosen by user at boot time,</li>
<li>or the passed LSM is configured as the default and the user did not
choose an alternate LSM at boot time.</li>
</ul>
<p>Otherwise, return false.</p>
<dl class="function">
<dt id="c.security_add_hooks">
void <code class="descname">security_add_hooks</code><span class="sig-paren">(</span>struct security_hook_list *<em>&nbsp;hooks</em>, int<em>&nbsp;count</em>, char *<em>&nbsp;lsm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_add_hooks" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a modules hooks to the hook lists.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">security_hook_list</span> <span class="pre">*</span> <span class="pre">hooks</span></code></dt>
<dd>the hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">lsm</span></code></dt>
<dd>the name of the security module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM has to register its hooks with the infrastructure.</p>
<dl class="function">
<dt id="c.securityfs_create_file">
struct dentry * <code class="descname">securityfs_create_file</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_dir">
struct dentry * <code class="descname">securityfs_create_dir</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the directory to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_symlink">
struct dentry * <code class="descname">securityfs_create_symlink</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;target</em>, const struct inode_operations *<em>&nbsp;iops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symlink in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the symlink to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for the symlink.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>a pointer to a string containing the name of the symlink&#8217;s target.
If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the <strong>iops</strong> parameter needs to be
setup to handle .readlink and .get_link inode_operations.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode_operations</span> <span class="pre">*</span> <span class="pre">iops</span></code></dt>
<dd>a pointer to the struct inode_operations to use for the symlink. If
this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the default simple_symlink_inode
operations will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symlink in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_remove">
void <code class="descname">securityfs_remove</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a file or directory from the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the file or directory to be removed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
<a class="reference internal" href="#c.securityfs_create_file" title="securityfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">securityfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed. No automatic cleanup of files will happen when a module is
removed; you are responsible here.</p>
</div>
<div class="section" id="audit-interfaces">
<h2>Audit Interfaces<a class="headerlink" href="#audit-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.audit_log_start">
struct audit_buffer * <code class="descname">audit_log_start</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_start" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an audit buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context (may be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns audit_buffer pointer on success or NULL on error.</p>
<p>Obtain an audit buffer.  This routine does locking to obtain the
audit buffer, but then no locking is required for calls to
audit_log_*format.  If the task (ctx) is a task that is currently in a
syscall, then the syscall is marked as auditable and an audit record
will be written at syscall exit.  If there is no associated task, then
task context (ctx) should be NULL.</p>
<dl class="function">
<dt id="c.audit_log_format">
void <code class="descname">audit_log_format</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>format a message into the audit buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>audit_buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>optional parameters matching <strong>fmt</strong> string</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the work is done in audit_log_vformat.</p>
<dl class="function">
<dt id="c.audit_log_end">
void <code class="descname">audit_log_end</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_end" title="Permalink to this definition">¶</a></dt>
<dd><p>end one audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>the audit_buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can not do a netlink send inside an irq context because it blocks (last
arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
queue and a tasklet is scheduled to remove them from the queue outside the
irq context.  May be called in any context.</p>
<dl class="function">
<dt id="c.audit_log">
void <code class="descname">audit_log</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log an audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit context</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable parameters matching the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a convenience function that calls audit_log_start,
audit_log_vformat, and audit_log_end.  It may be called
in any context.</p>
<dl class="function">
<dt id="c.audit_log_secctx">
void <code class="descname">audit_log_secctx</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em>, u32<em>&nbsp;secid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_secctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts and logs SELinux context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>audit_buffer</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">secid</span></code></dt>
<dd>security number</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function that calls security_secid_to_secctx to convert
secid to secctx and then adds the (converted) SELinux context to the audit
log by calling audit_log_format, thus also preventing leak of internal secid
to userspace. If secid cannot be converted audit_panic is called.</p>
<dl class="function">
<dt id="c.audit_alloc">
int <code class="descname">audit_alloc</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an audit context block for a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filter on the task information and allocate a per-task audit context
if necessary.  Doing so turns on system call auditing for the
specified task.  This is called from copy_process, so no lock is
needed.</p>
<dl class="function">
<dt id="c.__audit_free">
void <code class="descname">__audit_free</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a per-task audit context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task whose audit context block to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from copy_process and do_exit</p>
<dl class="function">
<dt id="c.__audit_syscall_entry">
void <code class="descname">__audit_syscall_entry</code><span class="sig-paren">(</span>int<em>&nbsp;major</em>, unsigned long<em>&nbsp;a1</em>, unsigned long<em>&nbsp;a2</em>, unsigned long<em>&nbsp;a3</em>, unsigned long<em>&nbsp;a4</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in an audit record at syscall entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major syscall type (function)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a1</span></code></dt>
<dd>additional syscall register 1</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a2</span></code></dt>
<dd>additional syscall register 2</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a3</span></code></dt>
<dd>additional syscall register 3</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a4</span></code></dt>
<dd>additional syscall register 4</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in audit context at syscall entry.  This only happens if the
audit context was created when the task was created and the state or
filters demand the audit context be built.  If the state from the
per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,
then the record will be written at syscall exit time (otherwise, it
will only be written if another part of the kernel requests that it
be written).</p>
<dl class="function">
<dt id="c.__audit_syscall_exit">
void <code class="descname">__audit_syscall_exit</code><span class="sig-paren">(</span>int<em>&nbsp;success</em>, long<em>&nbsp;return_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate audit context after a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">success</span></code></dt>
<dd>success value of the syscall</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">return_code</span></code></dt>
<dd>return value of the syscall</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down after system call.  If the audit context has been marked as
auditable (either because of the AUDIT_RECORD_CONTEXT state from
filtering, or because some other part of the kernel wrote an audit
message), then write out the syscall information.  In call cases,
free the names stored from <code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_reusename">
struct filename * <code class="descname">__audit_reusename</code><span class="sig-paren">(</span>const __user char *<em>&nbsp;uptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_reusename" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out filename with info from existing entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">__user</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uptr</span></code></dt>
<dd>userland ptr to pathname</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the audit_names list for the current audit context. If there is an
existing entry with a matching &#8220;uptr&#8221; then return the filename
associated with that audit_name. If not, return NULL.</p>
<dl class="function">
<dt id="c.__audit_getname">
void <code class="descname">__audit_getname</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_getname" title="Permalink to this definition">¶</a></dt>
<dd><p>add a name to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a name to the list of audit names for this context.
Called from fs/namei.c:<code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_inode">
void <code class="descname">__audit_inode</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em>, const struct dentry *<em>&nbsp;dentry</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>store the inode and device from a lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name being audited</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry being audited</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>attributes for this particular entry</dd>
</dl>
<dl class="function">
<dt id="c.auditsc_get_stamp">
int <code class="descname">auditsc_get_stamp</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, struct timespec64 *<em>&nbsp;t</em>, unsigned int *<em>&nbsp;serial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.auditsc_get_stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get local copies of audit_context values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context for the task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>timespec64 to store time recorded in the audit_context</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">serial</span></code></dt>
<dd>serial value that is recorded in the audit_context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also sets the context as auditable.</p>
<dl class="function">
<dt id="c.audit_set_loginuid">
int <code class="descname">audit_set_loginuid</code><span class="sig-paren">(</span>kuid_t<em>&nbsp;loginuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_set_loginuid" title="Permalink to this definition">¶</a></dt>
<dd><p>set current task&#8217;s audit_context loginuid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kuid_t</span> <span class="pre">loginuid</span></code></dt>
<dd>loginuid value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0.</p>
<p>Called (set) from fs/proc/base.c::<code class="xref c c-func docutils literal"><span class="pre">proc_loginuid_write()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_mq_open">
void <code class="descname">__audit_mq_open</code><span class="sig-paren">(</span>int<em>&nbsp;oflag</em>, umode_t<em>&nbsp;mode</em>, struct mq_attr *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ open</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oflag</span></code></dt>
<dd>open flag</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>mode bits</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>queue attributes</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_sendrecv">
void <code class="descname">__audit_mq_sendrecv</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, size_t<em>&nbsp;msg_len</em>, unsigned int<em>&nbsp;msg_prio</em>, const struct timespec *<em>&nbsp;abs_timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_sendrecv" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ timed send/receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">msg_len</span></code></dt>
<dd>Message length</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msg_prio</span></code></dt>
<dd>Message priority</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec</span> <span class="pre">*</span> <span class="pre">abs_timeout</span></code></dt>
<dd>Message timeout in absolute time</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_notify">
void <code class="descname">__audit_mq_notify</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, const struct sigevent *<em>&nbsp;notification</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigevent</span> <span class="pre">*</span> <span class="pre">notification</span></code></dt>
<dd>Notification event</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_getsetattr">
void <code class="descname">__audit_mq_getsetattr</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, struct mq_attr *<em>&nbsp;mqstat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_getsetattr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ get/set attribute</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">mqstat</span></code></dt>
<dd>MQ flags</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_obj">
void <code class="descname">__audit_ipc_obj</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permissions</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_set_perm">
void <code class="descname">__audit_ipc_set_perm</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;qbytes</em>, uid_t<em>&nbsp;uid</em>, gid_t<em>&nbsp;gid</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_set_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for new ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">qbytes</span></code></dt>
<dd>msgq bytes</dd>
<dt><code class="docutils literal"><span class="pre">uid_t</span> <span class="pre">uid</span></code></dt>
<dd>msgq user id</dd>
<dt><code class="docutils literal"><span class="pre">gid_t</span> <span class="pre">gid</span></code></dt>
<dd>msgq group id</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>msgq mode (permissions)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called only after <code class="xref c c-func docutils literal"><span class="pre">audit_ipc_obj()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_socketcall">
int <code class="descname">__audit_socketcall</code><span class="sig-paren">(</span>int<em>&nbsp;nargs</em>, unsigned long *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_socketcall" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_socketcall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nargs</span></code></dt>
<dd>number of args, which should not be more than AUDITSC_ARGS.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>args array</dd>
</dl>
<dl class="function">
<dt id="c.__audit_fd_pair">
void <code class="descname">__audit_fd_pair</code><span class="sig-paren">(</span>int<em>&nbsp;fd1</em>, int<em>&nbsp;fd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_fd_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for pipe and socketpair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd1</span></code></dt>
<dd>the first file descriptor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd2</span></code></dt>
<dd>the second file descriptor</dd>
</dl>
<dl class="function">
<dt id="c.__audit_sockaddr">
int <code class="descname">__audit_sockaddr</code><span class="sig-paren">(</span>int<em>&nbsp;len</em>, void *<em>&nbsp;a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_bind, sys_connect, sys_sendto</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>data length in user space</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>data address in kernel space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or NULL context or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.audit_signal_info">
int <code class="descname">audit_signal_info</code><span class="sig-paren">(</span>int<em>&nbsp;sig</em>, struct task_struct *<em>&nbsp;t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_signal_info" title="Permalink to this definition">¶</a></dt>
<dd><p>record signal info for shutting down audit subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>task being signaled</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the audit subsystem is being terminated, record the task (pid)
and uid that is doing that.</p>
<dl class="function">
<dt id="c.__audit_log_bprm_fcaps">
int <code class="descname">__audit_log_bprm_fcaps</code><span class="sig-paren">(</span>struct linux_binprm *<em>&nbsp;bprm</em>, const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_bprm_fcaps" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about a loading bprm and relevant fcaps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*</span> <span class="pre">bprm</span></code></dt>
<dd>pointer to the bprm being processed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the proposed new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simply check if the proc already has the caps given by the file and if not
store the priv escalation info for later auditing at the end of the syscall</p>
<p>-Eric</p>
<dl class="function">
<dt id="c.__audit_log_capset">
void <code class="descname">__audit_log_capset</code><span class="sig-paren">(</span>const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_capset" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about the arguments to the capset syscall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old (current) credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the arguments userspace sent to sys_capset for later printing by the
audit system if applicable</p>
<dl class="function">
<dt id="c.audit_core_dumps">
void <code class="descname">audit_core_dumps</code><span class="sig-paren">(</span>long<em>&nbsp;signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_core_dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about processes that end abnormally</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">signr</span></code></dt>
<dd>signal value</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a process ends with a core dump, something fishy is going on and we
should record the event for investigation.</p>
<dl class="function">
<dt id="c.audit_rule_change">
int <code class="descname">audit_rule_change</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, int<em>&nbsp;seq</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;datasz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_rule_change" title="Permalink to this definition">¶</a></dt>
<dd><p>apply all rules to the specified message type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>payload data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">datasz</span></code></dt>
<dd>size of payload data</dd>
</dl>
<dl class="function">
<dt id="c.audit_list_rules_send">
int <code class="descname">audit_list_rules_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;request_skb</em>, int<em>&nbsp;seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_list_rules_send" title="Permalink to this definition">¶</a></dt>
<dd><p>list the audit rules</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">request_skb</span></code></dt>
<dd>skb of request we are replying to (used to target the reply)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
</dl>
<dl class="function">
<dt id="c.parent_len">
int <code class="descname">parent_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parent_len" title="Permalink to this definition">¶</a></dt>
<dd><p>find the length of the parent portion of a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>pathname of which to determine length</dd>
</dl>
<dl class="function">
<dt id="c.audit_compare_dname_path">
int <code class="descname">audit_compare_dname_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;dname</em>, const char *<em>&nbsp;path</em>, int<em>&nbsp;parentlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_compare_dname_path" title="Permalink to this definition">¶</a></dt>
<dd><p>compare given dentry name with last component in given path. Return of 0 indicates a match.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dname</span></code></dt>
<dd>dentry name that we&#8217;re comparing</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>full pathname that we&#8217;re comparing</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">parentlen</span></code></dt>
<dd>length of the parent if known. Passing in AUDIT_NAME_FULL
here indicates that we must compute this value.</dd>
</dl>
</div>
<div class="section" id="accounting-framework">
<h2>Accounting Framework<a class="headerlink" href="#accounting-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sys_acct">
long <code class="descname">sys_acct</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_acct" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable process accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>file name for accounting records or NULL to shutdown accounting</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative errno values for failure.</p>
<p><a class="reference internal" href="#c.sys_acct" title="sys_acct"><code class="xref c c-func docutils literal"><span class="pre">sys_acct()</span></code></a> is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.</p>
<dl class="function">
<dt id="c.acct_collect">
void <code class="descname">acct_collect</code><span class="sig-paren">(</span>long<em>&nbsp;exitcode</em>, int<em>&nbsp;group_dead</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>collect accounting information into pacct_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">exitcode</span></code></dt>
<dd>task exit code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">group_dead</span></code></dt>
<dd>not 0, if this thread is the last one in the process.</dd>
</dl>
<dl class="function">
<dt id="c.acct_process">
void <code class="descname">acct_process</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.acct_process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>handles process accounting for an exiting task</p>
</div>
<div class="section" id="block-devices">
<h2>Block Devices<a class="headerlink" href="#block-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.blk_delay_queue">
void <code class="descname">blk_delay_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_delay_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart queueing after defined interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">msecs</span></code></dt>
<dd>Delay in msecs</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Sometimes queueing needs to be postponed for a little while, to allow
resources to come back. This function will make sure that queueing is
restarted around the specified time.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue_async">
void <code class="descname">blk_start_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronously restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue_async" title="blk_start_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue_async()</span></code></a> will clear the stop flag on the queue, and
ensure that the request_fn for the queue is run from an async
context.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue">
void <code class="descname">blk_start_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> will clear the stop flag on the queue, and call
the request_fn for the queue if it was in a stopped state when
entered. Also see <a class="reference internal" href="#c.blk_stop_queue" title="blk_stop_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_stop_queue()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_stop_queue">
void <code class="descname">blk_stop_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The Linux block layer assumes that a block driver will consume all
entries on the request queue when the request_fn strategy is called.
Often this will not happen, because of hardware limitations (queue
depth settings). If a device driver gets a &#8216;queue full&#8217; response,
or if it simply chooses not to queue more I/O at one point, it can
call this function to prevent the request_fn from being called until
the driver has signalled it&#8217;s ready to go again. This happens by calling
<a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> to restart queue operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_sync_queue">
void <code class="descname">blk_sync_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_sync_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel any pending callbacks on a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
that the callbacks might use. The caller must already have made sure
that its -&gt;make_request_fn will not re-add plugging prior to calling
this function.</p>
<p>This function does not cancel any asynchronous activity arising
out of elevator or throttling code. That would require <code class="xref c c-func docutils literal"><span class="pre">elevator_exit()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">blkcg_exit_queue()</span></code> to be called with queue lock initialized.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__blk_run_queue_uncond">
void <code class="descname">__blk_run_queue_uncond</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>run a queue whether or not it has been stopped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on a queue if there are any pending requests.
May be used to restart request handling after a request has completed.
This variant runs the queue whether or not the queue has been
stopped. Must be called with the queue lock held and interrupts
disabled. See also <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_run_queue">
void <code class="descname">__blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue_async">
void <code class="descname">blk_run_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue in workqueue context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tells kblockd to perform the equivalent of <strong>blk_run_queue</strong> on behalf
of us.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>Since it is not allowed to run q-&gt;delay_work after <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>
has canceled q-&gt;delay_work, callers must hold the queue lock to avoid
race conditions between <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> and <a class="reference internal" href="#c.blk_run_queue_async" title="blk_run_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_run_queue_async()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue">
void <code class="descname">blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on this queue, if it has pending work to do.
May be used to restart queueing when a request has completed.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_bypass_start">
void <code class="descname">blk_queue_bypass_start</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_start" title="Permalink to this definition">¶</a></dt>
<dd><p>enter queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>In bypass mode, only the dispatch FIFO queue of <strong>q</strong> is used.  This
function makes <strong>q</strong> enter bypass mode and drains all requests which were
throttled or issued before.  On return, it&#8217;s guaranteed that no request
is being throttled or has ELVPRIV set and <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass()</span></code> <code class="docutils literal"><span class="pre">true</span></code>
inside queue or RCU read lock.</p>
<dl class="function">
<dt id="c.blk_queue_bypass_end">
void <code class="descname">blk_queue_bypass_end</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_end" title="Permalink to this definition">¶</a></dt>
<dd><p>leave queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Leave bypass mode and restore the normal queueing behavior.</p>
<p><strong>Note</strong></p>
<p>although <a class="reference internal" href="#c.blk_queue_bypass_start" title="blk_queue_bypass_start"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass_start()</span></code></a> is only called for blk-sq queues,
this function is called for both blk-sq and blk-mq queues.</p>
<dl class="function">
<dt id="c.blk_cleanup_queue">
void <code class="descname">blk_cleanup_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cleanup_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to shutdown</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>q</strong> DYING, drain all pending requests, mark <strong>q</strong> DEAD, destroy and
put it.  All future requests will be failed immediately with -ENODEV.</p>
<dl class="function">
<dt id="c.blk_init_queue">
struct request_queue * <code class="descname">blk_init_queue</code><span class="sig-paren">(</span>request_fn_proc *<em>&nbsp;rfn</em>, spinlock_t *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a request queue for use with a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">request_fn_proc</span> <span class="pre">*</span> <span class="pre">rfn</span></code></dt>
<dd>The function to be called to process requests that have been
placed on the queue.</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>Request queue spin lock</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a block device wishes to use the standard request handling procedures,
which sorts requests and coalesces adjacent requests, then it must
call <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>.  The function <strong>rfn</strong> will be called when there
are requests on the queue that need to be processed.  If the device
supports plugging, then <strong>rfn</strong> may not be called immediately when requests
are available on the queue, but may be called at some time later instead.
Plugged queues are generally unplugged when a buffer belonging to one
of the requests on the queue is needed, or due to memory pressure.</p>
<p><strong>rfn</strong> is not required, or even expected, to remove all requests off the
queue, but only as many as it can handle at a time.  If it does leave
requests on the queue, it is responsible for arranging that the requests
get dealt with eventually.</p>
<p>The queue spin lock must be held while manipulating the requests on the
request queue; this lock will be taken also from interrupt context, so irq
disabling is needed for it.</p>
<p>Function returns a pointer to the initialized request queue, or <code class="docutils literal"><span class="pre">NULL</span></code> if
it didn&#8217;t succeed.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a> must be paired with a <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> call
when the block device is deactivated (such as at module unload).</div></blockquote>
<dl class="function">
<dt id="c.blk_requeue_request">
void <code class="descname">blk_requeue_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_requeue_request" title="Permalink to this definition">¶</a></dt>
<dd><p>put a request back on queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to be inserted</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drivers often keep queueing requests until the hardware cannot accept
more, when that condition happens we need to put the request back
on the queue. Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.part_round_stats">
void <code class="descname">part_round_stats</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct hd_struct *<em>&nbsp;part</em><span class="sig-paren">)</span><a class="headerlink" href="#c.part_round_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Round off the performance stats on a struct disk_stats.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu number for stats access</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>target partition</dd>
</dl>
<p><strong>Description</strong></p>
<p>The average IO queue length and utilisation statistics are maintained
by observing the current state of the queue length and the amount of
time it has been in this state for.</p>
<p>Normally, that accounting is done on IO completion, but that can result
in more than a second&#8217;s worth of IO being accounted for within any one
second, leading to &gt;100% utilisation.  To deal with that, we call this
function to do a round-off before returning the results when reading
/proc/diskstats.  This accounts immediately for all queue usage up to
the current jiffies and restarts the counters again.</p>
<dl class="function">
<dt id="c.generic_make_request">
blk_qc_t <code class="descname">generic_make_request</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The bio describing the location in memory and on the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> is used to make I/O requests of block
devices. It is passed a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, which describes the I/O that needs
to be done.</p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> does not return any status.  The
success/failure status of the request, along with notification of
completion, is delivered asynchronously through the bio-&gt;bi_end_io
function described (one day) else where.</p>
<p>The caller of generic_make_request must make sure that bi_io_vec
are set to describe the memory buffer, and that bi_dev and bi_sector are
set to describe the device address, and the
bi_end_io and optionally bi_private are set to describe how
completion notification should be signaled.</p>
<p>generic_make_request and the drivers it calls may use bi_next if this
bio happens to be merged with someone else, and may resubmit the bio to
a lower device by calling into generic_make_request recursively, which
means the bio should NOT be touched after the call to -&gt;make_request_fn.</p>
<dl class="function">
<dt id="c.submit_bio">
blk_qc_t <code class="descname">submit_bio</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio to the block device layer for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code></a> is very similar in purpose to <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a>, and
uses that function to do most of the work. Both are fairly rough
interfaces; <strong>bio</strong> must be presetup and ready for I/O.</p>
<dl class="function">
<dt id="c.blk_insert_cloned_request">
blk_status_t <code class="descname">blk_insert_cloned_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_insert_cloned_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for stacking drivers to submit a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue to submit the request</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being queued</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_err_bytes">
unsigned int <code class="descname">blk_rq_err_bytes</code><span class="sig-paren">(</span>const struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_err_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>determine number of bytes till the next failure boundary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to examine</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A request could be merge of IOs which require different failure
handling.  This function determines the number of bytes which
can be failed from the beginning of the request without
crossing into area which need to be retried further.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>The number of bytes to fail.</div></blockquote>
<dl class="function">
<dt id="c.blk_peek_request">
struct request * <code class="descname">blk_peek_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_peek_request" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the top of a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The returned request
should be started using <a class="reference internal" href="#c.blk_start_request" title="blk_start_request"><code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code></a> before LLD starts
processing it.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_request">
void <code class="descname">blk_start_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>start request processing on the driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request to dequeue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Dequeue <strong>req</strong> and start timeout timer on it.  This hands off the
request to the driver.</p>
<p>Block internal functions which don&#8217;t want to start timer should
call <code class="xref c c-func docutils literal"><span class="pre">blk_dequeue_request()</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_fetch_request">
struct request * <code class="descname">blk_fetch_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_fetch_request" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a request from a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to fetch a request from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The request is started on
return and LLD can start processing it immediately.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_update_request">
bool <code class="descname">blk_update_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_update_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Special helper function for request stacking drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>req</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ends I/O on a number of bytes attached to <strong>req</strong>, but doesn&#8217;t complete
the request structure even if <strong>req</strong> doesn&#8217;t have leftover.
If <strong>req</strong> has leftover, sets it up for the next range of segments.</p>
<p>This special helper function is only for request stacking drivers
(e.g. request-based dm) so that they can handle partial completion.
Actual device drivers should use blk_end_request instead.</p>
<p>Passing the result of <code class="xref c c-func docutils literal"><span class="pre">blk_rq_bytes()</span></code> as <strong>nr_bytes</strong> guarantees
<code class="docutils literal"><span class="pre">false</span></code> return from this function.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - this request doesn&#8217;t have any more data
<code class="docutils literal"><span class="pre">true</span></code>  - this request has more data</div></blockquote>
<dl class="function">
<dt id="c.blk_unprep_request">
void <code class="descname">blk_unprep_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unprep_request" title="Permalink to this definition">¶</a></dt>
<dd><p>unprepare a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes a request ready for complete resubmission (or
completion).  It happens only after all error handling is complete,
so represents the appropriate moment to deallocate any resources
that were allocated to the request in the prep_rq_fn.  The queue
lock is held when calling this.</p>
<dl class="function">
<dt id="c.blk_end_request">
bool <code class="descname">blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong>.
If <strong>rq</strong> has leftover, sets it up for the next range of segments.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_end_request_all">
void <code class="descname">blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request">
bool <code class="descname">__blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called with queue lock held unlike <a class="reference internal" href="#c.blk_end_request" title="blk_end_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_request()</span></code></a>.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_all">
void <code class="descname">__blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.  Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_cur">
bool <code class="descname">__blk_end_request_cur</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to finish the current request chunk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish the current chunk for</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Complete the current consecutively mapped chunk from <strong>rq</strong>.  Must
be called with queue lock held.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.rq_flush_dcache_pages">
void <code class="descname">rq_flush_dcache_pages</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rq_flush_dcache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to flush all pages in a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be flushed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flush all pages in <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_lld_busy">
int <code class="descname">blk_lld_busy</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_lld_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if underlying low-level drivers of a device are busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if underlying low-level drivers of a device are busy.
If the drivers want to export their busy state, they must set own
exporting function using <code class="xref c c-func docutils literal"><span class="pre">blk_queue_lld_busy()</span></code> first.</p>
<p>Basically, this function is used only by request stacking drivers
to stop dispatching requests to underlying devices when underlying
devices are busy.  This behavior helps more I/O merging on the queue
of the request stacking driver and prevents I/O throughput regression
on burst I/O load.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0 - Not busy (The request stacking driver should dispatch request)
1 - Busy (The request stacking driver should stop dispatching request)</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_unprep_clone">
void <code class="descname">blk_rq_unprep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unprep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to free all bios in a cloned request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the clone request to be cleaned up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Free all bios in <strong>rq</strong> for a cloned request.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_prep_clone">
int <code class="descname">blk_rq_prep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, struct request *<em>&nbsp;rq_src</em>, struct bio_set *<em>&nbsp;bs</em>, gfp_t<em>&nbsp;gfp_mask</em>, int (*bio_ctr) (struct bio<em>&nbsp;*</em>, struct bio<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_prep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to setup clone request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq_src</span></code></dt>
<dd>original request to be cloned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio_set that bios for clone are allocated from</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation mask for bio</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">bio_ctr</span></code></dt>
<dd>setup function to be called for each clone bio.
Returns <code class="docutils literal"><span class="pre">0</span></code> for success, non <code class="docutils literal"><span class="pre">0</span></code> for failure.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data to be passed to <strong>bio_ctr</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Clones bios in <strong>rq_src</strong> to <strong>rq</strong>, and copies attributes of <strong>rq_src</strong> to <strong>rq</strong>.
The actual data parts of <strong>rq_src</strong> (e.g. -&gt;cmd, -&gt;sense)
are not copied, and copying such parts is the caller&#8217;s responsibility.
Also, pages which the original bios are pointing to are not copied
and the cloned bios just point same pages.
So cloned bios must be completed before original bios, which means
the caller must complete <strong>rq</strong> before <strong>rq_src</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_plug">
void <code class="descname">blk_start_plug</code><span class="sig-paren">(</span>struct blk_plug *<em>&nbsp;plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize blk_plug and track it inside the task_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> that needs to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tracking blk_plug inside the task_struct will help with auto-flushing the
pending I/O should the task end up blocking between <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal"><span class="pre">blk_start_plug()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">blk_finish_plug()</span></code>. This is important from a performance perspective, but
also ensures that we don&#8217;t deadlock. For instance, if the task is blocking
for a memory allocation, memory reclaim could end up wanting to free a
page belonging to that request that is currently residing in our private
plug. By flushing the pending I/O when the process goes to sleep, we avoid
this kind of deadlock.</div></blockquote>
<dl class="function">
<dt id="c.blk_pm_runtime_init">
void <code class="descname">blk_pm_runtime_init</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pm_runtime_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Block layer runtime PM initialization routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device the queue belongs to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize runtime-PM-related fields for <strong>q</strong> and start auto suspend for
<strong>dev</strong>. Drivers that want to take advantage of request-based runtime PM
should call this function after <strong>dev</strong> has been initialized, and its
request queue <strong>q</strong> has been allocated, and runtime PM for it can not happen
yet(either due to disabled/forbidden or its usage_count &gt; 0). In most
cases, driver should call this function before any I/O has taken place.</p>
<p>This function takes care of setting up using auto suspend for the device,
the autosuspend delay is set to -1 to make runtime suspend impossible
until an updated value is either set by user or by driver. Drivers do
not need to touch other autosuspend settings.</p>
<p>The block layer runtime PM is request based, so only works for drivers
that use request as their IO unit instead of those directly use bio&#8217;s.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_suspend">
int <code class="descname">blk_pre_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime suspend check</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function will check if runtime suspend is allowed for the device
by examining if there are any requests pending in the queue. If there
are requests pending, the device can not be runtime suspended; otherwise,
the queue&#8217;s status will be updated to SUSPENDING and the driver can
proceed to suspend the device.</p>
<p>For the not allowed case, we mark last busy for the device so that
runtime PM core will try to autosuspend it some time later.</p>
<p>This function should be called near the start of the device&#8217;s
runtime_suspend callback.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0            - OK to runtime suspend the device
-EBUSY       - Device should not be runtime suspended</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_suspend">
void <code class="descname">blk_post_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime suspend processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device&#8217;s runtime_suspend function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status according to the return value of the
device&#8217;s runtime suspend function and mark last busy for the device so
that PM core will try to auto suspend the device at a later time.</p>
<p>This function should be called near the end of the device&#8217;s
runtime_suspend callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_resume">
void <code class="descname">blk_pre_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status to RESUMING in preparation for the
runtime resume of the device.</p>
<p>This function should be called near the start of the device&#8217;s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_resume">
void <code class="descname">blk_post_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device&#8217;s runtime_resume function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status according to the return value of the
device&#8217;s runtime_resume function. If it is successfully resumed, process
the requests that are queued into the device&#8217;s queue when it is resuming
and then mark last busy and initiate autosuspend for it.</p>
<p>This function should be called near the end of the device&#8217;s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_runtime_active">
void <code class="descname">blk_set_runtime_active</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_runtime_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Force runtime status of the queue to be active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device is left runtime suspended during system suspend the resume
hook typically resumes the device and corrects runtime status
accordingly. However, that does not affect the queue runtime PM status
which is still &#8220;suspended&#8221;. This prevents processing requests from the
queue.</p>
<p>This function can be used in driver&#8217;s resume hook to correct queue
runtime PM status and re-enable peeking requests from the queue. It
should be called before first request is added to the queue.</p>
<dl class="function">
<dt id="c.__blk_drain_queue">
void <code class="descname">__blk_drain_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;drain_all</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_drain_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>drain requests from request_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to drain</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">drain_all</span></code></dt>
<dd>whether to drain all requests or only the ones w/ ELVPRIV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drain requests from <strong>q</strong>.  If <strong>drain_all</strong> is set, all requests are drained.
If not, only ELVPRIV requests are drained.  The caller is responsible
for ensuring that no new requests which need to be drained are queued.</p>
<dl class="function">
<dt id="c.__get_request">
struct request * <code class="descname">__get_request</code><span class="sig-paren">(</span>struct request_list *<em>&nbsp;rl</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_list</span> <span class="pre">*</span> <span class="pre">rl</span></code></dt>
<dd>request list to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  This function may fail under memory
pressure or if <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.get_request">
struct request * <code class="descname">get_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue to allocate request from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  If <code class="docutils literal"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> is set in <strong>gfp_mask</strong>,
this function keeps retrying under memory pressure and fails iff <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.blk_attempt_plug_merge">
bool <code class="descname">blk_attempt_plug_merge</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, unsigned int *<em>&nbsp;request_count</em>, struct request **<em>&nbsp;same_queue_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_attempt_plug_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge with <code class="docutils literal"><span class="pre">current</span></code>&#8216;s plugged list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue new bio is being queued at</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>new bio being queued</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">request_count</span></code></dt>
<dd>out parameter for number of traversed plugged requests</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">**</span> <span class="pre">same_queue_rq</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> that gets filled in when
another request associated with <strong>q</strong> is found on the plug list
(optional, may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether <strong>bio</strong> being queued on <strong>q</strong> can be merged with a request
on <code class="docutils literal"><span class="pre">current</span></code>&#8216;s plugged list.  Returns <code class="docutils literal"><span class="pre">true</span></code> if merge was successful,
otherwise <code class="docutils literal"><span class="pre">false</span></code>.</p>
<p>Plugging coalesces IOs from the same issuer for the same purpose without
going through <strong>q</strong>-&gt;queue_lock.  As such it&#8217;s more of an issuing mechanism
than scheduling, and the request, while may have elvpriv data, is not
added on the elevator at this point.  In addition, we don&#8217;t have
reliable access to the elevator outside queue lock.  Only check basic
merging parameters without querying the elevator.</p>
<p>Caller must ensure !blk_queue_nomerges(q) beforehand.</p>
<dl class="function">
<dt id="c.blk_cloned_rq_check_limits">
int <code class="descname">blk_cloned_rq_check_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cloned_rq_check_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to check a cloned request for new the queue limits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>rq</strong> may have been made based on weaker limitations of upper-level queues
in request stacking drivers, and it may violate the limitation of <strong>q</strong>.
Since the block layer and the underlying device driver trust <strong>rq</strong>
after it is inserted to <strong>q</strong>, it should be checked against <strong>q</strong> before
the insertion using this generic function.</p>
<p>Request stacking drivers like request-based dm may change the queue
limits when retrying requests on other queues. Those requests need
to be checked against the new queue limits again during dispatch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_end_bidi_request">
bool <code class="descname">blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong> and <strong>rq</strong>-&gt;next_rq.
Drivers that supports bidi can safely call this member for any
type of request, bidi or uni.  In the later case <strong>bidi_bytes</strong> is
just ignored.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_bidi_request">
bool <code class="descname">__blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request with queue lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Identical to <a class="reference internal" href="#c.blk_end_bidi_request" title="blk_end_bidi_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_bidi_request()</span></code></a> except that queue lock is
assumed to be locked on entry and remains so on return.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_user_iov">
int <code class="descname">blk_rq_map_user_iov</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, struct rq_map_data *<em>&nbsp;map_data</em>, const struct iov_iter *<em>&nbsp;iter</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_user_iov" title="Permalink to this definition">¶</a></dt>
<dd><p>map user data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to map data to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rq_map_data</span> <span class="pre">*</span> <span class="pre">map_data</span></code></dt>
<dd>pointer to the rq_map_data holding pages (if necessary)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>iovec iterator</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly for zero copy I/O, if possible. Otherwise
a kernel bounce buffer is used.</p>
<p>A matching <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> must be issued at the end of I/O, while
still in process context.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>The mapped bio may need to be bounced through <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code></dt>
<dd>before being submitted to the device, as pages mapped may be out of
reach. It&#8217;s the callers responsibility to make sure this happens. The
original bio must be passed back in to <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> for proper
unmapping.</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_unmap_user">
int <code class="descname">blk_rq_unmap_user</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unmap_user" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a request with user data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>start of bio list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Unmap a rq previously mapped by <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code>. The caller must
supply the original rq-&gt;bio from the <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code> return, since
the I/O completion may have changed rq-&gt;bio.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_kern">
int <code class="descname">blk_rq_map_kern</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, void *<em>&nbsp;kbuf</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>map kernel data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to fill</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kbuf</span></code></dt>
<dd>the kernel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of user data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Data will be mapped directly if possible. Otherwise a bounce
buffer is used. Can be called multiple times to append multiple
buffers.</div></blockquote>
<dl class="function">
<dt id="c.__blk_release_queue">
void <code class="descname">__blk_release_queue</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_release_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>release a request queue when it is no longer needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>pointer to the release_work member of the request queue to be released</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>blk_release_queue is the counterpart of <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>. It should be
called when a request queue is being released; typically when a block
device is being de-registered. Its primary task it to free the queue
itself.</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The low level driver must have finished any outstanding requests first
via <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>.</p>
<p>Although <code class="xref c c-func docutils literal"><span class="pre">blk_release_queue()</span></code> may be called with preemption disabled,
<a class="reference internal" href="#c.__blk_release_queue" title="__blk_release_queue"><code class="xref c c-func docutils literal"><span class="pre">__blk_release_queue()</span></code></a> may sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_prep_rq">
void <code class="descname">blk_queue_prep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, prep_rq_fn *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_prep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set a prepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">prep_rq_fn</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>prepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible for a queue to register a prepare_request callback which
is invoked before the request is handed to the request_fn. The goal of
the function is to prepare a request for I/O, it can be used to build a
cdb from the request data for instance.</p>
<dl class="function">
<dt id="c.blk_queue_unprep_rq">
void <code class="descname">blk_queue_unprep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unprep_rq_fn *<em>&nbsp;ufn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_unprep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set an unprepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">unprep_rq_fn</span> <span class="pre">*</span> <span class="pre">ufn</span></code></dt>
<dd>unprepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible for a queue to register an unprepare_request callback
which is invoked before the request is finally completed. The goal
of the function is to deallocate any data that was allocated in the
prepare_request callback.</p>
<dl class="function">
<dt id="c.blk_set_default_limits">
void <code class="descname">blk_set_default_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_default_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>reset limits to default values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_stacking_limits">
void <code class="descname">blk_set_stacking_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_stacking_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>set default limits for stacking devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state. Should be used
by stacking drivers like DM that have no internal limits.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_make_request">
void <code class="descname">blk_queue_make_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, make_request_fn *<em>&nbsp;mfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>define an alternate make_request function for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device to be affected</dd>
<dt><code class="docutils literal"><span class="pre">make_request_fn</span> <span class="pre">*</span> <span class="pre">mfn</span></code></dt>
<dd>the alternate make_request function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The normal way for <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bios</span></code> to be passed to a device
driver is for them to be collected into requests on a request
queue, and then to allow the device driver to select requests
off that queue when it is ready.  This works well for many block
devices. However some block devices (typically virtual devices
such as md or lvm) do not benefit from the processing on the
request queue, and are served best by having the requests passed
directly to them.  This can be achieved by providing a function
to <a class="reference internal" href="#c.blk_queue_make_request" title="blk_queue_make_request"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_make_request()</span></code></a>.</div></blockquote>
<dl class="docutils">
<dt>Caveat:</dt>
<dd>The driver that does this <em>must</em> be able to deal appropriately
with buffers in &#8220;highmemory&#8221;. This can be accomplished by either calling
<code class="xref c c-func docutils literal"><span class="pre">__bio_kmap_atomic()</span></code> to get a temporary kernel mapping, or by calling
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code> to create a buffer in normal memory.</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_bounce_limit">
void <code class="descname">blk_queue_bounce_limit</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, u64<em>&nbsp;max_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bounce_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set bounce buffer limit for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">max_addr</span></code></dt>
<dd>the maximum address the device can handle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Different hardware can have different requirements as to what pages
it can do I/O directly to. A low level driver can call
blk_queue_bounce_limit to have lower memory pages allocated as bounce
buffers for doing I/O to pages residing above <strong>max_addr</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_hw_sectors">
void <code class="descname">blk_queue_max_hw_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_hw_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_hw_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_hw_sectors</span></code></dt>
<dd>max hardware sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set a hard upper limit,
max_hw_sectors, on the size of requests.  max_hw_sectors is set by
the device driver based upon the capabilities of the I/O
controller.</p>
<p>max_dev_sectors is a hard limit imposed by the storage device for
READ/WRITE requests. It is set by the disk driver.</p>
<p>max_sectors is a soft limit imposed by the block layer for
filesystem type requests.  This value can be overridden on a
per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.
The soft limit can not exceed max_hw_sectors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_chunk_sectors">
void <code class="descname">blk_queue_chunk_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;chunk_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_chunk_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set size of the chunk for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">chunk_sectors</span></code></dt>
<dd>chunk sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If a driver doesn&#8217;t want IOs to cross a given chunk size, it can set
this limit and prevent merging across chunks. Note that the chunk size
must currently be a power-of-2 in sectors. Also note that the block
layer must accept a page worth of data at any offset. So if the
crossing of chunks is a hard limitation in the driver, it must still be
prepared to split single page bios.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_sectors">
void <code class="descname">blk_queue_max_discard_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_discard_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_discard_sectors</span></code></dt>
<dd>maximum number of sectors to discard</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_same_sectors">
void <code class="descname">blk_queue_max_write_same_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_same_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_same_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write same</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_same_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_zeroes_sectors">
void <code class="descname">blk_queue_max_write_zeroes_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_zeroes_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_zeroes_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write zeroes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_zeroes_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_segments">
void <code class="descname">blk_queue_max_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max hw segments for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
hw data segments in a request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_segments">
void <code class="descname">blk_queue_max_discard_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segments for discard requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
segments in a discard request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_segment_size">
void <code class="descname">blk_queue_max_segment_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segment_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segment size for blk_rq_map_sg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_size</span></code></dt>
<dd>max size of segment in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the size of a
coalesced segment</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_logical_block_size">
void <code class="descname">blk_queue_logical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_logical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set logical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">size</span></code></dt>
<dd>the logical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible block size that the
storage device can address.  The default of 512 covers most
hardware.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_physical_block_size">
void <code class="descname">blk_queue_physical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_physical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the physical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible sector size that the
hardware can operate on without reverting to read-modify-write
operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_alignment_offset">
void <code class="descname">blk_queue_alignment_offset</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_alignment_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block alignment offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>alignment offset in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices are naturally misaligned to compensate for things like
the legacy DOS partition table 63-sector offset.  Low-level drivers
should call this function for devices whose first sector is not
naturally aligned.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_min">
void <code class="descname">blk_limits_io_min</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices have an internal block size bigger than the reported
hardware sector size.  This function can be used to signal the
smallest I/O the device can perform without incurring a performance
penalty.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_min">
void <code class="descname">blk_queue_io_min</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report a granularity or preferred minimum I/O
size which is the smallest request the device can perform without
incurring a performance penalty.  For disk drives this is often the
physical block size.  For RAID arrays it is often the stripe chunk
size.  A properly aligned multiple of minimum_io_size is the
preferred request size for workloads where a high number of I/O
operations is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_opt">
void <code class="descname">blk_limits_io_opt</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device&#8217;s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_opt">
void <code class="descname">blk_queue_io_opt</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>optimal request size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device&#8217;s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_stack_limits">
void <code class="descname">blk_queue_stack_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;t</em>, struct request_queue *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>inherit underlying queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying device (bottom)</dd>
</dl>
<dl class="function">
<dt id="c.blk_stack_limits">
int <code class="descname">blk_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct queue_limits *<em>&nbsp;b</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue_limits for stacked devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying queue limits (bottom, component device)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is used by stacking drivers like MD and DM to ensure
that all component devices have compatible block sizes and
alignments.  The stacking driver must provide a queue_limits
struct (top) and then iteratively call the stacking function for
all component (bottom) devices.  The stacking function will
attempt to combine the values and ensure proper alignment.</p>
<p>Returns 0 if the top and bottom queue_limits are compatible.  The
top device&#8217;s block sizes and alignment offsets may be adjusted to
ensure alignment with the bottom device. If no compatible sizes
and alignments exist, -1 is returned and the resulting top
queue_limits will have the misaligned flag set to indicate that
the alignment_offset is undefined.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bdev_stack_limits">
int <code class="descname">bdev_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the component block_device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges queue limits for a top device and a block_device.  Returns
0 if alignment didn&#8217;t change.  Returns -1 if adding the bottom
device caused misalignment.</div></blockquote>
<dl class="function">
<dt id="c.disk_stack_limits">
void <code class="descname">disk_stack_limits</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>MD/DM gendisk (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the underlying block device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt>
<dd>offset to beginning of data within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges the limits for a top level gendisk and a bottom level
block_device.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_dma_pad">
void <code class="descname">blk_queue_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>set pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_update_dma_pad">
void <code class="descname">blk_queue_update_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>update pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_dma_drain">
int <code class="descname">blk_queue_dma_drain</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, dma_drain_needed_fn *<em>&nbsp;dma_drain_needed</em>, void *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_drain" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up a drain buffer for excess dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">dma_drain_needed_fn</span> <span class="pre">*</span> <span class="pre">dma_drain_needed</span></code></dt>
<dd>fn which returns non-zero if drain is necessary</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>physically contiguous buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size of the buffer in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices have excess DMA problems and can&#8217;t simply discard (or
zero fill) the unwanted piece of the transfer.  They have to have a
real area of memory to transfer it into.  The use case for this is
ATAPI devices in DMA mode.  If the packet command causes a transfer
bigger than the transfer size some HBAs will lock up if there
aren&#8217;t DMA elements to contain the excess transfer.  What this API
does is adjust the queue so that the buf is always appended
silently to the scatterlist.</p>
<p><strong>Note</strong></p>
<p>This routine adjusts max_hw_segments to make room for appending
the drain buffer.  If you call <a class="reference internal" href="#c.blk_queue_max_segments" title="blk_queue_max_segments"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_max_segments()</span></code></a> after calling
this routine, you must set the limit to one fewer than your device
can support otherwise there won&#8217;t be room for the drain buffer.</p>
<dl class="function">
<dt id="c.blk_queue_segment_boundary">
void <code class="descname">blk_queue_segment_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_segment_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for segment merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_virt_boundary">
void <code class="descname">blk_queue_virt_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_virt_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for bio merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_dma_alignment">
void <code class="descname">blk_queue_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>set dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>set required memory and length alignment for direct dma transactions.
this is used when building direct io requests for the queue.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_update_dma_alignment">
void <code class="descname">blk_queue_update_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>update dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>update required memory and length alignment for direct dma transactions.
If the requested alignment is larger than the current alignment, then
the current queue alignment is updated to the new value, otherwise it
is left alone.  The design of this is to allow multiple objects
(driver, device, transport etc) to set their respective
alignments without having them interfere.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_queue_depth">
void <code class="descname">blk_set_queue_depth</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>tell the block layer about the device queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>queue depth</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_write_cache">
void <code class="descname">blk_queue_write_cache</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;wc</em>, bool<em>&nbsp;fua</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>configure queue&#8217;s write cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wc</span></code></dt>
<dd>write back cache on or off</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">fua</span></code></dt>
<dd>device supports FUA writes, if true</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about the write cache of <strong>q</strong>.</p>
<dl class="function">
<dt id="c.blk_execute_rq_nowait">
void <code class="descname">blk_execute_rq_nowait</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em>, rq_end_io_fn *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
<dt><code class="docutils literal"><span class="pre">rq_end_io_fn</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>I/O completion handler</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution.  Don&#8217;t wait for completion.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>This function will invoke <strong>done</strong> directly if the queue is dead.</div></blockquote>
<dl class="function">
<dt id="c.blk_execute_rq">
void <code class="descname">blk_execute_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution and wait for completion.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_flush">
int <code class="descname">blkdev_issue_flush</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, gfp_t<em>&nbsp;gfp_mask</em>, sector_t *<em>&nbsp;error_sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue flush for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">error_sector</span></code></dt>
<dd>error sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a flush for the block device in question. Caller can supply
room for storing the error offset in case of a flush error, if they
wish to.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_discard">
int <code class="descname">blkdev_issue_discard</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue discard for</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to discard</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>BLKDEV_DISCARD_* flags to control behaviour</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a discard request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_write_same">
int <code class="descname">blkdev_issue_write_same</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_write_same" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a write same operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>target blockdev</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page containing data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a write same request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.__blkdev_issue_zeroout">
int <code class="descname">__blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio **<em>&nbsp;biop</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>generate number of zero filed write bios</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">**</span> <span class="pre">biop</span></code></dt>
<dd>pointer to anchor bio</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.</p>
<p>Note that this function may fail with -EOPNOTSUPP if the driver signals
zeroing offload support, but the device fails to process the command (for
some devices there is no non-destructive way to verify whether this
operation is actually supported).  In this case the caller should call
retry the call to <a class="reference internal" href="#c.blkdev_issue_zeroout" title="blkdev_issue_zeroout"><code class="xref c c-func docutils literal"><span class="pre">blkdev_issue_zeroout()</span></code></a> and the fallback path will be used.</p>
<p>If a device is using logical block provisioning, the underlying space will
not be released if <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOUNMAP.</p>
<p>If <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOFALLBACK, the function will return
-EOPNOTSUPP if no explicit hardware offload for zeroing is provided.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_zeroout">
int <code class="descname">blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>zero-fill a block range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to write</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.  See <a class="reference internal" href="#c.__blkdev_issue_zeroout" title="__blkdev_issue_zeroout"><code class="xref c c-func docutils literal"><span class="pre">__blkdev_issue_zeroout()</span></code></a> for the
valid values for <code class="docutils literal"><span class="pre">flags</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_find_tag">
struct request * <code class="descname">blk_queue_find_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_find_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a request by its tag and queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>The tag of the request</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Should be used when a device returns a tag and you want to match
it with a request.</p>
<p>no locks need be held.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_free_tags">
void <code class="descname">blk_free_tags</code><span class="sig-paren">(</span>struct blk_queue_tag *<em>&nbsp;bqt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release a given set of tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">bqt</span></code></dt>
<dd>the tag map to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop the reference count on <strong>bqt</strong> and frees it when the last reference
is dropped.</p>
<dl class="function">
<dt id="c.blk_queue_free_tags">
void <code class="descname">blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>This is used to disable tagged queuing to a device, yet leave
queue in function.</div></blockquote>
<dl class="function">
<dt id="c.blk_init_tags">
struct blk_queue_tag * <code class="descname">blk_init_tags</code><span class="sig-paren">(</span>int<em>&nbsp;depth</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the tag info for an external tag map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_init_tags">
int <code class="descname">blk_queue_init_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;depth</em>, struct blk_queue_tag *<em>&nbsp;tags</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the queue tag info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">tags</span></code></dt>
<dd>the tag to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue lock must be held here if the function is called to resize an
existing map.</p>
<dl class="function">
<dt id="c.blk_queue_resize_tags">
int <code class="descname">blk_queue_resize_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;new_depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_resize_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>change the queueing depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_depth</span></code></dt>
<dd>the new max command queueing depth</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>Must be called with the queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_end_tag">
void <code class="descname">blk_queue_end_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_end_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>end tag operations for a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request that has completed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Typically called when <code class="xref c c-func docutils literal"><span class="pre">end_that_request_first()</span></code> returns <code class="docutils literal"><span class="pre">0</span></code>, meaning
all transfers have been done for a request. It&#8217;s important to call
this function before <code class="xref c c-func docutils literal"><span class="pre">end_that_request_last()</span></code>, as that will put the
request back on the free list thus corrupting the internal tag list.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_start_tag">
int <code class="descname">blk_queue_start_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_start_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a free tag and assign it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the block request that needs tagging</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This can either be used as a stand-alone helper, or possibly be
assigned as the queue <code class="xref c c-type docutils literal"><span class="pre">prep_rq_fn</span></code> (in which case <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code>
automagically gets a tag assigned). Note that this function
assumes that any type of request can be queued! if this is not
true for your device, you must check the request type before
calling this function.  The request will also be removed from
the request queue, so it&#8217;s the drivers responsibility to readd
it if it should need to be restarted for some reason.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_invalidate_tags">
void <code class="descname">blk_queue_invalidate_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_invalidate_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>invalidate all pending tags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Hardware conditions may dictate a need to stop all pending requests.
In this case, we will safely clear the block side of the tag queue and
readd all requests to the request queue in the right order.</div></blockquote>
<dl class="function">
<dt id="c.__blk_queue_free_tags">
void <code class="descname">__blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> will take care of calling this function, if tagging
has been used. So there&#8217;s no need to call this directly.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_count_integrity_sg">
int <code class="descname">blk_rq_count_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_count_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of integrity scatterlist elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of elements required in a
scatterlist corresponding to the integrity metadata in a bio.</p>
<dl class="function">
<dt id="c.blk_rq_map_integrity_sg">
int <code class="descname">blk_rq_map_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, struct scatterlist *<em>&nbsp;sglist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Map integrity metadata into a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sglist</span></code></dt>
<dd>target scatterlist</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the integrity vectors in request into a
scatterlist.  The scatterlist must be big enough to hold all
elements.  I.e. sized using <a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="blk_rq_count_integrity_sg"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_count_integrity_sg()</span></code></a>.</p>
<dl class="function">
<dt id="c.blk_integrity_compare">
int <code class="descname">blk_integrity_compare</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;gd1</em>, struct gendisk *<em>&nbsp;gd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare integrity profile of two disks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd1</span></code></dt>
<dd>Disk to compare</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd2</span></code></dt>
<dd>Disk to compare</dd>
</dl>
<p><strong>Description</strong></p>
<p>Meta-devices like DM and MD need to verify that all
sub-devices use the same integrity format before advertising to
upper layers that they can send/receive integrity metadata.  This
function can be used to check whether two gendisk devices have
compatible integrity formats.</p>
<dl class="function">
<dt id="c.blk_integrity_register">
void <code class="descname">blk_integrity_register</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct blk_integrity *<em>&nbsp;template</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a gendisk as being integrity-capable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk pointer to make integrity-aware</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_integrity</span> <span class="pre">*</span> <span class="pre">template</span></code></dt>
<dd>block integrity profile to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device needs to advertise itself as being able to
send/receive integrity metadata it must use this function to register
the capability with the block layer. The template is a blk_integrity
struct with values appropriate for the underlying hardware. See
Documentation/block/data-integrity.txt.</p>
<dl class="function">
<dt id="c.blk_integrity_unregister">
void <code class="descname">blk_integrity_unregister</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister block integrity profile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk whose integrity profile to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the integrity capability from
a block device.</p>
<dl class="function">
<dt id="c.blk_trace_ioctl">
int <code class="descname">blk_trace_ioctl</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, unsigned<em>&nbsp;cmd</em>, char __user *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the ioctls associated with tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the block device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">cmd</span></code></dt>
<dd>the ioctl cmd</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>the argument data, if any</dd>
</dl>
<dl class="function">
<dt id="c.blk_trace_shutdown">
void <code class="descname">blk_trace_shutdown</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>stop and cleanup trace structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue associated with the device</dd>
</dl>
<dl class="function">
<dt id="c.blk_add_trace_rq">
void <code class="descname">blk_add_trace_rq</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, int<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, u32<em>&nbsp;what</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>return status to log</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of completed bytes</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a request. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio">
void <code class="descname">blk_add_trace_bio</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, u32<em>&nbsp;what</em>, int<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>error, if any</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a bio. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio_remap">
void <code class="descname">blk_add_trace_bio_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper or raid target sometimes need to split a bio because
it spans a stripe (or similar). Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_rq_remap">
void <code class="descname">blk_add_trace_rq_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper remaps request to other devices.
Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_mangle_minor">
int <code class="descname">blk_mangle_minor</code><span class="sig-paren">(</span>int<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_mangle_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>scatter minor numbers apart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">minor</span></code></dt>
<dd>minor number to mangle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatter consecutively allocated <strong>minor</strong> number apart if MANGLE_DEVT
is enabled.  Mangling twice gives the original value.</p>
<p><strong>Return</strong></p>
<p>Mangled value.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.blk_alloc_devt">
int <code class="descname">blk_alloc_devt</code><span class="sig-paren">(</span>struct hd_struct *<em>&nbsp;part</em>, dev_t *<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_alloc_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dev_t for a partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>partition to allocate dev_t for</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">devt</span></code></dt>
<dd>out parameter for resulting dev_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dev_t for block device.</p>
<p><strong>Return</strong></p>
<p>0 on success, allocated dev_t is returned in <strong>*devt</strong>.  -errno on
failure.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.blk_free_devt">
void <code class="descname">blk_free_devt</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>free a dev_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>dev_t to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>devt</strong> which was allocated using <a class="reference internal" href="#c.blk_alloc_devt" title="blk_alloc_devt"><code class="xref c c-func docutils literal"><span class="pre">blk_alloc_devt()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_replace_part_tbl">
void <code class="descname">disk_replace_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct disk_part_tbl *<em>&nbsp;new_ptbl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_replace_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>replace disk-&gt;part_tbl in RCU-safe way</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to replace part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_tbl</span> <span class="pre">*</span> <span class="pre">new_ptbl</span></code></dt>
<dd>new part_tbl to install</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace disk-&gt;part_tbl with <strong>new_ptbl</strong> in RCU-safe way.  The
original ptbl is freed using RCU callback.</p>
<p>LOCKING:
Matching bd_mutx locked.</p>
<dl class="function">
<dt id="c.disk_expand_part_tbl">
int <code class="descname">disk_expand_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_expand_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>expand disk-&gt;part_tbl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to expand part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>expand such that this partno can fit in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expand disk-&gt;part_tbl such that <strong>partno</strong> can fit in.  disk-&gt;part_tbl
uses RCU to allow unlocked dereferencing for stats and other stuff.</p>
<p>LOCKING:
Matching bd_mutex locked, might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.disk_block_events">
void <code class="descname">disk_block_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_block_events" title="Permalink to this definition">¶</a></dt>
<dd><p>block and flush disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to block events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return from this function, it is guaranteed that event checking
isn&#8217;t in progress and won&#8217;t happen until unblocked by
<a class="reference internal" href="#c.disk_unblock_events" title="disk_unblock_events"><code class="xref c c-func docutils literal"><span class="pre">disk_unblock_events()</span></code></a>.  Events blocking is counted and the actual
unblocking happens after the matching number of unblocks are done.</p>
<p>Note that this intentionally does not block event checking from
<a class="reference internal" href="#c.disk_clear_events" title="disk_clear_events"><code class="xref c c-func docutils literal"><span class="pre">disk_clear_events()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_unblock_events">
void <code class="descname">disk_unblock_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_unblock_events" title="Permalink to this definition">¶</a></dt>
<dd><p>unblock disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to unblock events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.disk_block_events" title="disk_block_events"><code class="xref c c-func docutils literal"><span class="pre">disk_block_events()</span></code></a>.  When the block count reaches zero, it
starts events polling if configured.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.  Safe to call from irq context.</p>
<dl class="function">
<dt id="c.disk_flush_events">
void <code class="descname">disk_flush_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_flush_events" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule immediate event checking and flushing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to check and flush events for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>events to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule immediate event checking on <strong>disk</strong> if not blocked.  Events in
<strong>mask</strong> are scheduled to be cleared from the driver.  Note that this
doesn&#8217;t clear the events from <strong>disk</strong>-&gt;ev.</p>
<p><strong>Context</strong></p>
<p>If <strong>mask</strong> is non-zero must be called with bdev-&gt;bd_mutex held.</p>
<dl class="function">
<dt id="c.disk_clear_events">
unsigned int <code class="descname">disk_clear_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_clear_events" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously check, clear and return pending events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to fetch and clear events from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>mask of events to be fetched and cleared</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disk events are synchronously checked and pending events in <strong>mask</strong>
are cleared and returned.  This ignores the block count.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_get_part">
struct hd_struct * <code class="descname">disk_get_part</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_get_part" title="Permalink to this definition">¶</a></dt>
<dd><p>get partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to look partition from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for partition <strong>partno</strong> from <strong>disk</strong>.  If found, increment
reference count and return it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<p><strong>Return</strong></p>
<p>Pointer to the found partition on success, NULL if not found.</p>
<dl class="function">
<dt id="c.disk_part_iter_init">
void <code class="descname">disk_part_iter_init</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em>, struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize partition iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to iterate over</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>DISK_PITER_* flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>piter</strong> so that it iterates over partitions of <strong>disk</strong>.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_next">
struct hd_struct * <code class="descname">disk_part_iter_next</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>proceed iterator to the next partition and return it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>piter</strong> to the next partition and return it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_exit">
void <code class="descname">disk_part_iter_exit</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish up partition iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iter of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when iteration is over.  Cleans up <strong>piter</strong>.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_map_sector_rcu">
struct hd_struct * <code class="descname">disk_map_sector_rcu</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, sector_t<em>&nbsp;sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_map_sector_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>map sector to partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>sector to map</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out which partition <strong>sector</strong> maps to on <strong>disk</strong>.  This is
primarily used for stats accounting.</p>
<p><strong>Context</strong></p>
<p>RCU read locked.  The returned partition pointer is valid only
while preemption is disabled.</p>
<p><strong>Return</strong></p>
<p>Found partition on success, part0 is returned if no partition matches</p>
<dl class="function">
<dt id="c.register_blkdev">
int <code class="descname">register_blkdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_blkdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>the requested major device number [1..255]. If <strong>major</strong> = 0, try to
allocate any unused major number.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the new block device as a zero terminated string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>name</strong> must be unique within the system.</p>
<p>The return value depends on the <strong>major</strong> input parameter:</p>
<blockquote>
<div><ul class="simple">
<li>if a major device number was requested in range [1..255] then the
function returns zero on success, or a negative error code</li>
<li>if any unused major number was requested with <strong>major</strong> = 0 parameter
then the return value is the allocated major number in range
[1..255] or a negative error code otherwise</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.device_add_disk">
void <code class="descname">device_add_disk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>add partitioning information to kernel list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the disk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>per-device partitioning information</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the partitioning information in <strong>disk</strong>
with the kernel.</p>
<p>FIXME: error handling</p>
<dl class="function">
<dt id="c.get_gendisk">
struct gendisk * <code class="descname">get_gendisk</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em>, int *<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_gendisk" title="Permalink to this definition">¶</a></dt>
<dd><p>get partitioning information for a given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>device to get partitioning information for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">partno</span></code></dt>
<dd>returned partition index</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the structure containing partitioning
information for the given device <strong>devt</strong>.</p>
<dl class="function">
<dt id="c.bdget_disk">
struct block_device * <code class="descname">bdget_disk</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdget_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> by gendisk and partition number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find partition <strong>partno</strong> from <strong>disk</strong>, do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> on it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<p><strong>Return</strong></p>
<p>Resulting block_device on success, NULL on failure.</p>
</div>
<div class="section" id="char-devices">
<h2>Char devices<a class="headerlink" href="#char-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.register_chrdev_region">
int <code class="descname">register_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the desired range of device numbers; must include
the major number.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive device numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the device or driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return value is zero on success, a negative error code on failure.</p>
<dl class="function">
<dt id="c.alloc_chrdev_region">
int <code class="descname">alloc_chrdev_region</code><span class="sig-paren">(</span>dev_t *<em>&nbsp;dev</em>, unsigned<em>&nbsp;baseminor</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of char device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>output parameter for first assigned number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the associated device or driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a range of char device numbers.  The major number will be
chosen dynamically, and returned (along with the first minor number)
in <strong>dev</strong>.  Returns zero or a negative error code.</p>
<dl class="function">
<dt id="c.__register_chrdev">
int <code class="descname">__register_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register a cdev occupying a range of minors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number or 0 for dynamic allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>file operations associated with this devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>major</strong> == 0 this functions will dynamically allocate a major and return
its number.</p>
<p>If <strong>major</strong> &gt; 0 this function will attempt to reserve a device with the given
major number and will return zero on success.</p>
<p>Returns a -ve errno on failure.</p>
<p>The name of this device has nothing to do with the name of the device in
/dev. It only helps to keep track of the different owners of devices. If
your module name has only one type of devices it&#8217;s ok to use e.g. the name
of the module here.</p>
<dl class="function">
<dt id="c.unregister_chrdev_region">
void <code class="descname">unregister_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the range of numbers to unregister</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of device numbers to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will unregister a range of <strong>count</strong> device numbers,
starting with <strong>from</strong>.  The caller should normally be the one who
allocated those numbers in the first place...</p>
<dl class="function">
<dt id="c.__unregister_chrdev">
void <code class="descname">__unregister_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__unregister_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and destroy a cdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers this cdev is occupying</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister and destroy the cdev occupying the region described by
<strong>major</strong>, <strong>baseminor</strong> and <strong>count</strong>.  This function undoes what
<a class="reference internal" href="#c.__register_chrdev" title="__register_chrdev"><code class="xref c c-func docutils literal"><span class="pre">__register_chrdev()</span></code></a> did.</p>
<dl class="function">
<dt id="c.cdev_add">
int <code class="descname">cdev_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, dev_t<em>&nbsp;dev</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure for the device</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>the first device number for which this device is responsible</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive minor numbers corresponding to this
device</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a> adds the device represented by <strong>p</strong> to the system, making it
live immediately.  A negative error code is returned on failure.</p>
<dl class="function">
<dt id="c.cdev_set_parent">
void <code class="descname">cdev_set_parent</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent kobject for a char device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>the kobject to take a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_set_parent" title="cdev_set_parent"><code class="xref c c-func docutils literal"><span class="pre">cdev_set_parent()</span></code></a> sets a parent kobject which will be referenced
appropriately so the parent is not freed before the cdev. This
should be called before cdev_add.</p>
<dl class="function">
<dt id="c.cdev_device_add">
int <code class="descname">cdev_device_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device and it&#8217;s corresponding struct device, linkink</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_add" title="cdev_device_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_add()</span></code></a> adds the char device represented by <strong>cdev</strong> to the system,
just as cdev_add does. It then adds <strong>dev</strong> to the system using device_add
The dev_t for the char device will be taken from the struct device which
needs to be initialized first. This helper function correctly takes a
reference to the parent device so the parent will not get released until
all references to the cdev are released.</p>
<p>This helper uses dev-&gt;devt for the device number. If it is not set
it will not add the cdev and it will be equivalent to device_add.</p>
<p>This function should be used whenever the struct cdev and the
struct device are members of the same structure whose lifetime is
managed by the struct device.</p>
<p><strong>NOTE</strong></p>
<p>Callers must assume that userspace was able to open the cdev and
can call cdev fops callbacks at any time, even if this function fails.</p>
<dl class="function">
<dt id="c.cdev_device_del">
void <code class="descname">cdev_device_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>inverse of cdev_device_add</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_del" title="cdev_device_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_del()</span></code></a> is a helper function to call cdev_del and device_del.
It should be used whenever cdev_device_add is used.</p>
<p>If dev-&gt;devt is not set it will not remove the cdev and will be equivalent
to device_del.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that associated sysfs callbacks are not running
or runnable, however any cdevs already open will remain and their fops
will still be callable even after this function returns.</p>
<dl class="function">
<dt id="c.cdev_del">
void <code class="descname">cdev_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a cdev from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_del" title="cdev_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_del()</span></code></a> removes <strong>p</strong> from the system, possibly freeing the structure
itself.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that cdev device will no longer be able to be
opened, however any cdevs already open will remain and their fops will
still be callable even after cdev_del returns.</p>
<dl class="function">
<dt id="c.cdev_alloc">
struct cdev * <code class="descname">cdev_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a cdev structure, or NULL on failure.</p>
<dl class="function">
<dt id="c.cdev_init">
void <code class="descname">cdev_init</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the structure to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>the file_operations for this device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cdev</strong>, remembering <strong>fops</strong>, making it ready to add to the
system with <a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a>.</p>
</div>
<div class="section" id="clock-framework">
<h2>Clock Framework<a class="headerlink" href="#clock-framework" title="Permalink to this headline">¶</a></h2>
<p>The clock framework defines programming interfaces to support software
management of the system clock tree. This framework is widely used with
System-On-Chip (SOC) platforms to support power management and various
devices which may need custom clock rates. Note that these &#8220;clocks&#8221;
don&#8217;t relate to timekeeping or real time clocks (RTCs), each of which
have separate frameworks. These <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk</span></code>
instances may be used to manage for example a 96 MHz signal that is used
to shift bits into and out of peripherals or busses, or otherwise
trigger synchronous state machine transitions in system hardware.</p>
<p>Power management is supported by explicit software clock gating: unused
clocks are disabled, so the system doesn&#8217;t waste power changing the
state of transistors that aren&#8217;t in active use. On some systems this may
be backed by hardware clock gating, where clocks are gated without being
disabled in software. Sections of chips that are powered but not clocked
may be able to retain their last state. This low power state is often
called a <em>retention mode</em>. This mode still incurs leakage currents,
especially with finer circuit geometries, but for CMOS circuits power is
mostly used by clocked state changes.</p>
<p>Power-aware drivers only enable their clocks when the device they manage
is in active use. Also, system sleep states often differ according to
which clock domains are active: while a &#8220;standby&#8221; state may allow wakeup
from several active domains, a &#8220;mem&#8221; (suspend-to-RAM) state may require
a more wholesale shutdown of clocks derived from higher speed PLLs and
oscillators, limiting the number of possible wakeup event sources. A
driver&#8217;s suspend method may need to be aware of system-specific clock
constraints on the target sleep state.</p>
<p>Some platforms support programmable clock generators. These can be used
by external chips of various kinds, such as other CPUs, multimedia
codecs, and devices with strict requirements for interface clocking.</p>
<dl class="type">
<dt id="c.clk_notifier">
struct <code class="descname">clk_notifier</code><a class="headerlink" href="#c.clk_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a clk with a notifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_notifier {
  struct clk * clk;
  struct srcu_notifier_head notifier_head;
  struct list_head node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to associate the notifier with</dd>
<dt><code class="docutils literal"><span class="pre">notifier_head</span></code></dt>
<dd>a blocking_notifier_head for this clk</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>linked list pointers</dd>
</dl>
<p><strong>Description</strong></p>
<p>A list of struct clk_notifier is maintained by the notifier code.
An entry is created whenever code registers the first notifier on a
particular <strong>clk</strong>.  Future notifiers on that <strong>clk</strong> are added to the
<strong>notifier_head</strong>.</p>
<dl class="type">
<dt id="c.clk_notifier_data">
struct <code class="descname">clk_notifier_data</code><a class="headerlink" href="#c.clk_notifier_data" title="Permalink to this definition">¶</a></dt>
<dd><p>rate data to pass to the notifier callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_notifier_data {
  struct clk * clk;
  unsigned long old_rate;
  unsigned long new_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * being changed</dd>
<dt><code class="docutils literal"><span class="pre">old_rate</span></code></dt>
<dd>previous rate of this clk</dd>
<dt><code class="docutils literal"><span class="pre">new_rate</span></code></dt>
<dd>new rate of this clk</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a pre-notifier, old_rate is the clk&#8217;s rate before this rate
change, and new_rate is what the rate will be in the future.  For a
post-notifier, old_rate and new_rate are both set to the clk&#8217;s
current rate (this was done to optimize the implementation).</p>
<dl class="type">
<dt id="c.clk_bulk_data">
struct <code class="descname">clk_bulk_data</code><a class="headerlink" href="#c.clk_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk clk operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_bulk_data {
  const char * id;
  struct clk * clk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to store the associated clock</dd>
</dl>
<p><strong>Description</strong></p>
<p>The CLK APIs provide a series of <code class="xref c c-func docutils literal"><span class="pre">clk_bulk_()</span></code> API calls as
a convenience to consumers which require multiple clks.  This
structure is used to manage data for these calls.</p>
<dl class="function">
<dt id="c.clk_notifier_register">
int <code class="descname">clk_notifier_register</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block with callback function pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>ProTip: debugging across notifier chains can be frustrating. Make sure that
your notifier callback function prints a nice big warning in case of
failure.</p>
<dl class="function">
<dt id="c.clk_notifier_unregister">
int <code class="descname">clk_notifier_unregister</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are no longer interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block which will be unregistered</dd>
</dl>
<dl class="function">
<dt id="c.clk_get_accuracy">
long <code class="descname">clk_get_accuracy</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the clock accuracy in ppb (parts per billion) for a clock source.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This gets the clock source accuracy expressed in ppb.
A perfect clock returns 0.</p>
<dl class="function">
<dt id="c.clk_set_phase">
int <code class="descname">clk_set_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, int<em>&nbsp;degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">degrees</span></code></dt>
<dd>number of degrees the signal is shifted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifts the phase of a clock signal by the specified degrees. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_phase">
int <code class="descname">clk_get_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>return the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the phase shift of a clock node in degrees, otherwise returns
-EERROR.</p>
<dl class="function">
<dt id="c.clk_is_match">
bool <code class="descname">clk_is_match</code><span class="sig-paren">(</span>const struct clk *<em>&nbsp;p</em>, const struct clk *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>check if two clk&#8217;s point to the same hardware clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>clk compared against q</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>clk compared against p</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the two struct clk pointers both point to the same hardware
clock node. Put differently, returns true if <strong>p</strong> and <strong>q</strong>
share the same <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk_core</span></code> object.</p>
<p>Returns false otherwise. Note that two NULL clks are treated as matching.</p>
<dl class="function">
<dt id="c.clk_prepare">
int <code class="descname">clk_prepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the clock source for use.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_unprepare">
void <code class="descname">clk_unprepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>undo preparation of a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This undoes a previously prepared clock.  The caller must balance
the number of prepare and unprepare calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_get">
struct clk * <code class="descname">clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get">
int <code class="descname">clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a number of references to clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get several clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully, or valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data</strong>.id to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data</strong>.clk field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get">
int <code class="descname">devm_clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
<dl class="function">
<dt id="c.devm_clk_get">
struct clk * <code class="descname">devm_clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>devm_clk_get should not be called from within interrupt context.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.devm_get_clk_from_child">
struct clk * <code class="descname">devm_get_clk_from_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;np</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_clk_from_child" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer from child node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>pointer to clock consumer node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function parses the clocks, and uses them to look up the
struct clk from the registered list of clock providers by using
<strong>np</strong> and <strong>con_id</strong></p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.clk_enable">
int <code class="descname">clk_enable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the clock can not be enabled/disabled, this should return success.</p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_bulk_enable">
int <code class="descname">clk_bulk_enable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_disable">
void <code class="descname">clk_disable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a clock source is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the clock source is shared between
multiple drivers, <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_bulk_disable">
void <code class="descname">clk_bulk_disable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a set of clks is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the set of clks is shared between
multiple drivers, <a class="reference internal" href="#c.clk_bulk_enable" title="clk_bulk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_bulk_disable" title="clk_bulk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_get_rate">
unsigned long <code class="descname">clk_get_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the current clock rate (in Hz) for a clock source. This is only valid once the clock source has been enabled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<dl class="function">
<dt id="c.clk_put">
void <code class="descname">clk_put</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_put">
void <code class="descname">clk_bulk_put</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p>clk_bulk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_put">
void <code class="descname">devm_clk_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; a managed clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device used to acquire the clock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source acquired with <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal"><span class="pre">devm_clk_get()</span></code></a></dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_round_rate">
long <code class="descname">clk_round_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_round_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust a rate to the exact rate a clock can provide</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>This answers the question &#8220;if I were to pass <strong>rate</strong> to <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal"><span class="pre">clk_set_rate()</span></code></a>,
what clock rate would I end up with?&#8221; without changing the hardware
in any way.  In other words:</p>
<blockquote>
<div>rate = clk_round_rate(clk, r);</div></blockquote>
<p>and:</p>
<blockquote>
<div>clk_set_rate(clk, r);
rate = clk_get_rate(clk);</div></blockquote>
<p>are equivalent except the former does not modify the clock hardware
in any way.</p>
<p>Returns rounded clock rate in Hz, or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate">
int <code class="descname">clk_set_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_has_parent">
bool <code class="descname">clk_has_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_has_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a clock is a possible parent for another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers that need to check that a clock can be
the parent of another without actually changing the parent.</p>
<p>Returns true if <strong>parent</strong> is a possible parent for <strong>clk</strong>, false otherwise.</p>
<dl class="function">
<dt id="c.clk_set_rate_range">
int <code class="descname">clk_set_rate_range</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;min</em>, unsigned long<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>set a rate range for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_min_rate">
int <code class="descname">clk_set_min_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_min_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a minimum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_max_rate">
int <code class="descname">clk_set_max_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_max_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a maximum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_parent">
int <code class="descname">clk_set_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_get_parent">
struct clk * <code class="descname">clk_get_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct clk corresponding to parent clock source, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.</p>
<dl class="function">
<dt id="c.clk_get_sys">
struct clk * <code class="descname">clk_get_sys</code><span class="sig-paren">(</span>const char *<em>&nbsp;dev_id</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_sys" title="Permalink to this definition">¶</a></dt>
<dd><p>get a clock based upon the device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>connection ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev_id</strong> and <strong>con_id</strong> to determine the clock consumer, and
thereby the clock producer. In contrast to <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal"><span class="pre">clk_get()</span></code></a> this function
takes the device name instead of the device itself for identification.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get_sys should not be called from within interrupt context.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="assoc_array.html" class="btn btn-neutral float-right" title="Generic Associative Array Implementation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Core API Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.13.0-rc5+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>