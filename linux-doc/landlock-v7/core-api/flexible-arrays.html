

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Using flexible arrays in the kernel &mdash; The Linux Kernel 4.13.0-rc5+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.13.0-rc5+ documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="Reed-Solomon Library Programming Interface" href="librs.html"/>
        <link rel="prev" title="Linux generic IRQ handling" href="genericirq.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.13.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Using flexible arrays in the kernel</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flexible-array-functions">Flexible array functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>Using flexible arrays in the kernel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/flexible-arrays.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-flexible-arrays-in-the-kernel">
<h1>Using flexible arrays in the kernel<a class="headerlink" href="#using-flexible-arrays-in-the-kernel" title="Permalink to this headline">¶</a></h1>
<p>Large contiguous memory allocations can be unreliable in the Linux kernel.
Kernel programmers will sometimes respond to this problem by allocating
pages with <a class="reference internal" href="kernel-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a>.  This solution not ideal, though.  On 32-bit
systems, memory from vmalloc() must be mapped into a relatively small address
space; it&#8217;s easy to run out.  On SMP systems, the page table changes required
by vmalloc() allocations can require expensive cross-processor interrupts on
all CPUs.  And, on all systems, use of space in the vmalloc() range increases
pressure on the translation lookaside buffer (TLB), reducing the performance
of the system.</p>
<p>In many cases, the need for memory from vmalloc() can be eliminated by piecing
together an array from smaller parts; the flexible array library exists to make
this task easier.</p>
<p>A flexible array holds an arbitrary (within limits) number of fixed-sized
objects, accessed via an integer index.  Sparse arrays are handled
reasonably well.  Only single-page allocations are made, so memory
allocation failures should be relatively rare.  The down sides are that the
arrays cannot be indexed directly, individual object size cannot exceed the
system page size, and putting data into a flexible array requires a copy
operation.  It&#8217;s also worth noting that flexible arrays do no internal
locking at all; if concurrent access to an array is possible, then the
caller must arrange for appropriate mutual exclusion.</p>
<p>The creation of a flexible array is done with <a class="reference internal" href="#c.flex_array_alloc" title="flex_array_alloc"><code class="xref c c-func docutils literal"><span class="pre">flex_array_alloc()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#include &lt;linux/flex_array.h&gt;

struct flex_array *flex_array_alloc(int element_size,
                                    unsigned int total,
                                    gfp_t flags);
</pre></div>
</div>
<p>The individual object size is provided by <code class="docutils literal"><span class="pre">element_size</span></code>, while total is the
maximum number of objects which can be stored in the array.  The flags
argument is passed directly to the internal memory allocation calls.  With
the current code, using flags to ask for high memory is likely to lead to
notably unpleasant side effects.</p>
<p>It is also possible to define flexible arrays at compile time with:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>DEFINE_FLEX_ARRAY(name, element_size, total);
</pre></div>
</div>
<p>This macro will result in a definition of an array with the given name; the
element size and total will be checked for validity at compile time.</p>
<p>Storing data into a flexible array is accomplished with a call to
<a class="reference internal" href="#c.flex_array_put" title="flex_array_put"><code class="xref c c-func docutils literal"><span class="pre">flex_array_put()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int flex_array_put(struct flex_array *array, unsigned int element_nr,
                   void *src, gfp_t flags);
</pre></div>
</div>
<p>This call will copy the data from src into the array, in the position
indicated by <code class="docutils literal"><span class="pre">element_nr</span></code> (which must be less than the maximum specified when
the array was created).  If any memory allocations must be performed, flags
will be used.  The return value is zero on success, a negative error code
otherwise.</p>
<p>There might possibly be a need to store data into a flexible array while
running in some sort of atomic context; in this situation, sleeping in the
memory allocator would be a bad thing.  That can be avoided by using
<code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> for the flags value, but, often, there is a better way.  The
trick is to ensure that any needed memory allocations are done before
entering atomic context, using <a class="reference internal" href="#c.flex_array_prealloc" title="flex_array_prealloc"><code class="xref c c-func docutils literal"><span class="pre">flex_array_prealloc()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int flex_array_prealloc(struct flex_array *array, unsigned int start,
                        unsigned int nr_elements, gfp_t flags);
</pre></div>
</div>
<p>This function will ensure that memory for the elements indexed in the range
defined by <code class="docutils literal"><span class="pre">start</span></code> and <code class="docutils literal"><span class="pre">nr_elements</span></code> has been allocated.  Thereafter, a
<code class="docutils literal"><span class="pre">flex_array_put()</span></code> call on an element in that range is guaranteed not to
block.</p>
<p>Getting data back out of the array is done with <a class="reference internal" href="#c.flex_array_get" title="flex_array_get"><code class="xref c c-func docutils literal"><span class="pre">flex_array_get()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void *flex_array_get(struct flex_array *fa, unsigned int element_nr);
</pre></div>
</div>
<p>The return value is a pointer to the data element, or NULL if that
particular element has never been allocated.</p>
<p>Note that it is possible to get back a valid pointer for an element which
has never been stored in the array.  Memory for array elements is allocated
one page at a time; a single allocation could provide memory for several
adjacent elements.  Flexible array elements are normally initialized to the
value <code class="docutils literal"><span class="pre">FLEX_ARRAY_FREE</span></code> (defined as 0x6c in &lt;linux/poison.h&gt;), so errors
involving that number probably result from use of unstored array entries.
Note that, if array elements are allocated with <code class="docutils literal"><span class="pre">__GFP_ZERO</span></code>, they will be
initialized to zero and this poisoning will not happen.</p>
<p>Individual elements in the array can be cleared with
<a class="reference internal" href="#c.flex_array_clear" title="flex_array_clear"><code class="xref c c-func docutils literal"><span class="pre">flex_array_clear()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int flex_array_clear(struct flex_array *array, unsigned int element_nr);
</pre></div>
</div>
<p>This function will set the given element to <code class="docutils literal"><span class="pre">FLEX_ARRAY_FREE</span></code> and return
zero.  If storage for the indicated element is not allocated for the array,
<code class="docutils literal"><span class="pre">flex_array_clear()</span></code> will return <code class="docutils literal"><span class="pre">-EINVAL</span></code> instead.  Note that clearing an
element does not release the storage associated with it; to reduce the
allocated size of an array, call <a class="reference internal" href="#c.flex_array_shrink" title="flex_array_shrink"><code class="xref c c-func docutils literal"><span class="pre">flex_array_shrink()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int flex_array_shrink(struct flex_array *array);
</pre></div>
</div>
<p>The return value will be the number of pages of memory actually freed.
This function works by scanning the array for pages containing nothing but
<code class="docutils literal"><span class="pre">FLEX_ARRAY_FREE</span></code> bytes, so (1) it can be expensive, and (2) it will not work
if the array&#8217;s pages are allocated with <code class="docutils literal"><span class="pre">__GFP_ZERO</span></code>.</p>
<p>It is possible to remove all elements of an array with a call to
<a class="reference internal" href="#c.flex_array_free_parts" title="flex_array_free_parts"><code class="xref c c-func docutils literal"><span class="pre">flex_array_free_parts()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void flex_array_free_parts(struct flex_array *array);
</pre></div>
</div>
<p>This call frees all elements, but leaves the array itself in place.
Freeing the entire array is done with <a class="reference internal" href="#c.flex_array_free" title="flex_array_free"><code class="xref c c-func docutils literal"><span class="pre">flex_array_free()</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void flex_array_free(struct flex_array *array);
</pre></div>
</div>
<p>As of this writing, there are no users of flexible arrays in the mainline
kernel.  The functions described here are also not exported to modules;
that will probably be fixed when somebody comes up with a need for it.</p>
<div class="section" id="flexible-array-functions">
<h2>Flexible array functions<a class="headerlink" href="#flexible-array-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.flex_array_alloc">
struct flex_array * <code class="descname">flex_array_alloc</code><span class="sig-paren">(</span>int<em>&nbsp;element_size</em>, unsigned int<em>&nbsp;total</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a flexible array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">element_size</span></code></dt>
<dd>individual object size.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">total</span></code></dt>
<dd>maximum number of objects which can be stored.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>GFP flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns an object of structure flex_array.</p>
<dl class="function">
<dt id="c.flex_array_prealloc">
int <code class="descname">flex_array_prealloc</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em>, unsigned int<em>&nbsp;start</em>, unsigned int<em>&nbsp;nr_elements</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_prealloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensures that memory for the elements indexed in the range defined by start and nr_elements has been allocated.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array to allocate memory to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>start address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_elements</span></code></dt>
<dd>number of elements to be allocated.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>GFP flags</dd>
</dl>
<dl class="function">
<dt id="c.flex_array_free">
void <code class="descname">flex_array_free</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all elements of a flexible array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array to be freed.</dd>
</dl>
<dl class="function">
<dt id="c.flex_array_free_parts">
void <code class="descname">flex_array_free_parts</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_free_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all elements of a flexible array, but leaves the array itself in place.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array to be emptied.</dd>
</dl>
<dl class="function">
<dt id="c.flex_array_put">
int <code class="descname">flex_array_put</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em>, unsigned int<em>&nbsp;element_nr</em>, void *<em>&nbsp;src</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores data into a flexible array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array where element is to be stored.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">element_nr</span></code></dt>
<dd>position to copy, must be less than the maximum specified when
the array was created.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>data source to be copied into the array.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>GFP flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns zero on success, a negative error code otherwise.</p>
<dl class="function">
<dt id="c.flex_array_clear">
int <code class="descname">flex_array_clear</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em>, unsigned int<em>&nbsp;element_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears an individual element in the array, sets the given element to FLEX_ARRAY_FREE.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array to which element to be cleared belongs.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">element_nr</span></code></dt>
<dd>element position to clear.</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns zero on success, -EINVAL otherwise.</p>
<dl class="function">
<dt id="c.flex_array_get">
void * <code class="descname">flex_array_get</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em>, unsigned int<em>&nbsp;element_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves data into a flexible array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array from which data is to be retrieved.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">element_nr</span></code></dt>
<dd>Element position to retrieve data from.</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Returns a pointer to the data element, or NULL if that</dt>
<dd>particular element has never been allocated.</dd>
</dl>
<dl class="function">
<dt id="c.flex_array_shrink">
int <code class="descname">flex_array_shrink</code><span class="sig-paren">(</span>struct flex_array *<em>&nbsp;fa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flex_array_shrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the allocated size of an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">flex_array</span> <span class="pre">*</span> <span class="pre">fa</span></code></dt>
<dd>array to shrink.</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns number of pages of memory actually freed.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="librs.html" class="btn btn-neutral float-right" title="Reed-Solomon Library Programming Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="genericirq.html" class="btn btn-neutral" title="Linux generic IRQ handling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.13.0-rc5+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>