

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Mode Setting (KMS) &mdash; The Linux Kernel 4.13.0-rc5+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.13.0-rc5+ documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Mode Setting Helper Functions" href="drm-kms-helpers.html"/>
        <link rel="prev" title="DRM Memory Management" href="drm-mm.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.13.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel Mode Setting (KMS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-core-structures-and-functions">KMS Core Structures and Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeset-base-object-abstraction">Modeset Base Object Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-mode-setting">Atomic Mode Setting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomic-mode-setting-function-reference">Atomic Mode Setting Function Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtc-functions-reference">CRTC Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frame-buffer-functions-reference">Frame Buffer Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-format-handling">DRM Format Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dumb-buffer-objects">Dumb Buffer Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-abstraction">Plane Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plane-functions-reference">Plane Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#display-modes-function-reference">Display Modes Function Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connector-abstraction">Connector Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connector-functions-reference">Connector Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#encoder-functions-reference">Encoder Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-initialization-and-cleanup">KMS Initialization and Cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtcs-struct-drm-crtc">CRTCs (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cleanup">Cleanup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-discovery-and-initialization-example">Output discovery and initialization example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-locking">KMS Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-properties">KMS Properties</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#property-types-and-blob-property-support">Property Types and Blob Property Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-connector-properties">Standard Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#color-management-properties">Color Management Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tile-group-property">Tile Group Property</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-fencing-properties">Explicit Fencing Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existing-kms-properties">Existing KMS Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-blanking">Vertical Blanking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vertical-blanking-and-interrupt-handling-functions-reference">Vertical Blanking and Interrupt Handling Functions Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
        
      <li>Kernel Mode Setting (KMS)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-kms.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-mode-setting-kms">
<h1>Kernel Mode Setting (KMS)<a class="headerlink" href="#kernel-mode-setting-kms" title="Permalink to this headline">¶</a></h1>
<p>Drivers must initialize the mode setting core by calling
<a class="reference internal" href="#c.drm_mode_config_init" title="drm_mode_config_init"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_init()</span></code></a> on the DRM device. The function
initializes the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>
mode_config field and never fails. Once done, mode configuration must
be setup by initializing the following fields.</p>
<ul class="simple">
<li>int min_width, min_height; int max_width, max_height;
Minimum and maximum width and height of the frame buffers in pixel
units.</li>
<li>struct drm_mode_config_funcs *funcs;
Mode setting functions.</li>
</ul>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id1">
<img alt="KMS Display Pipeline" src="../_images/DOT-dade12aa9127c64406e41cdf8d7f80694c134db2.svg" /><p class="caption"><span class="caption-text">KMS Display Pipeline Overview</span></p>
</div>
<p>The basic object structure KMS presents to userspace is fairly simple.
Framebuffers (represented by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>,
see <a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a>) feed into planes. One or more (or even no)
planes feed their pixel data into a CRTC (represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_crtc</span></code></a>, see <a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a>) for blending. The precise
blending step is explained in more detail in <a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a> and
related chapters.</p>
<p>For the output routing the first step is encoders (represented by
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a>, see <a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a>). Those
are really just internal artifacts of the helper libraries used to implement KMS
drivers. Besides that they make it unecessarily more complicated for userspace
to figure out which connections between a CRTC and a connector are possible, and
what kind of cloning is supported, they serve no purpose in the userspace API.
Unfortunately encoders have been exposed to userspace, hence can&#8217;t remove them
at this point.  Futhermore the exposed restrictions are often wrongly set by
drivers, and in many cases not powerful enough to express the real restrictions.
A CRTC can be connected to multiple encoders, and for an active CRTC there must
be at least one encoder.</p>
<p>The final, and real, endpoint in the display chain is the connector (represented
by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>, see <a class="reference internal" href="#connector-abstraction">Connector
Abstraction</a>). Connectors can have different possible encoders, but the kernel
driver selects which encoder to use for each connector. The use case is DVI,
which could switch between an analog and a digital encoder. Encoders can also
drive multiple different connectors. There is exactly one active connector for
every active encoder.</p>
<p>Internally the output pipeline is a bit more complex and matches today&#8217;s
hardware more closely:</p>
<div class="figure" id="id2">
<img alt="KMS Output Pipeline" src="../_images/DOT-6445c75fc4859992454fd377127d4d309e82f09a.svg" /><p class="caption"><span class="caption-text">KMS Output Pipeline</span></p>
</div>
<p>Internally two additional helper objects come into play. First, to be able to
share code for encoders (sometimes on the same SoC, sometimes off-chip) one or
more <a class="reference internal" href="drm-kms-helpers.html#drm-bridges"><span class="std std-ref">Bridges</span></a> (represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>) can be linked to an encoder. This link is static and cannot be
changed, which means the cross-bar (if there is any) needs to be mapped between
the CRTC and any encoders. Often for drivers with bridges there&#8217;s no code left
at the encoder level. Atomic drivers can leave out all the encoder callbacks to
essentially only leave a dummy routing object behind, which is needed for
backwards compatibility since encoders are exposed to userspace.</p>
<p>The second object is for panels, represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span></code></a>, see <a class="reference internal" href="drm-kms-helpers.html#drm-panel-helper"><span class="std std-ref">Panel Helper Reference</span></a>. Panels do not have a fixed binding
point, but are generally linked to the driver private structure that embeds
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>.</p>
<p>Note that currently the bridge chaining and interactions with connectors and
panels are still in-flux and not really fully sorted out yet.</p>
</div>
<div class="section" id="kms-core-structures-and-functions">
<h2>KMS Core Structures and Functions<a class="headerlink" href="#kms-core-structures-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_config_funcs">
struct <code class="descname">drm_mode_config_funcs</code><a class="headerlink" href="#c.drm_mode_config_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>basic driver provided mode setting functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_mode_config_funcs {
  struct drm_framebuffer *(* fb_create) (struct drm_device *dev,struct drm_file *file_priv,const struct drm_mode_fb_cmd2 *mode_cmd);
  const struct drm_format_info *(* get_format_info) (const struct drm_mode_fb_cmd2 *mode_cmd);
  void (* output_poll_changed) (struct drm_device *dev);
  int (* atomic_check) (struct drm_device *dev,struct drm_atomic_state *state);
  int (* atomic_commit) (struct drm_device *dev,struct drm_atomic_state *state,bool nonblock);
  struct drm_atomic_state *(* atomic_state_alloc) (struct drm_device *dev);
  void (* atomic_state_clear) (struct drm_atomic_state *state);
  void (* atomic_state_free) (struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_create</span></code></dt>
<dd><p class="first">Create a new framebuffer object. The core does basic checks on the
requested metadata, but most of that is left to the driver. See
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> for details.</p>
<p>If the parameters are deemed valid and the backing storage objects in
the underlying memory manager all exist, then the driver allocates
a new <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> structure, subclassed to contain
driver-specific information (like the internal native buffer object
references). It also needs to fill out all relevant metadata, which
should be done by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a>.</p>
<p>The initialization is finalized by calling <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_init()</span></code></a>,
which registers the framebuffer and makes it accessible to other
threads.</p>
<p>RETURNS:</p>
<p class="last">A new framebuffer with an initial reference count of 1 or a negative
error code encoded with <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_format_info</span></code></dt>
<dd><p class="first">Allows a driver to return custom format information for special
fb layouts (eg. ones with auxiliary compression control planes).</p>
<p>RETURNS:</p>
<p class="last">The format information specific to the given fb metadata, or
NULL if none is found.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_changed</span></code></dt>
<dd><p class="first">Callback used by helpers to inform the driver of output configuration
changes.</p>
<p>Drivers implementing fbdev emulation with the helpers can call
drm_fb_helper_hotplug_changed from this hook to inform the fbdev
helper of output changes.</p>
<p>FIXME:</p>
<p class="last">Except that there&#8217;s no vtable for device-level helper callbacks
there&#8217;s no reason this is a core function.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This is the only hook to validate an atomic modeset update. This
function must reject any modeset and state changes which the hardware
or driver doesn&#8217;t support. This includes but is of course not limited
to:</p>
<blockquote>
<div><ul class="simple">
<li>Checking that the modes, framebuffers, scaling and placement
requirements and so on are within the limits of the hardware.</li>
<li>Checking that any hidden shared resources are not oversubscribed.
This can be shared PLLs, shared lanes, overall memory bandwidth,
display fifo space (where shared between planes or maybe even
CRTCs).</li>
<li>Checking that virtualized resources exported to userspace are not
oversubscribed. For various reasons it can make sense to expose
more planes, crtcs or encoders than which are physically there. One
example is dual-pipe operations (which generally should be hidden
from userspace if when lockstepped in hardware, exposed otherwise),
where a plane might need 1 hardware plane (if it&#8217;s just on one
pipe), 2 hardware planes (when it spans both pipes) or maybe even
shared a hardware plane with a 2nd plane (if there&#8217;s a compatible
plane requested on the area handled by the other pipe).</li>
<li>Check that any transitional state is possible and that if
requested, the update can indeed be done in the vblank period
without temporarily disabling some functions.</li>
<li>Check any other constraints the driver or hardware might have.</li>
<li>This callback also needs to correctly fill out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a>
in this update to make sure that <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>
reflects the nature of the possible update and returns true if and
only if the update cannot be applied without tearing within one
vblank on that CRTC. The core uses that information to reject
updates which require a full modeset (i.e. blanking the screen, or
at least pausing updates for a substantial amount of time) if
userspace has disallowed that in its request.</li>
<li>The driver also does not need to repeat basic input validation
like done for the corresponding legacy entry points. The core does
that before calling this hook.</li>
</ul>
</div></blockquote>
<p>See the documentation of <strong>atomic_commit</strong> for an exhaustive list of
error conditions which don&#8217;t have to be checked at the in this
callback.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote class="last">
<div><ul class="simple">
<li>-EINVAL, if any of the above constraints are violated.</li>
<li>-EDEADLK, when returned from an attempt to acquire an additional
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> through <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>.</li>
<li>-ENOMEM, if allocating additional state sub-structures failed due
to lack of memory.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point all errors are
treated equally.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_commit</span></code></dt>
<dd><p class="first">This is the only hook to commit an atomic modeset update. The core
guarantees that <strong>atomic_check</strong> has been called successfully before
calling this function, and that nothing has been changed in the
interim.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>Nonblocking commits (as indicated with the nonblock parameter) must
do any preparatory work which might result in an unsuccessful commit
in the context of this callback. The only exceptions are hardware
errors resulting in -EIO. But even in that case the driver must
ensure that the display pipe is at least running, to avoid
compositors crashing when pageflips don&#8217;t work. Anything else,
specifically committing the update to the hardware, should be done
without blocking the caller. For updates which do not require a
modeset this must be guaranteed.</p>
<p>The driver must wait for any pending rendering to the new
framebuffers to complete before executing the flip. It should also
wait for any pending rendering from other drivers if the underlying
buffer is a shared dma-buf. Nonblocking commits must not wait for
rendering in the context of this callback.</p>
<p>An application can request to be notified when the atomic commit has
completed. These events are per-CRTC and can be distinguished by the
CRTC index supplied in <code class="xref c c-type docutils literal"><span class="pre">drm_event</span></code> to userspace.</p>
<p>The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in each CRTC&#8217;s
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a>. See the documentation for
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> for more details about the precise semantics of
this event.</p>
<p>NOTE:</p>
<p>Drivers are not allowed to shut down any display pipe successfully
enabled through an atomic commit on their own. Doing so can result in
compositors crashing if a page flip is suddenly rejected because the
pipe is off.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote>
<div><ul class="simple">
<li>-EBUSY, if a nonblocking updated is requested and there is
an earlier updated pending. Drivers are allowed to support a queue
of outstanding updates, but currently no driver supports that.
Note that drivers must wait for preceding updates to complete if a
synchronous update is requested, they are not allowed to fail the
commit in that case.</li>
<li>-ENOMEM, if the driver failed to allocate memory. Specifically
this can happen when trying to pin framebuffers, which must only
be done when committing the state.</li>
<li>-ENOSPC, as a refinement of the more generic -ENOMEM to indicate
that the driver has run out of vram, iommu space or similar GPU
address space needed for framebuffer.</li>
<li>-EIO, if the hardware completely died.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point of view all errors are
treated equally.</li>
</ul>
</div></blockquote>
<p class="last">This list is exhaustive. Specifically this hook is not allowed to
return -EINVAL (any invalid requests should be caught in
<strong>atomic_check</strong>) or -EDEADLK (this function must not acquire
additional modeset locks).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_alloc</span></code></dt>
<dd><p class="first">This optional hook can be used by drivers that want to subclass struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> to be able to track their own driver-private global
state easily. If this hook is implemented, drivers must also
implement <strong>atomic_state_clear</strong> and <strong>atomic_state_free</strong>.</p>
<p>RETURNS:</p>
<p class="last">A new <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> on success or NULL on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_clear</span></code></dt>
<dd><p class="first">This hook must clear any driver private state duplicated into the
passed-in <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>. This hook is called when the caller
encountered a <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> deadlock and needs to drop all
already acquired locks as part of the deadlock avoidance dance
implemented in <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>Any duplicated state must be invalidated since a concurrent atomic
update might change it, and the drm atomic interfaces always apply
updates as relative changes to the current state.</p>
<p class="last">Drivers that implement this must call <a class="reference internal" href="#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_clear()</span></code></a>
to clear common state.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_free</span></code></dt>
<dd><p class="first">This hook needs driver private resources and the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
itself. Note that the core first calls <a class="reference internal" href="#c.drm_atomic_state_clear" title="drm_atomic_state_clear"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_clear()</span></code></a> to
avoid code duplicate between the clear and free hooks.</p>
<p class="last">Drivers that implement this must call
<a class="reference internal" href="#c.drm_atomic_state_default_release" title="drm_atomic_state_default_release"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_release()</span></code></a> to release common resources.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
involve drivers.</p>
<dl class="type">
<dt id="c.drm_mode_config">
struct <code class="descname">drm_mode_config</code><a class="headerlink" href="#c.drm_mode_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode configuration control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_mode_config {
  struct mutex mutex;
  struct drm_modeset_lock connection_mutex;
  struct drm_modeset_acquire_ctx * acquire_ctx;
  struct mutex idr_mutex;
  struct idr crtc_idr;
  struct idr tile_idr;
  struct mutex fb_lock;
  int num_fb;
  struct list_head fb_list;
  spinlock_t connector_list_lock;
  int num_connector;
  struct ida connector_ida;
  struct list_head connector_list;
  int num_encoder;
  struct list_head encoder_list;
  int num_overlay_plane;
  int num_total_plane;
  struct list_head plane_list;
  int num_crtc;
  struct list_head crtc_list;
  struct list_head property_list;
  int min_width;
  int min_height;
  int max_width;
  int max_height;
  const struct drm_mode_config_funcs * funcs;
  resource_size_t fb_base;
  bool poll_enabled;
  bool poll_running;
  bool delayed_event;
  struct delayed_work output_poll_work;
  struct mutex blob_lock;
  struct list_head property_blob_list;
  struct drm_property * edid_property;
  struct drm_property * dpms_property;
  struct drm_property * path_property;
  struct drm_property * tile_property;
  struct drm_property * link_status_property;
  struct drm_property * plane_type_property;
  struct drm_property * prop_src_x;
  struct drm_property * prop_src_y;
  struct drm_property * prop_src_w;
  struct drm_property * prop_src_h;
  struct drm_property * prop_crtc_x;
  struct drm_property * prop_crtc_y;
  struct drm_property * prop_crtc_w;
  struct drm_property * prop_crtc_h;
  struct drm_property * prop_fb_id;
  struct drm_property * prop_in_fence_fd;
  struct drm_property * prop_out_fence_ptr;
  struct drm_property * prop_crtc_id;
  struct drm_property * prop_active;
  struct drm_property * prop_mode_id;
  struct drm_property * dvi_i_subconnector_property;
  struct drm_property * dvi_i_select_subconnector_property;
  struct drm_property * tv_subconnector_property;
  struct drm_property * tv_select_subconnector_property;
  struct drm_property * tv_mode_property;
  struct drm_property * tv_left_margin_property;
  struct drm_property * tv_right_margin_property;
  struct drm_property * tv_top_margin_property;
  struct drm_property * tv_bottom_margin_property;
  struct drm_property * tv_brightness_property;
  struct drm_property * tv_contrast_property;
  struct drm_property * tv_flicker_reduction_property;
  struct drm_property * tv_overscan_property;
  struct drm_property * tv_saturation_property;
  struct drm_property * tv_hue_property;
  struct drm_property * scaling_mode_property;
  struct drm_property * aspect_ratio_property;
  struct drm_property * degamma_lut_property;
  struct drm_property * degamma_lut_size_property;
  struct drm_property * ctm_property;
  struct drm_property * gamma_lut_property;
  struct drm_property * gamma_lut_size_property;
  struct drm_property * suggested_x_property;
  struct drm_property * suggested_y_property;
  uint32_t preferred_depth;
  uint32_t prefer_shadow;
  bool async_page_flip;
  bool allow_fb_modifiers;
  uint32_t cursor_width;
  uint32_t cursor_height;
  const struct drm_mode_config_helper_funcs * helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This is the big scary modeset BKL which protects everything that
isn&#8217;t protect otherwise. Scope is unclear and fuzzy, try to remove
anything from under it&#8217;s protection and move it into more well-scoped
locks.</p>
<p class="last">The one important thing this protects is the use of <strong>acquire_ctx</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">connection_mutex</span></code></dt>
<dd><p class="first">This protects connector state and the connector to encoder to CRTC
routing chain.</p>
<p class="last">For atomic drivers specifically this protects <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>Global implicit acquire context used by atomic drivers for legacy
IOCTLs. Deprecated, since implicit locking contexts make it
impossible to use driver-private <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a>. Users of
this must hold <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">idr_mutex</span></code></dt>
<dd>Mutex for KMS ID allocation and management. Protects both <strong>crtc_idr</strong>
and <strong>tile_idr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_idr</span></code></dt>
<dd>Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
connector, modes - just makes life easier to have only one.</dd>
<dt><code class="docutils literal"><span class="pre">tile_idr</span></code></dt>
<dd>Use this idr for allocating new IDs for tiled sinks like use in some
high-res DP MST screens.</dd>
<dt><code class="docutils literal"><span class="pre">fb_lock</span></code></dt>
<dd>Mutex to protect fb the global <strong>fb_list</strong> and <strong>num_fb</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_fb</span></code></dt>
<dd>Number of entries on <strong>fb_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">fb_list</span></code></dt>
<dd>List of all <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list_lock</span></code></dt>
<dd>Protects <strong>num_connector</strong> and
<strong>connector_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>Number of connectors on this device. Protected by
<strong>connector_list_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_ida</span></code></dt>
<dd>ID allocator for connector indices.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list</span></code></dt>
<dd>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.head</span></code></a>. Protected
by <strong>connector_list_lock</strong>. Only use <a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</dd>
<dt><code class="docutils literal"><span class="pre">num_encoder</span></code></dt>
<dd>Number of encoders on this device. This is invariant over the
lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">encoder_list</span></code></dt>
<dd>List of encoder objects linked with <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_overlay_plane</span></code></dt>
<dd><p class="first">Number of overlay planes on this device, excluding primary and cursor
planes.</p>
<p class="last">Track number of overlay planes separately from number of total
planes.  By default we only advertise overlay planes to userspace; if
userspace sets the &#8220;universal plane&#8221; capability bit, we&#8217;ll go ahead
and expose all planes. This is invariant over the lifetime of a
device and hence doesn&#8217;t need any locks.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">num_total_plane</span></code></dt>
<dd>Number of universal (i.e. with primary/curso) planes on this device.
This is invariant over the lifetime of a device and hence doesn&#8217;t
need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">plane_list</span></code></dt>
<dd>List of plane objects linked with <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_crtc</span></code></dt>
<dd>Number of CRTCs on this device linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant over the lifetime
of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_list</span></code></dt>
<dd>List of CRTC objects linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">property_list</span></code></dt>
<dd>List of property type objects linked with <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">min_width</span></code></dt>
<dd>minimum pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">min_height</span></code></dt>
<dd>minimum pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_width</span></code></dt>
<dd>maximum pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_height</span></code></dt>
<dd>maximum pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>core driver provided mode setting functions</dd>
<dt><code class="docutils literal"><span class="pre">fb_base</span></code></dt>
<dd>base address of the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">poll_enabled</span></code></dt>
<dd>track polling support for this device</dd>
<dt><code class="docutils literal"><span class="pre">poll_running</span></code></dt>
<dd>track polling status for this device</dd>
<dt><code class="docutils literal"><span class="pre">delayed_event</span></code></dt>
<dd>track delayed poll uevent deliver for this device</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_work</span></code></dt>
<dd>delayed work for polling in process context</dd>
<dt><code class="docutils literal"><span class="pre">blob_lock</span></code></dt>
<dd>Mutex for blob property allocation and management, protects
<strong>property_blob_list</strong> and <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">property_blob_list</span></code></dt>
<dd>List of all the blob property objects linked with
<a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob.head</span></code></a>. Protected by <strong>blob_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">edid_property</span></code></dt>
<dd>Default connector property to hold the EDID of the
currently connected sink, if any.</dd>
<dt><code class="docutils literal"><span class="pre">dpms_property</span></code></dt>
<dd>Default connector property to control the
connector&#8217;s DPMS state.</dd>
<dt><code class="docutils literal"><span class="pre">path_property</span></code></dt>
<dd>Default connector property to hold the DP MST path
for the port.</dd>
<dt><code class="docutils literal"><span class="pre">tile_property</span></code></dt>
<dd>Default connector property to store the tile
position of a tiled screen, for sinks which need to be driven with
multiple CRTCs.</dd>
<dt><code class="docutils literal"><span class="pre">link_status_property</span></code></dt>
<dd>Default connector property for link status
of a connector</dd>
<dt><code class="docutils literal"><span class="pre">plane_type_property</span></code></dt>
<dd>Default plane property to differentiate
CURSOR, PRIMARY and OVERLAY legacy uses of planes.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_x</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_y</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_w</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_h</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_x</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_y</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_w</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_h</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_fb_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_in_fence_fd</span></code></dt>
<dd>Sync File fd representing the incoming fences
for a Plane.</dd>
<dt><code class="docutils literal"><span class="pre">prop_out_fence_ptr</span></code></dt>
<dd>Sync File fd pointer representing the
outgoing fences for a CRTC. Userspace should provide a pointer to a
value of type s32, and then cast that pointer to u64.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_active</span></code></dt>
<dd>Default atomic CRTC property to control the active
state, which is the simplified implementation for DPMS in atomic
drivers.</dd>
<dt><code class="docutils literal"><span class="pre">prop_mode_id</span></code></dt>
<dd>Default atomic CRTC property to set the mode for a
CRTC. A 0 mode implies that the CRTC is entirely disabled - all
connectors must be of and active must be set to disabled, too.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
differentiate between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_select_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
select between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_subconnector_property</span></code></dt>
<dd>Optional TV property to differentiate
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_select_subconnector_property</span></code></dt>
<dd>Optional TV property to select
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_mode_property</span></code></dt>
<dd>Optional TV property to select
the output TV mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_left_margin_property</span></code></dt>
<dd>Optional TV property to set the left
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_right_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_top_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_bottom_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_brightness_property</span></code></dt>
<dd>Optional TV property to set the
brightness.</dd>
<dt><code class="docutils literal"><span class="pre">tv_contrast_property</span></code></dt>
<dd>Optional TV property to set the
contrast.</dd>
<dt><code class="docutils literal"><span class="pre">tv_flicker_reduction_property</span></code></dt>
<dd>Optional TV property to control the
flicker reduction mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_overscan_property</span></code></dt>
<dd>Optional TV property to control the overscan
setting.</dd>
<dt><code class="docutils literal"><span class="pre">tv_saturation_property</span></code></dt>
<dd>Optional TV property to set the
saturation.</dd>
<dt><code class="docutils literal"><span class="pre">tv_hue_property</span></code></dt>
<dd>Optional TV property to set the hue.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional connector property to control the
upscaling, mostly used for built-in panels.</dd>
<dt><code class="docutils literal"><span class="pre">aspect_ratio_property</span></code></dt>
<dd>Optional connector property to control the
HDMI infoframe aspect ratio setting.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the framebuffer&#8217;s colors to linear gamma.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of
the degamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">ctm_property</span></code></dt>
<dd>Optional CRTC property to set the
matrix used to convert colors after the lookup in the
degamma LUT.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the colors, after the CTM matrix, to the gamma space of the
connected screen.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of the
gamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">suggested_x_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">suggested_y_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">preferred_depth</span></code></dt>
<dd>preferred RBG pixel depth, used by fb helpers</dd>
<dt><code class="docutils literal"><span class="pre">prefer_shadow</span></code></dt>
<dd>hint to userspace to prefer shadow-fb rendering</dd>
<dt><code class="docutils literal"><span class="pre">async_page_flip</span></code></dt>
<dd>Does this device support async flips on the primary
plane?</dd>
<dt><code class="docutils literal"><span class="pre">allow_fb_modifiers</span></code></dt>
<dd>Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_width</span></code></dt>
<dd>hint to userspace for max cursor width</dd>
<dt><code class="docutils literal"><span class="pre">cursor_height</span></code></dt>
<dd>hint to userspace for max cursor height</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core mode resource tracking structure.  All CRTC, encoders, and connectors
enumerated by the driver are added here, as are global properties.  Some
global restrictions are also here, e.g. dimension restrictions.</p>
<dl class="function">
<dt id="c.drm_mode_config_reset">
void <code class="descname">drm_mode_config_reset</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>call -&gt;reset callbacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions calls all the crtc&#8217;s, encoder&#8217;s and connector&#8217;s -&gt;reset
callback. Drivers can use this in e.g. their driver load or resume code to
reset hardware and software state.</p>
<dl class="function">
<dt id="c.drm_mode_config_init">
void <code class="descname">drm_mode_config_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize DRM mode_configuration structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>dev</strong>&#8216;s mode_config structure, used for tracking the graphics
configuration of <strong>dev</strong>.</p>
<p>Since this initializes the modeset locks, no locking is possible. Which is no
problem, since this should happen single threaded at init time. It is the
driver&#8217;s problem to ensure this guarantee.</p>
<dl class="function">
<dt id="c.drm_mode_config_cleanup">
void <code class="descname">drm_mode_config_cleanup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>free up DRM mode_config info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free up all the connectors and CRTCs associated with this DRM device, then
free up the framebuffers and associated buffer objects.</p>
<p>Note that since this /should/ happen single-threaded at driver/device
teardown time, no locking is required. It&#8217;s the driver&#8217;s job to ensure that
this guarantee actually holds true.</p>
<p>FIXME: cleanup any dangling user buffer objects too</p>
</div>
<div class="section" id="modeset-base-object-abstraction">
<h2>Modeset Base Object Abstraction<a class="headerlink" href="#modeset-base-object-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id3">
<img alt="Mode Objects and Properties" src="../_images/DOT-1eee3f74bb2de20b2b68c4aa6c9c1cabe5078857.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>The base structure for all KMS objects is <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span></code></a>. One of the base services it provides is tracking properties,
which are especially important for the atomic IOCTL (see <a class="reference internal" href="#atomic-mode-setting">Atomic Mode
Setting</a>). The somewhat surprising part here is that properties are not
directly instantiated on each object, but free-standing mode objects themselves,
represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a>, which only specify
the type and value range of a property. Any given property can be attached
multiple times to different objects using <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_mode_object">
struct <code class="descname">drm_mode_object</code><a class="headerlink" href="#c.drm_mode_object" title="Permalink to this definition">¶</a></dt>
<dd><p>base structure for modeset objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_mode_object {
  uint32_t id;
  uint32_t type;
  struct drm_object_properties * properties;
  struct kref refcount;
  void (* free_cb) (struct kref *kref);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>userspace visible identifier</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the object, one of DRM_MODE_OBJECT_*</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>properties attached to this object, including values</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count for objects which with dynamic lifetime</dd>
<dt><code class="docutils literal"><span class="pre">free_cb</span></code></dt>
<dd>free function callback, only set for objects with dynamic lifetime</dd>
</dl>
<p><strong>Description</strong></p>
<p>Base structure for modeset objects visible to userspace. Objects can be
looked up using <a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>. Besides basic uapi interface
properties like <strong>id</strong> and <strong>type</strong> it provides two services:</p>
<ul class="simple">
<li>It tracks attached properties and their values. This is used by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>,
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>. Properties are attached by calling
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a> before the object is visible to userspace.</li>
<li>For objects with dynamic lifetimes (as indicated by a non-NULL <strong>free_cb</strong>) it
provides reference counting through <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>. This is used by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>
and <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a>. These objects provide specialized reference
counting wrappers.</li>
</ul>
<dl class="type">
<dt id="c.drm_object_properties">
struct <code class="descname">drm_object_properties</code><a class="headerlink" href="#c.drm_object_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>property tracking for <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_object_properties {
  int count;
  struct drm_property * properties;
  uint64_t values;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>number of valid properties, must be less than or equal to
DRM_OBJECT_MAX_PROPERTY.</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd><p class="first">Array of pointers to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p class="last">NOTE: if we ever start dynamically destroying properties (ie.
not at <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> time), then we&#8217;d have to do
a better job of detaching property from mode objects to avoid
dangling property pointers:</p>
</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd><p class="first">Array to store the property values, matching <strong>properties</strong>. Do
not read/write values directly, but use
<a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code></a> and <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code></a>.</p>
<p>Note that atomic drivers do not store mutable properties in this
array, but only the decoded values in the corresponding state
structure. The decoding is done using the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_set_property</span></code></a> hooks for <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. For
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> the hooks are <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a>. And for <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>
the hooks are <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> .</p>
<p class="last">Hence atomic drivers should not use <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code></a>
and <a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code></a> on mutable objects, i.e. those
without the DRM_MODE_PROP_IMMUTABLE flag set.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_object_reference">
void <code class="descname">drm_mode_object_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_mode_object_unreference">
void <code class="descname">drm_mode_object_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_mode_object_find">
struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> * <code class="descname">drm_mode_object_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_find" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a drm object with static lifetime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the mode object</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>type of the mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to look up a modeset object. It will acquire a
reference for reference counted objects. This reference must be dropped again
by callind <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_mode_object_put">
void <code class="descname">drm_mode_object_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the object&#8217;s refcount if it is a refcounted modeset
object. It is a no-op on any other object. This is used to drop references
acquired with <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_mode_object_get">
void <code class="descname">drm_mode_object_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the object&#8217;s refcount if it is a refcounted modeset
object. It is a no-op on any other object. References should be dropped again
by calling <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_object_attach_property">
void <code class="descname">drm_object_attach_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;init_val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_attach_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a property to a modeset object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm modeset object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to attach</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">init_val</span></code></dt>
<dd>initial value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This attaches the given property to the modeset object with the given initial
value. Currently this function cannot fail since the properties are stored in
a statically sized array.</p>
<dl class="function">
<dt id="c.drm_object_property_set_value">
int <code class="descname">drm_object_property_set_value</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm mode object to set property value for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value the property should be set to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets a given property on a given object. This function only
changes the software state of the property, it does not call into the
driver&#8217;s -&gt;set_property callback.</p>
<p>Note that atomic drivers should not have any need to call this, the core will
ensure consistency of values reported back to userspace through the
appropriate -&gt;atomic_get_property callback. Only legacy drivers should call
this function to update the tracked value (after clamping and other
restrictions have been applied).</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_object_property_get_value">
int <code class="descname">drm_object_property_get_value</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm mode object to get property value from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>storage for the property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves the softare state of the given property for the given
property. Since there is no driver callback to retrieve the current property
value this might be out of sync with the hardware, depending upon the driver
and property.</p>
<p>Atomic drivers should never call this function directly, the core will read
out property values through the various -&gt;atomic_get_property callbacks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<div class="section" id="atomic-mode-setting">
<h2>Atomic Mode Setting<a class="headerlink" href="#atomic-mode-setting" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id4">
<img alt="Mode Objects and Properties" src="../_images/DOT-69c6997054dbfdfb0892fa0cab076cfd8074c7ed.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>Atomic provides transactional modeset (including planes) updates, but a
bit differently from the usual transactional approach of try-commit and
rollback:</p>
<ul class="simple">
<li>Firstly, no hardware changes are allowed when the commit would fail. This
allows us to implement the DRM_MODE_ATOMIC_TEST_ONLY mode, which allows
userspace to explore whether certain configurations would work or not.</li>
<li>This would still allow setting and rollback of just the software state,
simplifying conversion of existing drivers. But auditing drivers for
correctness of the atomic_check code becomes really hard with that: Rolling
back changes in data structures all over the place is hard to get right.</li>
<li>Lastly, for backwards compatibility and to support all use-cases, atomic
updates need to be incremental and be able to execute in parallel. Hardware
doesn&#8217;t always allow it, but where possible plane updates on different CRTCs
should not interfere, and not get stalled due to output routing changing on
different CRTCs.</li>
</ul>
<p>Taken all together there&#8217;s two consequences for the atomic design:</p>
<ul class="simple">
<li>The overall state is split up into per-object state structures:
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> for planes, <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_crtc_state</span></code></a> for CRTCs and <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_connector_state</span></code></a> for connectors. These are the only
objects with userspace-visible and settable state. For internal state drivers
can subclass these structures through embeddeding, or add entirely new state
structures for their globally shared hardware functions.</li>
<li>An atomic update is assembled and validated as an entirely free-standing pile
of structures within the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
container. Again drivers can subclass that container for their own state
structure tracking needs. Only when a state is committed is it applied to the
driver and modeset objects. This way rolling back an update boils down to
releasing memory and unreferencing objects like framebuffers.</li>
</ul>
<p>Read on in this chapter, and also in <a class="reference internal" href="drm-kms-helpers.html#drm-atomic-helper"><span class="std std-ref">Atomic Modeset Helper Functions Reference</span></a> for more detailed
coverage of specific topics.</p>
<div class="section" id="atomic-mode-setting-function-reference">
<h3>Atomic Mode Setting Function Reference<a class="headerlink" href="#atomic-mode-setting-function-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_commit">
struct <code class="descname">drm_crtc_commit</code><a class="headerlink" href="#c.drm_crtc_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>track modeset commits on a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_crtc_commit {
  struct drm_crtc * crtc;
  struct kref ref;
  struct completion flip_done;
  struct completion hw_done;
  struct completion cleanup_done;
  struct list_head commit_entry;
  struct drm_pending_vblank_event * event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>DRM CRTC for this commit.</dd>
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>Reference count for this structure. Needed to allow blocking on
completions without the risk of the completion disappearing
meanwhile.</dd>
<dt><code class="docutils literal"><span class="pre">flip_done</span></code></dt>
<dd>Will be signaled when the hardware has flipped to the new set of
buffers. Signals at the same time as when the drm event for this
commit is sent to userspace, or when an out-fence is singalled. Note
that for most hardware, in most cases this happens after <strong>hw_done</strong> is
signalled.</dd>
<dt><code class="docutils literal"><span class="pre">hw_done</span></code></dt>
<dd><p class="first">Will be signalled when all hw register changes for this commit have
been written out. Especially when disabling a pipe this can be much
later than than <strong>flip_done</strong>, since that can signal already when the
screen goes black, whereas to fully shut down a pipe more register
I/O is required.</p>
<p class="last">Note that this does not need to include separately reference-counted
resources like backing storage buffer pinning, or runtime pm
management.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_done</span></code></dt>
<dd>Will be signalled after old buffers have been cleaned up by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>. Since this can only happen after
a vblank wait completed it might be a bit later. This completion is
useful to throttle updates and avoid hardware updates getting ahead
of the buffer cleanup too much.</dd>
<dt><code class="docutils literal"><span class="pre">commit_entry</span></code></dt>
<dd>Entry on the per-CRTC <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.commit_list</span></code></a>. Protected by
$drm_crtc.commit_lock.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_vblank_event</span></code></a> pointer to clean up private events.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used to track pending modeset changes and atomic commit on
a per-CRTC basis. Since updating the list should never block this structure
is reference counted to allow waiters to safely wait on an event to complete,
without holding any locks.</p>
<p>It has 3 different events in total to allow a fine-grained synchronization
between outstanding updates:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>atomic commit thread                    hardware

write new state into hardware   ----&gt;   ...
signal hw_done
                                        switch to new state on next
...                                     v/hblank

wait for buffers to show up             ...

...                                     send completion irq
                                        irq handler signals flip_done
cleanup old buffers

signal cleanup_done

wait for flip_done              &lt;----
clean up atomic state
</pre></div>
</div>
<p>The important bit to know is that cleanup_done is the terminal event, but the
ordering between flip_done and hw_done is entirely up to the specific driver
and modeset state change.</p>
<p>For an implementation of how to use this look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> from the atomic helper library.</p>
<dl class="type">
<dt id="c.drm_private_state_funcs">
struct <code class="descname">drm_private_state_funcs</code><a class="headerlink" href="#c.drm_private_state_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>atomic state functions for private objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_private_state_funcs {
  void *(* duplicate_state) (struct drm_atomic_state *state, void *obj);
  void (* swap_state) (void *obj, void **obj_state_ptr);
  void (* destroy_state) (void *obj_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current state of the private object and return it. It
is an error to call this before obj-&gt;state has been initialized.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when obj-&gt;state is not
initialized or allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">swap_state</span></code></dt>
<dd>This function swaps the existing state of a private object <strong>obj</strong> with
it&#8217;s newly created state, the pointer to which is passed as
<strong>obj_state_ptr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_state</span></code></dt>
<dd>Frees the private object state created with <strong>duplicate_state</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by atomic helpers to create, swap and destroy states of
private objects. The structure itself is used as a vtable to identify the
associated private object type. Each private object type that needs to be
added to the atomic states is expected to have an implementation of these
hooks and pass a pointer to it&#8217;s drm_private_state_funcs struct to
<a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_atomic_state">
struct <code class="descname">drm_atomic_state</code><a class="headerlink" href="#c.drm_atomic_state" title="Permalink to this definition">¶</a></dt>
<dd><p>the global state object for atomic updates</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_atomic_state {
  struct kref ref;
  struct drm_device * dev;
  bool allow_modeset:1;
  bool legacy_cursor_update:1;
  struct __drm_planes_state * planes;
  struct __drm_crtcs_state * crtcs;
  int num_connector;
  struct __drm_connnectors_state * connectors;
  int num_private_objs;
  struct __drm_private_objs_state * private_objs;
  struct drm_modeset_acquire_ctx * acquire_ctx;
  struct work_struct commit_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>count of all references to this state (will not be freed until zero)</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">allow_modeset</span></code></dt>
<dd>allow full modeset</dd>
<dt><code class="docutils literal"><span class="pre">legacy_cursor_update</span></code></dt>
<dd>hint to enforce legacy cursor IOCTL semantics</dd>
<dt><code class="docutils literal"><span class="pre">planes</span></code></dt>
<dd>pointer to array of structures with per-plane data</dd>
<dt><code class="docutils literal"><span class="pre">crtcs</span></code></dt>
<dd>pointer to array of CRTC pointers</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>size of the <strong>connectors</strong> and <strong>connector_states</strong> arrays</dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>pointer to array of structures with per-connector data</dd>
<dt><code class="docutils literal"><span class="pre">num_private_objs</span></code></dt>
<dd>size of the <strong>private_objs</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">private_objs</span></code></dt>
<dd>pointer to array of private object pointers</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>acquire context for this atomic modeset state update</dd>
<dt><code class="docutils literal"><span class="pre">commit_work</span></code></dt>
<dd>Work item which can be used by the driver or helpers to execute the
commit without blocking.</dd>
</dl>
<dl class="function">
<dt id="c.drm_crtc_commit_get">
void <code class="descname">drm_crtc_commit_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the CRTC commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increases the reference of <strong>commit</strong>.</p>
<dl class="function">
<dt id="c.drm_crtc_commit_put">
void <code class="descname">drm_crtc_commit_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the CRTC commmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>commit</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_state_get">
struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_state_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new reference to the <strong>state</strong></p>
<dl class="function">
<dt id="c.drm_atomic_state_put">
void <code class="descname">drm_atomic_state_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>state</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_existing_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the crtc state for the given crtc, or NULL
if the crtc is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_crtc_state</strong> or
<strong>drm_atomic_get_new_crtc_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_old_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get old crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_new_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get new crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_existing_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, or NULL
if the plane is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_plane_state</strong> or
<strong>drm_atomic_get_new_plane_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_old_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_new_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_existing_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_connector_state</strong> or
<strong>drm_atomic_get_new_connector_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_old_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_new_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.__drm_atomic_get_current_plane_state">
const struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">__drm_atomic_get_current_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_get_current_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get current plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, either from
<strong>state</strong>, or if the plane isn&#8217;t part of the atomic state update, from <strong>plane</strong>.
This is useful in atomic check callbacks, when drivers need to peek at, but
not change, state of other planes, since it avoids threading an error code
back up the call chain.</p>
<p>WARNING:</p>
<p>Note that this function is in general unsafe since it doesn&#8217;t check for the
required locking for access state structures. Drivers must ensure that it is
safe to access the returned state structure through other means. One common
example is when planes are fixed to a single CRTC, and the driver knows that
the CRTC lock is held already. In that case holding the CRTC lock gives a
read-lock on all planes connected to that CRTC. But if planes can be
reassigned things get more tricky. In that case it&#8217;s better to use
drm_atomic_get_plane_state and wire up full error handling.</p>
<p><strong>Return</strong></p>
<p>Read-only pointer to the current plane state.</p>
<dl class="function">
<dt id="c.for_each_connector_in_state">
<code class="descname">for_each_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update. Note that before the
software state is committed (by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>, this
points to the new state, while afterwards it points to the old state. Due to
this tricky confusion this macro is deprecated.</p>
<p>FIXME:</p>
<p>Replace all usage of this with one of the explicit iterators below and then
remove this macro.</p>
<dl class="function">
<dt id="c.for_each_oldnew_connector_in_state">
<code class="descname">for_each_oldnew_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_connector_in_state">
<code class="descname">for_each_old_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_connector_in_state">
<code class="descname">for_each_new_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_crtc_in_state">
<code class="descname">for_each_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update. Note that before the
software state is committed (by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>, this
points to the new state, while afterwards it points to the old state. Due to
this tricky confusion this macro is deprecated.</p>
<p>FIXME:</p>
<p>Replace all usage of this with one of the explicit iterators below and then
remove this macro.</p>
<dl class="function">
<dt id="c.for_each_oldnew_crtc_in_state">
<code class="descname">for_each_oldnew_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_crtc_in_state">
<code class="descname">for_each_old_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_crtc_in_state">
<code class="descname">for_each_new_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_plane_in_state">
<code class="descname">for_each_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update. Note that before the
software state is committed (by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>, this
points to the new state, while afterwards it points to the old state. Due to
this tricky confusion this macro is deprecated.</p>
<p>FIXME:</p>
<p>Replace all usage of this with one of the explicit iterators below and then
remove this macro.</p>
<dl class="function">
<dt id="c.for_each_oldnew_plane_in_state">
<code class="descname">for_each_oldnew_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_plane_in_state">
<code class="descname">for_each_old_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_plane_in_state">
<code class="descname">for_each_new_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.__for_each_private_obj">
<code class="descname">__for_each_private_obj</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>obj_state</em>, <em>__i</em>, <em>__funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__for_each_private_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>private object iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">obj_state</span></code></dt>
<dd>private object state iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
<dt><code class="docutils literal"><span class="pre">__funcs</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span></code></a> iteration cursor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro iterates over the array containing private object data in atomic
state</p>
<dl class="function">
<dt id="c.for_each_private_obj">
<code class="descname">for_each_private_obj</code><span class="sig-paren">(</span><em>__state</em>, <em>obj_funcs</em>, <em>obj</em>, <em>obj_state</em>, <em>__i</em>, <em>__funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_private_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a specify type of private object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj_funcs</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span></code></a> function table to filter
private objects</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>private object iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">obj_state</span></code></dt>
<dd>private object state iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
<dt><code class="docutils literal"><span class="pre">__funcs</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span></code></a> iteration cursor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro iterates over the private objects state array while filtering the
objects based on the vfunc table that is passed as <strong>obj_funcs</strong>. New macros
can be created by passing in the vfunc table associated with a specific
private object.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_needs_modeset">
bool <code class="descname">drm_atomic_crtc_needs_modeset</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_needs_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>compute combined modeset need</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a> for the CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>To give drivers flexibility <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> has 3 booleans to track
whether the state CRTC changed enough to need a full modeset cycle:
planes_changed, mode_changed and active_changed. This helper simply
combines these three to compute the overall need for a modeset for <strong>state</strong>.</p>
<p>The atomic helper code sets these booleans, but drivers can and should
change them appropriately to accurately represent whether a modeset is
really needed. In general, drivers should avoid full modesets whenever
possible.</p>
<p>For example if the CRTC mode has changed, and the hardware is able to enact
the requested mode change without going through a full modeset, the driver
should clear mode_changed in its <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
implementation.</p>
<dl class="function">
<dt id="c.drm_atomic_state_default_release">
void <code class="descname">drm_atomic_state_default_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory initialized by drm_atomic_state_init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all the memory allocated by drm_atomic_state_init.
This is useful for drivers that subclass the atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_state_init">
int <code class="descname">drm_atomic_state_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_init" title="Permalink to this definition">¶</a></dt>
<dd><p>init new atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for filling in a new atomic state.
This is useful for drivers that subclass the atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_state_alloc">
struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_state_alloc</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates an empty atomic state to track updates.</p>
<dl class="function">
<dt id="c.drm_atomic_state_default_clear">
void <code class="descname">drm_atomic_state_default_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear base atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for clearing atomic state.
This is useful for drivers that subclass the atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_state_clear">
void <code class="descname">drm_atomic_state_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the w/w mutex algorithm detects a deadlock we need to back off and drop
all locks. So someone else could sneak in and change the current modeset
configuration. Which means that all the state assembled in <strong>state</strong> is no
longer an atomic update to the current state, but to some arbitrary earlier
state. Which could break assumptions the driver&#8217;s
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> likely relies on.</p>
<p>Hence we must clear all cached state and completely start over, using this
function.</p>
<dl class="function">
<dt id="c.__drm_atomic_state_free">
void <code class="descname">__drm_atomic_state_free</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;ref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_state_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free all memory for an atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">ref</span></code></dt>
<dd>This atomic state to deallocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>This frees all memory associated with an atomic state, including all the
per-object state for planes, crtcs and connectors.</p>
<dl class="function">
<dt id="c.drm_atomic_get_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get crtc state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the crtc state for the given crtc, allocating it if
needed. It will also grab the relevant crtc lock to make sure that the state
is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_mode_for_crtc">
int <code class="descname">drm_atomic_set_mode_for_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_for_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the CRTC whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>kernel-internal mode to use for the CRTC, or NULL to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from the kernel) on the desired CRTC state and update
the enable property.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_atomic_set_mode_prop_for_crtc">
int <code class="descname">drm_atomic_set_mode_prop_for_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_prop_for_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the CRTC whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>pointer to blob property to use for mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from a blob property) on the desired CRTC state.
This function will take a reference on the blob property for the CRTC state,
and release the reference held on the state&#8217;s existing mode property, if any
was set.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_set_property">
int <code class="descname">drm_atomic_crtc_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the drm CRTC to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.atomic_set_property</span></code></a> for driver properties. To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_get_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, allocating it if
needed. It will also grab the relevant plane lock to make sure that the state
is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_plane_set_property">
int <code class="descname">drm_atomic_plane_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>the drm plane to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_get_private_obj_state">
void * <code class="descname">drm_atomic_get_private_obj_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, void *<em>&nbsp;obj</em>, const struct <a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs">drm_private_state_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_private_obj_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get private object state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>private object to get the state for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>pointer to the struct of function pointers that identify the object
type</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the private object state for the given private object,
allocating the state if needed. It does not grab any locks as the caller is
expected to care of any required locking.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into a pointer.</p>
<dl class="function">
<dt id="c.drm_atomic_get_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
allocating it if needed. It will also grab the relevant connector lock to
make sure that the state is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_connector_set_property">
int <code class="descname">drm_atomic_connector_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_connector_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on connector.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the drm connector to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_set_crtc_for_plane">
int <code class="descname">drm_atomic_set_crtc_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set crtc for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>the plane whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned crtc for a plane requires us to grab the lock and state
for the new crtc, as needed. This function takes care of all these details
besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_fb_for_plane">
void <code class="descname">drm_atomic_set_fb_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fb_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set framebuffer for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>atomic state object for the plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>fb to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned framebuffer for a plane requires us to grab a reference
to the new fb and drop the reference to the old fb, if there is one. This
function takes care of all these details besides updating the pointer in the
state object itself.</p>
<dl class="function">
<dt id="c.drm_atomic_set_fence_for_plane">
void <code class="descname">drm_atomic_set_fence_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fence_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set fence for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>atomic state object for the plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>dma_fence to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to setup the plane_state fence in case it is not set yet.
By using this drivers doesn&#8217;t need to worry if the user choose
implicit or explicit fencing.</p>
<p>This function will not set the fence to the state if it was set
via explicit fencing interfaces on the atomic ioctl. In that case it will
drop the reference to the fence as we are not storing it anywhere.
Otherwise, if <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.fence</span></code></a> is not set this function we just set it
with the received implicit fence. In both cases this function consumes a
reference for <strong>fence</strong>.</p>
<dl class="function">
<dt id="c.drm_atomic_set_crtc_for_connector">
int <code class="descname">drm_atomic_set_crtc_for_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>set crtc for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>atomic state object for the connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to use for the connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned crtc for a connector requires us to grab the lock and
state for the new crtc, as needed. This function takes care of all these
details besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_add_affected_connectors">
int <code class="descname">drm_atomic_add_affected_connectors</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_connectors" title="Permalink to this definition">¶</a></dt>
<dd><p>add connectors for crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all connectors
currently using <strong>crtc</strong> to the atomic configuration <strong>state</strong>. Note that this
function must acquire the connection mutex. This can potentially cause
unneeded seralization if the update is just for the planes on one crtc. Hence
drivers and helpers should only call this when really needed (e.g. when a
full modeset needs to happen due to some change).</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_add_affected_planes">
int <code class="descname">drm_atomic_add_affected_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>add planes for crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all planes
currently used by <strong>crtc</strong> to the atomic configuration <strong>state</strong>. This is useful
when an atomic commit also needs to check all currently enabled plane on
<strong>crtc</strong>, e.g. when changing the mode. It&#8217;s also useful when re-enabling a CRTC
to avoid special code to force-enable all planes.</p>
<p>Since acquiring a plane state will always also acquire the w/w mutex of the
current CRTC for that plane (if there is any) adding all the plane states for
a CRTC will not reduce parallism of atomic updates.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_legacy_backoff">
void <code class="descname">drm_atomic_legacy_backoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_legacy_backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>locking backoff for legacy ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be used by legacy entry points which don&#8217;t understand
-EDEADLK semantics. For simplicity this one will grab all modeset locks after
the slowpath completed.</p>
<dl class="function">
<dt id="c.drm_atomic_check_only">
int <code class="descname">drm_atomic_check_only</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_check_only" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a given config would work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_commit">
int <code class="descname">drm_atomic_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit configuration atomically</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_nonblocking_commit">
int <code class="descname">drm_atomic_nonblocking_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_nonblocking_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>atomic nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_state_dump">
void <code class="descname">drm_state_dump</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_state_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump entire device atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>where to print the state to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just for debugging.  Drivers might want an option to dump state
to dmesg in case of error irq&#8217;s.  (Hint, you probably want to
ratelimit this!)</p>
<p>The caller must <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a>, or if this is called
from error irq handler, it should not be enabled by default.
(Ie. if you are debugging errors you might not care that this
is racey.  But calling this without all modeset locks held is
not inherently safe.)</p>
<dl class="function">
<dt id="c.drm_atomic_clean_old_fb">
void <code class="descname">drm_atomic_clean_old_fb</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned<em>&nbsp;plane_mask</em>, int<em>&nbsp;ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_clean_old_fb" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Unset old_fb pointers and set plane-&gt;fb pointers.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device to check.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">plane_mask</span></code></dt>
<dd>plane mask for planes that were updated.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ret</span></code></dt>
<dd>return value, can be -EDEADLK for a retry.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before doing an update <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.old_fb</span></code></a> is set to <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.fb</span></code></a>, but before
dropping the locks old_fb needs to be set to NULL and plane-&gt;fb updated. This
is a common operation for each atomic update, so this call is split off as a
helper.</p>
</div>
</div>
<div class="section" id="crtc-abstraction">
<h2>CRTC Abstraction<a class="headerlink" href="#crtc-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A CRTC represents the overall display pipeline. It receives pixel data from
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> and blends them together. The <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_display_mode</span></code></a> is also attached
to the CRTC, specifying display timings. On the output side the data is fed
to one or more <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>, which are then each connected to one
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>.</p>
<p>To create a CRTC, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The CRTC is also the entry point for legacy modeset operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a>, legacy plane operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.cursor_set2</span></code></a>, and other legacy
operations like <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.gamma_set</span></code></a>. For atomic drivers all these
features are controlled through <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a> and
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>.</p>
<div class="section" id="crtc-functions-reference">
<h3>CRTC Functions Reference<a class="headerlink" href="#crtc-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_state">
struct <code class="descname">drm_crtc_state</code><a class="headerlink" href="#c.drm_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable CRTC state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_crtc_state {
  struct drm_crtc * crtc;
  bool enable;
  bool active;
  bool planes_changed:1;
  bool mode_changed:1;
  bool active_changed:1;
  bool connectors_changed:1;
  bool zpos_changed:1;
  bool color_mgmt_changed:1;
  u32 plane_mask;
  u32 connector_mask;
  u32 encoder_mask;
  struct drm_display_mode adjusted_mode;
  struct drm_display_mode mode;
  struct drm_property_blob * mode_blob;
  struct drm_property_blob * degamma_lut;
  struct drm_property_blob * ctm;
  struct drm_property_blob * gamma_lut;
  u32 target_vblank;
  u32 pageflip_flags;
  struct drm_pending_vblank_event * event;
  struct drm_atomic_state * state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>backpointer to the CRTC</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>whether the CRTC should be enabled, gates all other state</dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>whether the CRTC is actively displaying (used for DPMS)</dd>
<dt><code class="docutils literal"><span class="pre">planes_changed</span></code></dt>
<dd>planes on this crtc are updated</dd>
<dt><code class="docutils literal"><span class="pre">mode_changed</span></code></dt>
<dd><strong>mode</strong> or <strong>enable</strong> has been changed</dd>
<dt><code class="docutils literal"><span class="pre">active_changed</span></code></dt>
<dd><strong>active</strong> has been toggled.</dd>
<dt><code class="docutils literal"><span class="pre">connectors_changed</span></code></dt>
<dd>connectors to this crtc have been updated</dd>
<dt><code class="docutils literal"><span class="pre">zpos_changed</span></code></dt>
<dd>zpos values of planes on this crtc have been updated</dd>
<dt><code class="docutils literal"><span class="pre">color_mgmt_changed</span></code></dt>
<dd>color management properties have changed (degamma or
gamma LUT or CSC matrix)</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_plane_index(plane)) of attached planes</dd>
<dt><code class="docutils literal"><span class="pre">connector_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_connector_index(connector)) of attached connectors</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_encoder_index(encoder)) of attached encoders</dd>
<dt><code class="docutils literal"><span class="pre">adjusted_mode</span></code></dt>
<dd>Internal display timings which can be used by the driver to handle
differences between the mode requested by userspace in <strong>mode</strong> and what
is actually programmed into the hardware. It is purely driver
implementation defined what exactly this adjusted mode means. Usually
it is used to store the hardware display timings used between the
CRTC and encoder blocks.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd><p class="first">Display timings requested by userspace. The driver should try to
match the refresh rate as close as possible (but note that it&#8217;s
undefined what exactly is close enough, e.g. some of the HDMI modes
only differ in less than 1% of the refresh rate). The active width
and height as observed by userspace for positioning planes must match
exactly.</p>
<p class="last">For external connectors where the sink isn&#8217;t fixed (like with a
built-in panel), this mode here should match the physical mode on the
wire to the last details (i.e. including sync polarities and
everything).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_blob</span></code></dt>
<dd><a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a> for <strong>mode</strong></dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut</span></code></dt>
<dd>Lookup table for converting framebuffer pixel data before apply the
color conversion matrix <strong>ctm</strong>. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ctm</span></code></dt>
<dd>Color transformation matrix. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_ctm</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut</span></code></dt>
<dd>Lookup table for converting pixel data after the color conversion
matrix <strong>ctm</strong>.  See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The blob (if not
NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">target_vblank</span></code></dt>
<dd>Target vertical blank period when a page flip
should take effect.</dd>
<dt><code class="docutils literal"><span class="pre">pageflip_flags</span></code></dt>
<dd>DRM_MODE_PAGE_FLIP_* flags, as passed to the page flip ioctl.
Zero in any other case.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><p class="first">Optional pointer to a DRM event to signal upon completion of the
state update. The driver must send out the event when the atomic
commit operation completes. There are two cases:</p>
<blockquote>
<div><ul class="simple">
<li>The event is for a CRTC which is being disabled through this
atomic commit. In that case the event can be send out any time
after the hardware has stopped scanning out the current
framebuffers. It should contain the timestamp and counter for the
last vblank before the display pipeline was shut off. The simplest
way to achieve that is calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a>
somewhen after <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> has been called.</li>
<li>For a CRTC which is enabled at the end of the commit (even when it
undergoes an full modeset) the vblank timestamp and counter must
be for the vblank right before the first frame that scans out the
new set of buffers. Again the event can only be sent out after the
hardware has stopped scanning out the old buffers.</li>
<li>Events for disabled CRTCs are not allowed, and drivers can ignore
that case.</li>
</ul>
</div></blockquote>
<p>This can be handled by the <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function,
which the driver should call on the provided event upon completion of
the atomic commit. Note that if the driver supports vblank signalling
and timestamping the vblank counters and timestamps must agree with
the ones returned from page flip events. With the current vblank
helper infrastructure this can be achieved by holding a vblank
reference while the page flip is pending, acquired through
<a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with <a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code></a>.
Drivers are free to implement their own vblank counter and timestamp
tracking though, e.g. if they have accurate timestamp registers in
hardware.</p>
<p>For hardware which supports some means to synchronize vblank
interrupt delivery with committing display state there&#8217;s also
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>. See the documentation of that function
for a detailed discussion of the constraints it needs to be used
safely.</p>
<p class="last">If the device can&#8217;t notify of flip completion in a race-free way
at all, then the event should be armed just after the page flip is
committed. In the worst case the driver will send the event to
userspace one frame too late. This doesn&#8217;t allow for a real atomic
update, but it should avoid tearing.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the distinction between <strong>enable</strong> and <strong>active</strong> is rather subtile:
Flipping <strong>active</strong> while <strong>enable</strong> is set without changing anything else may
never return in a failure from the <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
callback. Userspace assumes that a DPMS On will always succeed. In other
words: <strong>enable</strong> controls resource assignment, <strong>active</strong> controls the actual
hardware state.</p>
<p>The three booleans active_changed, connectors_changed and mode_changed are
intended to indicate whether a full modeset is needed, rather than strictly
describing what has changed in a commit.
See also: <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<dl class="type">
<dt id="c.drm_crtc_funcs">
struct <code class="descname">drm_crtc_funcs</code><a class="headerlink" href="#c.drm_crtc_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control CRTCs for a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_crtc_funcs {
  void (* reset) (struct drm_crtc *crtc);
  int (* cursor_set) (struct drm_crtc *crtc, struct drm_file *file_priv,uint32_t handle, uint32_t width, uint32_t height);
  int (* cursor_set2) (struct drm_crtc *crtc, struct drm_file *file_priv,uint32_t handle, uint32_t width, uint32_t height,int32_t hot_x, int32_t hot_y);
  int (* cursor_move) (struct drm_crtc *crtc, int x, int y);
  int (* gamma_set) (struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,uint32_t size,struct drm_modeset_acquire_ctx *ctx);
  void (* destroy) (struct drm_crtc *crtc);
  int (* set_config) (struct drm_mode_set *set,struct drm_modeset_acquire_ctx *ctx);
  int (* page_flip) (struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags,struct drm_modeset_acquire_ctx *ctx);
  int (* page_flip_target) (struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, uint32_t target,struct drm_modeset_acquire_ctx *ctx);
  int (* set_property) (struct drm_crtc *crtc,struct drm_property *property, uint64_t val);
  struct drm_crtc_state *(* atomic_duplicate_state) (struct drm_crtc *crtc);
  void (* atomic_destroy_state) (struct drm_crtc *crtc,struct drm_crtc_state *state);
  int (* atomic_set_property) (struct drm_crtc *crtc,struct drm_crtc_state *state,struct drm_property *property,uint64_t val);
  int (* atomic_get_property) (struct drm_crtc *crtc,const struct drm_crtc_state *state,struct drm_property *property,uint64_t *val);
  int (* late_register) (struct drm_crtc *crtc);
  void (* early_unregister) (struct drm_crtc *crtc);
  int (* set_crc_source) (struct drm_crtc *crtc, const char *source,size_t *values_cnt);
  void (* atomic_print_state) (struct drm_printer *p,const struct drm_crtc_state *state);
  u32 (* get_vblank_counter) (struct drm_crtc *crtc);
  int (* enable_vblank) (struct drm_crtc *crtc);
  void (* disable_vblank) (struct drm_crtc *crtc);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset CRTC hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_reset" title="drm_atomic_helper_crtc_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set</span></code></dt>
<dd><p class="first">Update the cursor image. The cursor position is relative to the CRTC
and can be partially or fully outside of the visible area.</p>
<p>Note that contrary to all other KMS functions the legacy cursor entry
points don&#8217;t take a framebuffer object, but instead take directly a
raw buffer object id from the driver&#8217;s buffer manager (which is
either GEM or TTM for current drivers).</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set2</span></code></dt>
<dd><p class="first">Update the cursor image, including hotspot information. The hotspot
must not affect the cursor position in CRTC coordinates, but is only
meant as a hint for virtualized display hardware to coordinate the
guests and hosts cursor position. The cursor hotspot is relative to
the cursor image. Otherwise this works exactly like <strong>cursor_set</strong>.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_move</span></code></dt>
<dd><p class="first">Update the cursor position. The cursor does not need to be visible
when this hook is called.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gamma_set</span></code></dt>
<dd><p class="first">Set gamma on the CRTC.</p>
<p>This callback is optional.</p>
<p>Atomic drivers who want to support gamma tables should implement the
atomic color management support, enabled by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>, which then supports the legacy gamma
interface through the <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a>
compatibility implementation.</p>
<p>NOTE:</p>
<p class="last">Drivers that support gamma tables and also fbdev emulation through
the provided helper library need to take care to fill out the gamma
hooks for both. Currently there&#8217;s a bit an unfortunate duplication
going on, which should eventually be unified to just one set of
hooks.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a CRTC cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd><p class="first">This is the main legacy entry point to change the modeset state on a
CRTC. All the details of the desired configuration are passed in a
<a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span></code></a> - see there for details.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_set_config()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip</span></code></dt>
<dd><p class="first">Legacy entry point to schedule a flip to the given framebuffer.</p>
<p>Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing (except when requested otherwise
through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
requests a page flip the DRM core verifies that the new frame buffer
is large enough to be scanned out by the CRTC in the currently
configured mode and then calls this hook with a pointer to the new
frame buffer.</p>
<p>The driver must wait for any pending rendering to the new framebuffer
to complete before executing the flip. It should also wait for any
pending rendering from other drivers if the underlying buffer is a
shared dma-buf.</p>
<p>An application can request to be notified when the page flip has
completed. The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in the event
parameter in this case. This can be handled by the
<a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function, which the driver should call on
the provided event upon completion of the flip. Note that if
the driver supports vblank signalling and timestamping the vblank
counters and timestamps must agree with the ones returned from page
flip events. With the current vblank helper infrastructure this can
be achieved by holding a vblank reference while the page flip is
pending, acquired through <a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with
<a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code></a>. Drivers are free to implement their own vblank
counter and timestamp tracking though, e.g. if they have accurate
timestamp registers in hardware.</p>
<p>This callback is optional.</p>
<p>NOTE:</p>
<p>Very early versions of the KMS ABI mandated that the driver must
block (but not reject) any rendering to the old framebuffer until the
flip operation has completed and the old framebuffer is no longer
visible. This requirement has been lifted, and userspace is instead
expected to request delivery of an event and wait with recycling old
buffers until such has been received.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure. Note that if a
page flip operation is already pending the callback should return
-EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
or just runtime disabled through DPMS respectively the new atomic
&#8220;ACTIVE&#8221; state) should result in an -EINVAL error code. Note that
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> checks this already for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip_target</span></code></dt>
<dd><p class="first">Same as <strong>page_flip</strong> but with an additional parameter specifying the
absolute target vertical blank period (as reported by
<a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_count()</span></code></a>) when the flip should take effect.</p>
<p class="last">Note that the core code calls drm_crtc_vblank_get before this entry
point, and will call drm_crtc_vblank_put if this entry point returns
any non-0 error code. It&#8217;s the driver&#8217;s responsibility to call
drm_crtc_vblank_put after this entry point returns 0, typically when
the flip completes.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
CRTC.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_set_property" title="drm_atomic_helper_crtc_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_set_property()</span></code></a> to implement this hook.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this CRTC and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_duplicate_state" title="drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_crtc_duplicate_state" title="__drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_crtc_set_property" title="drm_atomic_crtc_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which should never happen, the core only
asks for properties attached to this CRTC). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCRTC IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this CRTC).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the crtc like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the crtc from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">set_crc_source</span></code></dt>
<dd><p class="first">Changes the source of CRC checksums of frames at the request of
userspace, typically for testing purposes. The sources available are
specific of each driver and a <code class="docutils literal"><span class="pre">NULL</span></code> value indicates that CRC
generation is to be switched off.</p>
<p>When CRC generation is enabled, the driver should call
<a class="reference internal" href="drm-uapi.html#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_add_crc_entry()</span></code></a> at each frame, providing any information
that characterizes the frame contents in the crcN arguments, as
provided from the configured source. Drivers must accept an &#8220;auto&#8221;
source name that will select a default source for this CRTC.</p>
<p>Note that &#8220;auto&#8221; can depend upon the current modeset configuration,
e.g. it could pick an encoder or output specific CRC sampling point.</p>
<p>This callback is optional if the driver does not support any CRC
generation functionality.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_print_state()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_vblank_counter</span></code></dt>
<dd><p class="first">Driver callback for fetching a raw hardware vblank counter for the
CRTC. It&#8217;s meant to be used by new drivers as the replacement of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_vblank_counter</span></code></a> hook.</p>
<p>This callback is optional. If a device doesn&#8217;t have a hardware
counter, the driver can simply leave the hook as NULL. The DRM core
will account for missed vblank events while interrupts where disabled
based on system timestamps.</p>
<p>Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> when disabling or
enabling a CRTC.</p>
<p>Returns:</p>
<p class="last">Raw vblank counter value.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable_vblank</span></code></dt>
<dd><p class="first">Enable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.enable_vblank</span></code></a> hook.</p>
<p>Returns:</p>
<p class="last">Zero on success, appropriate errno if the vblank interrupt cannot
be enabled.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_vblank</span></code></dt>
<dd>Disable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.disable_vblank</span></code></a> hook.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The drm_crtc_funcs structure is the central CRTC management structure
in the DRM.  Each CRTC controls one or more connectors (note that the name
CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
connectors, not just CRTs).</p>
<p>Each driver is responsible for filling out this structure at startup time,
in addition to providing other modesetting features, like i2c and DDC
bus accessors.</p>
<dl class="type">
<dt id="c.drm_crtc">
struct <code class="descname">drm_crtc</code><a class="headerlink" href="#c.drm_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>central CRTC control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_crtc {
  struct drm_device * dev;
  struct device_node * port;
  struct list_head head;
  char * name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  struct drm_plane * primary;
  struct drm_plane * cursor;
  unsigned index;
  int cursor_x;
  int cursor_y;
  bool enabled;
  struct drm_display_mode mode;
  struct drm_display_mode hwmode;
  int x;
  int y;
  const struct drm_crtc_funcs * funcs;
  uint32_t gamma_size;
  uint16_t * gamma_store;
  const struct drm_crtc_helper_funcs * helper_private;
  struct drm_object_properties properties;
  struct drm_crtc_state * state;
  struct list_head commit_list;
  spinlock_t commit_lock;
#ifdef CONFIG_DEBUG_FS
  struct dentry * debugfs_entry;
#endif
  struct drm_crtc_crc crc;
  unsigned int fence_context;
  spinlock_t fence_lock;
  unsigned long fence_seqno;
  char timeline_name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">port</span></code></dt>
<dd>OF node used by <code class="xref c c-func docutils literal"><span class="pre">drm_of_find_possible_crtcs()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This provides a read lock for the overall CRTC state (mode, dpms
state, ...) and a write lock for everything which can be update
without a full modeset (fb, cursor data, CRTC properties ...). A full
modeset also need to grab <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>.</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object for ID tracking etc.</dd>
<dt><code class="docutils literal"><span class="pre">primary</span></code></dt>
<dd>primary plane for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">cursor</span></code></dt>
<dd>cursor plane for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_x</span></code></dt>
<dd>current x position of the cursor, used for universal cursor planes</dd>
<dt><code class="docutils literal"><span class="pre">cursor_y</span></code></dt>
<dd>current y position of the cursor, used for universal cursor planes</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>is this CRTC enabled?</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>current mode timings</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd>mode timings as programmed to hw regs</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>x position on screen</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>y position on screen</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>CRTC control functions</dd>
<dt><code class="docutils literal"><span class="pre">gamma_size</span></code></dt>
<dd>size of gamma ramp</dd>
<dt><code class="docutils literal"><span class="pre">gamma_store</span></code></dt>
<dd>gamma ramp values</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this CRTC.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current CRTC state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_crtc_in_state" title="for_each_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_crtc_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_oldnew_crtc_in_state" title="for_each_oldnew_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_crtc_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_crtc_in_state" title="for_each_old_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_crtc_in_state()</span></code></a> and <a class="reference internal" href="#c.for_each_new_crtc_in_state" title="for_each_new_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_crtc_in_state()</span></code></a>. Or
through careful ordering of atomic commit operations as implemented
in the atomic helpers, see <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_list</span></code></dt>
<dd>List of <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit</span></code></a> structures tracking pending commits.
Protected by <strong>commit_lock</strong>. This list doesn&#8217;t hold its own full
reference, but burrows it from the ongoing commit. Commit entries
must be removed from this list once the commit is fully completed,
but before it&#8217;s correspoding <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> gets destroyed.</dd>
<dt><code class="docutils literal"><span class="pre">commit_lock</span></code></dt>
<dd>Spinlock to protect <strong>commit_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>Debugfs directory for this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">crc</span></code></dt>
<dd>Configuration settings of CRC capture.</dd>
<dt><code class="docutils literal"><span class="pre">fence_context</span></code></dt>
<dd>timeline context used for fence operations.</dd>
<dt><code class="docutils literal"><span class="pre">fence_lock</span></code></dt>
<dd>spinlock to protect the fences in the fence_context.</dd>
<dt><code class="docutils literal"><span class="pre">fence_seqno</span></code></dt>
<dd>Seqno variable used as monotonic counter for the fences
created on the CRTC&#8217;s timeline.</dd>
<dt><code class="docutils literal"><span class="pre">timeline_name</span></code></dt>
<dd>The name of the CRTC&#8217;s fence timeline.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors associated with it.  This structure
allows the CRTC to be controlled.</p>
<dl class="type">
<dt id="c.drm_mode_set">
struct <code class="descname">drm_mode_set</code><a class="headerlink" href="#c.drm_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>new values for a CRTC config change</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_mode_set {
  struct drm_framebuffer * fb;
  struct drm_crtc * crtc;
  struct drm_display_mode * mode;
  uint32_t x;
  uint32_t y;
  struct drm_connector ** connectors;
  size_t num_connectors;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>framebuffer to use for new config</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>CRTC whose configuration we&#8217;re about to change</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>mode timings to use</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>array of connectors to drive with this CRTC if possible</dd>
<dt><code class="docutils literal"><span class="pre">num_connectors</span></code></dt>
<dd>size of <strong>connectors</strong> array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a modeset configuration for the legacy SETCRTC ioctl and is
also used internally. Atomic drivers instead use <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_index">
unsigned int <code class="descname">drm_crtc_index</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the index of that CRTC within a DRM
device&#8217;s list of CRTCs.</p>
<dl class="function">
<dt id="c.drm_crtc_mask">
uint32_t <code class="descname">drm_crtc_mask</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find mask for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the mask bit of that CRTC for an
encoder&#8217;s possible_crtcs field.</p>
<dl class="function">
<dt id="c.drm_crtc_find">
struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> * <code class="descname">drm_crtc_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a CRTC object from its ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a> ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to look up a CRTC from its userspace ID. Only used by
drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
userspace interface should be done using <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_crtc">
<code class="descname">drm_for_each_crtc</code><span class="sig-paren">(</span><em>crtc</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> as the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all CRTCs of <strong>dev</strong>.</p>
<dl class="function">
<dt id="c.drm_crtc_from_index">
struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> * <code class="descname">drm_crtc_from_index</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_from_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the registered CRTC at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of registered CRTC to find for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a CRTC index, return the registered CRTC from DRM device&#8217;s
list of CRTCs with matching index. This is the inverse of <a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a>.
It&#8217;s useful in the vblank callbacks (like <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.enable_vblank</span></code></a> or
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.disable_vblank</span></code></a>), since that still deals with indices instead
of pointers to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>.&#8221;</p>
<dl class="function">
<dt id="c.drm_crtc_force_disable">
int <code class="descname">drm_crtc_force_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to turn off</dd>
</dl>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_force_disable_all">
int <code class="descname">drm_crtc_force_disable_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_force_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off all enabled CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device whose CRTCs to turn off</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may want to call this on unload to ensure that all displays are
unlit and the GPU is in a consistent, low power state. Takes modeset locks.</p>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers. For an atomic
version look at <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_init_with_planes">
int <code class="descname">drm_crtc_init_with_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;primary</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;cursor</em>, const struct <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a> *<em>&nbsp;funcs</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init_with_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a new CRTC object with specified primary and cursor planes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC object to init</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">primary</span></code></dt>
<dd>Primary plane for CRTC</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>Cursor plane for CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the CRTC name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inits a new object created as base part of a driver crtc object. Drivers
should use this function instead of <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_init" title="drm_crtc_init"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init()</span></code></a>, which is only provided
for backwards compatibility with drivers which do not yet support universal
planes). For really simple hardware which has only 1 plane look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_cleanup">
void <code class="descname">drm_crtc_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the core crtc usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>crtc</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the crtc structure itself,
this is the responsibility of the caller.</p>
<dl class="function">
<dt id="c.drm_mode_set_config_internal">
int <code class="descname">drm_mode_set_config_internal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em>&nbsp;set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_config_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to call <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.set_config</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt>
<dd>modeset config to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a little helper to wrap internal calls to the
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> driver interface. The only thing it adds is
correct refcounting dance.</p>
<p>This should only be used by non-atomic legacy drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_check_viewport">
int <code class="descname">drm_crtc_check_viewport</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, int<em>&nbsp;x</em>, int<em>&nbsp;y</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_check_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a framebuffer is big enough for the CRTC viewport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC that framebuffer will be displayed on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>x panning</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span></code></dt>
<dd>y panning</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode that framebuffer will be displayed under</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to check size of</dd>
</dl>
</div>
</div>
<div class="section" id="frame-buffer-abstraction">
<h2>Frame Buffer Abstraction<a class="headerlink" href="#frame-buffer-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Frame buffers are abstract memory objects that provide a source of pixels to
scanout to a CRTC. Applications explicitly request the creation of frame
buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque
handle that can be passed to the KMS CRTC control, plane configuration and
page flip functions.</p>
<p>Frame buffers rely on the underlying memory manager for allocating backing
storage. When creating a frame buffer applications pass a memory handle
(or a list of memory handles for multi-planar formats) through the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> argument. For drivers using GEM as their userspace
buffer management interface this would be a GEM handle.  Drivers are however
free to use their own backing storage object handles, e.g. vmwgfx directly
exposes special TTM handles to userspace and so expects TTM handles in the
create ioctl and not GEM handles.</p>
<p>Framebuffers are tracked with <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>. They are published
using <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_init()</span></code></a> - after calling that function userspace can use
and access the framebuffer object. The helper function
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a> can be used to pre-fill the required
metadata fields.</p>
<p>The lifetime of a drm framebuffer is controlled with a reference count,
drivers can grab additional references with <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and drop
them again with <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>. For driver-private framebuffers for
which the last reference is never dropped (e.g. for the fbdev framebuffer
when the struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a> is embedded into the fbdev helper
struct) drivers can manually clean up a framebuffer at module unload time
with <a class="reference internal" href="#c.drm_framebuffer_unregister_private" title="drm_framebuffer_unregister_private"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_unregister_private()</span></code></a>. But doing this is not
recommended, and it&#8217;s better to have a normal free-standing <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_framebuffer</span></code></a>.</p>
<div class="section" id="frame-buffer-functions-reference">
<h3>Frame Buffer Functions Reference<a class="headerlink" href="#frame-buffer-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_framebuffer_funcs">
struct <code class="descname">drm_framebuffer_funcs</code><a class="headerlink" href="#c.drm_framebuffer_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>framebuffer hooks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_framebuffer_funcs {
  void (* destroy) (struct drm_framebuffer *framebuffer);
  int (* create_handle) (struct drm_framebuffer *fb,struct drm_file *file_priv,unsigned int *handle);
  int (* dirty) (struct drm_framebuffer *framebuffer,struct drm_file *file_priv, unsigned flags,unsigned color, struct drm_clip_rect *clips,unsigned num_clips);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up framebuffer resources, specifically also unreference the
backing storage. The core guarantees to call this function for every
framebuffer successfully created by calling
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>. Drivers must also call
<a class="reference internal" href="#c.drm_framebuffer_cleanup" title="drm_framebuffer_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_cleanup()</span></code></a> to release DRM core resources for this
framebuffer.</dd>
<dt><code class="docutils literal"><span class="pre">create_handle</span></code></dt>
<dd><p class="first">Create a buffer handle in the driver-specific buffer manager (either
GEM or TTM) valid for the passed-in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a>. This is used by
the core to implement the GETFB IOCTL, which returns (for
sufficiently priviledged user) also a native buffer handle. This can
be used for seamless transitions between modesetting clients by
copying the current screen contents to a private buffer and blending
between that and the new contents.</p>
<p>GEM based drivers should call <a class="reference internal" href="drm-mm.html#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_create()</span></code></a> to create the
handle.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dirty</span></code></dt>
<dd><p class="first">Optional callback for the dirty fb IOCTL.</p>
<p>Userspace can notify the driver via this callback that an area of the
framebuffer has changed and should be flushed to the display
hardware. This can also be used internally, e.g. by the fbdev
emulation, though that&#8217;s not the case currently.</p>
<p>See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
for more information as all the semantics and arguments have a one to
one mapping on this function.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_framebuffer">
struct <code class="descname">drm_framebuffer</code><a class="headerlink" href="#c.drm_framebuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>frame buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_framebuffer {
  struct drm_device * dev;
  struct list_head head;
  struct drm_mode_object base;
  const struct drm_format_info * format;
  const struct drm_framebuffer_funcs * funcs;
  unsigned int pitches;
  unsigned int offsets;
  uint64_t modifier;
  unsigned int width;
  unsigned int height;
  int flags;
  int hot_x;
  int hot_y;
  struct list_head filp_head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this framebuffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>Place on the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_list</span></code></a>, access protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_lock</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base modeset object structure, contains the reference count.</dd>
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>framebuffer format information</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>framebuffer vfunc table</dd>
<dt><code class="docutils literal"><span class="pre">pitches</span></code></dt>
<dd>Line stride per buffer. For userspace created object this
is copied from drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">offsets</span></code></dt>
<dd><p class="first">Offset from buffer start to the actual pixel data in bytes,
per buffer. For userspace created object this is copied from
drm_mode_fb_cmd2.</p>
<p>Note that this is a linear offset and does not take into account
tiling or buffer laytou per <strong>modifier</strong>. It meant to be used when the
actual pixel data for this framebuffer plane starts at an offset,
e.g.  when multiple planes are allocated within the same backing
storage buffer object. For tiled layouts this generally means it
<strong>offsets</strong> must at least be tile-size aligned, but hardware often has
stricter requirements.</p>
<p class="last">This should not be used to specifiy x/y pixel offsets into the buffer
data (even for linear buffers). Specifying an x/y pixel offset is
instead done through the source rectangle in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">modifier</span></code></dt>
<dd>Data layout modifier. This is used to describe
tiling, or also special layouts (like compression) of auxiliary
buffers. For userspace created object this is copied from
drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">width</span></code></dt>
<dd>Logical width of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">height</span></code></dt>
<dd>Logical height of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Framebuffer flags like DRM_MODE_FB_INTERLACED or
DRM_MODE_FB_MODIFIERS.</dd>
<dt><code class="docutils literal"><span class="pre">hot_x</span></code></dt>
<dd>X coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">hot_y</span></code></dt>
<dd>Y coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">filp_head</span></code></dt>
<dd>Placed on <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs</span></code></a>, protected by <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs_lock</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the fb is refcounted for the benefit of driver internals,
for example some hw, disabling a CRTC/plane is asynchronous, and
scanout does not actually complete until the next vblank.  So some
cleanup (like releasing the reference(s) on the backing GEM bo(s))
should be deferred.  In cases like this, the driver would like to
hold a ref to the fb even though it has already been removed from
userspace perspective. See <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and
<a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<p>The refcount is stored inside the mode object <strong>base</strong>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_get">
void <code class="descname">drm_framebuffer_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_put">
void <code class="descname">drm_framebuffer_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the framebuffer&#8217;s reference count and frees the
framebuffer if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_framebuffer_reference">
void <code class="descname">drm_framebuffer_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_unreference">
void <code class="descname">drm_framebuffer_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_read_refcount">
uint32_t <code class="descname">drm_framebuffer_read_refcount</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_read_refcount" title="Permalink to this definition">¶</a></dt>
<dd><p>read the framebuffer reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_assign">
void <code class="descname">drm_framebuffer_assign</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> **<em>&nbsp;p</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>store a reference to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">**</span> <span class="pre">p</span></code></dt>
<dd>location to store framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>new framebuffer (maybe NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets the location to store a reference to the framebuffer,
unreferencing the framebuffer that was previously stored in that location.</p>
<dl class="function">
<dt id="c.drm_framebuffer_init">
int <code class="descname">drm_framebuffer_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, const struct <a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>... with these functions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an ID for the framebuffer&#8217;s parent mode object, sets its mode
functions &amp; device file and adds it to the master fd list.</p>
<p>IMPORTANT:
This functions publishes the fb and makes it available for concurrent access
by other users. Which means by this point the fb _must_ be fully set up -
since all the fb attributes are invariant over its lifetime, no further
locking but only correct reference counting is required.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_framebuffer_lookup">
struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="descname">drm_framebuffer_lookup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a drm framebuffer and grab a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the fb object</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this grabs an additional reference to the framebuffer -
callers need to make sure to eventually unreference the returned framebuffer
again, using <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_unregister_private">
void <code class="descname">drm_framebuffer_unregister_private</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unregister_private" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a private fb from the lookup idr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>fb to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers need to call this when cleaning up driver-private framebuffers, e.g.
those used for fbdev. Note that the caller must hold a reference of it&#8217;s own,
i.e. the object may not be destroyed through this call (since it&#8217;ll lead to a
locking inversion).</p>
<p><strong>NOTE</strong></p>
<p>This function is deprecated. For driver-private framebuffers it is not
recommended to embed a framebuffer struct info fbdev struct, instead, a
framebuffer pointer is preferred and <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a> should be called
when the framebuffer is to be cleaned up.</p>
<dl class="function">
<dt id="c.drm_framebuffer_cleanup">
void <code class="descname">drm_framebuffer_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup framebuffer. This function is intended to be used from the drivers
<a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.destroy</span></code></a> callback. It can also be used to clean up
driver private framebuffers embedded into a larger structure.</p>
<p>Note that this function does not remove the fb from active usage - if it is
still used anywhere, hilarity can ensue since userspace could call getfb on
the id and get back -EINVAL. Obviously no concern at driver unload time.</p>
<p>Also, the framebuffer will not be removed from the lookup idr - for
user-created framebuffers this will happen in in the rmfb ioctl. For
driver-private objects (e.g. for fbdev) drivers need to explicitly call
drm_framebuffer_unregister_private.</p>
<dl class="function">
<dt id="c.drm_framebuffer_remove">
void <code class="descname">drm_framebuffer_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and unreference a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans all the CRTCs and planes in <strong>dev</strong>&#8216;s mode_config.  If they&#8217;re
using <strong>fb</strong>, removes it, setting it to NULL. Then drops the reference to the
passed-in framebuffer. Might take the modeset locks.</p>
<p>Note that this function optimizes the cleanup away if the caller holds the
last reference to the framebuffer. It is also guaranteed to not take the
modeset locks in this case.</p>
<dl class="function">
<dt id="c.drm_framebuffer_plane_width">
int <code class="descname">drm_framebuffer_plane_width</code><span class="sig-paren">(</span>int<em>&nbsp;width</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_width" title="Permalink to this definition">¶</a></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_plane_height">
int <code class="descname">drm_framebuffer_plane_height</code><span class="sig-paren">(</span>int<em>&nbsp;height</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_height" title="Permalink to this definition">¶</a></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>height of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
</div>
</div>
<div class="section" id="drm-format-handling">
<h2>DRM Format Handling<a class="headerlink" href="#drm-format-handling" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_format_info">
struct <code class="descname">drm_format_info</code><a class="headerlink" href="#c.drm_format_info" title="Permalink to this definition">¶</a></dt>
<dd><p>information about a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_format_info {
  u32 format;
  u8 depth;
  u8 num_planes;
  u8 cpp;
  u8 hsub;
  u8 vsub;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>4CC format identifier (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">depth</span></code></dt>
<dd>Color depth (number of bits per pixel excluding padding bits),
valid for a subset of RGB formats only. This is a legacy field, do not
use in new code and set to 0 for new formats.</dd>
<dt><code class="docutils literal"><span class="pre">num_planes</span></code></dt>
<dd>Number of color planes (1 to 3)</dd>
<dt><code class="docutils literal"><span class="pre">cpp</span></code></dt>
<dd>Number of bytes per pixel (per plane)</dd>
<dt><code class="docutils literal"><span class="pre">hsub</span></code></dt>
<dd>Horizontal chroma subsampling factor</dd>
<dt><code class="docutils literal"><span class="pre">vsub</span></code></dt>
<dd>Vertical chroma subsampling factor</dd>
</dl>
<dl class="type">
<dt id="c.drm_format_name_buf">
struct <code class="descname">drm_format_name_buf</code><a class="headerlink" href="#c.drm_format_name_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>name of a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_format_name_buf {
  char str;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">str</span></code></dt>
<dd>string buffer containing the format name</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_legacy_fb_format">
uint32_t <code class="descname">drm_mode_legacy_fb_format</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;bpp</em>, uint32_t<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_legacy_fb_format" title="Permalink to this definition">¶</a></dt>
<dd><p>compute drm fourcc code from legacy description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">bpp</span></code></dt>
<dd>bits per pixels</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">depth</span></code></dt>
<dd>bit depth per pixel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes a drm fourcc pixel format code for the given <strong>bpp</strong>/<strong>depth</strong> values.
Useful in fbdev emulation code, since that deals in those values.</p>
<dl class="function">
<dt id="c.drm_get_format_name">
const char * <code class="descname">drm_get_format_name</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em>, struct <a class="reference internal" href="#c.drm_format_name_buf" title="drm_format_name_buf">drm_format_name_buf</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_name" title="Permalink to this definition">¶</a></dt>
<dd><p>fill a string with a drm fourcc format&#8217;s name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>format to compute name of</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_format_name_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>caller-supplied buffer</dd>
</dl>
<dl class="function">
<dt>
const struct <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> * <code class="descname">drm_format_info</code><span class="sig-paren">(</span>u32<em>&nbsp;format</em><span class="sig-paren">)</span></dt>
<dd><p>query information for a given format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller should only pass a supported pixel format to this function.
Unsupported pixel formats will generate a warning in the kernel log.</p>
<p><strong>Return</strong></p>
<p>The instance of struct drm_format_info that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="function">
<dt id="c.drm_get_format_info">
const struct <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> * <code class="descname">drm_get_format_info</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, const struct drm_mode_fb_cmd2 *<em>&nbsp;mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_info" title="Permalink to this definition">¶</a></dt>
<dd><p>query information for a given framebuffer configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt>
<dd>metadata from the userspace fb creation request</dd>
</dl>
<p><strong>Return</strong></p>
<p>The instance of struct drm_format_info that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="function">
<dt id="c.drm_format_num_planes">
int <code class="descname">drm_format_num_planes</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_num_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of planes for format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of planes used by the specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_plane_cpp">
int <code class="descname">drm_format_plane_cpp</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_cpp" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the bytes per pixel value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The bytes per pixel value for the specified plane.</p>
<dl class="function">
<dt id="c.drm_format_horz_chroma_subsampling">
int <code class="descname">drm_format_horz_chroma_subsampling</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_horz_chroma_subsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>get the horizontal chroma subsampling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The horizontal chroma subsampling factor for the
specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_vert_chroma_subsampling">
int <code class="descname">drm_format_vert_chroma_subsampling</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_vert_chroma_subsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>get the vertical chroma subsampling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The vertical chroma subsampling factor for the
specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_plane_width">
int <code class="descname">drm_format_plane_width</code><span class="sig-paren">(</span>int<em>&nbsp;width</em>, uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_width" title="Permalink to this definition">¶</a></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="function">
<dt id="c.drm_format_plane_height">
int <code class="descname">drm_format_plane_height</code><span class="sig-paren">(</span>int<em>&nbsp;height</em>, uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_height" title="Permalink to this definition">¶</a></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>height of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
</div>
<div class="section" id="dumb-buffer-objects">
<h2>Dumb Buffer Objects<a class="headerlink" href="#dumb-buffer-objects" title="Permalink to this headline">¶</a></h2>
<p>The KMS API doesn&#8217;t standardize backing storage object creation and leaves it
to driver-specific ioctls. Furthermore actually creating a buffer object even
for GEM-based drivers is done through a driver-specific ioctl - GEM only has
a common userspace interface for sharing and destroying objects. While not an
issue for full-fledged graphics stacks that include device-specific userspace
components (in libdrm for instance), this limit makes DRM-based early boot
graphics unnecessarily complex.</p>
<p>Dumb objects partly alleviate the problem by providing a standard API to
create dumb buffers suitable for scanout, which can then be used to create
KMS frame buffers.</p>
<p>To support dumb objects drivers must implement the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_create</span></code></a>,
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_destroy</span></code></a> and <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_map_offset</span></code></a> operations. See
there for further details.</p>
<p>Note that dumb objects may not be used for gpu acceleration, as has been
attempted on some ARM embedded platforms. Such drivers really must have
a hardware-specific ioctl to allocate suitable buffer objects.</p>
</div>
<div class="section" id="plane-abstraction">
<h2>Plane Abstraction<a class="headerlink" href="#plane-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A plane represents an image source that can be blended with or overlayed on
top of a CRTC during the scanout process. Planes take their input data from a
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> object. The plane itself specifies the cropping and scaling
of that image, and where it is placed on the visible are of a display
pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. A plane can also have additional
properties that specify how the pixels are positioned and blended, like
rotation or Z-position. All these properties are stored in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>To create a plane, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal"><span class="pre">drm_universal_plane_init()</span></code></a>.</p>
<p>Cursor and overlay planes are optional. All drivers should provide one
primary plane per CRTC to avoid surprising userspace too much. See enum
drm_plane_type for a more in-depth discussion of these special uapi-relevant
plane types. Special planes are associated with their CRTC by calling
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The type of a plane is exposed in the immutable &#8220;type&#8221; enumeration property,
which has one of the following values: &#8220;Overlay&#8221;, &#8220;Primary&#8221;, &#8220;Cursor&#8221;.</p>
<div class="section" id="plane-functions-reference">
<h3>Plane Functions Reference<a class="headerlink" href="#plane-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_plane_state">
struct <code class="descname">drm_plane_state</code><a class="headerlink" href="#c.drm_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable plane state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_plane_state {
  struct drm_plane * plane;
  struct drm_crtc * crtc;
  struct drm_framebuffer * fb;
  struct dma_fence * fence;
  int32_t crtc_x;
  int32_t crtc_y;
  uint32_t crtc_w;
  uint32_t crtc_h;
  uint32_t src_x;
  uint32_t src_y;
  uint32_t src_h;
  uint32_t src_w;
  unsigned int rotation;
  unsigned int zpos;
  unsigned int normalized_zpos;
  struct drm_rect src;
  struct drm_rect dst;
  bool visible;
  struct drm_atomic_state * state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>backpointer to the plane</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>Currently bound CRTC, NULL if disabled. Do not this write directly,
use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_plane" title="drm_atomic_set_crtc_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_plane()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Currently bound framebuffer. Do not write this directly, use
<a class="reference internal" href="#c.drm_atomic_set_fb_for_plane" title="drm_atomic_set_fb_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fb_for_plane()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd>Optional fence to wait for before scanning out <strong>fb</strong>. Do not write this
directly, use <a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">crtc_x</span></code></dt>
<dd>Left position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_y</span></code></dt>
<dd>Upper position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_w</span></code></dt>
<dd>width of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">crtc_h</span></code></dt>
<dd>height of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">src_x</span></code></dt>
<dd>left position of visible portion of plane within
plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_y</span></code></dt>
<dd>upper position of visible portion of plane within
plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_h</span></code></dt>
<dd>height of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_w</span></code></dt>
<dd>width of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">rotation</span></code></dt>
<dd>rotation of the plane</dd>
<dt><code class="docutils literal"><span class="pre">zpos</span></code></dt>
<dd>priority of the given plane on crtc (optional)
Note that multiple active planes on the same crtc can have an identical
zpos value. The rule to solving the conflict is to compare the plane
object IDs; the plane with a higher ID must be stacked on top of a
plane with a lower ID.</dd>
<dt><code class="docutils literal"><span class="pre">normalized_zpos</span></code></dt>
<dd>normalized value of zpos: unique, range from 0 to N-1
where N is the number of active planes for given crtc. Note that
the driver must call <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> to update this before
it can be trusted.</dd>
<dt><code class="docutils literal"><span class="pre">src</span></code></dt>
<dd>clipped source coordinates of the plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">dst</span></code></dt>
<dd>clipped destination coordinates of the plane</dd>
<dt><code class="docutils literal"><span class="pre">visible</span></code></dt>
<dd>Visibility of the plane. This can be false even if fb!=NULL and
crtc!=NULL, due to clipping.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_funcs">
struct <code class="descname">drm_plane_funcs</code><a class="headerlink" href="#c.drm_plane_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver plane control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_plane_funcs {
  int (* update_plane) (struct drm_plane *plane,struct drm_crtc *crtc, struct drm_framebuffer *fb,int crtc_x, int crtc_y,unsigned int crtc_w, unsigned int crtc_h,uint32_t src_x, uint32_t src_y,uint32_t src_w, uint32_t src_h,struct drm_modeset_acquire_ctx *ctx);
  int (* disable_plane) (struct drm_plane *plane,struct drm_modeset_acquire_ctx *ctx);
  void (* destroy) (struct drm_plane *plane);
  void (* reset) (struct drm_plane *plane);
  int (* set_property) (struct drm_plane *plane,struct drm_property *property, uint64_t val);
  struct drm_plane_state *(* atomic_duplicate_state) (struct drm_plane *plane);
  void (* atomic_destroy_state) (struct drm_plane *plane,struct drm_plane_state *state);
  int (* atomic_set_property) (struct drm_plane *plane,struct drm_plane_state *state,struct drm_property *property,uint64_t val);
  int (* atomic_get_property) (struct drm_plane *plane,const struct drm_plane_state *state,struct drm_property *property,uint64_t *val);
  int (* late_register) (struct drm_plane *plane);
  void (* early_unregister) (struct drm_plane *plane);
  void (* atomic_print_state) (struct drm_printer *p,const struct drm_plane_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">update_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to enable and configure the plane for
the given CRTC and framebuffer. It is never called to disable the
plane, i.e. the passed-in crtc and fb paramters are never NULL.</p>
<p>The source rectangle in frame buffer memory coordinates is given by
the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
values). Devices that don&#8217;t support subpixel plane coordinates can
ignore the fractional part.</p>
<p>The destination rectangle in CRTC coordinates is given by the
crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
Devices scale the source rectangle to the destination rectangle. If
scaling is not supported, and the source rectangle size doesn&#8217;t match
the destination rectangle size, the driver must return a
-&lt;errorname&gt;EINVAL&lt;/errorname&gt; error.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_plane" title="drm_atomic_helper_update_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to disable the plane. The DRM core
calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
with the frame buffer ID set to 0.  Disabled planes must not be
processed by the CRTC.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a plane cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset plane hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_reset" title="drm_atomic_helper_plane_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
plane.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_set_property" title="drm_atomic_helper_plane_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_set_property()</span></code></a> to implement this hook.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this plane and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_duplicate_state" title="drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_plane_duplicate_state" title="__drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_plane_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_plane_set_property" title="drm_atomic_plane_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this plane). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETPLANE IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this plane).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the plane like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the plane from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_print_state()</span></code>
instead.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_type">
enum <code class="descname">drm_plane_type</code><a class="headerlink" href="#c.drm_plane_type" title="Permalink to this definition">¶</a></dt>
<dd><p>uapi plane type enumeration</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_OVERLAY</span></code></dt>
<dd>Overlay planes represent all non-primary, non-cursor planes. Some
drivers refer to these types of planes as &#8220;sprites&#8221; internally.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_PRIMARY</span></code></dt>
<dd>Primary planes represent a &#8220;main&#8221; plane for a CRTC.  Primary planes
are the planes operated upon by CRTC modesetting and flipping
operations described in the <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a> hooks.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_CURSOR</span></code></dt>
<dd>Cursor planes represent a &#8220;cursor&#8221; plane for a CRTC.  Cursor planes
are the planes operated upon by the DRM_IOCTL_MODE_CURSOR and
DRM_IOCTL_MODE_CURSOR2 IOCTLs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For historical reasons not all planes are made the same. This enumeration is
used to tell the different types of planes apart to implement the different
uapi semantics for them. For userspace which is universal plane aware and
which is using that atomic IOCTL there&#8217;s no difference between these planes
(beyong what the driver and hardware can support of course).</p>
<p>For compatibility with legacy userspace, only overlay planes are made
available to userspace by default. Userspace clients may set the
DRM_CLIENT_CAP_UNIVERSAL_PLANES client capability bit to indicate that they
wish to receive a universal plane list containing all plane types. See also
<a class="reference internal" href="#c.drm_for_each_legacy_plane" title="drm_for_each_legacy_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_legacy_plane()</span></code></a>.</p>
<p>WARNING: The values of this enum is UABI since they&#8217;re exposed in the &#8220;type&#8221;
property.</p>
<dl class="type">
<dt id="c.drm_plane">
struct <code class="descname">drm_plane</code><a class="headerlink" href="#c.drm_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM plane control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_plane {
  struct drm_device * dev;
  struct list_head head;
  char * name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  uint32_t possible_crtcs;
  uint32_t * format_types;
  unsigned int format_count;
  bool format_default;
  struct drm_crtc * crtc;
  struct drm_framebuffer * fb;
  struct drm_framebuffer * old_fb;
  const struct drm_plane_funcs * funcs;
  struct drm_object_properties properties;
  enum drm_plane_type type;
  unsigned index;
  const struct drm_plane_helper_funcs * helper_private;
  struct drm_plane_state * state;
  struct drm_property * zpos_property;
  struct drm_property * rotation_property;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this plane belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>for list management</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">Protects modeset plane state, together with the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.mutex</span></code></a> of
CRTC this plane is linked to (when active, getting activated or
getting disabled).</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base mode object</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd>pipes this plane can be bound to</dd>
<dt><code class="docutils literal"><span class="pre">format_types</span></code></dt>
<dd>array of formats supported by this plane</dd>
<dt><code class="docutils literal"><span class="pre">format_count</span></code></dt>
<dd>number of formats supported</dd>
<dt><code class="docutils literal"><span class="pre">format_default</span></code></dt>
<dd>driver hasn&#8217;t supplied supported formats for the plane</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>currently bound CRTC</dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>currently bound fb</dd>
<dt><code class="docutils literal"><span class="pre">old_fb</span></code></dt>
<dd>Temporary tracking of the old fb while a modeset is ongoing. Used by
<a class="reference internal" href="#c.drm_mode_set_config_internal" title="drm_mode_set_config_internal"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_config_internal()</span></code></a> to implement correct refcounting.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>helper functions</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this plane</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of plane (overlay, primary, cursor)</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the plane.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this plane.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current plane state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_plane_in_state" title="for_each_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_plane_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_oldnew_plane_in_state" title="for_each_oldnew_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_plane_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_plane_in_state" title="for_each_old_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_plane_in_state()</span></code></a> and <a class="reference internal" href="#c.for_each_new_plane_in_state" title="for_each_new_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_plane_in_state()</span></code></a>. Or
through careful ordering of atomic commit operations as implemented
in the atomic helpers, see <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">zpos_property</span></code></dt>
<dd>zpos property for this plane</dd>
<dt><code class="docutils literal"><span class="pre">rotation_property</span></code></dt>
<dd>rotation property for this plane</dd>
</dl>
<dl class="function">
<dt id="c.drm_plane_index">
unsigned int <code class="descname">drm_plane_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered plane, return the index of that plane within a DRM
device&#8217;s list of planes.</p>
<dl class="function">
<dt id="c.drm_plane_find">
struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> * <code class="descname">drm_plane_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>plane id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the plane with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane_mask">
<code class="descname">drm_for_each_plane_mask</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em>, <em>plane_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>bitmask of plane indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_legacy_plane">
<code class="descname">drm_for_each_legacy_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_legacy_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes for legacy userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all legacy planes of <strong>dev</strong>, excluding primary and cursor planes.
This is useful for implementing userspace apis when userspace is not
universal plane aware. See also <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane">
<code class="descname">drm_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes of <strong>dev</strong>, include primary and cursor planes.</p>
<dl class="function">
<dt id="c.drm_universal_plane_init">
int <code class="descname">drm_universal_plane_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, uint32_t<em>&nbsp;possible_crtcs</em>, const struct <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>&nbsp;funcs</em>, const uint32_t *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;format_count</em>, enum <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type">drm_plane_type</a><em>&nbsp;type</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_universal_plane_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a new universal plane object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to init</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt>
<dd>bitmask of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array of supported formats (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt>
<dd>number of elements in <strong>formats</strong></dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span> <span class="pre">type</span></code></dt>
<dd>type of plane (overlay, primary, cursor)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the plane name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a plane object of type <strong>type</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_plane_init">
int <code class="descname">drm_plane_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, uint32_t<em>&nbsp;possible_crtcs</em>, const struct <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>&nbsp;funcs</em>, const uint32_t *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;format_count</em>, bool<em>&nbsp;is_primary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a legacy plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to init</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt>
<dd>bitmask of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array of supported formats (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt>
<dd>number of elements in <strong>formats</strong></dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_primary</span></code></dt>
<dd>plane type (primary vs overlay)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy API to initialize a DRM plane.</p>
<p>New drivers should call <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal"><span class="pre">drm_universal_plane_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_plane_cleanup">
void <code class="descname">drm_plane_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the core plane usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>plane</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the plane structure itself,
this is the responsibility of the caller.</p>
<dl class="function">
<dt id="c.drm_plane_from_index">
struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> * <code class="descname">drm_plane_from_index</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_from_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the registered plane at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of registered plane to find for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a plane index, return the registered plane from DRM device&#8217;s
list of planes with matching index. This is the inverse of <a class="reference internal" href="#c.drm_plane_index" title="drm_plane_index"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_index()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_plane_force_disable">
void <code class="descname">drm_plane_force_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly disable a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces the plane to be disabled.</p>
<p>Used when the plane&#8217;s current framebuffer is destroyed,
and when restoring fbdev mode.</p>
<p>Note that this function is not suitable for atomic drivers, since it doesn&#8217;t
wire through the lock acquisition context properly and hence can&#8217;t handle
retries or driver private locks. You probably want to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.drm_mode_plane_set_obj_prop">
int <code class="descname">drm_mode_plane_set_obj_prop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_plane_set_obj_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane object to set property value for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt>
<dd>value the property should be set to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets a given property on a given plane object. This function
calls the driver&#8217;s -&gt;set_property callback and changes the software state of
the property if the callback succeeds.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
</div>
<div class="section" id="display-modes-function-reference">
<h2>Display Modes Function Reference<a class="headerlink" href="#display-modes-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_status">
enum <code class="descname">drm_mode_status</code><a class="headerlink" href="#c.drm_mode_status" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware support status of a mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MODE_OK</span></code></dt>
<dd>Mode OK</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC</span></code></dt>
<dd>hsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC</span></code></dt>
<dd>vsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_H_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_V_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_WIDTH</span></code></dt>
<dd>requires an unsupported linepitch</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOMODE</span></code></dt>
<dd>no mode with a matching name</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_INTERLACE</span></code></dt>
<dd>interlaced mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_DBLESCAN</span></code></dt>
<dd>doublescan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_VSCAN</span></code></dt>
<dd>multiscan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM</span></code></dt>
<dd>insufficient video memory</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_X</span></code></dt>
<dd>mode width too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_Y</span></code></dt>
<dd>mode height too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM_VIRT</span></code></dt>
<dd>insufficient video memory given virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOCLOCK</span></code></dt>
<dd>no fixed clock available</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_HIGH</span></code></dt>
<dd>clock required is too high</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_LOW</span></code></dt>
<dd>clock required is too low</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_RANGE</span></code></dt>
<dd>clock/mode isn&#8217;t in a ClockRange</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_HVALUE</span></code></dt>
<dd>horizontal timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VVALUE</span></code></dt>
<dd>vertical timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VSCAN</span></code></dt>
<dd>VScan value out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_NARROW</span></code></dt>
<dd>horizontal sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_WIDE</span></code></dt>
<dd>horizontal sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_NARROW</span></code></dt>
<dd>horizontal blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_WIDE</span></code></dt>
<dd>horizontal blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_NARROW</span></code></dt>
<dd>vertical sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_WIDE</span></code></dt>
<dd>vertical sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_NARROW</span></code></dt>
<dd>vertical blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_WIDE</span></code></dt>
<dd>vertical blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_PANEL</span></code></dt>
<dd>exceeds panel dimensions</dd>
<dt><code class="docutils literal"><span class="pre">MODE_INTERLACE_WIDTH</span></code></dt>
<dd>width too large for interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_WIDTH</span></code></dt>
<dd>only one width is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_HEIGHT</span></code></dt>
<dd>only one height is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_SIZE</span></code></dt>
<dd>only one resolution is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_REDUCED</span></code></dt>
<dd>monitor doesn&#8217;t accept reduced blanking</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_STEREO</span></code></dt>
<dd>stereo modes not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_STALE</span></code></dt>
<dd>mode has become stale</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD</span></code></dt>
<dd>unspecified reason</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ERROR</span></code></dt>
<dd>error condition</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to filter out modes not supported by the driver/hardware
combination.</p>
<dl class="type">
<dt id="c.drm_display_mode">
struct <code class="descname">drm_display_mode</code><a class="headerlink" href="#c.drm_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM kernel-internal display mode structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_display_mode {
  struct list_head head;
  struct drm_mode_object base;
  char name;
  enum drm_mode_status status;
  unsigned int type;
  int clock;
  int hdisplay;
  int hsync_start;
  int hsync_end;
  int htotal;
  int hskew;
  int vdisplay;
  int vsync_start;
  int vsync_end;
  int vtotal;
  int vscan;
  unsigned int flags;
  int width_mm;
  int height_mm;
  int crtc_clock;
  int crtc_hdisplay;
  int crtc_hblank_start;
  int crtc_hblank_end;
  int crtc_hsync_start;
  int crtc_hsync_end;
  int crtc_htotal;
  int crtc_hskew;
  int crtc_vdisplay;
  int crtc_vblank_start;
  int crtc_vblank_end;
  int crtc_vsync_start;
  int crtc_vsync_end;
  int crtc_vtotal;
  int * private;
  int private_flags;
  int vrefresh;
  int hsync;
  enum hdmi_picture_aspect picture_aspect_ratio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>struct list_head for mode lists.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd><p class="first">A display mode is a normal modeset object, possibly including public
userspace id.</p>
<p>FIXME:</p>
<p class="last">This can probably be removed since the entire concept of userspace
managing modes explicitly has never landed in upstream kernel mode
setting support.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Human-readable name of the mode, filled out with <a class="reference internal" href="#c.drm_mode_set_name" title="drm_mode_set_name"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_name()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Status of the mode, used to filter out modes not supported by the
hardware. See enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_status</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd><p class="first">A bitmask of flags, mostly about the source of a mode. Possible flags
are:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, effectively
unused.</li>
<li>DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
resolution of an LCD panel. There should only be one preferred
mode per connector at any given time.</li>
<li>DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
them really. Drivers must set this bit for all modes they create
and expose to userspace.</li>
</ul>
</div></blockquote>
<p>Plus a big list of flags which shouldn&#8217;t be used at all, but are
still around since these flags are also used in the userspace ABI:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_TYPE_DEFAULT: Again a leftover, use
DRM_MODE_TYPE_PREFERRED instead.</li>
<li>DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
which are stuck around for hysterical raisins only. No one has an
idea what they were meant for. Don&#8217;t use.</li>
<li>DRM_MODE_TYPE_USERDEF: Mode defined by userspace, again a vestige
from older kms designs where userspace had to first add a custom
mode to the kernel&#8217;s mode list before it could use it. Don&#8217;t use.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">clock</span></code></dt>
<dd>Pixel clock in kHz.</dd>
<dt><code class="docutils literal"><span class="pre">hdisplay</span></code></dt>
<dd>horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">hsync_start</span></code></dt>
<dd>horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">hsync_end</span></code></dt>
<dd>horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">htotal</span></code></dt>
<dd>horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">hskew</span></code></dt>
<dd>horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">vdisplay</span></code></dt>
<dd>vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">vsync_start</span></code></dt>
<dd>vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">vsync_end</span></code></dt>
<dd>vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">vtotal</span></code></dt>
<dd>vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">vscan</span></code></dt>
<dd>vertical scan?!</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Sync and timing flags:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_FLAG_PHSYNC: horizontal sync is active high.</li>
<li>DRM_MODE_FLAG_NHSYNC: horizontal sync is active low.</li>
<li>DRM_MODE_FLAG_PVSYNC: vertical sync is active high.</li>
<li>DRM_MODE_FLAG_NVSYNC: vertical sync is active low.</li>
<li>DRM_MODE_FLAG_INTERLACE: mode is interlaced.</li>
<li>DRM_MODE_FLAG_DBLSCAN: mode uses doublescan.</li>
<li>DRM_MODE_FLAG_CSYNC: mode uses composite sync.</li>
<li>DRM_MODE_FLAG_PCSYNC: composite sync is active high.</li>
<li>DRM_MODE_FLAG_NCSYNC: composite sync is active low.</li>
<li>DRM_MODE_FLAG_HSKEW: hskew provided (not used?).</li>
<li>DRM_MODE_FLAG_BCAST: not used?</li>
<li>DRM_MODE_FLAG_PIXMUX: not used?</li>
<li>DRM_MODE_FLAG_DBLCLK: double-clocked mode.</li>
<li>DRM_MODE_FLAG_CLKDIV2: half-clocked mode.</li>
</ul>
</div></blockquote>
<p>Additionally there&#8217;s flags to specify how 3D modes are packed:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_FLAG_3D_NONE: normal, non-3D mode.</li>
<li>DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right.</li>
<li>DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields.</li>
<li>DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames.</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom
parts.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and
right parts.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_clock</span></code></dt>
<dd><p class="first">Actual pixel or dot clock in the hardware. This differs from the
logical <strong>clock</strong> when e.g. using interlacing, double-clocking, stereo
modes or other fancy stuff that changes the timings and signals
actually sent over the wire.</p>
<p>This is again in kHz.</p>
<p class="last">Note that with digital outputs like HDMI or DP there&#8217;s usually a
massive confusion between the dot clock and the signal clock at the
bit encoding level. Especially when a 8b/10b encoding is used and the
difference is exactly a factor of 10.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hdisplay</span></code></dt>
<dd>hardware mode horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_start</span></code></dt>
<dd>hardware mode horizontal blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_end</span></code></dt>
<dd>hardware mode horizontal blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_start</span></code></dt>
<dd>hardware mode horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_end</span></code></dt>
<dd>hardware mode horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_htotal</span></code></dt>
<dd>hardware mode horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hskew</span></code></dt>
<dd>hardware mode horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vdisplay</span></code></dt>
<dd>hardware mode vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_start</span></code></dt>
<dd>hardware mode vertical blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_end</span></code></dt>
<dd>hardware mode vertical blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_start</span></code></dt>
<dd>hardware mode vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_end</span></code></dt>
<dd>hardware mode vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vtotal</span></code></dt>
<dd>hardware mode vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>Pointer for driver private data. This can only be used for mode
objects passed to drivers in modeset operations. It shouldn&#8217;t be used
by atomic drivers since they can store any additional data by
subclassing state structures.</dd>
<dt><code class="docutils literal"><span class="pre">private_flags</span></code></dt>
<dd>Similar to <strong>private</strong>, but just an integer.</dd>
<dt><code class="docutils literal"><span class="pre">vrefresh</span></code></dt>
<dd><p class="first">Vertical refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in Hz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">hsync</span></code></dt>
<dd><p class="first">Horizontal refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in kHz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd>Field for setting the HDMI picture aspect ratio of a mode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The horizontal and vertical timings are defined per the following diagram.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>          Active                 Front           Sync           Back
         Region                 Porch                          Porch
&lt;-----------------------&gt;&lt;----------------&gt;&lt;-------------&gt;&lt;--------------&gt;
  //////////////////////|
 ////////////////////// |
//////////////////////  |..................               ................
                                           _______________
&lt;----- [hv]display -----&gt;
&lt;------------- [hv]sync_start ------------&gt;
&lt;--------------------- [hv]sync_end ---------------------&gt;
&lt;-------------------------------- [hv]total -----------------------------&gt;*
</pre></div>
</div>
<p>This structure contains two copies of timings. First are the plain timings,
which specify the logical mode, as it would be for a progressive 1:1 scanout
at the refresh rate userspace can observe through vblank timestamps. Then
there&#8217;s the hardware timings, which are corrected for interlacing,
double-clocking and similar things. They are provided as a convenience, and
can be appropriately computed using <a class="reference internal" href="#c.drm_mode_set_crtcinfo" title="drm_mode_set_crtcinfo"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_crtcinfo()</span></code></a>.</p>
<p>For printing you can use <code class="docutils literal"><span class="pre">DRM_MODE_FMT</span></code> and <a class="reference internal" href="#c.DRM_MODE_ARG" title="DRM_MODE_ARG"><code class="xref c c-func docutils literal"><span class="pre">DRM_MODE_ARG()</span></code></a>.</p>
<dl class="function">
<dt id="c.DRM_MODE_FMT">
<code class="descname">DRM_MODE_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_MODE_ARG">
<code class="descname">DRM_MODE_ARG</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>display mode</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_is_stereo">
bool <code class="descname">drm_mode_is_stereo</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_stereo" title="Permalink to this definition">¶</a></dt>
<dd><p>check for stereo mode flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>drm_display_mode to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the mode is one of the stereo modes (like side-by-side), false if
not.</p>
<dl class="function">
<dt id="c.drm_mode_debug_printmodeline">
void <code class="descname">drm_mode_debug_printmodeline</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_debug_printmodeline" title="Permalink to this definition">¶</a></dt>
<dd><p>print a mode to dmesg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to print</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describe <strong>mode</strong> using DRM_DEBUG.</p>
<dl class="function">
<dt id="c.drm_mode_create">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it
and return it.</p>
<p><strong>Return</strong></p>
<p>Pointer to new mode on success, NULL on error.</p>
<dl class="function">
<dt id="c.drm_mode_destroy">
void <code class="descname">drm_mode_destroy</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release <strong>mode</strong>&#8216;s unique ID, then free it <strong>mode</strong> structure itself using kfree.</p>
<dl class="function">
<dt id="c.drm_mode_probed_add">
void <code class="descname">drm_mode_probed_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_probed_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a mode to a connector&#8217;s probed_mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector the new mode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>mode</strong> to <strong>connector</strong>&#8216;s probed_mode list for later use. This list should
then in a second step get filtered and all the modes actually supported by
the hardware moved to the <strong>connector</strong>&#8216;s modes list.</p>
<dl class="function">
<dt id="c.drm_cvt_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_cvt_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;reduced</em>, bool<em>&nbsp;interlaced</em>, bool<em>&nbsp;margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_cvt_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>create a modeline based on the CVT algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">reduced</span></code></dt>
<dd>whether to use reduced blanking</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">margins</span></code></dt>
<dd>whether to add margins (borders)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called to generate the modeline based on CVT algorithm
according to the hdisplay, vdisplay, vrefresh.
It is based from the VESA(TM) Coordinated Video Timing Generator by
Graham Loveridge April 9, 2003 available at
<a class="reference external" href="http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls">http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls</a></p>
<p>And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
What I have done is to translate it by using integer calculation.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the CVT algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_gtf_mode_complex">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_gtf_mode_complex</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;interlaced</em>, int<em>&nbsp;margins</em>, int<em>&nbsp;GTF_M</em>, int<em>&nbsp;GTF_2C</em>, int<em>&nbsp;GTF_K</em>, int<em>&nbsp;GTF_2J</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>create the modeline based on the full GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">margins</span></code></dt>
<dd>desired margin (borders) size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_M</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_2C</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_K</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_2J</span></code></dt>
<dd>extended GTF formula parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>GTF feature blocks specify C and J in multiples of 0.5, so we pass them
in here multiplied by two.  For a C of 40, pass in 80.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the full GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_gtf_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_gtf_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;interlaced</em>, int<em>&nbsp;margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>create the modeline based on the GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">margins</span></code></dt>
<dd>desired margin (borders) size</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the modeline based on GTF algorithm</p>
<p>This function is to create the modeline based on the GTF algorithm.
Generalized Timing Formula is derived from:</p>
<blockquote>
<div>GTF Spreadsheet by Andy Morrish (1/5/97)
available at <a class="reference external" href="http://www.vesa.org">http://www.vesa.org</a></div></blockquote>
<p>And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
What I have done is to translate it by using integer calculation.
I also refer to the function of fb_get_mode in the file of
drivers/video/fbmon.c</p>
<p>Standard GTF parameters:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>M = 600
C = 40
K = 128
J = 20
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The modeline based on the GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_display_mode_from_videomode">
void <code class="descname">drm_display_mode_from_videomode</code><span class="sig-paren">(</span>const struct videomode *<em>&nbsp;vm</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_from_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in <strong>dmode</strong> using <strong>vm</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use as source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>drm_display_mode structure to use as destination</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>dmode</strong> using the display mode specified in <strong>vm</strong>.</p>
<dl class="function">
<dt id="c.drm_display_mode_to_videomode">
void <code class="descname">drm_display_mode_to_videomode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em>, struct videomode *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_to_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in <strong>vm</strong> using <strong>dmode</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>drm_display_mode structure to use as source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use as destination</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>vm</strong> using the display mode specified in <strong>dmode</strong>.</p>
<dl class="function">
<dt id="c.drm_bus_flags_from_videomode">
void <code class="descname">drm_bus_flags_from_videomode</code><span class="sig-paren">(</span>const struct videomode *<em>&nbsp;vm</em>, u32 *<em>&nbsp;bus_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bus_flags_from_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>extract information about pixelclk and DE polarity from videomode and store it in a separate variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bus_flags</span></code></dt>
<dd>information about pixelclk and DE polarity will be stored here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets DRM_BUS_FLAG_DE_(LOW|HIGH) and DRM_BUS_FLAG_PIXDATA_(POS|NEG)EDGE
in <strong>bus_flags</strong> according to DISPLAY_FLAGS found in <strong>vm</strong></p>
<dl class="function">
<dt id="c.of_get_drm_display_mode">
int <code class="descname">of_get_drm_display_mode</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;np</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em>, u32 *<em>&nbsp;bus_flags</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_drm_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>get a drm_display_mode from devicetree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device_node with the timing specification</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>will be set to the return value</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bus_flags</span></code></dt>
<dd>information about pixelclk and DE polarity</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index into the list of display timings in devicetree</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is expensive and should only be used, if only one mode is to be
read from DT. To get multiple modes start with of_get_display_timings and
work with that instead.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative errno code when no of videomode node was found.</p>
<dl class="function">
<dt id="c.drm_mode_set_name">
void <code class="descname">drm_mode_set_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set the name on a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>name will be set in this mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the name of <strong>mode</strong> to a standard format which is &lt;hdisplay&gt;x&lt;vdisplay&gt;
with an optional &#8216;i&#8217; suffix for interlaced modes.</p>
<dl class="function">
<dt id="c.drm_mode_hsync">
int <code class="descname">drm_mode_hsync</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_hsync" title="Permalink to this definition">¶</a></dt>
<dd><p>get the hsync of a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>modes</strong>&#8216;s hsync rate in kHz, rounded to the nearest integer. Calculates the
value first if it is not yet set.</p>
<dl class="function">
<dt id="c.drm_mode_vrefresh">
int <code class="descname">drm_mode_vrefresh</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_vrefresh" title="Permalink to this definition">¶</a></dt>
<dd><p>get the vrefresh of a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>modes</strong>&#8216;s vrefresh rate in Hz, rounded to the nearest integer. Calculates the
value first if it is not yet set.</p>
<dl class="function">
<dt id="c.drm_mode_get_hv_timing">
void <code class="descname">drm_mode_get_hv_timing</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, int *<em>&nbsp;hdisplay</em>, int *<em>&nbsp;vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_hv_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches hdisplay/vdisplay for given mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay value to fill in</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay value to fill in</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vdisplay value will be doubled if the specified mode is a stereo mode of
the appropriate layout.</p>
<dl class="function">
<dt id="c.drm_mode_set_crtcinfo">
void <code class="descname">drm_mode_set_crtcinfo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;p</em>, int<em>&nbsp;adjust_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_crtcinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>set CRTC modesetting timing parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">adjust_flags</span></code></dt>
<dd>a combination of adjustment flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the CRTC modesetting timing parameters for <strong>p</strong>, adjusting if necessary.</p>
<ul class="simple">
<li>The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
interlaced modes.</li>
<li>The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
buffers containing two eyes (only adjust the timings when needed, eg. for
&#8220;frame packing&#8221; or &#8220;side by side full&#8221;).</li>
<li>The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment <em>not</em>
be performed for doublescan and vscan &gt; 1 modes respectively.</li>
</ul>
<dl class="function">
<dt id="c.drm_mode_copy">
void <code class="descname">drm_mode_copy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dst</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>mode to overwrite</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>mode to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy an existing mode into another mode, preserving the object id and
list head of the destination mode.</p>
<dl class="function">
<dt id="c.drm_mode_duplicate">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_duplicate</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and duplicate an existing mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device to allocate the duplicated mode for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to duplicate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just allocate a new mode, copy the existing mode into it, and return
a pointer to it.  Used to create new instances of established modes.</p>
<p><strong>Return</strong></p>
<p>Pointer to duplicated mode on success, NULL on error.</p>
<dl class="function">
<dt id="c.drm_mode_equal">
bool <code class="descname">drm_mode_equal</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_equal_no_clocks">
bool <code class="descname">drm_mode_equal_no_clocks</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don&#8217;t check the pixel clocks.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_equal_no_clocks_no_stereo">
bool <code class="descname">drm_mode_equal_no_clocks_no_stereo</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks_no_stereo" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don&#8217;t check the pixel clocks nor the stereo layout.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_validate_basic">
enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_mode_validate_basic</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure the mode is somewhat sane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the mode timings are at least somewhat reasonable.
Any hardware specific limits are left up for each driver to check.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="function">
<dt id="c.drm_mode_validate_size">
enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_mode_validate_size</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, int<em>&nbsp;maxX</em>, int<em>&nbsp;maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure modes adhere to size constraints</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to check</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxX</span></code></dt>
<dd>maximum width</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxY</span></code></dt>
<dd>maximum height</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a helper which can be used to validate modes against size
limitations of the DRM device/connector. If a mode is too big its status
member is updated with the appropriate validation failure code. The list
itself is not changed.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="function">
<dt id="c.drm_mode_prune_invalid">
void <code class="descname">drm_mode_prune_invalid</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct list_head *<em>&nbsp;mode_list</em>, bool<em>&nbsp;verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_prune_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove invalid modes from mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">mode_list</span></code></dt>
<dd>list of modes to check</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">verbose</span></code></dt>
<dd>be verbose about it</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function can be used to prune a display mode list after
validation has been completed. All modes who&#8217;s status is not MODE_OK will be
removed from the list, and if <strong>verbose</strong> the status code and mode name is also
printed to dmesg.</p>
<dl class="function">
<dt id="c.drm_mode_sort">
void <code class="descname">drm_mode_sort</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;mode_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">mode_list</span></code></dt>
<dd>list of drm_display_mode structures to sort</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sort <strong>mode_list</strong> by favorability, moving good modes to the head of the list.</p>
<dl class="function">
<dt id="c.drm_mode_connector_list_update">
void <code class="descname">drm_mode_connector_list_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_list_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the mode list for the connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to update</dd>
</dl>
<p><strong>Description</strong></p>
<p>This moves the modes from the <strong>connector</strong> probed_modes list
to the actual mode list. It compares the probed mode against the current
list and only adds different/new modes.</p>
<p>This is just a helper functions doesn&#8217;t validate any modes itself and also
doesn&#8217;t prune any invalid modes. Callers need to do that themselves.</p>
<dl class="function">
<dt id="c.drm_mode_parse_command_line_for_connector">
bool <code class="descname">drm_mode_parse_command_line_for_connector</code><span class="sig-paren">(</span>const char *<em>&nbsp;mode_option</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct drm_cmdline_mode *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_parse_command_line_for_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>parse command line modeline for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mode_option</span></code></dt>
<dd>optional per connector mode option</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to parse modeline for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>preallocated drm_cmdline_mode structure to fill out</dd>
</dl>
<p><strong>Description</strong></p>
<p>This parses <strong>mode_option</strong> command line modeline for modes and options to
configure the connector. If <strong>mode_option</strong> is NULL the default command line
modeline in fb_mode_option will be parsed instead.</p>
<p>This uses the same parameters as the fb modedb.c, except for an extra
force-enable, force-enable-digital and force-disable bit at the end:</p>
<p>&lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][&#64;&lt;refresh&gt;][i][m][eDd]</p>
<p>The intermediate drm_cmdline_mode structure is required to store additional
options from the command line modline like the force-enable/disable flag.</p>
<p><strong>Return</strong></p>
<p>True if a valid modeline has been parsed, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_create_from_cmdline_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_create_from_cmdline_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct drm_cmdline_mode *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_from_cmdline_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a command line modeline into a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device to create the new mode for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>input command line modeline</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to converted mode on success, NULL on error.</p>
</div>
<div class="section" id="connector-abstraction">
<h2>Connector Abstraction<a class="headerlink" href="#connector-abstraction" title="Permalink to this headline">¶</a></h2>
<p>In DRM connectors are the general abstraction for display sinks, and include
als fixed panels or anything else that can display pixels in some form. As
opposed to all other KMS objects representing hardware (like CRTC, encoder or
plane abstractions) connectors can be hotplugged and unplugged at runtime.
Hence they are reference-counted using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_put()</span></code></a>.</p>
<p>KMS driver must create, initialize, register and attach at a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_connector</span></code></a> for each such sink. The instance is created as other KMS
objects and initialized by setting the following fields. The connector is
initialized with a call to <a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_init()</span></code></a> with a pointer to the
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_funcs</span></code></a> and a connector type, and then exposed to
userspace with a call to <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code></a>.</p>
<p>Connectors must be attached to an encoder to be used. For devices that map
connectors to encoders 1:1, the connector should be attached at
initialization time with a call to <a class="reference internal" href="#c.drm_mode_connector_attach_encoder" title="drm_mode_connector_attach_encoder"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_attach_encoder()</span></code></a>. The
driver must also set the <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.encoder</span></code></a> field to point to the
attached encoder.</p>
<p>For connectors which are not fixed (like built-in panels) the driver needs to
support hotplug notifications. The simplest way to do that is by using the
probe helpers, see <a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_init()</span></code></a> for connectors which don&#8217;t have
hardware support for hotplug interrupts. Connectors with hardware hotplug
support can instead use e.g. <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_hpd_irq_event()</span></code></a>.</p>
<div class="section" id="connector-functions-reference">
<h3>Connector Functions Reference<a class="headerlink" href="#connector-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_connector_status">
enum <code class="descname">drm_connector_status</code><a class="headerlink" href="#c.drm_connector_status" title="Permalink to this definition">¶</a></dt>
<dd><p>status for a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector_status_connected</span></code></dt>
<dd>The connector is definitely connected to
a sink device, and can be enabled.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_disconnected</span></code></dt>
<dd>The connector isn&#8217;t connected to a
sink device which can be autodetect. For digital outputs like DP or
HDMI (which can be realiable probed) this means there&#8217;s really
nothing there. It is driver-dependent whether a connector with this
status can be lit up or not.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_unknown</span></code></dt>
<dd>The connector&#8217;s status could not be
reliably detected. This happens when probing would either cause
flicker (like load-detection when the connector is in use), or when a
hardware resource isn&#8217;t available (like when load-detection needs a
free CRTC). It should be possible to light up the connector with one
of the listed fallback modes. For default configuration userspace
should only try to light up connectors with unknown status when
there&#8217;s not connector with <strong>connector_status_connected</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the connector status. There are no separate
#defines for the uapi!</p>
<dl class="type">
<dt id="c.drm_scrambling">
struct <code class="descname">drm_scrambling</code><a class="headerlink" href="#c.drm_scrambling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_scrambling {
  bool supported;
  bool low_rates;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">supported</span></code></dt>
<dd>scrambling supported for rates &gt; 340 Mhz.</dd>
<dt><code class="docutils literal"><span class="pre">low_rates</span></code></dt>
<dd>scrambling supported for rates &lt;= 340 Mhz.</dd>
</dl>
<dl class="type">
<dt id="c.drm_hdmi_info">
struct <code class="descname">drm_hdmi_info</code><a class="headerlink" href="#c.drm_hdmi_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime information about the connected HDMI sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_hdmi_info {
  struct drm_scdc scdc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">scdc</span></code></dt>
<dd>sink&#8217;s scdc support and capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes if a given display supports advanced HDMI 2.0 features.
This information is available in CEA-861-F extension blocks (like HF-VSDB).</p>
<dl class="type">
<dt id="c.drm_link_status">
enum <code class="descname">drm_link_status</code><a class="headerlink" href="#c.drm_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>connector&#8217;s link_status property value</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_GOOD</span></code></dt>
<dd>DP Link is Good as a result of successful
link training</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_BAD</span></code></dt>
<dd>DP Link is BAD as a result of link training
failure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used as the connector&#8217;s link status property value.
It is set to the values defined in uapi.</p>
<dl class="type">
<dt id="c.drm_display_info">
struct <code class="descname">drm_display_info</code><a class="headerlink" href="#c.drm_display_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime data about the connected sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_display_info {
  char name;
  unsigned int width_mm;
  unsigned int height_mm;
  unsigned int pixel_clock;
  unsigned int bpc;
  enum subpixel_order subpixel_order;
#define DRM_COLOR_FORMAT_RGB444               (1\\\lt;\\\lt;0
#define DRM_COLOR_FORMAT_YCRCB444     (1\\\lt;\\\lt;1
#define DRM_COLOR_FORMAT_YCRCB422     (1\\\lt;\\\lt;2
  u32 color_formats;
  const u32 * bus_formats;
  unsigned int num_bus_formats;
#define DRM_BUS_FLAG_DE_LOW           (1\\\lt;\\\lt;0
#define DRM_BUS_FLAG_DE_HIGH          (1\\\lt;\\\lt;1
#define DRM_BUS_FLAG_PIXDATA_POSEDGE  (1\\\lt;\\\lt;2
#define DRM_BUS_FLAG_PIXDATA_NEGEDGE  (1\\\lt;\\\lt;3
#define DRM_BUS_FLAG_DATA_MSB_TO_LSB  (1\\\lt;\\\lt;4
#define DRM_BUS_FLAG_DATA_LSB_TO_MSB  (1\\\lt;\\\lt;5
  u32 bus_flags;
  int max_tmds_clock;
  bool dvi_dual;
  u8 edid_hdmi_dc_modes;
  u8 cea_rev;
  struct drm_hdmi_info hdmi;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the display.</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Physical width in mm.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Physical height in mm.</dd>
<dt><code class="docutils literal"><span class="pre">pixel_clock</span></code></dt>
<dd>Maximum pixel clock supported by the sink, in units of
100Hz. This mismatches the clock in <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_display_mode</span></code></a> (which is in
kHZ), because that&#8217;s what the EDID uses as base unit.</dd>
<dt><code class="docutils literal"><span class="pre">bpc</span></code></dt>
<dd>Maximum bits per color channel. Used by HDMI and DP outputs.</dd>
<dt><code class="docutils literal"><span class="pre">subpixel_order</span></code></dt>
<dd>Subpixel order of LCD panels.</dd>
<dt><code class="docutils literal"><span class="pre">color_formats</span></code></dt>
<dd>HDMI Color formats, selects between RGB and YCrCb
modes. Used DRM_COLOR_FORMAT_ defines, which are _not_ the same ones
as used to describe the pixel format in framebuffers, and also don&#8217;t
match the formats in <strong>bus_formats</strong> which are shared with v4l.</dd>
<dt><code class="docutils literal"><span class="pre">bus_formats</span></code></dt>
<dd>Pixel data format on the wire, somewhat redundant with
<strong>color_formats</strong>. Array of size <strong>num_bus_formats</strong> encoded using
MEDIA_BUS_FMT_ defines shared with v4l and media drivers.</dd>
<dt><code class="docutils literal"><span class="pre">num_bus_formats</span></code></dt>
<dd>Size of <strong>bus_formats</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">bus_flags</span></code></dt>
<dd>Additional information (like pixel signal polarity) for
the pixel data on the bus, using DRM_BUS_FLAGS_ defines.</dd>
<dt><code class="docutils literal"><span class="pre">max_tmds_clock</span></code></dt>
<dd>Maximum TMDS clock rate supported by the
sink in kHz. 0 means undefined.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_dual</span></code></dt>
<dd>Dual-link DVI sink?</dd>
<dt><code class="docutils literal"><span class="pre">edid_hdmi_dc_modes</span></code></dt>
<dd>Mask of supported hdmi deep color modes. Even
more stuff redundant with <strong>bus_formats</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cea_rev</span></code></dt>
<dd>CEA revision of the HDMI sink.</dd>
<dt><code class="docutils literal"><span class="pre">hdmi</span></code></dt>
<dd>advance features of a HDMI sink.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes a given display (e.g. CRT or flat panel) and its limitations. For
fixed display sinks like built-in panels there&#8217;s not much difference between
this and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>. But for sinks with a real cable this
structure is meant to describe all the things at the other end of the cable.</p>
<p>For sinks which provide an EDID this can be filled out by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_tv_connector_state">
struct <code class="descname">drm_tv_connector_state</code><a class="headerlink" href="#c.drm_tv_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>TV connector related states</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_tv_connector_state {
  enum drm_mode_subconnector subconnector;
  struct margins;
  unsigned int mode;
  unsigned int brightness;
  unsigned int contrast;
  unsigned int flicker_reduction;
  unsigned int overscan;
  unsigned int saturation;
  unsigned int hue;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">subconnector</span></code></dt>
<dd>selected subconnector</dd>
<dt><code class="docutils literal"><span class="pre">margins</span></code></dt>
<dd>left/right/top/bottom margins</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>TV mode</dd>
<dt><code class="docutils literal"><span class="pre">brightness</span></code></dt>
<dd>brightness in percent</dd>
<dt><code class="docutils literal"><span class="pre">contrast</span></code></dt>
<dd>contrast in percent</dd>
<dt><code class="docutils literal"><span class="pre">flicker_reduction</span></code></dt>
<dd>flicker reduction in percent</dd>
<dt><code class="docutils literal"><span class="pre">overscan</span></code></dt>
<dd>overscan in percent</dd>
<dt><code class="docutils literal"><span class="pre">saturation</span></code></dt>
<dd>saturation in percent</dd>
<dt><code class="docutils literal"><span class="pre">hue</span></code></dt>
<dd>hue in percent</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_state">
struct <code class="descname">drm_connector_state</code><a class="headerlink" href="#c.drm_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable connector state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_connector_state {
  struct drm_connector * connector;
  struct drm_crtc * crtc;
  struct drm_encoder * best_encoder;
  enum drm_link_status link_status;
  struct drm_atomic_state * state;
  struct drm_tv_connector_state tv;
  enum hdmi_picture_aspect picture_aspect_ratio;
  unsigned int scaling_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>backpointer to the connector</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><p class="first">CRTC to connect connector to, NULL if disabled.</p>
<p class="last">Do not change this directly, use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_connector" title="drm_atomic_set_crtc_for_connector"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_connector()</span></code></a>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">best_encoder</span></code></dt>
<dd>can be used by helpers and drivers to select the encoder</dd>
<dt><code class="docutils literal"><span class="pre">link_status</span></code></dt>
<dd>Connector link_status to keep track of whether link is
GOOD or BAD to notify userspace if retraining is necessary.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
<dt><code class="docutils literal"><span class="pre">tv</span></code></dt>
<dd>TV connector state</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd><p class="first">Connector property to control the
HDMI infoframe aspect ratio setting.</p>
<p class="last">The <code class="docutils literal"><span class="pre">DRM_MODE_PICTURE_ASPECT_</span></code>* values much match the
values for <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">hdmi_picture_aspect</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode</span></code></dt>
<dd>Connector property to control the
upscaling, mostly used for built-in panels.</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_funcs">
struct <code class="descname">drm_connector_funcs</code><a class="headerlink" href="#c.drm_connector_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control connectors on a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_connector_funcs {
  int (* dpms) (struct drm_connector *connector, int mode);
  void (* reset) (struct drm_connector *connector);
  enum drm_connector_status (* detect) (struct drm_connector *connector,bool force);
  void (* force) (struct drm_connector *connector);
  int (* fill_modes) (struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
  int (* set_property) (struct drm_connector *connector, struct drm_property *property,uint64_t val);
  int (* late_register) (struct drm_connector *connector);
  void (* early_unregister) (struct drm_connector *connector);
  void (* destroy) (struct drm_connector *connector);
  struct drm_connector_state *(* atomic_duplicate_state) (struct drm_connector *connector);
  void (* atomic_destroy_state) (struct drm_connector *connector,struct drm_connector_state *state);
  int (* atomic_set_property) (struct drm_connector *connector,struct drm_connector_state *state,struct drm_property *property,uint64_t val);
  int (* atomic_get_property) (struct drm_connector *connector,const struct drm_connector_state *state,struct drm_property *property,uint64_t *val);
  void (* atomic_print_state) (struct drm_printer *p,const struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Legacy entry point to set the per-connector DPMS state. Legacy DPMS
is exposed as a standard property on the connector, but diverted to
this callback in the drm core. Note that atomic drivers don&#8217;t
implement the 4 level DPMS support on the connector any more, but
instead only have an on/off &#8220;ACTIVE&#8221; property on the CRTC object.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_dpms" title="drm_atomic_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_dpms()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset connector hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_reset" title="drm_atomic_helper_connector_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd><p class="first">Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>FIXME:</p>
<p>Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core  entry point to probe connector state is <strong>fill_modes</strong>.</p>
<p>Note that the helper library will already hold
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Drivers which need to grab additional
locks to avoid races with concurrent modeset changes need to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.detect_ctx</span></code></a> instead.</p>
<p>RETURNS:</p>
<p class="last">drm_connector_status indicating the connector&#8217;s status.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd><p class="first">This function is called to update internal encoder state when the
connector is forced to a certain state by userspace, either through
the sysfs interfaces or on the kernel cmdline. In that case the
<strong>detect</strong> callback isn&#8217;t called.</p>
<p>FIXME:</p>
<p class="last">Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core  entry point to probe connector state is <strong>fill_modes</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">fill_modes</span></code></dt>
<dd><p class="first">Entry point for output detection and basic mode validation. The
driver should reprobe the output if needed (e.g. when hotplug
handling is unreliable), add all detected modes to <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>
and filter out any the device can&#8217;t support in any configuration. It
also needs to filter out any modes wider or higher than the
parameters max_width and max_height indicate.</p>
<p>The drivers must also prune any modes no longer valid from
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. Furthermore it must update
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.status</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.edid</span></code></a>.  If no EDID has been
received for this output connector-&gt;edid must be NULL.</p>
<p>Drivers using the probe helpers should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> or
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes_nomerge()</span></code> to implement this
function.</p>
<p>RETURNS:</p>
<p class="last">The number of modes detected and filled into <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
connector.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_set_property" title="drm_atomic_helper_connector_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_set_property()</span></code></a> to implement this hook.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the connector, light backlight control, i2c,
DP aux or similar interfaces. It is called late in the driver load
sequence from <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code></a> when registering all the
core drm connector interfaces. Everything added from this callback
should be unregistered in the early_unregister callback.</p>
<p>This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd><p class="first">This optional hook should be used to unregister the additional
userspace interfaces attached to the connector from
<code class="xref c c-func docutils literal"><span class="pre">late_register()</span></code>. It is called from <a class="reference internal" href="#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
<p class="last">This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up connector resources. This is called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>. It can also be called at runtime
when a connector is being hot-unplugged for drivers that support
connector hotplugging (e.g. DisplayPort MST).</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this connector and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_duplicate_state" title="drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_connector_duplicate_state" title="__drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_connector_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_connector_set_property" title="drm_atomic_connector_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this connector). No other validation
is allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCONNECTOR IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which shouldn&#8217;t ever happen, the core only asks for
properties attached to this connector).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_print_state()</span></code>
instead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors attached to it.  The functions
below allow the core DRM code to control connectors, enumerate available modes,
etc.</p>
<dl class="type">
<dt id="c.drm_connector">
struct <code class="descname">drm_connector</code><a class="headerlink" href="#c.drm_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM connector control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_connector {
  struct drm_device * dev;
  struct device * kdev;
  struct device_attribute * attr;
  struct list_head head;
  struct drm_mode_object base;
  char * name;
  struct mutex mutex;
  unsigned index;
  int connector_type;
  int connector_type_id;
  bool interlace_allowed;
  bool doublescan_allowed;
  bool stereo_allowed;
  bool registered;
  struct list_head modes;
  enum drm_connector_status status;
  struct list_head probed_modes;
  struct drm_display_info display_info;
  const struct drm_connector_funcs * funcs;
  struct drm_property_blob * edid_blob_ptr;
  struct drm_object_properties properties;
  struct drm_property * scaling_mode_property;
  struct drm_property_blob * path_blob_ptr;
  struct drm_property_blob * tile_blob_ptr;
#define DRM_CONNECTOR_POLL_HPD (1 \\\lt;\\\lt; 0
#define DRM_CONNECTOR_POLL_CONNECT (1 \\\lt;\\\lt; 1
#define DRM_CONNECTOR_POLL_DISCONNECT (1 \\\lt;\\\lt; 2
  uint8_t polled;
  int dpms;
  const struct drm_connector_helper_funcs * helper_private;
  struct drm_cmdline_mode cmdline_mode;
  enum drm_connector_force force;
  bool override_edid;
#define DRM_CONNECTOR_MAX_ENCODER 3
  uint32_t encoder_ids;
  struct drm_encoder * encoder;
#define MAX_ELD_BYTES 128
  uint8_t eld;
  bool latency_present;
  int video_latency;
  int audio_latency;
  int null_edid_counter;
  unsigned bad_edid_counter;
  bool edid_corrupt;
  struct dentry * debugfs_entry;
  struct drm_connector_state * state;
  bool has_tile;
  struct drm_tile_group * tile_group;
  bool tile_is_single_monitor;
  uint8_t num_h_tile;
  uint8_t num_v_tile;
  uint8_t tile_h_loc;
  uint8_t tile_v_loc;
  uint16_t tile_h_size;
  uint16_t tile_v_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">kdev</span></code></dt>
<dd>kernel device for sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">attr</span></code></dt>
<dd>sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>Lock for general connector state, but currently only protects
<strong>registered</strong>. Most of the connector state is still protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Compacted connector index, which matches the position inside
the mode_config.list for drivers not supporting hot-add/removing. Can
be used as an array index. It is invariant over the lifetime of the
connector.</dd>
<dt><code class="docutils literal"><span class="pre">connector_type</span></code></dt>
<dd>one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</dd>
<dt><code class="docutils literal"><span class="pre">connector_type_id</span></code></dt>
<dd>index into connector type enum</dd>
<dt><code class="docutils literal"><span class="pre">interlace_allowed</span></code></dt>
<dd>can this connector handle interlaced modes?</dd>
<dt><code class="docutils literal"><span class="pre">doublescan_allowed</span></code></dt>
<dd>can this connector handle doublescan?</dd>
<dt><code class="docutils literal"><span class="pre">stereo_allowed</span></code></dt>
<dd>can this connector handle stereo modes?</dd>
<dt><code class="docutils literal"><span class="pre">registered</span></code></dt>
<dd>Is this connector exposed (registered) with userspace?
Protected by <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">modes</span></code></dt>
<dd>Modes available on this connector (from <code class="xref c c-func docutils literal"><span class="pre">fill_modes()</span></code> + user).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>One of the drm_connector_status enums (connected, not, or unknown).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">probed_modes</span></code></dt>
<dd>These are modes added by probing with DDC or the BIOS, before
filtering is applied. Used by the probe helpers. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">display_info</span></code></dt>
<dd><p class="first">Display information is filled from EDID information
when a display is detected. For non hot-pluggable displays such as
flat panels in embedded systems, the driver should initialize the
<a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.width_mm</span></code></a> and <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.height_mm</span></code></a> fields
with the physical size of the display.</p>
<p class="last">Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>connector control functions</dd>
<dt><code class="docutils literal"><span class="pre">edid_blob_ptr</span></code></dt>
<dd>DRM property containing EDID if present</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this connector</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional atomic property to control the upscaling.</dd>
<dt><code class="docutils literal"><span class="pre">path_blob_ptr</span></code></dt>
<dd>DRM blob property data for the DP MST path property.</dd>
<dt><code class="docutils literal"><span class="pre">tile_blob_ptr</span></code></dt>
<dd>DRM blob property data for the tile property (used mostly by DP MST).
This is meant for screens which are driven through separate display
pipelines represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>, which might not be running with
genlocked clocks. For tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose
the tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> if needed.</dd>
<dt><code class="docutils literal"><span class="pre">polled</span></code></dt>
<dd><p class="first">Connector polling mode, a combination of</p>
<dl class="docutils">
<dt>DRM_CONNECTOR_POLL_HPD</dt>
<dd>The connector generates hotplug events and doesn&#8217;t need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.</dd>
<dt>DRM_CONNECTOR_POLL_CONNECT</dt>
<dd>Periodically poll the connector for connection.</dd>
<dt>DRM_CONNECTOR_POLL_DISCONNECT</dt>
<dd>Periodically poll the connector for disconnection.</dd>
</dl>
<p class="last">Set to 0 for connectors that don&#8217;t support connection status
discovery.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd>current dpms state</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">cmdline_mode</span></code></dt>
<dd>mode line parsed from the kernel cmdline for this connector</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd>a DRM_FORCE_&lt;foo&gt; state for forced mode sets</dd>
<dt><code class="docutils literal"><span class="pre">override_edid</span></code></dt>
<dd>has the EDID been overwritten through debugfs for testing?</dd>
<dt><code class="docutils literal"><span class="pre">encoder_ids</span></code></dt>
<dd>valid encoders for this connector</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>encoder driving this connector, if any</dd>
<dt><code class="docutils literal"><span class="pre">eld</span></code></dt>
<dd>EDID-like data, if present</dd>
<dt><code class="docutils literal"><span class="pre">latency_present</span></code></dt>
<dd>AV delay info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">video_latency</span></code></dt>
<dd>video latency info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">audio_latency</span></code></dt>
<dd>audio latency info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">null_edid_counter</span></code></dt>
<dd>track sinks that give us all zeros for the EDID</dd>
<dt><code class="docutils literal"><span class="pre">bad_edid_counter</span></code></dt>
<dd>track sinks that give us an EDID with invalid checksum</dd>
<dt><code class="docutils literal"><span class="pre">edid_corrupt</span></code></dt>
<dd>indicates whether the last read EDID was corrupt</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>debugfs directory for this connector</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this connector.</p>
<p class="last">This is protected by <strong>drm_mode_config</strong>.connection_mutex. Note that
nonblocking atomic commits access the current connector state without
taking locks. Either by going through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a>
pointers, see <a class="reference internal" href="#c.for_each_connector_in_state" title="for_each_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_connector_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_oldnew_connector_in_state" title="for_each_oldnew_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_connector_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_connector_in_state" title="for_each_old_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_connector_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_connector_in_state" title="for_each_new_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_connector_in_state()</span></code></a>. Or through careful ordering of
atomic commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">has_tile</span></code></dt>
<dd>is this connector connected to a tiled monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_group</span></code></dt>
<dd>tile group for the connected monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_is_single_monitor</span></code></dt>
<dd>whether the tile is one monitor housing</dd>
<dt><code class="docutils literal"><span class="pre">num_h_tile</span></code></dt>
<dd>number of horizontal tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">num_v_tile</span></code></dt>
<dd>number of vertical tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_loc</span></code></dt>
<dd>horizontal location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_loc</span></code></dt>
<dd>vertical location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_size</span></code></dt>
<dd>horizontal size of this tile.</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_size</span></code></dt>
<dd>vertical size of this tile.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each connector may be connected to one or more CRTCs, or may be clonable by
another connector if they can share a CRTC.  Each connector also has a specific
position in the broader display (referred to as a &#8216;screen&#8217; though it could
span multiple monitors).</p>
<dl class="function">
<dt id="c.drm_connector_lookup">
struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="descname">drm_connector_lookup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup connector object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>connector object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the connector object specified by id
add takes a reference to it.</p>
<dl class="function">
<dt id="c.drm_connector_get">
void <code class="descname">drm_connector_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the connector&#8217;s refcount.</p>
<dl class="function">
<dt id="c.drm_connector_put">
void <code class="descname">drm_connector_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the connector&#8217;s reference count and frees the
object if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_connector_reference">
void <code class="descname">drm_connector_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_connector_unreference">
void <code class="descname">drm_connector_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_put()</span></code></a> and should not be
used by new code.</p>
<dl class="type">
<dt id="c.drm_tile_group">
struct <code class="descname">drm_tile_group</code><a class="headerlink" href="#c.drm_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile group metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_tile_group {
  struct kref refcount;
  struct drm_device * dev;
  int id;
  u8 group_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>tile group id exposed to userspace</dd>
<dt><code class="docutils literal"><span class="pre">group_data</span></code></dt>
<dd>Sink-private data identifying this group</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>group_data</strong> corresponds to displayid vend/prod/serial for external screens
with an EDID.</p>
<dl class="type">
<dt id="c.drm_connector_list_iter">
struct <code class="descname">drm_connector_list_iter</code><a class="headerlink" href="#c.drm_connector_list_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_connector_list_iter {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This iterator tracks state needed to be able to walk the connector_list
within struct drm_mode_config. Only use together with
<a class="reference internal" href="#c.drm_connector_list_iter_begin" title="drm_connector_list_iter_begin"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_begin()</span></code></a>, <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_next()</span></code></a> respectively the convenience macro
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_connector_iter">
<code class="descname">drm_for_each_connector_iter</code><span class="sig-paren">(</span><em>connector</em>, <em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_connector_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator macro</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer used as cursor</dd>
<dt><code class="docutils literal"><span class="pre">iter</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>connector</strong> is only valid within the list body, if you want to use
<strong>connector</strong> after calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a> then you need to grab
your own reference first using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_connector_init">
int <code class="descname">drm_connector_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>&nbsp;funcs</em>, int<em>&nbsp;connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init a preallocated connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to init</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for this connector</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt>
<dd>user visible type of the connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated connector. Connectors should be
subclassed as part of driver connector objects.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_mode_connector_attach_encoder">
int <code class="descname">drm_mode_connector_attach_encoder</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_attach_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a connector to an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to attach <strong>connector</strong> to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function links up a connector to an encoder. Note that the routing
restrictions between encoders and crtcs are exposed to userspace through the
possible_clones and possible_crtcs bitmasks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_cleanup">
void <code class="descname">drm_connector_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up an initialised connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the connector but doesn&#8217;t free the object.</p>
<dl class="function">
<dt id="c.drm_connector_register">
int <code class="descname">drm_connector_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register userspace interfaces for a connector</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_connector_unregister">
void <code class="descname">drm_connector_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister userspace interfaces for a connector</p>
<dl class="function">
<dt id="c.drm_get_connector_status_name">
const char * <code class="descname">drm_get_connector_status_name</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a><em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_connector_status_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return a string for connector status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt>
<dd>connector status to compute name of</dd>
</dl>
<p><strong>Description</strong></p>
<p>In contrast to the other drm_get_*_name functions this one here returns a
const pointer and hence is threadsafe.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_begin">
void <code class="descname">drm_connector_list_iter_begin</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connector_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <strong>iter</strong> up to walk the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_list</span></code></a> of <strong>dev</strong>. <strong>iter</strong>
must always be cleaned up again by calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a>.
Iteration itself happens using <a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_next()</span></code></a> or
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_next">
struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="descname">drm_connector_list_iter_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return next connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connectr_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next connector for <strong>iter</strong>, or NULL when the list walk has
completed.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_end">
void <code class="descname">drm_connector_list_iter_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_end" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connector_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down <strong>iter</strong> and releases any resources (like <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> references)
acquired while walking the list. This must always be called, both when the
iteration completes fully or when it was aborted without walking the entire
list.</p>
<dl class="function">
<dt id="c.drm_get_subpixel_order_name">
const char * <code class="descname">drm_get_subpixel_order_name</code><span class="sig-paren">(</span>enum subpixel_order<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_subpixel_order_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return a string for a given subpixel enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">subpixel_order</span> <span class="pre">order</span></code></dt>
<dd>enum of subpixel_order</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note you could abuse this and return something out of bounds, but that
would be a caller error.  No unscrubbed user data should make it here.</p>
<dl class="function">
<dt id="c.drm_display_info_set_bus_formats">
int <code class="descname">drm_display_info_set_bus_formats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>&nbsp;info</em>, const u32 *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;num_formats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_info_set_bus_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>set the supported bus formats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>display info to store bus formats in</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array containing the supported bus formats</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_formats</span></code></dt>
<dd>the number of entries in the fmts array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Store the supported bus formats in display info structure.
See MEDIA_BUS_FMT_* definitions in include/uapi/linux/media-bus-format.h for
a full list of available formats.</p>
<dl class="function">
<dt id="c.drm_mode_create_dvi_i_properties">
int <code class="descname">drm_mode_create_dvi_i_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_dvi_i_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create DVI-I specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time a DVI-I connector is made.</p>
<dl class="function">
<dt id="c.drm_mode_create_tv_properties">
int <code class="descname">drm_mode_create_tv_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num_modes</em>, const char *const<em>&nbsp;modes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tv_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create TV specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_modes</span></code></dt>
<dd>number of different TV formats (modes) supported</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">modes</span></code></dt>
<dd>array of pointers to strings containing name of each format</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver&#8217;s TV initialization routine, this function creates
the TV specific connector properties for a given device.  Caller is
responsible for allocating a list of format names and passing them to
this routine.</p>
<dl class="function">
<dt id="c.drm_mode_create_scaling_mode_property">
int <code class="descname">drm_mode_create_scaling_mode_property</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_scaling_mode_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it&#8217;s needed, must be attached to desired
connectors.</p>
<p>Atomic drivers should use <a class="reference internal" href="#c.drm_connector_attach_scaling_mode_property" title="drm_connector_attach_scaling_mode_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_scaling_mode_property()</span></code></a>
instead to correctly assign <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
in the atomic state.</p>
<dl class="function">
<dt id="c.drm_connector_attach_scaling_mode_property">
int <code class="descname">drm_connector_attach_scaling_mode_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, u32<em>&nbsp;scaling_mode_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_scaling_mode_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach atomic scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach scaling mode property on.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">scaling_mode_mask</span></code></dt>
<dd>or&#8217;ed mask of BIT(<code class="docutils literal"><span class="pre">DRM_MODE_SCALE_</span></code>*).</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for scaling mode to atomic drivers.
The scaling mode will be set to <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
and can be used from <a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs-&gt;atomic_check</span></code></a> for validation.</p>
<p>This is the atomic version of <a class="reference internal" href="#c.drm_mode_create_scaling_mode_property" title="drm_mode_create_scaling_mode_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create_scaling_mode_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_create_aspect_ratio_property">
int <code class="descname">drm_mode_create_aspect_ratio_property</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_aspect_ratio_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create aspect ratio property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it&#8217;s needed, must be attached to desired
connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_create_suggested_offset_properties">
int <code class="descname">drm_mode_create_suggested_offset_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_suggested_offset_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create suggests offset properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create the the suggested x/y offset property for connectors.</p>
<dl class="function">
<dt id="c.drm_mode_connector_set_path_property">
int <code class="descname">drm_mode_connector_set_path_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_set_path_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to set property on.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to use for property; must not be NULL.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a property to expose to userspace to specify a
connector path. This is mainly used for DisplayPort MST where
connectors have a topology and we want to allow userspace to give
them more meaningful names.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_connector_set_tile_property">
int <code class="descname">drm_mode_connector_set_tile_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_set_tile_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to set property on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This looks up the tile information for a connector, and creates a
property for userspace to parse if it exists. The property is of
the form of 8 integers using &#8216;:&#8217; as a separator.</p>
<p><strong>Return</strong></p>
<p>Zero on success, errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_connector_update_edid_property">
int <code class="descname">drm_mode_connector_update_edid_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_update_edid_property" title="Permalink to this definition">¶</a></dt>
<dd><p>update the edid property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>new value of the edid property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new blob modeset object and assigns its id to the
connector&#8217;s edid property.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_connector_set_link_status_property">
void <code class="descname">drm_mode_connector_set_link_status_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, uint64_t<em>&nbsp;link_status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_connector_set_link_status_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Set link status property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">link_status</span></code></dt>
<dd>new value of link status property (0: Good, 1: Bad)</dd>
</dl>
<p><strong>Description</strong></p>
<p>In usual working scenario, this link status property will always be set to
&#8220;GOOD&#8221;. If something fails during or after a mode set, the kernel driver
may set this link status property to &#8220;BAD&#8221;. The caller then needs to send a
hotplug uevent for userspace to re-check the valid modes through
GET_CONNECTOR_IOCTL and retry modeset.</p>
<p><strong>Note</strong></p>
<p>Drivers cannot rely on userspace to support this property and
issue a modeset. As such, they may choose to handle issues (like
re-training a link) without userspace&#8217;s intervention.</p>
<p>The reason for adding this property is to handle link training failures, but
it is not limited to DP or link training. For example, if we implement
asynchronous setcrtc, this property can be used to report any failures in that.</p>
<dl class="function">
<dt id="c.drm_mode_put_tile_group">
void <code class="descname">drm_mode_put_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> *<em>&nbsp;tg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_put_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a reference to a tile group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_tile_group</span> <span class="pre">*</span> <span class="pre">tg</span></code></dt>
<dd>tile group to drop reference to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>drop reference to tile group and free if 0.</p>
<dl class="function">
<dt id="c.drm_mode_get_tile_group">
struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> * <code class="descname">drm_mode_get_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, char<em>&nbsp;topology</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to an existing tile group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">topology</span></code></dt>
<dd>8-bytes unique per monitor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the unique bytes to get a reference to an existing tile group.</p>
<p><strong>Return</strong></p>
<p>tile group or NULL if not found.</p>
<dl class="function">
<dt id="c.drm_mode_create_tile_group">
struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> * <code class="descname">drm_mode_create_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, char<em>&nbsp;topology</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>create a tile group from a displayid description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">topology</span></code></dt>
<dd>8-bytes unique per monitor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a tile group for the unique monitor, and get a unique
identifier for the tile group.</p>
<p><strong>Return</strong></p>
<p>new tile group or error.</p>
</div>
</div>
<div class="section" id="encoder-abstraction">
<h2>Encoder Abstraction<a class="headerlink" href="#encoder-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Encoders represent the connecting element between the CRTC (as the overall
pixel pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>) and the connectors (as the
generic sink entity, represented by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>). An encoder takes
pixel data from a CRTC and converts it to a format suitable for any attached
connector. Encoders are objects exposed to userspace, originally to allow
userspace to infer cloning and connector/CRTC restrictions. Unfortunately
almost all drivers get this wrong, making the uabi pretty much useless. On
top of that the exposed restrictions are too simple for today&#8217;s hardware, and
the recommended way to infer restrictions is by using the
DRM_MODE_ATOMIC_TEST_ONLY flag for the atomic IOCTL.</p>
<p>Otherwise encoders aren&#8217;t used in the uapi at all (any modeset request from
userspace directly connects a connector with a CRTC), drivers are therefore
free to use them however they wish. Modeset helper libraries make strong use
of encoders to facilitate code sharing. But for more complex settings it is
usually better to move shared code into a separate <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>. Compared to
encoders, bridges also have the benefit of being purely an internal
abstraction since they are not exposed to userspace at all.</p>
<p>Encoders are initialized with <a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a> and cleaned up using
<a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a>.</p>
<div class="section" id="encoder-functions-reference">
<h3>Encoder Functions Reference<a class="headerlink" href="#encoder-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_encoder_funcs">
struct <code class="descname">drm_encoder_funcs</code><a class="headerlink" href="#c.drm_encoder_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>encoder controls</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_encoder_funcs {
  void (* reset) (struct drm_encoder *encoder);
  void (* destroy) (struct drm_encoder *encoder);
  int (* late_register) (struct drm_encoder *encoder);
  void (* early_unregister) (struct drm_encoder *encoder);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd>Reset encoder hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up encoder resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since an encoder cannot be
hotplugged in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the encoder like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the encoder from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encoders sit between CRTCs and connectors.</p>
<dl class="type">
<dt id="c.drm_encoder">
struct <code class="descname">drm_encoder</code><a class="headerlink" href="#c.drm_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM encoder structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_encoder {
  struct drm_device * dev;
  struct list_head head;
  struct drm_mode_object base;
  char * name;
  int encoder_type;
  unsigned index;
  uint32_t possible_crtcs;
  uint32_t possible_clones;
  struct drm_crtc * crtc;
  struct drm_bridge * bridge;
  const struct drm_encoder_funcs * funcs;
  const struct drm_encoder_helper_funcs * helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">encoder_type</span></code></dt>
<dd><p class="first">One of the DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h. The following
encoder types are defined thus far:</p>
<ul class="last simple">
<li>DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A.</li>
<li>DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort.</li>
<li>DRM_MODE_ENCODER_LVDS for display panels, or in general any panel
with a proprietary parallel connector.</li>
<li>DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video,
Component, SCART).</li>
<li>DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</li>
<li>DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus.</li>
<li>DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel
bus.</li>
<li>DRM_MODE_ENCODER_DPMST for special fake encoders used to allow
mutliple DP MST streams to share one physical encoder.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the encoder.</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd><p class="first">Bitmask of potential CRTC bindings, using
<a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> as the index into the bitfield. The driver must set
the bits for all <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> objects this encoder can be connected to
before calling <a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a>.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since CRTC objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">possible_clones</span></code></dt>
<dd><p class="first">Bitmask of potential sibling encoders for cloning,
using <a class="reference internal" href="#c.drm_encoder_index" title="drm_encoder_index"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_index()</span></code></a> as the index into the bitfield. The driver
must set the bits for all <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> objects which can clone a
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> together with this encoder before calling
<a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a>. Drivers should set the bit representing the
encoder itself, too. Cloning bits should be set such that when two
encoders can be used in a cloned configuration, they both should have
each another bits set.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since encoder objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>currently bound CRTC</dd>
<dt><code class="docutils literal"><span class="pre">bridge</span></code></dt>
<dd>bridge associated to the encoder</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>control functions</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>CRTCs drive pixels to encoders, which convert them into signals
appropriate for a given connector or set of connectors.</p>
<dl class="function">
<dt id="c.drm_encoder_index">
unsigned int <code class="descname">drm_encoder_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the index of that encoder within a DRM
device&#8217;s list of encoders.</p>
<dl class="function">
<dt id="c.drm_encoder_crtc_ok">
bool <code class="descname">drm_encoder_crtc_ok</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_crtc_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>can a given crtc drive a given encoder?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to test</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns false if <strong>encoder</strong> can&#8217;t be driven by <strong>crtc</strong>, true otherwise.</p>
<dl class="function">
<dt id="c.drm_encoder_find">
struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> * <code class="descname">drm_encoder_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>encoder id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the encoder with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder_mask">
<code class="descname">drm_for_each_encoder_mask</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em>, <em>encoder_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over encoders specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>bitmask of encoder indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder">
<code class="descname">drm_for_each_encoder</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all encoders</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders of <strong>dev</strong>.</p>
<dl class="function">
<dt id="c.drm_encoder_init">
int <code class="descname">drm_encoder_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs">drm_encoder_funcs</a> *<em>&nbsp;funcs</em>, int<em>&nbsp;encoder_type</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init a preallocated encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>the encoder to init</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for this encoder</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">encoder_type</span></code></dt>
<dd>user visible type of the encoder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the encoder name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated encoder. Encoder should be subclassed as part of
driver encoder objects. At driver unload time <a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a> should be
called from the driver&#8217;s <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_funcs.destroy</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_encoder_cleanup">
void <code class="descname">drm_encoder_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up an initialised encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the encoder but doesn&#8217;t free the object.</p>
</div>
</div>
<div class="section" id="kms-initialization-and-cleanup">
<h2>KMS Initialization and Cleanup<a class="headerlink" href="#kms-initialization-and-cleanup" title="Permalink to this headline">¶</a></h2>
<p>A KMS device is abstracted and exposed as a set of planes, CRTCs,
encoders and connectors. KMS drivers must thus create and initialize all
those objects at load time after initializing mode setting.</p>
<div class="section" id="crtcs-struct-drm-crtc">
<h3>CRTCs (<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>)<a class="headerlink" href="#crtcs-struct-drm-crtc" title="Permalink to this headline">¶</a></h3>
<p>A CRTC is an abstraction representing a part of the chip that contains a
pointer to a scanout buffer. Therefore, the number of CRTCs available
determines how many independent scanout buffers can be active at any
given time. The CRTC structure contains several fields to support this:
a pointer to some video memory (abstracted as a frame buffer object), a
display mode, and an (x, y) offset into the video memory to support
panning or configurations where one piece of video memory spans multiple
CRTCs.</p>
<div class="section" id="crtc-initialization">
<h4>CRTC Initialization<a class="headerlink" href="#crtc-initialization" title="Permalink to this headline">¶</a></h4>
<p>A KMS device must create and register at least one struct
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> instance. The instance is
allocated and zeroed by the driver, possibly as part of a larger
structure, and registered with a call to <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_init" title="drm_crtc_init"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init()</span></code></a>
with a pointer to CRTC functions.</p>
</div>
</div>
<div class="section" id="cleanup">
<h3>Cleanup<a class="headerlink" href="#cleanup" title="Permalink to this headline">¶</a></h3>
<p>The DRM core manages its objects&#8217; lifetime. When an object is not needed
anymore the core calls its destroy function, which must clean up and
free every resource allocated for the object. Every
<code class="xref c c-func docutils literal"><span class="pre">drm_*_init()</span></code> call must be matched with a corresponding
<code class="xref c c-func docutils literal"><span class="pre">drm_*_cleanup()</span></code> call to cleanup CRTCs
(<a class="reference internal" href="#c.drm_crtc_cleanup" title="drm_crtc_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_cleanup()</span></code></a>), planes
(<a class="reference internal" href="#c.drm_plane_cleanup" title="drm_plane_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_cleanup()</span></code></a>), encoders
(<a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a>) and connectors
(<a class="reference internal" href="#c.drm_connector_cleanup" title="drm_connector_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code></a>). Furthermore, connectors that
have been added to sysfs must be removed by a call to
<a class="reference internal" href="#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code></a> before calling
<a class="reference internal" href="#c.drm_connector_cleanup" title="drm_connector_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code></a>.</p>
<p>Connectors state change detection must be cleanup up with a call to
<a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_poll_fini" title="drm_kms_helper_poll_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_fini()</span></code></a>.</p>
</div>
<div class="section" id="output-discovery-and-initialization-example">
<h3>Output discovery and initialization example<a class="headerlink" href="#output-discovery-and-initialization-example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">intel_crt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">intel_output</span> <span class="o">*</span><span class="n">intel_output</span><span class="p">;</span>

    <span class="n">intel_output</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_output</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">connector</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="n">drm_connector_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
               <span class="o">&amp;</span><span class="n">intel_crt_connector_funcs</span><span class="p">,</span> <span class="n">DRM_MODE_CONNECTOR_VGA</span><span class="p">);</span>

    <span class="n">drm_encoder_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_enc_funcs</span><span class="p">,</span>
             <span class="n">DRM_MODE_ENCODER_DAC</span><span class="p">);</span>

    <span class="n">drm_mode_connector_attach_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">);</span>

    <span class="cm">/* Set up the DDC bus. */</span>
    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span> <span class="o">=</span> <span class="n">intel_i2c_create</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GPIOA</span><span class="p">,</span> <span class="s">&quot;CRTDDC_A&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DDC bus registration &quot;</span>
               <span class="s">&quot;failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">INTEL_OUTPUT_ANALOG</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">interlace_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">doublescan_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">drm_encoder_helper_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_helper_funcs</span><span class="p">);</span>
    <span class="n">drm_connector_helper_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_connector_helper_funcs</span><span class="p">);</span>

    <span class="n">drm_connector_register</span><span class="p">(</span><span class="n">connector</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above (taken from the i915 driver), a CRTC, connector and
encoder combination is created. A device-specific i2c bus is also
created for fetching EDID data and performing monitor detection. Once
the process is complete, the new connector is registered with sysfs to
make its properties available to applications.</p>
</div>
</div>
<div class="section" id="kms-locking">
<h2>KMS Locking<a class="headerlink" href="#kms-locking" title="Permalink to this headline">¶</a></h2>
<p>As KMS moves toward more fine grained locking, and atomic ioctl where
userspace can indirectly control locking order, it becomes necessary
to use <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code> and acquire-contexts to avoid deadlocks.  But because
the locking is more distributed around the driver code, we want a bit
of extra utility/tracking out of our acquire-ctx.  This is provided
by <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a> and <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span></code></a>.</p>
<p>For basic principles of <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code>, see: Documentation/locking/ww-mutex-design.txt</p>
<p>The basic usage pattern is to:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>drm_modeset_acquire_init(:c:type:`ctx`)
retry:
foreach (lock in random_ordered_set_of_locks) {
    ret = drm_modeset_lock(lock, :c:type:`ctx`)
    if (ret == -EDEADLK) {
        drm_modeset_backoff(:c:type:`ctx`);
        goto retry;
    }
}
... do stuff ...
drm_modeset_drop_locks(:c:type:`ctx`);
drm_modeset_acquire_fini(:c:type:`ctx`);
</pre></div>
</div>
<p>On top of of these per-object locks using <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code> there&#8217;s also an overall
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>, for protecting everything else. Mostly this means
probe state of connectors, and preventing hotplug add/removal of connectors.</p>
<p>Finally there&#8217;s a bunch of dedicated locks to protect drm core internal
lists and lookup data structures.</p>
<dl class="type">
<dt id="c.drm_modeset_acquire_ctx">
struct <code class="descname">drm_modeset_acquire_ctx</code><a class="headerlink" href="#c.drm_modeset_acquire_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>locking context (see ww_acquire_ctx)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_modeset_acquire_ctx {
  struct ww_acquire_ctx ww_ctx;
  struct drm_modeset_lock * contended;
  struct list_head locked;
  bool trylock_only;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ww_ctx</span></code></dt>
<dd>base acquire ctx</dd>
<dt><code class="docutils literal"><span class="pre">contended</span></code></dt>
<dd>used internally for -EDEADLK handling</dd>
<dt><code class="docutils literal"><span class="pre">locked</span></code></dt>
<dd>list of held locks</dd>
<dt><code class="docutils literal"><span class="pre">trylock_only</span></code></dt>
<dd>trylock mode used in atomic contexts/panic notifiers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each thread competing for a set of locks must use one acquire
ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
retry.</p>
<dl class="type">
<dt id="c.drm_modeset_lock">
struct <code class="descname">drm_modeset_lock</code><a class="headerlink" href="#c.drm_modeset_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>used for locking modeset resources.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_modeset_lock {
  struct ww_mutex mutex;
  struct list_head head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>resource locking</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>used to hold it&#8217;s place on <code class="xref c c-type docutils literal"><span class="pre">drm_atomi_state.locked</span></code> list when
part of an atomic update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for locking CRTCs and other modeset resources.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_fini">
void <code class="descname">drm_modeset_lock_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to cleanup</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_is_locked">
bool <code class="descname">drm_modeset_is_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent to <a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_is_locked" title="mutex_is_locked"><code class="xref c c-func docutils literal"><span class="pre">mutex_is_locked()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to check</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_lock_all">
void <code class="descname">drm_modeset_lock_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all" title="Permalink to this definition">¶</a></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn&#8217;t (yet) implemented. Locks must be dropped by calling the
<a class="reference internal" href="#c.drm_modeset_unlock_all" title="drm_modeset_unlock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_unlock_all()</span></code></a> function.</p>
<p>This function is deprecated. It allocates a lock acquisition context and
stores it in <code class="xref c c-type docutils literal"><span class="pre">drm_device.mode_config</span></code>. This facilitate conversion of
existing code because it removes the need to manually deal with the
acquisition context, but it is also brittle because the context is global
and care must be taken not to nest calls. New code should use the
<a class="reference internal" href="#c.drm_modeset_lock_all_ctx" title="drm_modeset_lock_all_ctx"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all_ctx()</span></code></a> function and pass in the context explicitly.</p>
<dl class="function">
<dt id="c.drm_modeset_unlock_all">
void <code class="descname">drm_modeset_unlock_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock_all" title="Permalink to this definition">¶</a></dt>
<dd><p>drop all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops all modeset locks taken by a previous call to the
<a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a> function.</p>
<p>This function is deprecated. It uses the lock acquisition context stored
in <code class="xref c c-type docutils literal"><span class="pre">drm_device.mode_config</span></code>. This facilitates conversion of existing
code because it removes the need to manually deal with the acquisition
context, but it is also brittle because the context is global and care must
be taken not to nest calls. New code should pass the acquisition context
directly to the <a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a> function.</p>
<dl class="function">
<dt id="c.drm_warn_on_modeset_not_all_locked">
void <code class="descname">drm_warn_on_modeset_not_all_locked</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_warn_on_modeset_not_all_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>check that all modeset locks are locked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful as a debug assert.</p>
<dl class="function">
<dt id="c.drm_modeset_acquire_init">
void <code class="descname">drm_modeset_acquire_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em>, uint32_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>for future</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_acquire_fini">
void <code class="descname">drm_modeset_acquire_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_drop_locks">
void <code class="descname">drm_modeset_drop_locks</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_drop_locks" title="Permalink to this definition">¶</a></dt>
<dd><p>drop all locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop all locks currently held against this acquire context.</p>
<dl class="function">
<dt id="c.drm_modeset_backoff">
void <code class="descname">drm_modeset_backoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>deadlock avoidance backoff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>If deadlock is detected (ie. <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a> returns -EDEADLK),
you must call this function to drop all currently held locks and
block until the contended lock becomes available.</p>
<dl class="function">
<dt id="c.drm_modeset_backoff_interruptible">
int <code class="descname">drm_modeset_backoff_interruptible</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_backoff_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>deadlock avoidance backoff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Interruptible version of <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a></p>
<dl class="function">
<dt id="c.drm_modeset_lock_init">
void <code class="descname">drm_modeset_lock_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to init</dd>
</dl>
<dl class="function">
<dt>
int <code class="descname">drm_modeset_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em>, struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span></dt>
<dd><p>take modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to take</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>acquire ctx</dd>
</dl>
<p><strong>Description</strong></p>
<p>If ctx is not NULL, then its ww acquire context is used and the
lock will be tracked by the context and can be released by calling
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a>.  If -EDEADLK is returned, this means a
deadlock scenario has been detected and it is an error to attempt
to take any more locks without first calling <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_interruptible">
int <code class="descname">drm_modeset_lock_interruptible</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em>, struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>take modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to take</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>acquire ctx</dd>
</dl>
<p><strong>Description</strong></p>
<p>Interruptible version of <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a></p>
<dl class="function">
<dt id="c.drm_modeset_unlock">
void <code class="descname">drm_modeset_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to release</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_lock_all_ctx">
int <code class="descname">drm_modeset_lock_all_ctx</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn&#8217;t (yet) implemented.</p>
<p>Unlike <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a>, it doesn&#8217;t take the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>
since that lock isn&#8217;t required for modeset state changes. Callers which
need to grab that lock too need to do so outside of the acquire context
<strong>ctx</strong>.</p>
<p>Locks acquired with this function should be released by calling the
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a> function on <strong>ctx</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error-code on failure.</p>
</div>
<div class="section" id="kms-properties">
<h2>KMS Properties<a class="headerlink" href="#kms-properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="property-types-and-blob-property-support">
<h3>Property Types and Blob Property Support<a class="headerlink" href="#property-types-and-blob-property-support" title="Permalink to this headline">¶</a></h3>
<p>Properties as represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a> are used to extend the modeset
interface exposed to userspace. For the atomic modeset IOCTL properties are
even the only way to transport metadata about the desired new modeset
configuration from userspace to the kernel. Properties have a well-defined
value range, which is enforced by the drm core. See the documentation of the
flags member of <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a> for an overview of the different
property types and ranges.</p>
<p>Properties don&#8217;t store the current value directly, but need to be
instatiated by attaching them to a <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a> with
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<p>Property values are only 64bit. To support bigger piles of data (like gamma
tables, color correction matrices or large structures) a property can instead
point at a <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a> with that additional data.</p>
<p>Properties are defined by their symbolic name, userspace must keep a
per-object mapping from those names to the property ID used in the atomic
IOCTL and in the get/set property IOCTL.</p>
<dl class="type">
<dt id="c.drm_property_enum">
struct <code class="descname">drm_property_enum</code><a class="headerlink" href="#c.drm_property_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>symbolic values for enumerations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_property_enum {
  uint64_t value;
  struct list_head head;
  char name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>numeric property value for this enum entry</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list of enum values, linked to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.enum_list</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name for the enum</dd>
</dl>
<p><strong>Description</strong></p>
<p>For enumeration and bitmask properties this structure stores the symbolic
decoding for each value. This is used for example for the rotation property.</p>
<dl class="type">
<dt id="c.drm_property">
struct <code class="descname">drm_property</code><a class="headerlink" href="#c.drm_property" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset object property</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_property {
  struct list_head head;
  struct drm_mode_object base;
  uint32_t flags;
  char name;
  uint32_t num_values;
  uint64_t * values;
  struct drm_device * dev;
  struct list_head enum_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>per-device list of properties, for cleanup.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Property flags and type. A property needs to be one of the following
types:</p>
<dl class="docutils">
<dt>DRM_MODE_PROP_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is unsigned. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_range" title="drm_property_create_range"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_range()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_SIGNED_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is signed. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_signed_range" title="drm_property_create_signed_range"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_signed_range()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_ENUM</dt>
<dd>Enumerated properties take a numerical value that ranges from 0 to
the number of enumerated values defined by the property minus one,
and associate a free-formed string name to each value. Applications
can retrieve the list of defined value-name pairs and use the
numerical value to get and set property instance values. Enum
properties are created using <a class="reference internal" href="#c.drm_property_create_enum" title="drm_property_create_enum"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_enum()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_BITMASK</dt>
<dd>Bitmask properties are enumeration properties that additionally
restrict all enumerated values to the 0..63 range. Bitmask property
instance values combine one or more of the enumerated bits defined
by the property. Bitmask properties are created using
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_bitmask()</span></code></a>.</dd>
<dt>DRM_MODE_PROB_OBJECT</dt>
<dd><p class="first">Object properties are used to link modeset objects. This is used
extensively in the atomic support to create the display pipeline,
by linking <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> to <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> to
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. An object property can
only link to a specific type of <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a>, this limit is
enforced by the core. Object properties are created using
<a class="reference internal" href="#c.drm_property_create_object" title="drm_property_create_object"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_object()</span></code></a>.</p>
<p class="last">Object properties work like blob properties, but in a more
general fashion. They are limited to atomic drivers and must have
the DRM_MODE_PROP_ATOMIC flag set.</p>
</dd>
<dt>DRM_MODE_PROP_BLOB</dt>
<dd><p class="first">Blob properties store a binary blob without any format restriction.
The binary blobs are created as KMS standalone objects, and blob
property instance values store the ID of their associated blob
object. Blob properties are created by calling
<a class="reference internal" href="#c.drm_property_create" title="drm_property_create"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create()</span></code></a> with DRM_MODE_PROP_BLOB as the type.</p>
<p>Actual blob objects to contain blob data are created using
<a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code></a>, or through the corresponding IOCTL.</p>
<p class="last">Besides the built-in limit to only accept blob objects blob
properties work exactly like object properties. The only reasons
blob properties exist is backwards compatibility with existing
userspace.</p>
</dd>
</dl>
<p>In addition a property can have any combination of the below flags:</p>
<dl class="last docutils">
<dt>DRM_MODE_PROP_ATOMIC</dt>
<dd>Set for properties which encode atomic modeset state. Such
properties are not exposed to legacy userspace.</dd>
<dt>DRM_MODE_PROP_IMMUTABLE</dt>
<dd>Set for properties where userspace cannot be changed by
userspace. The kernel is allowed to update the value of these
properties. This is generally used to expose probe state to
usersapce, e.g. the EDID, or the connector path property on DP
MST sinks.</dd>
</dl>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name of the properties</dd>
<dt><code class="docutils literal"><span class="pre">num_values</span></code></dt>
<dd>size of the <strong>values</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd>Array with limits and values for the property. The
interpretation of these limits is dependent upon the type per <strong>flags</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">enum_list</span></code></dt>
<dd>List of <code class="xref c c-type docutils literal"><span class="pre">drm_prop_enum_list</span></code> structures with the symbolic names for
enum and bitmask values.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represent a modeset object property. It combines both the name
of the property with the set of permissible values. This means that when a
driver wants to use a property with the same name on different objects, but
with different value ranges, then it must create property for each one. An
example would be rotation of <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, when e.g. the primary plane cannot
be rotated. But if both the name and the value range match, then the same
property structure can be instantiated multiple times for the same object.
Userspace must be able to cope with this and cannot assume that the same
symbolic property will have the same modeset object ID on all modeset
objects.</p>
<p>Properties are created by one of the special functions, as explained in
detail in the <strong>flags</strong> structure member.</p>
<p>To actually expose a property it must be attached to each object using
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. Currently properties can only be attached to
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>.</p>
<p>Properties are also used as the generic metadatatransport for the atomic
IOCTL. Everything that was set directly in structures in the legacy modeset
IOCTLs (like the plane source or destination windows, or e.g. the links to
the CRTC) is exposed as a property with the DRM_MODE_PROP_ATOMIC flag set.</p>
<dl class="type">
<dt id="c.drm_property_blob">
struct <code class="descname">drm_property_blob</code><a class="headerlink" href="#c.drm_property_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Blob data for <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_property_blob {
  struct drm_mode_object base;
  struct drm_device * dev;
  struct list_head head_global;
  struct list_head head_file;
  size_t length;
  unsigned char data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head_global</span></code></dt>
<dd>entry on the global blob list in
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.property_blob_list</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">head_file</span></code></dt>
<dd>entry on the per-file blob list in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a> list.</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>size of the blob in bytes, invariant over the lifetime of the object</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>actual data, embedded at the end of this structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blobs are used to store bigger values than what fits directly into the 64
bits available for a <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p>Blobs are reference counted using <a class="reference internal" href="#c.drm_property_blob_get" title="drm_property_blob_get"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_get()</span></code></a> and
<a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code></a>. They are created using <a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_property_type_is">
bool <code class="descname">drm_property_type_is</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_type_is" title="Permalink to this definition">¶</a></dt>
<dd><p>check the type of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to check</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>property type to compare with</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function becauase the uapi encoding of property types is
a bit special for historical reasons.</p>
<dl class="function">
<dt id="c.drm_property_reference_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_reference_blob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_reference_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_property_blob_get" title="drm_property_blob_get"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_property_unreference_blob">
void <code class="descname">drm_property_unreference_blob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_unreference_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>release a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_property_find">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find property object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>property object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the property object specified by id and returns it.</p>
<dl class="function">
<dt id="c.drm_property_create">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_values</span></code></dt>
<dd>number of pre-defined values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_enum">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_enum</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, const struct drm_prop_enum_list *<em>&nbsp;props</em>, int<em>&nbsp;num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new enumeration property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*</span> <span class="pre">props</span></code></dt>
<dd>enumeration lists with property values</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_values</span></code></dt>
<dd>number of pre-defined values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set one of the predefined values for enumeration
properties.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_bitmask">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_bitmask</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, const struct drm_prop_enum_list *<em>&nbsp;props</em>, int<em>&nbsp;num_props</em>, uint64_t<em>&nbsp;supported_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bitmask" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new bitmask property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*</span> <span class="pre">props</span></code></dt>
<dd>enumeration lists with property bitflags</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_props</span></code></dt>
<dd>size of the <strong>props</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">supported_bits</span></code></dt>
<dd>bitmask of all supported enumeration values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new bitmask drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Compared to plain enumeration properties userspace is allowed to set any
or&#8217;ed together combination of the predefined property bitflag values</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_range">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_range</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, uint64_t<em>&nbsp;min</em>, uint64_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_range" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new unsigned ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">min</span></code></dt>
<dd>minimum value of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">max</span></code></dt>
<dd>maximum value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any unsigned integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_signed_range">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_signed_range</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, int64_t<em>&nbsp;min</em>, int64_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_signed_range" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new signed ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">int64_t</span> <span class="pre">min</span></code></dt>
<dd>minimum value of the property</dd>
<dt><code class="docutils literal"><span class="pre">int64_t</span> <span class="pre">max</span></code></dt>
<dd>maximum value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any signed integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_object">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_object</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_object" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new object property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>object type from DRM_MODE_OBJECT_* defines</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set this to any property value of the given
<strong>type</strong>. Only useful for atomic properties, which is enforced.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_bool">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_bool</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new boolean property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>This is implemented as a ranged property with only {0, 1} as valid values.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_add_enum">
int <code class="descname">drm_property_add_enum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, int<em>&nbsp;index</em>, uint64_t<em>&nbsp;value</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_add_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>add a possible value to an enumeration property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>enumeration property to change</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the new enumeration</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt>
<dd>value of the new enumeration</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>symbolic name of the new enumeration</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions adds enumerations to a property.</p>
<p>It&#8217;s use is deprecated, drivers should use one of the more specific helpers
to directly create the property with all enumerations already attached.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_property_destroy">
void <code class="descname">drm_property_destroy</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a drm property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to destry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees a property including any attached resources like
enumeration values.</p>
<dl class="function">
<dt id="c.drm_property_create_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_create_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, size_t<em>&nbsp;length</em>, const void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device to create property for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>Length to allocate for blob data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>If specified, copies data into blob</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new blob property for a specified DRM device, optionally
copying data. Note that blob properties are meant to be invariant, hence the
data must be filled out before the blob is used as the value of any property.</p>
<p><strong>Return</strong></p>
<p>New blob property with a single reference on success, or an ERR_PTR
value on failure.</p>
<dl class="function">
<dt id="c.drm_property_blob_put">
void <code class="descname">drm_property_blob_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference to a blob property. May free the object.</p>
<dl class="function">
<dt id="c.drm_property_blob_get">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_blob_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a reference to an existing blob property. Returns <strong>blob</strong>, which
allows this to be used as a shorthand in assignments.</p>
<dl class="function">
<dt id="c.drm_property_lookup_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_lookup_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_lookup_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a blob property and take a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this takes an additional reference to the blob property.
callers need to make sure to eventually unreference the returned property
again, using <a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>NULL on failure, pointer to the blob on success.</p>
<dl class="function">
<dt id="c.drm_property_replace_global_blob">
int <code class="descname">drm_property_replace_global_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>&nbsp;replace</em>, size_t<em>&nbsp;length</em>, const void *<em>&nbsp;data</em>, struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj_holds_id</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;prop_holds_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_replace_global_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>replace existing blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**</span> <span class="pre">replace</span></code></dt>
<dd>location of blob property pointer to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>length of data for new blob, or 0 for no data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>content for new blob, or NULL for no data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj_holds_id</span></code></dt>
<dd>optional object for property holding blob ID</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">prop_holds_id</span></code></dt>
<dd>optional property holding blob ID
<strong>return</strong> 0 on success or error on failure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will replace a global property in the blob list, optionally
updating a property which holds the ID of that property.</p>
<p>If length is 0 or data is NULL, no new blob will be created, and the holding
property, if specified, will be set to 0.</p>
<p>Access to the replace pointer is assumed to be protected by the caller, e.g.
by holding the relevant modesetting object lock for its parent.</p>
<p>For example, a drm_connector has a &#8216;PATH&#8217; property, which contains the ID
of a blob property with the value of the MST path information. Calling this
function with replace pointing to the connector&#8217;s path_blob_ptr, length and
data set for the new path information, obj_holds_id set to the connector&#8217;s
base object, and prop_holds_id set to the path property name, will perform
a completely atomic update. The access to path_blob_ptr is protected by the
caller holding a lock on the connector.</p>
</div>
<div class="section" id="standard-connector-properties">
<h3>Standard Connector Properties<a class="headerlink" href="#standard-connector-properties" title="Permalink to this headline">¶</a></h3>
<p>DRM connectors have a few standardized properties:</p>
<dl class="docutils">
<dt>EDID:</dt>
<dd>Blob property which contains the current EDID read from the sink. This
is useful to parse sink identification information like vendor, model
and serial. Drivers should update this property by calling
<a class="reference internal" href="#c.drm_mode_connector_update_edid_property" title="drm_mode_connector_update_edid_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_update_edid_property()</span></code></a>, usually after having parsed
the EDID using <a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code></a>. Userspace cannot change this
property.</dd>
<dt>DPMS:</dt>
<dd>Legacy property for setting the power state of the connector. For atomic
drivers this is only provided for backwards compatibility with existing
drivers, it remaps to controlling the &#8220;ACTIVE&#8221; property on the CRTC the
connector is linked to. Drivers should never set this property directly,
it is handled by the DRM core by calling the <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.dpms</span></code></a>
callback. Atomic drivers should implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_dpms" title="drm_atomic_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_dpms()</span></code></a>. This is the only property standard
connector property that userspace can change.</dd>
<dt>PATH:</dt>
<dd>Connector path property to identify how this sink is physically
connected. Used by DP MST. This should be set by calling
<a class="reference internal" href="#c.drm_mode_connector_set_path_property" title="drm_mode_connector_set_path_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_set_path_property()</span></code></a>, in the case of DP MST with the
path property the MST manager created. Userspace cannot change this
property.</dd>
<dt>TILE:</dt>
<dd>Connector tile group property to indicate how a set of DRM connector
compose together into one logical screen. This is used by both high-res
external screens (often only using a single cable, but exposing multiple
DP MST sinks), or high-res integrated panels (like dual-link DSI) which
are not gen-locked. Note that for tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose the
tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> if needed. Drivers
should update this value using <a class="reference internal" href="#c.drm_mode_connector_set_tile_property" title="drm_mode_connector_set_tile_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_set_tile_property()</span></code></a>.
Userspace cannot change this property.</dd>
<dt>link-status:</dt>
<dd>Connector link-status property to indicate the status of link. The default
value of link-status is &#8220;GOOD&#8221;. If something fails during or after modeset,
the kernel driver may set this to &#8220;BAD&#8221; and issue a hotplug uevent. Drivers
should update this value using <a class="reference internal" href="#c.drm_mode_connector_set_link_status_property" title="drm_mode_connector_set_link_status_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_set_link_status_property()</span></code></a>.</dd>
</dl>
<p>Connectors also have one standardized atomic property:</p>
<dl class="docutils">
<dt>CRTC_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this connector should be connected to.</dd>
</dl>
</div>
<div class="section" id="plane-composition-properties">
<h3>Plane Composition Properties<a class="headerlink" href="#plane-composition-properties" title="Permalink to this headline">¶</a></h3>
<p>The basic plane composition model supported by standard plane properties only
has a source rectangle (in logical pixels within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>), with
sub-pixel accuracy, which is scaled up to a pixel-aligned destination
rectangle in the visible area of a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. The visible area of a CRTC is
defined by the horizontal and vertical visible pixels (stored in <strong>hdisplay</strong>
and <strong>vdisplay</strong>) of the requested mode (stored in <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.mode</span></code></a>). These
two rectangles are both stored in the <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>For the atomic ioctl the following standard (atomic) properties on the plane object
encode the basic plane composition model:</p>
<dl class="docutils">
<dt>SRC_X:</dt>
<dd>X coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</dd>
<dt>SRC_Y:</dt>
<dd>Y coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</dd>
<dt>SRC_W:</dt>
<dd>Width for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_X plus SRC_W must be within the width of the source
framebuffer. Must be positive.</dd>
<dt>SRC_H:</dt>
<dd>Height for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_Y plus SRC_H must be within the height of the source
framebuffer. Must be positive.</dd>
<dt>CRTC_X:</dt>
<dd>X coordinate offset for the destination rectangle. Can be negative.</dd>
<dt>CRTC_Y:</dt>
<dd>Y coordinate offset for the destination rectangle. Can be negative.</dd>
<dt>CRTC_W:</dt>
<dd>Width for the destination rectangle. CRTC_X plus CRTC_W can extend past
the currently visible horizontal area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt>CRTC_H:</dt>
<dd>Height for the destination rectangle. CRTC_Y plus CRTC_H can extend past
the currently visible vertical area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt>FB_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> this plane should scan out.</dd>
<dt>CRTC_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this plane should be connected to.</dd>
</dl>
<p>Note that the source rectangle must fully lie within the bounds of the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>. The destination rectangle can lie outside of the visible
area of the current mode of the CRTC. It must be apprpriately clipped by the
driver, which can be done by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_check_update" title="drm_plane_helper_check_update"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_helper_check_update()</span></code></a>. Drivers
are also allowed to round the subpixel sampling positions appropriately, but
only to the next full pixel. No pixel outside of the source rectangle may
ever be sampled, which is important when applying more sophisticated
filtering than just a bilinear one when scaling. The filtering mode when
scaling is unspecified.</p>
<p>On top of this basic transformation additional properties can be exposed by
the driver:</p>
<ul class="simple">
<li>Rotation is set up with <a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_rotation_property()</span></code></a>. It adds a
rotation and reflection step between the source and destination rectangles.
Without this property the rectangle is only scaled, but not rotated or
reflected.</li>
<li>Z position is set up with <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> and
<a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a>. It controls the visibility of overlapping
planes. Without this property the primary plane is always below the cursor
plane, and ordering between all other planes is undefined.</li>
</ul>
<p>Note that all the property extensions described here apply either to the
plane or the CRTC (e.g. for the background color, which currently is not
exposed and assumed to be black).</p>
<dl class="function">
<dt id="c.drm_plane_create_rotation_property">
int <code class="descname">drm_plane_create_rotation_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;rotation</em>, unsigned int<em>&nbsp;supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_rotation_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new rotation property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>initial value of the rotation property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt>
<dd>bitmask of supported rotations and reflections</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new property with the selected support for transformations.</p>
<p>Since a rotation by 180° degress is the same as reflecting both along the x
and the y axis the rotation property is somewhat redundant. Drivers can use
<a class="reference internal" href="#c.drm_rotation_simplify" title="drm_rotation_simplify"><code class="xref c c-func docutils literal"><span class="pre">drm_rotation_simplify()</span></code></a> to normalize values of this property.</p>
<p>The property exposed to userspace is a bitmask property (see
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_bitmask()</span></code></a>) called &#8220;rotation&#8221; and has the following
bitmask enumaration values:</p>
<dl class="docutils">
<dt>DRM_MODE_ROTATE_0:</dt>
<dd>&#8220;rotate-0&#8221;</dd>
<dt>DRM_MODE_ROTATE_90:</dt>
<dd>&#8220;rotate-90&#8221;</dd>
<dt>DRM_MODE_ROTATE_180:</dt>
<dd>&#8220;rotate-180&#8221;</dd>
<dt>DRM_MODE_ROTATE_270:</dt>
<dd>&#8220;rotate-270&#8221;</dd>
<dt>DRM_MODE_REFLECT_X:</dt>
<dd>&#8220;reflect-x&#8221;</dd>
<dt>DRM_MODE_REFLECT_Y:</dt>
<dd>&#8220;reflect-y&#8221;</dd>
</dl>
<p>Rotation is the specified amount in degrees in counter clockwise direction,
the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
rotation. After reflection, the rotation is applied to the image sampled from
the source rectangle, before scaling it to fit the destination rectangle.</p>
<dl class="function">
<dt id="c.drm_rotation_simplify">
unsigned int <code class="descname">drm_rotation_simplify</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rotation</em>, unsigned int<em>&nbsp;supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rotation_simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to simplify the rotation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>Rotation to be simplified</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt>
<dd>Supported rotations</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to simplify the rotation to a form that is supported.
Eg. if the hardware supports everything except DRM_MODE_REFLECT_X
one could call this function like this:</p>
<dl class="docutils">
<dt>drm_rotation_simplify(rotation, DRM_MODE_ROTATE_0 |</dt>
<dd>DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |
DRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_Y);</dd>
</dl>
<p>to eliminate the DRM_MODE_ROTATE_X flag. Depending on what kind of
transforms the hardware supports, this function may not
be able to produce a supported transform, so the caller should
check the result afterwards.</p>
<dl class="function">
<dt id="c.drm_plane_create_zpos_property">
int <code class="descname">drm_plane_create_zpos_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;zpos</em>, unsigned int<em>&nbsp;min</em>, unsigned int<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create mutable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt>
<dd>initial value of zpos property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>minimal possible value of zpos property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>maximal possible value of zpos property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic mutable zpos property and enables support
for it in drm core. Drivers can then attach this property to planes to enable
support for configurable planes arrangement during blending operation.
Once mutable zpos property has been enabled, the DRM core will automatically
calculate <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.normalized_zpos</span></code></a> values. Usually min should be set
to 0 and max to maximal number of planes for given crtc - 1.</p>
<p>If zpos of some planes cannot be changed (like fixed background or
cursor/topmost planes), driver should adjust min/max values and assign those
planes immutable zpos property with lower or higher values (for more
information, see <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> function). In such
case driver should also assign proper initial zpos values for all planes in
its <code class="xref c c-func docutils literal"><span class="pre">plane_reset()</span></code> callback, so the planes will be always sorted properly.</p>
<p>See also <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a>.</p>
<p>The property exposed to userspace is called &#8220;zpos&#8221;.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_plane_create_zpos_immutable_property">
int <code class="descname">drm_plane_create_zpos_immutable_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;zpos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_immutable_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create immuttable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt>
<dd>value of zpos property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic immutable zpos property and enables
support for it in drm core. Using this property driver lets userspace
to get the arrangement of the planes for blending operation and notifies
it that the hardware (or driver) doesn&#8217;t support changing of the planes&#8217;
order. For mutable zpos see <a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a>.</p>
<p>The property exposed to userspace is called &#8220;zpos&#8221;.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_normalize_zpos">
int <code class="descname">drm_atomic_normalize_zpos</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_normalize_zpos" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate normalized zpos values for all crtcs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state of DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calculates normalized zpos value for all modified planes in
the provided atomic state of DRM device.</p>
<p>For every CRTC this function checks new states of all planes assigned to
it and calculates normalized zpos value for these planes. Planes are compared
first by their zpos values, then by plane id (if zpos is equal). The plane
with lowest zpos value is at the bottom. The <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.normalized_zpos</span></code></a>
is then filled with unique values from 0 to number of active planes in crtc
minus one.</p>
<p>RETURNS
Zero for success or -errno</p>
</div>
<div class="section" id="color-management-properties">
<h3>Color Management Properties<a class="headerlink" href="#color-management-properties" title="Permalink to this headline">¶</a></h3>
<p>Color management or color space adjustments is supported through a set of 5
properties on the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> object. They are set up by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>.</p>
<dl class="docutils">
<dt>&#8220;DEGAMMA_LUT”:</dt>
<dd><p class="first">Blob property to set the degamma lookup table (LUT) mapping pixel data
from the framebuffer before it is given to the transformation matrix.
The data is interpreted as an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.degamma_lut</span></code></a>.</p>
</dd>
<dt>“DEGAMMA_LUT_SIZE”:</dt>
<dd>Unsinged range property to give the size of the lookup table to be set
on the DEGAMMA_LUT property (the size depends on the underlying
hardware). If drivers support multiple LUT sizes then they should
publish the largest size, and sub-sample smaller sized LUTs (e.g. for
split-gamma modes) appropriately.</dd>
<dt>“CTM”:</dt>
<dd><p class="first">Blob property to set the current transformation matrix (CTM) apply to
pixel data after the lookup through the degamma LUT and before the
lookup through the gamma LUT. The data is interpreted as a struct
<code class="xref c c-type docutils literal"><span class="pre">drm_color_ctm</span></code>.</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
unit/pass-thru matrix should be used. This is generally the driver
boot-up state too. Drivers can access the blob for the color conversion
matrix through <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.ctm</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT”:</dt>
<dd><p class="first">Blob property to set the gamma lookup table (LUT) mapping pixel data
after the transformation matrix to data sent to the connector. The
data is interpreted as an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.gamma_lut</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT_SIZE”:</dt>
<dd>Unsigned range property to give the size of the lookup table to be set
on the GAMMA_LUT property (the size depends on the underlying hardware).
If drivers support multiple LUT sizes then they should publish the
largest size, and sub-sample smaller sized LUTs (e.g. for split-gamma
modes) appropriately.</dd>
</dl>
<p>There is also support for a legacy gamma table, which is set up by calling
<a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>. Drivers which support both should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a> to alias the legacy gamma ramp with the
&#8220;GAMMA_LUT&#8221; property above.</p>
<dl class="function">
<dt id="c.drm_color_lut_extract">
uint32_t <code class="descname">drm_color_lut_extract</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;user_input</em>, uint32_t<em>&nbsp;bit_precision</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_lut_extract" title="Permalink to this definition">¶</a></dt>
<dd><p>clamp and round LUT entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">user_input</span></code></dt>
<dd>input value</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">bit_precision</span></code></dt>
<dd>number of bits the hw LUT supports</dd>
</dl>
<p><strong>Description</strong></p>
<p>Extract a degamma/gamma LUT value provided by user (in the form of
<code class="xref c c-type docutils literal"><span class="pre">drm_color_lut</span></code> entries) and round it to the precision supported by the
hardware.</p>
<dl class="function">
<dt id="c.drm_crtc_enable_color_mgmt">
void <code class="descname">drm_crtc_enable_color_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, uint<em>&nbsp;degamma_lut_size</em>, bool<em>&nbsp;has_ctm</em>, uint<em>&nbsp;gamma_lut_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_enable_color_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>enable color management properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">uint</span> <span class="pre">degamma_lut_size</span></code></dt>
<dd>the size of the degamma lut (before CSC)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">has_ctm</span></code></dt>
<dd>whether to attach ctm_property for CSC matrix</dd>
<dt><code class="docutils literal"><span class="pre">uint</span> <span class="pre">gamma_lut_size</span></code></dt>
<dd>the size of the gamma lut (after CSC)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function lets the driver enable the color correction
properties on a CRTC. This includes 3 degamma, csc and gamma
properties that userspace can set and 2 size properties to inform
the userspace of the lut sizes. Each of the properties are
optional. The gamma and degamma properties are only attached if
their size is not 0 and ctm_property is only attached if has_ctm is
true.</p>
<dl class="function">
<dt id="c.drm_mode_crtc_set_gamma_size">
int <code class="descname">drm_mode_crtc_set_gamma_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, int<em>&nbsp;gamma_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_crtc_set_gamma_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set the gamma table size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to set the gamma table size for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">gamma_size</span></code></dt>
<dd>size of the gamma table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which support gamma tables should set this to the supported gamma
table size when initializing the CRTC. Currently the drm core only supports a
fixed gamma table size.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
</div>
<div class="section" id="tile-group-property">
<h3>Tile Group Property<a class="headerlink" href="#tile-group-property" title="Permalink to this headline">¶</a></h3>
<p>Tile groups are used to represent tiled monitors with a unique integer
identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle,
we store this in a tile group, so we have a common identifier for all tiles
in a monitor group. The property is called &#8220;TILE&#8221;. Drivers can manage tile
groups using <a class="reference internal" href="#c.drm_mode_create_tile_group" title="drm_mode_create_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create_tile_group()</span></code></a>, <a class="reference internal" href="#c.drm_mode_put_tile_group" title="drm_mode_put_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_put_tile_group()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_get_tile_group" title="drm_mode_get_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_get_tile_group()</span></code></a>. But this is only needed for internal panels where
the tile group information is exposed through a non-standard way.</p>
</div>
<div class="section" id="explicit-fencing-properties">
<h3>Explicit Fencing Properties<a class="headerlink" href="#explicit-fencing-properties" title="Permalink to this headline">¶</a></h3>
<p>Explicit fencing allows userspace to control the buffer synchronization
between devices. A Fence or a group of fences are transfered to/from
userspace using Sync File fds and there are two DRM properties for that.
IN_FENCE_FD on each DRM Plane to send fences to the kernel and
OUT_FENCE_PTR on each DRM CRTC to receive fences from the kernel.</p>
<p>As a contrast, with implicit fencing the kernel keeps track of any
ongoing rendering, and automatically ensures that the atomic update waits
for any pending rendering to complete. For shared buffers represented with
a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> this is tracked in <a class="reference internal" href="../driver-api/dma-buf.html#c.reservation_object" title="reservation_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span></code></a>.
Implicit syncing is how Linux traditionally worked (e.g. DRI2/3 on X.org),
whereas explicit fencing is what Android wants.</p>
<dl class="docutils">
<dt>&#8220;IN_FENCE_FD”:</dt>
<dd><p class="first">Use this property to pass a fence that DRM should wait on before
proceeding with the Atomic Commit request and show the framebuffer for
the plane on the screen. The fence can be either a normal fence or a
merged one, the sync_file framework will handle both cases and use a
fence_array if a merged fence is received. Passing -1 here means no
fences to wait on.</p>
<p>If the Atomic Commit request has the DRM_MODE_ATOMIC_TEST_ONLY flag
it will only check if the Sync File is a valid one.</p>
<p class="last">On the driver side the fence is stored on the <strong>fence</strong> parameter of
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>. Drivers which also support implicit fencing
should set the implicit fence using <a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a>,
to make sure there&#8217;s consistent behaviour between drivers in precedence
of implicit vs. explicit fencing.</p>
</dd>
<dt>&#8220;OUT_FENCE_PTR”:</dt>
<dd><p class="first">Use this property to pass a file descriptor pointer to DRM. Once the
Atomic Commit request call returns OUT_FENCE_PTR will be filled with
the file descriptor number of a Sync File. This Sync File contains the
CRTC fence that will be signaled when all framebuffers present on the
Atomic Commit * request for that given CRTC are scanned out on the
screen.</p>
<p>The Atomic Commit request fails if a invalid pointer is passed. If the
Atomic Commit request fails for any other reason the out fence fd
returned will be -1. On a Atomic Commit with the
DRM_MODE_ATOMIC_TEST_ONLY flag the out fence will also be set to -1.</p>
<p class="last">Note that out-fences don&#8217;t have a special interface to drivers and are
internally represented by a <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span></code></a> in struct
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a>, which is also used by the nonblocking atomic commit
helpers and for the DRM event handling for existing userspace.</p>
</dd>
</dl>
</div>
<div class="section" id="existing-kms-properties">
<h3>Existing KMS Properties<a class="headerlink" href="#existing-kms-properties" title="Permalink to this headline">¶</a></h3>
<p>The following table gives description of drm properties exposed by
various modules/drivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Owner Module/Drivers</th>
<th class="head">Group</th>
<th class="head">Property Name</th>
<th class="head">Type</th>
<th class="head">Property Values</th>
<th class="head">Object attached</th>
<th class="head">Description/Restrictions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“scaling mode”</td>
<td>ENUM</td>
<td>{ &#8220;None&#8221;, &#8220;Full&#8221;, &#8220;Center&#8221;, &#8220;Full aspect&#8221; }</td>
<td>Connector</td>
<td>Supported by: amdgpu, gma500, i915, nouveau and radeon.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>DVI-I</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ “Unknown”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ “Automatic”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>TV</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Unknown&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“left margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“right margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“top margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“bottom margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker reduction”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“overscan”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Virtual GPU</td>
<td>“suggested X”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an X offset for a connector</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“suggested Y”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an Y offset for a connector</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Optional</td>
<td>&#8220;aspect ratio&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;None&#8221;, &#8220;4:3&#8221;, &#8220;16:9&#8221; }</td>
<td>Connector</td>
<td>TDB</td>
</tr>
<tr class="row-odd"><td>i915</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Full&#8221;, &#8220;Limited 16:235&#8221; }</td>
<td>Connector</td>
<td>When this property is set to Limited 16:235 and CTM is set, the hardware will be programmed with the result of the multiplication of CTM by the limited range matrix to ensure the pixels normaly in the range 0..1.0 are remapped to the range 16/255..235/255.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;force-dvi&#8221;, &#8220;off&#8221;, &#8220;auto&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>CDV gma-500</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “Full”, “Limited 16:235” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “off”, “auto”, “on” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Poulsbo</td>
<td>Generic</td>
<td>“backlight”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>armada</td>
<td>CRTC</td>
<td>&#8220;CSC_YUV&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221; , &#8220;CCIR601&#8221;, &#8220;CCIR709&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;CSC_RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221;, &#8220;Computer system&#8221;, &#8220;Studio&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey_min&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey_max&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey_val&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey_alpha&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey_mode&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;disabled&#8221;, &#8220;Y component&#8221;, &#8220;U component&#8221; , &#8220;V component&#8221;, &#8220;RGB&#8221;, “R component&#8221;, &#8220;G component&#8221;, &#8220;B component&#8221; }</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;brightness&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=256 + 255</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;contrast&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;saturation&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>exynos</td>
<td>CRTC</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;normal&#8221;, &#8220;blank&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>i2c/ch7006_drv</td>
<td>Generic</td>
<td>“scale”</td>
<td>RANGE</td>
<td>Min=0, Max=2</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;PAL&#8221;, &#8220;PAL-M&#8221;,&#8221;PAL-N&#8221;}, ”PAL-Nc&#8221; , &#8220;PAL-60&#8221;, &#8220;NTSC-M&#8221;, &#8220;NTSC-J&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>nouveau</td>
<td>NV10 Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=359</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“iturbt_709”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Nv04 Overlay</td>
<td>“colorkey”</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Display</td>
<td>“dithering mode”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“dithering depth”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221;, &#8220;static 2x2&#8221;, &#8220;dynamic 2x2&#8221;, &#8220;temporal&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“underscan”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;6 bpc&#8221;, &#8220;8 bpc&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“underscan hborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“underscan vborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>“vibrant hue”</td>
<td>RANGE</td>
<td>Min=0, Max=180</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>“color vibrance”</td>
<td>RANGE</td>
<td>Min=0, Max=200</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>omap</td>
<td>Generic</td>
<td>“zorder”</td>
<td>RANGE</td>
<td>Min=0, Max=3</td>
<td>CRTC, Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>qxl</td>
<td>Generic</td>
<td>“hotplug_mode_update&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>radeon</td>
<td>DVI-I</td>
<td>“coherent”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>DAC enable load detect</td>
<td>“load detection”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>TV Standard</td>
<td>&#8220;tv standard&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;ntsc&#8221;, &#8220;pal&#8221;, &#8220;pal-m&#8221;, &#8220;pal-60&#8221;, &#8220;ntsc-j&#8221; , &#8220;scart-pal&#8221;, &#8220;pal-cn&#8221;, &#8220;secam&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>legacy TMDS PLL detect</td>
<td>&#8220;tmds_pll&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;driver&#8221;, &#8220;bios&#8221; }</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>Underscan</td>
<td>&#8220;underscan&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;underscan hborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;underscan vborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>Audio</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>FMT Dithering</td>
<td>“dither”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>rcar-du</td>
<td>Generic</td>
<td>&#8220;alpha&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=255</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="vertical-blanking">
<h2>Vertical Blanking<a class="headerlink" href="#vertical-blanking" title="Permalink to this headline">¶</a></h2>
<p>Vertical blanking plays a major role in graphics rendering. To achieve
tear-free display, users must synchronize page flips and/or rendering to
vertical blanking. The DRM API offers ioctls to perform page flips
synchronized to vertical blanking and wait for vertical blanking.</p>
<p>The DRM core handles most of the vertical blanking management logic,
which involves filtering out spurious interrupts, keeping race-free
blanking counters, coping with counter wrap-around and resets and
keeping use counts. It relies on the driver to generate vertical
blanking interrupts and optionally provide a hardware vertical blanking
counter. Drivers must implement the following operations.</p>
<ul class="simple">
<li>int (*enable_vblank) (struct drm_device *dev, int crtc); void
(*disable_vblank) (struct drm_device *dev, int crtc);
Enable or disable vertical blanking interrupts for the given CRTC.</li>
<li>u32 (*get_vblank_counter) (struct drm_device *dev, int crtc);
Retrieve the value of the vertical blanking counter for the given
CRTC. If the hardware maintains a vertical blanking counter its value
should be returned. Otherwise drivers can use the
<code class="xref c c-func docutils literal"><span class="pre">drm_vblank_count()</span></code> helper function to handle this
operation.</li>
</ul>
<p>Drivers must initialize the vertical blanking handling core with a call
to <a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal"><span class="pre">drm_vblank_init()</span></code></a> in their load operation.</p>
<p>Vertical blanking interrupts can be enabled by the DRM core or by
drivers themselves (for instance to handle page flipping operations).
The DRM core maintains a vertical blanking use count to ensure that the
interrupts are not disabled while a user still needs them. To increment
the use count, drivers call <code class="xref c c-func docutils literal"><span class="pre">drm_vblank_get()</span></code>. Upon
return vertical blanking interrupts are guaranteed to be enabled.</p>
<p>To decrement the use count drivers call
<code class="xref c c-func docutils literal"><span class="pre">drm_vblank_put()</span></code>. Only when the use count drops to zero
will the DRM core disable the vertical blanking interrupts after a delay
by scheduling a timer. The delay is accessible through the
vblankoffdelay module parameter or the <code class="docutils literal"><span class="pre">drm_vblank_offdelay</span></code> global
variable and expressed in milliseconds. Its default value is 5000 ms.
Zero means never disable, and a negative value means disable
immediately. Drivers may override the behaviour by setting the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>
vblank_disable_immediate flag, which when set causes vblank interrupts
to be disabled immediately regardless of the drm_vblank_offdelay
value. The flag should only be set if there&#8217;s a properly working
hardware vblank counter present.</p>
<p>When a vertical blanking interrupt occurs drivers only need to call the
<a class="reference internal" href="#c.drm_handle_vblank" title="drm_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_handle_vblank()</span></code></a> function to account for the
interrupt.</p>
<p>Resources allocated by <a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal"><span class="pre">drm_vblank_init()</span></code></a> must be freed
with a call to <a class="reference internal" href="#c.drm_vblank_cleanup" title="drm_vblank_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_vblank_cleanup()</span></code></a> in the driver unload
operation handler.</p>
<div class="section" id="vertical-blanking-and-interrupt-handling-functions-reference">
<h3>Vertical Blanking and Interrupt Handling Functions Reference<a class="headerlink" href="#vertical-blanking-and-interrupt-handling-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_pending_vblank_event">
struct <code class="descname">drm_pending_vblank_event</code><a class="headerlink" href="#c.drm_pending_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>pending vblank event tracking</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_pending_vblank_event {
  struct drm_pending_event base;
  unsigned int pipe;
  struct drm_event_vblank event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>Base structure for tracking pending DRM events.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this event is for.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>Actual event which will be sent to userspace.</dd>
</dl>
<dl class="type">
<dt id="c.drm_vblank_crtc">
struct <code class="descname">drm_vblank_crtc</code><a class="headerlink" href="#c.drm_vblank_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>vblank tracking for a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_vblank_crtc {
  struct drm_device * dev;
  wait_queue_head_t queue;
  struct timer_list disable_timer;
  seqlock_t seqlock;
  u32 count;
  struct timeval time;
  atomic_t refcount;
  u32 last;
  unsigned int inmodeset;
  unsigned int pipe;
  int framedur_ns;
  int linedur_ns;
  struct drm_display_mode hwmode;
  bool enabled;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Pointer to the <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>Wait queue for vblank waiters.</dd>
<dt><code class="docutils literal"><span class="pre">disable_timer</span></code></dt>
<dd>Disable timer for the delayed vblank disabling
hysteresis logic. Vblank disabling is controlled through the
drm_vblank_offdelay module option and the setting of the
<code class="xref c c-type docutils literal"><span class="pre">drm_device.max_vblank_count</span></code> value.</dd>
<dt><code class="docutils literal"><span class="pre">seqlock</span></code></dt>
<dd>Protect vblank count and time.</dd>
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>Current software vblank counter.</dd>
<dt><code class="docutils literal"><span class="pre">time</span></code></dt>
<dd>Vblank timestamp corresponding to <strong>count</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Number of users/waiters of the vblank interrupt. Only when
this refcount reaches 0 can the hardware interrupt be disabled using
<strong>disable_timer</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">last</span></code></dt>
<dd>Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.vbl_lock</span></code>, used for wraparound handling.</dd>
<dt><code class="docutils literal"><span class="pre">inmodeset</span></code></dt>
<dd>Tracks whether the vblank is disabled due to a modeset.
For legacy driver bit 2 additionally tracks whether an additional
temporary vblank reference has been acquired to paper over the
hardware counter resetting/jumping. KMS drivers should instead just
call <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a>, which explicitly
save and restore the vblank count.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> corresponding to this
structure.</dd>
<dt><code class="docutils literal"><span class="pre">framedur_ns</span></code></dt>
<dd>Frame/Field duration in ns, used by
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">linedur_ns</span></code></dt>
<dd>Line duration in ns, used by
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd>Cache of the current hardware display mode. Only valid when <strong>enabled</strong>
is set. This is used by helpers like
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a>. We can&#8217;t just access the
hardware mode by e.g. looking at <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>,
because that one is really hard to get from interrupt context.</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>Tracks the enabling state of the corresponding <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> to
avoid double-disabling and hence corrupting saved state. Needed by
drivers not using atomic KMS, since those might go through their CRTC
disabling functions multiple times.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure tracks the vblank state for one CRTC.</p>
<p>Note that for historical reasons - the vblank handling code is still shared
with legacy/non-kms drivers - this is a free-standing structure not directly
connected to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. But all public interface functions are taking
a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> to hide this implementation detail.</p>
<dl class="function">
<dt id="c.drm_accurate_vblank_count">
u32 <code class="descname">drm_accurate_vblank_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_accurate_vblank_count" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the master vblank counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <strong>drm_crtc_vblank_count</strong> but this
function interpolates to handle a race with vblank irq&#8217;s.</p>
<p>This is mostly useful for hardware that can obtain the scanout
position, but doesn&#8217;t have a frame counter.</p>
<dl class="function">
<dt id="c.drm_vblank_cleanup">
void <code class="descname">drm_vblank_cleanup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup vblank support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up any resources allocated in drm_vblank_init.</p>
<p>Drivers which don&#8217;t use <a class="reference internal" href="drm-internals.html#c.drm_irq_install" title="drm_irq_install"><code class="xref c c-func docutils literal"><span class="pre">drm_irq_install()</span></code></a> need to set <code class="xref c c-type docutils literal"><span class="pre">drm_device.irq_enabled</span></code>
themselves, to signal to the DRM core that vblank interrupts are enabled.</p>
<dl class="function">
<dt id="c.drm_vblank_init">
int <code class="descname">drm_vblank_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num_crtcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize vblank support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_crtcs</span></code></dt>
<dd>number of CRTCs supported by <strong>dev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes vblank support for <strong>num_crtcs</strong> display pipelines.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_waitqueue">
wait_queue_head_t * <code class="descname">drm_crtc_vblank_waitqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_waitqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>get vblank waitqueue for the CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which CRTC&#8217;s vblank waitqueue to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a pointer to the vblank waitqueue for the CRTC.
Drivers can use this to implement vblank waits using <a class="reference internal" href="../driver-api/basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal"><span class="pre">wait_event()</span></code></a> and related
functions.</p>
<dl class="function">
<dt id="c.drm_calc_timestamping_constants">
void <code class="descname">drm_calc_timestamping_constants</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_calc_timestamping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate vblank timestamp constants</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>drm_crtc whose timestamp constants should be updated.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>display mode containing the scanout timings</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate and store various constants which are later
needed by vblank and swap-completion timestamping, e.g,
by <a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a>. They are
derived from CRTC&#8217;s true scanout timing, so they take
things like panel scaling or other adjustments into account.</p>
<dl class="function">
<dt id="c.drm_calc_vbltimestamp_from_scanoutpos">
bool <code class="descname">drm_calc_vbltimestamp_from_scanoutpos</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em>, int *<em>&nbsp;max_error</em>, struct timeval *<em>&nbsp;vblank_time</em>, bool<em>&nbsp;in_vblank_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="Permalink to this definition">¶</a></dt>
<dd><p>precise vblank timestamp helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>index of CRTC whose vblank timestamp to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">max_error</span></code></dt>
<dd>Desired maximum allowable error in timestamps (nanosecs)
On return contains true maximum error of timestamp</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timeval</span> <span class="pre">*</span> <span class="pre">vblank_time</span></code></dt>
<dd>Pointer to struct timeval which should receive the timestamp</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">in_vblank_irq</span></code></dt>
<dd>True when called from <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements calculation of exact vblank timestamps from given drm_display_mode
timings and current video scanout position of a CRTC. This can be called from
within <code class="xref c c-func docutils literal"><span class="pre">get_vblank_timestamp()</span></code> implementation of a kms driver to implement the
actual timestamping.</p>
<p>Should return timestamps conforming to the OML_sync_control OpenML
extension specification. The timestamp corresponds to the end of
the vblank interval, aka start of scanout of topmost-leftmost display
pixel in the following video frame.</p>
<p>Requires support for optional dev-&gt;driver-&gt;:c:func:<cite>get_scanout_position()</cite>
in kms driver, plus a bit of setup code to provide a drm_display_mode
that corresponds to the true scanout timing.</p>
<p>The current implementation only handles standard video modes. It
returns as no operation if a doublescan or interlaced video mode is
active. Higher level code is expected to handle this.</p>
<p>This function can be used to implement the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_vblank_timestamp</span></code></a>
directly, if the driver implements the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_scanout_position</span></code></a> hook.</p>
<p>Note that atomic drivers must call <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a> before
enabling a CRTC. The atomic helpers already take care of that in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns true on success, and false on failure, i.e. when no accurate
timestamp could be acquired.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_count">
u32 <code class="descname">drm_crtc_vblank_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve &#8220;cooked&#8221; vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the &#8220;cooked&#8221; vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity.</p>
<p><strong>Return</strong></p>
<p>The software vblank counter.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_count_and_time">
u32 <code class="descname">drm_crtc_vblank_count_and_time</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct timeval *<em>&nbsp;vblanktime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count_and_time" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve &#8220;cooked&#8221; vblank counter value and the system timestamp corresponding to that vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timeval</span> <span class="pre">*</span> <span class="pre">vblanktime</span></code></dt>
<dd>Pointer to struct timeval to receive the vblank timestamp.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the &#8220;cooked&#8221; vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Returns corresponding system timestamp of the time
of the vblank interval that corresponds to the current vblank counter value.</p>
<dl class="function">
<dt id="c.drm_crtc_arm_vblank_event">
void <code class="descname">drm_crtc_arm_vblank_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_arm_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>arm vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the source CRTC of the vblank event</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">e</span></code></dt>
<dd>the event to send</dd>
</dl>
<p><strong>Description</strong></p>
<p>A lot of drivers need to generate vblank events for the very next vblank
interrupt. For example when the page flip interrupt happens when the page
flip gets armed, but not when it actually executes within the next vblank
period. This helper function implements exactly the required vblank arming
behaviour.</p>
<p><strong>NOTE</strong></p>
<p>Drivers using this to send out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> as part of an
atomic commit must ensure that the next vblank happens at exactly the same
time as the atomic commit is committed to the hardware. This function itself
does <strong>not</strong> protect again the next vblank interrupt racing with either this
function call or the atomic commit operation. A possible sequence could be:</p>
<ol class="arabic simple">
<li>Driver commits new hardware state into vblank-synchronized registers.</li>
<li>A vblank happens, committing the hardware state. Also the corresponding
vblank interrupt is fired off and fully processed by the interrupt
handler.</li>
<li>The atomic commit operation proceeds to call <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>.</li>
<li>The event is only send out for the next vblank, which is wrong.</li>
</ol>
<p>An equivalent race can happen when the driver calls
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> before writing out the new hardware state.</p>
<p>The only way to make this work safely is to prevent the vblank from firing
(and the hardware from committing anything else) until the entire atomic
commit sequence has run to completion. If the hardware does not have such a
feature (e.g. using a &#8220;go&#8221; bit), then it is unsafe to use this functions.
Instead drivers need to manually send out the event from their interrupt
handler by calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> and make sure that there&#8217;s no
possible race with the hardware committing the atomic update.</p>
<p>Caller must hold event lock. Caller must also hold a vblank reference for
the event <strong>e</strong>, which will be dropped when the next vblank arrives.</p>
<dl class="function">
<dt id="c.drm_crtc_send_vblank_event">
void <code class="descname">drm_crtc_send_vblank_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_send_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to send vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the source CRTC of the vblank event</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">e</span></code></dt>
<dd>the event to send</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates sequence # and timestamp on event for the most recently processed
vblank, and sends it to userspace.  Caller must hold event lock.</p>
<p>See <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> for a helper which can be used in certain
situation, especially to send out events for atomic commit operations.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_get">
int <code class="descname">drm_crtc_vblank_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference count on vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which CRTC to own</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquire a reference count on vblank events to avoid having them disabled
while in use.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_put">
void <code class="descname">drm_crtc_vblank_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_put" title="Permalink to this definition">¶</a></dt>
<dd><p>give up ownership of vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to give up</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release ownership of a given vblank counter, turning off interrupts
if possible. Disable interrupts after drm_vblank_offdelay milliseconds.</p>
<dl class="function">
<dt id="c.drm_wait_one_vblank">
void <code class="descname">drm_wait_one_vblank</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_wait_one_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>CRTC index</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>pipe</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>pipe</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<dl class="function">
<dt id="c.drm_crtc_wait_one_vblank">
void <code class="descname">drm_crtc_wait_one_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_wait_one_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>crtc</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>crtc</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_off">
void <code class="descname">drm_crtc_vblank_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_off" title="Permalink to this definition">¶</a></dt>
<dd><p>disable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to shut down the vblank interrupt handling when
disabling a crtc. This function ensures that the latest vblank frame count is
stored so that drm_vblank_on can restore it again.</p>
<p>Drivers must use this function when the hardware vblank counter can get
reset, e.g. when suspending.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_reset">
void <code class="descname">drm_crtc_vblank_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset vblank state to off on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to reset the vblank state to off at load time.
Drivers should use this together with the <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> functions. The difference compared to
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> is that this function doesn&#8217;t save the vblank counter
and hence doesn&#8217;t need to call any driver hooks.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_on">
void <code class="descname">drm_crtc_vblank_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_on" title="Permalink to this definition">¶</a></dt>
<dd><p>enable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions restores the vblank interrupt state captured with
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> again. Note that calls to <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> can be unbalanced and so can also be unconditionally called
in driver load code to reflect the current hardware state of the crtc.</p>
<dl class="function">
<dt id="c.drm_handle_vblank">
bool <code class="descname">drm_handle_vblank</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_handle_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>index of CRTC where this event occurred</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the legacy version of <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_handle_vblank">
bool <code class="descname">drm_crtc_handle_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_handle_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>where this event occurred</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the native KMS version of <a class="reference internal" href="#c.drm_handle_vblank" title="drm_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_handle_vblank()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if the event was successfully handled, false on failure.</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral float-right" title="Mode Setting Helper Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-mm.html" class="btn btn-neutral" title="DRM Memory Management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.13.0-rc5+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>