

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mode Setting Helper Functions &mdash; The Linux Kernel 4.13.0-rc5+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 4.13.0-rc5+ documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Userland interfaces" href="drm-uapi.html"/>
        <link rel="prev" title="Kernel Mode Setting (KMS)" href="drm-kms.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.13.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mode Setting Helper Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modeset-helper-reference-for-common-vtables">Modeset Helper Reference for Common Vtables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-modeset-helper-functions-reference">Atomic Modeset Helper Functions Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-asynchronous-atomic-commit">Implementing Asynchronous Atomic Commit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-state-reset-and-initialization">Atomic State Reset and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-functions-reference">Helper Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-crtc-modeset-helper-functions-reference">Legacy CRTC/Modeset Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-kms-helper-reference">Simple KMS Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fbdev-helper-functions-reference">fbdev Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#framebuffer-cma-helper-functions-reference">Framebuffer CMA Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bridges">Bridges</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-bridge-callback-sequence">Default bridge callback sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-helper-reference">Bridge Helper Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#panel-bridge-helper-reference">Panel-Bridge Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#panel-helper-reference">Panel Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-helper-functions-reference">Display Port Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-dual-mode-adaptor-helper-functions-reference">Display Port Dual Mode Adaptor Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-mst-helper-functions-reference">Display Port MST Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mipi-dsi-helper-functions-reference">MIPI DSI Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-probing-helper-functions-reference">Output Probing Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edid-helper-functions-reference">EDID Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scdc-helper-functions-reference">SCDC Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rectangle-utilities-reference">Rectangle Utilities Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hdmi-infoframes-helper-reference">HDMI Infoframes Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flip-work-helper-reference">Flip-work Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-helper-reference">Plane Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-modeset-helpers">Auxiliary Modeset Helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
        
      <li>Mode Setting Helper Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-kms-helpers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mode-setting-helper-functions">
<h1>Mode Setting Helper Functions<a class="headerlink" href="#mode-setting-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>The DRM subsystem aims for a strong separation between core code and helper
libraries. Core code takes care of general setup and teardown and decoding
userspace requests to kernel internal objects. Everything else is handled by a
large set of helper libraries, which can be combined freely to pick and choose
for each driver what fits, and avoid shared code where special behaviour is
needed.</p>
<p>This distinction between core code and helpers is especially strong in the
modesetting code, where there&#8217;s a shared userspace ABI for all drivers. This is
in contrast to the render side, where pretty much everything (with very few
exceptions) can be considered optional helper code.</p>
<p>There are a few areas these helpers can grouped into:</p>
<ul class="simple">
<li>Helpers to implement modesetting. The important ones here are the atomic
helpers. Old drivers still often use the legacy CRTC helpers. They both share
the same set of common helper vtables. For really simple drivers (anything
that would have been a great fit in the deprecated fbdev subsystem) there&#8217;s
also the simple display pipe helpers.</li>
<li>There&#8217;s a big pile of helpers for handling outputs. First the generic bridge
helpers for handling encoder and transcoder IP blocks. Second the panel helpers
for handling panel-related information and logic. Plus then a big set of
helpers for the various sink standards (DisplayPort, HDMI, MIPI DSI). Finally
there&#8217;s also generic helpers for handling output probing, and for dealing with
EDIDs.</li>
<li>The last group of helpers concerns itself with the frontend side of a display
pipeline: Planes, handling rectangles for visibility checking and scissoring,
flip queues and assorted bits.</li>
</ul>
<div class="section" id="modeset-helper-reference-for-common-vtables">
<h2>Modeset Helper Reference for Common Vtables<a class="headerlink" href="#modeset-helper-reference-for-common-vtables" title="Permalink to this headline">¶</a></h2>
<p>The DRM mode setting helper functions are common code for drivers to use if
they wish.  Drivers are not forced to use this code in their
implementations but it would be useful if the code they do use at least
provides a consistent interface and operation to userspace. Therefore it is
highly recommended to use the provided helpers as much as possible.</p>
<p>Because there is only one pointer per modeset object to hold a vfunc table
for helper libraries they are by necessity shared among the different
helpers.</p>
<p>To make this clear all the helper vtables are pulled together in this location here.</p>
<dl class="type">
<dt id="c.drm_crtc_helper_funcs">
struct <code class="descname">drm_crtc_helper_funcs</code><a class="headerlink" href="#c.drm_crtc_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for CRTCs</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_crtc_helper_funcs {
  void (* dpms) (struct drm_crtc *crtc, int mode);
  void (* prepare) (struct drm_crtc *crtc);
  void (* commit) (struct drm_crtc *crtc);
  enum drm_mode_status (* mode_valid) (struct drm_crtc *crtc,const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_crtc *crtc,const struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode);
  int (* mode_set) (struct drm_crtc *crtc, struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode, int x, int y,struct drm_framebuffer *old_fb);
  void (* mode_set_nofb) (struct drm_crtc *crtc);
  int (* mode_set_base) (struct drm_crtc *crtc, int x, int y,struct drm_framebuffer *old_fb);
  int (* mode_set_base_atomic) (struct drm_crtc *crtc,struct drm_framebuffer *fb, int x, int y,enum mode_set_atomic);
  void (* load_lut) (struct drm_crtc *crtc);
  void (* disable) (struct drm_crtc *crtc);
  void (* enable) (struct drm_crtc *crtc);
  int (* atomic_check) (struct drm_crtc *crtc,struct drm_crtc_state *state);
  void (* atomic_begin) (struct drm_crtc *crtc,struct drm_crtc_state *old_crtc_state);
  void (* atomic_flush) (struct drm_crtc *crtc,struct drm_crtc_state *old_crtc_state);
  void (* atomic_disable) (struct drm_crtc *crtc,struct drm_crtc_state *old_crtc_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Callback to control power levels on the CRTC.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy CRTC helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable a CRTC by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn&#8217;t used.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling a CRTC to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>enable</strong> and <strong>disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd><p class="first">This callback should prepare the CRTC for a subsequent modeset, which
in practice means the driver should disable the CRTC if it is
running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>disable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">This callback should commit the new mode on the CRTC after a modeset,
which in practice means the driver should enable the CRTC.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>enable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
crtc. This should be implemented if the crtc has some sort of
restriction in the modes it can display. For example, a given crtc
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate a mode. The parameter mode is the
display mode that userspace requested, adjusted_mode is the mode the
encoders need to be fed with. Note that this is the inverse semantics
of the meaning for the <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a>
vfunc. If the CRTC cannot support the requested conversion from mode
to adjusted_mode it should reject the modeset. See also
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
With atomic helpers it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback, but note that they&#8217;re not
perfectly equivalent: <strong>mode_valid</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>, but <strong>atomic_check</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>, because originally it was meant for
plane update checks only.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to set a new mode,
position and framebuffer. Since it ties the primary plane to every
mode change it is incompatible with universal plane support. And
since it can&#8217;t update other planes it&#8217;s incompatible with atomic
modeset support.</p>
<p>This callback is only used by CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_nofb</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of a CRTC without
changing anything of the primary plane configuration. This fits the
requirement of atomic and hence is used by the atomic helpers. It is
also used by the transitional plane helpers to implement a
<strong>mode_set</strong> hook in <a class="reference internal" href="#c.drm_helper_crtc_mode_set" title="drm_helper_crtc_mode_set"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_crtc_mode_set()</span></code></a>.</p>
<p>Note that the display pipe is completely off when this function is
called. Atomic drivers which need hardware to be running before they
program the new display mode (e.g. because they implement runtime PM)
should not use this hook. This is because the helper library calls
this hook only once per mode change and not every time the display
pipeline is suspended using either DPMS or the new &#8220;ACTIVE&#8221; property.
Which means register values set in this callback might get reset when
the CRTC is suspended, but not restored.  Such drivers should instead
move all their CRTC setup into the <strong>enable</strong> callback.</p>
<p class="last">This callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_base</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to set a new
framebuffer and scanout position. It is optional and used as an
optimized fast-path instead of a full mode set operation with all the
resulting flickering. If it is not present
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code></a> will fall back to a full modeset, using
the <strong>mode_set</strong> callback. Since it can&#8217;t update other planes it&#8217;s
incompatible with atomic modeset support.</p>
<p>This callback is only used by the CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_base_atomic</span></code></dt>
<dd><p class="first">This callback is used by the fbdev helpers to set a new framebuffer
and scanout without sleeping, i.e. from an atomic calling context. It
is only used to implement kgdb support.</p>
<p>This callback is optional and only needed for kgdb support in the fbdev
helpers.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">load_lut</span></code></dt>
<dd><p class="first">Load a LUT prepared with the <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper_funcs.gamma_set</span></code></a> vfunc.</p>
<p>This callback is optional and is only used by the fbdev emulation
helpers.</p>
<p>FIXME:</p>
<p class="last">This callback is functionally redundant with the core gamma table
support and simply exists because the fbdev hasn&#8217;t yet been
refactored to use the core gamma table interfaces.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
<code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
disable anything at the CRTC level. To ensure that runtime PM
handling (using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>disable</strong> must be the inverse of <strong>enable</strong> for atomic drivers.
Atomic drivers should consider to use <strong>atomic_disable</strong> instead of
this one.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there&#8217;s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
CRTC: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p class="last">Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd><p class="first">This callback should be used to enable the CRTC. With the atomic
drivers it is called before all encoders connected to this CRTC are
enabled through the encoder&#8217;s own <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>
hook.  If that sequence is too simple drivers can just add their own
hooks and call it from this CRTC callback here by looping over all
encoders connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p class="last">This hook is used only by atomic helpers, for symmetry with <strong>disable</strong>.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
enable anything at the CRTC level. To ensure that runtime PM handling
(using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>enable</strong> must be the inverse of <strong>disable</strong> for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">Drivers should check plane-update related CRTC constraints in this
hook. They can also check mode related limitations but need to be
aware of the calling order, since this hook is used by
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> whereas the preparations needed to
check output routing and the display mode is done in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. Therefore drivers that want to
check output routing and display mode constraints in this callback
must ensure that <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> has been called
beforehand. This is calling order used by the default helper
implementation in <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a>.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> this hook is called
after the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomc_check</span></code></a> hook for planes, which
allows drivers to assign shared resources requested by planes in this
callback here. For more complicated dependencies the driver can call
the provided check helpers multiple times until the computed state
has a final configuration and everything has been checked.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_begin</span></code></dt>
<dd><p class="first">Drivers should prepare for an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might be vblank
evasion, blocking updates by setting bits or doing preparatory work
for e.g. manual update display.</p>
<p>This hook is called before any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_flush</span></code></dt>
<dd><p class="first">Drivers should finalize an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might include
checking that vblank evasion was successful, unblocking updates by
setting bits or setting the GO bit to flush out all updates.</p>
<p>Simple hardware or hardware with special requirements can commit and
flush out all updates for all planes from this hook and forgo all the
other commit hooks for plane updates.</p>
<p>This hook is called after any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
<code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used only by atomic helpers. Atomic drivers don&#8217;t
need to implement it if there&#8217;s no need to disable anything at the
CRTC level.</p>
<p class="last">Comparing to <strong>disable</strong>, this one provides the additional input
parameter <strong>old_crtc_state</strong> which could be used to access the old
state. Atomic drivers should consider to use this one instead
of <strong>disable</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_add">
void <code class="descname">drm_crtc_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs">drm_crtc_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>crtc</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_encoder_helper_funcs">
struct <code class="descname">drm_encoder_helper_funcs</code><a class="headerlink" href="#c.drm_encoder_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for encoders</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_encoder_helper_funcs {
  void (* dpms) (struct drm_encoder *encoder, int mode);
  enum drm_mode_status (* mode_valid) (struct drm_encoder *crtc,const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_encoder *encoder,const struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode);
  void (* prepare) (struct drm_encoder *encoder);
  void (* commit) (struct drm_encoder *encoder);
  void (* mode_set) (struct drm_encoder *encoder,struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode);
  void (* atomic_mode_set) (struct drm_encoder *encoder,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state);
  struct drm_crtc *(* get_crtc) (struct drm_encoder *encoder);
  enum drm_connector_status (* detect) (struct drm_encoder *encoder,struct drm_connector *connector);
  void (* disable) (struct drm_encoder *encoder);
  void (* enable) (struct drm_encoder *encoder);
  int (* atomic_check) (struct drm_encoder *encoder,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Callback to control power levels on the encoder.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy encoder helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable an encoder by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn&#8217;t used.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling an encoder to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>enable</strong> and <strong>disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
encoder. This should be implemented if the encoder has some sort
of restriction in the modes it can display. For example, a given
encoder may be responsible to set a clock value. If the clock can
not produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> or a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>.
The parameter adjusted_mode is the input mode the encoder requires. It
can be modified by this callback and does not need to match mode. See
also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
This hook is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback. If <strong>atomic_check</strong> is used,
this hook isn&#8217;t called since <strong>atomic_check</strong> allows a strict superset
of the functionality of <strong>mode_fixup</strong>.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd><p class="first">This callback should prepare the encoder for a subsequent modeset,
which in practice means the driver should disable the encoder if it
is running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>disable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">This callback should commit the new mode on the encoder after a modeset,
which in practice means the driver should enable the encoder.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>enable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspend using either DPMS or the
new &#8220;ACTIVE&#8221; property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used both by the legacy CRTC helpers and the atomic
modeset helpers. It is optional in the atomic helpers.</p>
<p>NOTE:</p>
<p class="last">If the driver uses the atomic modeset helpers and needs to inspect
the connector state or connector display info during mode setting,
<strong>atomic_mode_set</strong> can be used instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_mode_set</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspended using either DPMS or the
new &#8220;ACTIVE&#8221; property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p class="last">This callback is used by the atomic modeset helpers in place of the
<strong>mode_set</strong> callback, if set by the driver. It is optional and should
be used instead of <strong>mode_set</strong> if the driver needs to inspect the
connector state or display info, since there is no direct way to
go from the encoder to the current connector.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_crtc</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to work around
deficiencies in its own book-keeping.</p>
<p>Do not use, use atomic helpers instead, which get the book keeping
right.</p>
<p>FIXME:</p>
<p class="last">Currently only nouveau is using this, and as soon as nouveau is
atomic we can ditch this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd><p class="first">This callback can be used by drivers who want to do detection on the
encoder object instead of in connector functions.</p>
<p>It is not used by any helper and therefore has purely driver-specific
semantics. New drivers shouldn&#8217;t use this and instead just implement
their own private callbacks.</p>
<p>FIXME:</p>
<p class="last">This should just be converted into a pile of driver vfuncs.
Currently radeon, amdgpu and nouveau are using it.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder&#8217;s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.  If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC&#8217;s callback by looping over all
encoders connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
disable anything at the encoder level. To ensure that runtime PM
handling (using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>disable</strong> must be the inverse of <strong>enable</strong> for atomic drivers.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there&#8217;s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
encoder: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p class="last">Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd><p class="first">This callback should be used to enable the encoder. With the atomic
drivers it is called after this encoder&#8217;s CRTC has been enabled using
their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.enable</span></code></a> hook.  If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC&#8217;s callback by looping over all encoders
connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p class="last">This hook is used only by atomic helpers, for symmetry with <strong>disable</strong>.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
enable anything at the encoder level. To ensure that runtime PM handling
(using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>enable</strong> must be the inverse of <strong>disable</strong> for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This callback is used to validate encoder state for atomic drivers.
Since the encoder is the object connecting the CRTC and connector it
gets passed both states, to be able to validate interactions and
update the CRTC to match what the encoder needs for the requested
connector.</p>
<p>Since this provides a strict superset of the functionality of
<strong>mode_fixup</strong> (the requested and adjusted modes are both available
through the passed in <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>) <strong>mode_fixup</strong> is not
called when <strong>atomic_check</strong> is implemented.</p>
<p>This function is used by the atomic helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_encoder_helper_add">
void <code class="descname">drm_encoder_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>DRM encoder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>encoder</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_helper_funcs">
struct <code class="descname">drm_connector_helper_funcs</code><a class="headerlink" href="#c.drm_connector_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for connectors</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_connector_helper_funcs {
  int (* get_modes) (struct drm_connector *connector);
  int (* detect_ctx) (struct drm_connector *connector,struct drm_modeset_acquire_ctx *ctx,bool force);
  enum drm_mode_status (* mode_valid) (struct drm_connector *connector,struct drm_display_mode *mode);
  struct drm_encoder *(* best_encoder) (struct drm_connector *connector);
  struct drm_encoder *(* atomic_best_encoder) (struct drm_connector *connector,struct drm_connector_state *connector_state);
  int (* atomic_check) (struct drm_connector *connector,struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">get_modes</span></code></dt>
<dd><p class="first">This function should fill in all modes currently valid for the sink
into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.probed_modes</span></code></a> list. It should also update the
EDID property by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_connector_update_edid_property" title="drm_mode_connector_update_edid_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_update_edid_property()</span></code></a>.</p>
<p>The usual way to implement this is to cache the EDID retrieved in the
probe callback somewhere in the driver-private connector structure.
In this function drivers then parse the modes in the EDID and add
them by calling <a class="reference internal" href="#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code></a>. But connectors that driver a
fixed panel can also manually add specific modes using
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_probed_add()</span></code></a>. Drivers which manually add modes should also
make sure that the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.display_info</span></code></a>,
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.width_mm</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.height_mm</span></code></a> fields are
filled in.</p>
<p>Virtual drivers that just want some standard VESA mode with a given
resolution can call <a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal"><span class="pre">drm_add_modes_noedid()</span></code></a>, and mark the preferred
one using <a class="reference internal" href="#c.drm_set_preferred_mode" title="drm_set_preferred_mode"><code class="xref c c-func docutils literal"><span class="pre">drm_set_preferred_mode()</span></code></a>.</p>
<p>Finally drivers that support audio probably want to update the ELD
data, too, using <a class="reference internal" href="#c.drm_edid_to_eld" title="drm_edid_to_eld"><code class="xref c c-func docutils literal"><span class="pre">drm_edid_to_eld()</span></code></a>.</p>
<p>This function is only called after the <strong>detect</strong> hook has indicated
that a sink is connected and when the EDID isn&#8217;t overridden through
sysfs or the kernel commandline.</p>
<p>This callback is used by the probe helpers in e.g.
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it&#8217;s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p class="last">The number of modes added by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect_ctx</span></code></dt>
<dd><p class="first">Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>This is the atomic version of <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.detect</span></code></a>.</p>
<p>To avoid races against concurrent connector state updates, the
helper libraries always call this with ctx set to a valid context,
and <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a> will always be locked with
the ctx parameter set to this ctx. This allows taking additional
locks as required.</p>
<p>RETURNS:</p>
<p class="last"><a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_status</span></code></a> indicating the connector&#8217;s status,
or the error code returned by <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>, -EDEADLK.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">Callback to validate a mode for a connector, irrespective of the
specific display configuration.</p>
<p>This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. <a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>This only filters the mode list supplied to userspace in the
GETCONNECTOR IOCTL. Compared to <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a>,
which are also called by the atomic helpers from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. This allows userspace to force and
ignore sink constraint (like the pixel clock limits in the screen&#8217;s
EDID), which is useful for e.g. testing, or working around a broken
EDID. Any source hardware constraint (which always need to be
enforced) therefore should be checked in one of the above callbacks,
and not this one here.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it&#8217;s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p class="last">Either <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_status.MODE_OK</span></code></a> or one of the failure reasons in <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">enum</span>
<span class="pre">drm_mode_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">best_encoder</span></code></dt>
<dd><p class="first">This function should select the best encoder for the given connector.</p>
<p>This function is used by both the atomic helpers (in the
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> function) and in the legacy CRTC
helpers.</p>
<p>NOTE:</p>
<p>In atomic drivers this function is called in the check phase of an
atomic update. The driver is not allowed to change or inspect
anything outside of arguments passed-in. Atomic drivers which need to
inspect dynamic configuration state should instead use
<strong>atomic_best_encoder</strong>.</p>
<p>You can leave this function to NULL if the connector is only
attached to a single encoder and you are using the atomic helpers.
In this case, the core will call <a class="reference internal" href="#c.drm_atomic_helper_best_encoder" title="drm_atomic_helper_best_encoder"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_best_encoder()</span></code></a>
for you.</p>
<p>RETURNS:</p>
<p class="last">Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren&#8217;t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_best_encoder</span></code></dt>
<dd><p class="first">This is the atomic version of <strong>best_encoder</strong> for atomic drivers which
need to select the best encoder depending upon the desired
configuration and can&#8217;t select it statically.</p>
<p>This function is used by <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.
If it is not implemented, the core will fallback to <strong>best_encoder</strong>
(or <a class="reference internal" href="#c.drm_atomic_helper_best_encoder" title="drm_atomic_helper_best_encoder"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_best_encoder()</span></code></a> if <strong>best_encoder</strong> is NULL).</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren&#8217;t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This hook is used to validate connector state. This function is
called from <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_helper_check_modeset</span></code></a>, and is called when
a connector property is set, or a modeset on the crtc is forced.</p>
<p>Because <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_helper_check_modeset</span></code></a> may be called multiple times,
this function should handle being called multiple times as well.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic and legacy modeset helpers and by the
probe helpers.</p>
<dl class="function">
<dt id="c.drm_connector_helper_add">
void <code class="descname">drm_connector_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs">drm_connector_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>connector</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_helper_funcs">
struct <code class="descname">drm_plane_helper_funcs</code><a class="headerlink" href="#c.drm_plane_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for planes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_plane_helper_funcs {
  int (* prepare_fb) (struct drm_plane *plane,struct drm_plane_state *new_state);
  void (* cleanup_fb) (struct drm_plane *plane,struct drm_plane_state *old_state);
  int (* atomic_check) (struct drm_plane *plane,struct drm_plane_state *state);
  void (* atomic_update) (struct drm_plane *plane,struct drm_plane_state *old_state);
  void (* atomic_disable) (struct drm_plane *plane,struct drm_plane_state *old_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">prepare_fb</span></code></dt>
<dd><p class="first">This hook is to prepare a framebuffer for scanout by e.g. pinning
it&#8217;s backing storage or relocating it into a contiguous block of
VRAM. Other possible preparatory work includes flushing caches.</p>
<p>This function must not block for outstanding rendering, since it is
called in the context of the atomic IOCTL even for async commits to
be able to return any errors to userspace. Instead the recommended
way is to fill out the fence member of the passed-in
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>. If the driver doesn&#8217;t support native fences then
equivalent functionality should be implemented through private
members in the plane structure.</p>
<p>The helpers will call <strong>cleanup_fb</strong> with matching arguments for every
successful call to this hook.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or one of the following negative error codes allowed by
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> vfunc. When using helpers
this callback is the only one which can fail an atomic commit,
everything else must complete successfully.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_fb</span></code></dt>
<dd><p class="first">This hook is called to clean up any resources allocated for the given
framebuffer and plane configuration in <strong>prepare_fb</strong>.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">Drivers should check plane specific constraints in this hook.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> plane&#8217;s <strong>atomic_check</strong>
hooks are called before the ones for CRTCs, which allows drivers to
request shared resources that the CRTC controls here. For more
complicated dependencies the driver can call the provided check helpers
multiple times until the computed state has a final configuration and
everything has been checked.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_update</span></code></dt>
<dd><p class="first">Drivers should use this function to update the plane state.  This
hook is called in-between the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_disable</span></code></dt>
<dd><p class="first">Drivers should use this function to unconditionally disable a plane.
This hook is called in-between the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks. It is an alternative to
<strong>atomic_update</strong>, which will be called for disabling planes, too, if
the <strong>atomic_disable</strong> hook isn&#8217;t implemented.</p>
<p>This hook is also useful to disable planes in preparation of a modeset,
by calling <a class="reference internal" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> from the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic helpers and by the transitional plane
helpers.</p>
<dl class="function">
<dt id="c.drm_plane_helper_add">
void <code class="descname">drm_plane_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, const struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs">drm_plane_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>DRM plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>plane</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_mode_config_helper_funcs">
struct <code class="descname">drm_mode_config_helper_funcs</code><a class="headerlink" href="#c.drm_mode_config_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>global modeset helper operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_mode_config_helper_funcs {
  void (* atomic_commit_tail) (struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_commit_tail</span></code></dt>
<dd><p class="first">This hook is used by the default <code class="xref c c-func docutils literal"><span class="pre">atomic_commit()</span></code> hook implemented in
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a> together with the nonblocking commit
helpers (see <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for a starting point)
to implement blocking and nonblocking commits easily. It is not used
by the atomic helpers</p>
<p>This function is called when the new atomic state has already been
swapped into the various state pointers. The passed in state
therefore contains copies of the old/previous state. This hook should
commit the new state into hardware. Note that the helpers have
already waited for preceeding atomic commits and fences, but drivers
can add more waiting calls at the start of their implementation, e.g.
to wait for driver-internal request for implicit syncing, before
starting to commit the update to the hardware.</p>
<p>After the atomic update is committed to the hardware this hook needs
to call <a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. Then wait for the upate
to be executed by the hardware, for example using
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a>, and then clean up the old
framebuffers using <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>When disabling a CRTC this hook _must_ stall for the commit to
complete. Vblank waits don&#8217;t work on disabled CRTC, hence the core
can&#8217;t take care of this. And it also can&#8217;t rely on the vblank event,
since that can be signalled already when the screen shows black,
which can happen much earlier than the last hardware access needed to
shut off the display pipeline completely.</p>
<p class="last">This hook is optional, the default implementation is
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These helper functions are used by the atomic helpers.</p>
</div>
<div class="section" id="atomic-modeset-helper-functions-reference">
<span id="drm-atomic-helper"></span><h2>Atomic Modeset Helper Functions Reference<a class="headerlink" href="#atomic-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>This helper library provides implementations of check and commit functions on
top of the CRTC modeset helper callbacks and the plane helper callbacks. It
also provides convenience implementations for the atomic state handling
callbacks for drivers which don&#8217;t need to subclass the drm core structures to
add their own additional internal state.</p>
<p>This library also provides default implementations for the check callback in
<a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a> and for the commit callback with
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a>. But the individual stages and callbacks are
exposed to allow drivers to mix and match and e.g. use the plane helpers only
together with a driver private modeset implementation.</p>
<p>This library also provides implementations for all the legacy driver
interfaces on top of the atomic interface. See <a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_set_config()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> and the
various functions to implement set_property callbacks. New drivers must not
implement these functions themselves but must use the provided helpers.</p>
<p>The atomic helper uses the same function table structures as all other
modesetting helpers. See the documentation for <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a>,
struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs</span></code></a> and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a>. It
also shares the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> function table with the plane
helpers.</p>
</div>
<div class="section" id="implementing-asynchronous-atomic-commit">
<h3>Implementing Asynchronous Atomic Commit<a class="headerlink" href="#implementing-asynchronous-atomic-commit" title="Permalink to this headline">¶</a></h3>
<p>Nonblocking atomic commits have to be implemented in the following sequence:</p>
<p>1. Run <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a> first. This is the only function
which commit needs to call which can fail, so we want to run it first and
synchronously.</p>
<p>2. Synchronize with any outstanding nonblocking commit worker threads which
might be affected the new state update. This can be done by either cancelling
or flushing the work items, depending upon whether the driver can deal with
cancelled updates. Note that it is important to ensure that the framebuffer
cleanup is still done when cancelling.</p>
<p>Asynchronous workers need to have sufficient parallelism to be able to run
different atomic commits on different CRTCs in parallel. The simplest way to
achive this is by running them on the <code class="xref c c-type docutils literal"><span class="pre">system_unbound_wq</span></code> work queue. Note
that drivers are not required to split up atomic commits and run an
individual commit in parallel - userspace is supposed to do that if it cares.
But it might be beneficial to do that for modesets, since those necessarily
must be done as one global operation, and enabling or disabling a CRTC can
take a long time. But even that is not required.</p>
<p>3. The software state is updated synchronously with
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>. Doing this under the protection of all modeset
locks means concurrent callers never see inconsistent state. And doing this
while it&#8217;s guaranteed that no relevant nonblocking worker runs means that
nonblocking workers do not need grab any locks. Actually they must not grab
locks, for otherwise the work flushing will deadlock.</p>
<p>4. Schedule a work item to do all subsequent steps, using the split-out
commit helpers: a) pre-plane commit b) plane commit c) post-plane commit and
then cleaning up the framebuffers after the old framebuffer is no longer
being displayed.</p>
<p>The above scheme is implemented in the atomic helper libraries in
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a> using a bunch of helper functions. See
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for a starting point.</p>
</div>
<div class="section" id="atomic-state-reset-and-initialization">
<h3>Atomic State Reset and Initialization<a class="headerlink" href="#atomic-state-reset-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>Both the drm core and the atomic helpers assume that there is always the full
and correct atomic software state for all connectors, CRTCs and planes
available. Which is a bit a problem on driver load and also after system
suspend. One way to solve this is to have a hardware state read-out
infrastructure which reconstructs the full software state (e.g. the i915
driver).</p>
<p>The simpler solution is to just reset the software state to everything off,
which is easiest to do by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>. To facilitate this
the atomic helpers provide default reset implementations for all hooks.</p>
<p>On the upside the precise state tracking of atomic simplifies system suspend
and resume a lot. For drivers using <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a> a complete recipe
is implemented in <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a>.
For other drivers the building blocks are split out, see the documentation
for these functions.</p>
</div>
<div class="section" id="helper-functions-reference">
<h3>Helper Functions Reference<a class="headerlink" href="#helper-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_atomic_crtc_for_each_plane">
<code class="descname">drm_atomic_crtc_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes currently attached to CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>the crtc whose planes are iterated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over the current state, useful (for example) when applying
atomic state after it has been checked and swapped.  To iterate over the
planes which <em>will</em> be attached (more useful in code called from
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>) see
<a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane">
<code class="descname">drm_atomic_crtc_state_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">crtc_state</span></code></dt>
<dd>the incoming crtc-state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_for_each_plane()</span></code>, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane_state">
<code class="descname">drm_atomic_crtc_state_for_each_plane_state</code><span class="sig-paren">(</span><em>plane</em>, <em>plane_state</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">plane_state</span></code></dt>
<dd>loop cursor for the plane&#8217;s state, must be const</dd>
<dt><code class="docutils literal"><span class="pre">crtc_state</span></code></dt>
<dd>the incoming crtc-state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_for_each_plane()</span></code>, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<p>Compared to just <a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a> this also fills in a
const plane_state. This is useful when a driver just wants to peek at other
active planes on this crtc, but does not need to change it.</p>
<dl class="function">
<dt id="c.drm_atomic_plane_disabling">
bool <code class="descname">drm_atomic_plane_disabling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;old_plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;new_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_disabling" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a plane is being disabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">old_plane_state</span></code></dt>
<dd>old atomic plane state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">new_plane_state</span></code></dt>
<dd>new atomic plane state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the atomic state of a plane to determine whether it&#8217;s being disabled
or not. This also WARNs if it detects an invalid state (both CRTC and FB
need to either both be NULL or both be non-NULL).</p>
<p><strong>Return</strong></p>
<p>True if the plane is being disabled, false otherwise.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check_modeset">
int <code class="descname">drm_atomic_helper_check_modeset</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for modeset changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the driver state object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the crtc and connector related computations for an atomic
update and adds any additional connectors needed for full modesets. It calls
the various per-object callbacks in the follow order:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.atomic_best_encoder</span></code></a> for determining the new encoder.</li>
<li><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> to validate the connector state.</li>
<li>If it&#8217;s determined a modeset is needed then all connectors on the affected crtc
crtc are added and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> is run on them.</li>
<li><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> are called on the affected components.</li>
<li><a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> is called on all encoder bridges.</li>
<li><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.atomic_check</span></code></a> is called to validate any encoder state.
This function is only called when the encoder will be part of a configured crtc,
it must not be used for implementing connector property validation.
If this function is NULL, <code class="xref c c-type docutils literal"><span class="pre">drm_atomic_encoder_helper_funcs.mode_fixup</span></code> is called
instead.</li>
<li><a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_fixup</span></code></a> is called last, to fix up the mode with crtc constraints.</li>
</ol>
<p><a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.mode_changed</span></code></a> is set when the input mode is changed.
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.connectors_changed</span></code></a> is set when a connector is added or
removed from the crtc.  <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.active_changed</span></code></a> is set when
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.active</span></code></a> changes, which is used for DPMS.
See also: <a class="reference internal" href="drm-kms.html#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<p>IMPORTANT:</p>
<p>Drivers which set <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.mode_changed</span></code></a> (e.g. in their
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hooks if a plane update can&#8217;t be done
without a full modeset) _must_ call this function afterwards after that
change. It is permitted to call this function multiple times for the same
update, e.g. when the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> functions depend
upon the adjusted dotclock for fifo space allocation and watermark
computation.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check_planes">
int <code class="descname">drm_atomic_helper_check_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for planes changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the driver state object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the plane update related checks using by calling into the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a>
hooks provided by the driver.</p>
<p>It also sets <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.planes_changed</span></code></a> to indicate that a crtc has
updated planes.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_check">
int <code class="descname">drm_atomic_helper_check</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the driver state object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
Only crtcs and planes have check callbacks, so for any additional (global)
checking that a driver needs it can simply wrap that around this function.
Drivers without such needs can directly use this as their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> callback.</p>
<p>This just wraps the two parts of the state checking for planes and modeset
state in the default order: First it calls <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>
and then <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>. The assumption is that the
<strong>drm_plane_helper_funcs</strong>.atomic_check and <strong>drm_crtc_helper_funcs</strong>.atomic_check
functions depend upon an updated adjusted_mode.clock to e.g. properly compute
watermarks.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
<dl class="function">
<dt id="c.drm_atomic_helper_update_legacy_modeset_state">
void <code class="descname">drm_atomic_helper_update_legacy_modeset_state</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_legacy_modeset_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update legacy modeset state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates all the various legacy modeset state pointers in
connectors, encoders and crtcs. It also updates the timestamping constants
used for precise vblank timestamps by calling
<a class="reference internal" href="drm-kms.html#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
<p>Drivers can use this for building their own atomic commit if they don&#8217;t have
a pure helper-based modeset implementation.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_disables">
void <code class="descname">drm_atomic_helper_commit_modeset_disables</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_disables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to disable outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shuts down all the outputs that need to be shut down and
prepares them (if required) with the new mode.</p>
<p>For compatibility with legacy crtc helpers this should be called before
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_enables">
void <code class="descname">drm_atomic_helper_commit_modeset_enables</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_enables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to enable outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables all the outputs with the new configuration which had to
be turned off for the update.</p>
<p>For compatibility with legacy crtc helpers this should be called after
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_fences">
int <code class="descname">drm_atomic_helper_wait_for_fences</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, bool<em>&nbsp;pre_swap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for fences stashed in plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state object with old state structures</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">pre_swap</span></code></dt>
<dd>If true, do an interruptible wait, and <strong>state</strong> is the new state.
Otherwise <strong>state</strong> is the old state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For implicit sync, driver should fish the exclusive fence out from the
incoming fb&#8217;s and stash it in the drm_plane_state.  This is called after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> so it uses the current plane state (and
just uses the atomic state to find the changed planes)</p>
<p>Note that <strong>pre_swap</strong> is needed since the point where we block for fences moves
around depending upon whether an atomic commit is blocking or
non-blocking. For non-blocking commit all waiting needs to happen after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> is called, but for blocking commits we want
to wait <strong>before</strong> we do anything that can&#8217;t be easily rolled back. That is
before we call <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>.</p>
<p>Returns zero if success or &lt; 0 if <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_wait()</span></code></a> fails.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_vblanks">
void <code class="descname">drm_atomic_helper_wait_for_vblanks</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_vblanks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for vblank on crtcs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to, after atomic commit, wait for vblanks on all effected
crtcs (ie. before cleaning up old framebuffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>). It will only wait on crtcs where the
framebuffers have actually changed to optimize for the legacy cursor and
plane update use-case.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_tail">
void <code class="descname">drm_atomic_helper_commit_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>commit atomic update to hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation for the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> hook.</p>
<p>Note that the default ordering of how the various stages are called is to
match the legacy modeset helper library closest. One peculiarity of that is
that it doesn&#8217;t mesh well with runtime PM at all.</p>
<p>For drivers supporting runtime PM the recommended sequence is instead</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>drm_atomic_helper_commit_modeset_disables(dev, old_state);

drm_atomic_helper_commit_modeset_enables(dev, old_state);

drm_atomic_helper_commit_planes(dev, old_state,
                                DRM_PLANE_COMMIT_ACTIVE_ONLY);
</pre></div>
</div>
<p>for committing the atomic update to hardware.  See the kerneldoc entries for
these three functions for more details.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit">
int <code class="descname">drm_atomic_helper_commit</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, bool<em>&nbsp;nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit validated state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the driver state object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt>
<dd>whether nonblocking behavior is requested.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits a with <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a> pre-validated state
object. This can still fail when e.g. the framebuffer reservation fails. This
function implements nonblocking commits, using
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> and related functions.</p>
<p>Committing the actual hardware state is done through the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> callback, or it&#8217;s default
implementation <a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_setup_commit">
int <code class="descname">drm_atomic_helper_setup_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, bool<em>&nbsp;nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_setup_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possibly nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>new modeset state to be committed</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt>
<dd>whether nonblocking behavior is requested.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares <strong>state</strong> to be used by the atomic helper&#8217;s support for
nonblocking commits. Drivers using the nonblocking commit infrastructure
should always call this function from their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> hook.</p>
<p>To be able to use this support drivers need to use a few more helper
functions. <a class="reference internal" href="#c.drm_atomic_helper_wait_for_dependencies" title="drm_atomic_helper_wait_for_dependencies"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_wait_for_dependencies()</span></code></a> must be called before
actually committing the hardware state, and for nonblocking commits this call
must be placed in the async worker. See also <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>
and it&#8217;s stall parameter, for when a driver&#8217;s commit hooks look at the
<a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a> pointer directly.</p>
<p>Completion of the hardware commit step must be signalled using
<a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. After this step the driver is not allowed
to read or change any permanent software or hardware modeset state. The only
exception is state protected by other means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> locks.
Only the free standing <strong>state</strong> with pointers to the old state structures can
be inspected, e.g. to clean up old buffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>At the very end, before cleaning up <strong>state</strong> drivers must call
<a class="reference internal" href="#c.drm_atomic_helper_commit_cleanup_done" title="drm_atomic_helper_commit_cleanup_done"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_cleanup_done()</span></code></a>.</p>
<p>This is all implemented by in <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a>, giving drivers a
complete and esay-to-use default implementation of the <code class="xref c c-func docutils literal"><span class="pre">atomic_commit()</span></code> hook.</p>
<p>The tracking of asynchronously executed and still pending commits is done
using the core structure <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit</span></code></a>.</p>
<p>By default there&#8217;s no need to clean up resources allocated by this function
explicitly: <a class="reference internal" href="drm-kms.html#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_clear()</span></code></a> will take care of that
automatically.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
-ENOMEM on allocation failures and -EINTR when a signal is pending.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_dependencies">
void <code class="descname">drm_atomic_helper_wait_for_dependencies</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for required preceeding commits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function waits for all preceeding commits that touch the same CRTC as
<strong>old_state</strong> to both be committed to the hardware (as signalled by
drm_atomic_helper_commit_hw_done) and executed by the hardware (as signalled
by calling <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_send_event()</span></code> on the <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a>).</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_hw_done">
void <code class="descname">drm_atomic_helper_commit_hw_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_hw_done" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possible nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to signal completion of the hardware commit step. After
this step the driver is not allowed to read or change any permanent software
or hardware modeset state. The only exception is state protected by other
means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> locks.</p>
<p>Drivers should try to postpone any expensive or delayed cleanup work after
this function is called.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_cleanup_done">
void <code class="descname">drm_atomic_helper_commit_cleanup_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_cleanup_done" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This signals completion of the atomic update <strong>old_state</strong>, including any
cleanup work. If used, it must be called right before calling
<a class="reference internal" href="drm-kms.html#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_prepare_planes">
int <code class="descname">drm_atomic_helper_prepare_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_prepare_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare plane resources before commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state object with new state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares plane state, specifically framebuffers, for the new
configuration, by calling <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>. If any failure
is encountered this function will call <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> on
any already successfully prepared framebuffer.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes">
void <code class="descname">drm_atomic_helper_commit_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em>, uint32_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>flags for committing plane state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes and crtcs. It assumes that the atomic state has already
been pushed into the relevant object state pointers, since this step can no
longer fail.</p>
<p>It still requires the global state object <strong>old_state</strong> to know which planes and
crtcs need to be updated though.</p>
<p>Note that this function does all plane updates across all CRTCs in one step.
If the hardware can&#8217;t support this approach look at
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="drm_atomic_helper_commit_planes_on_crtc"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes_on_crtc()</span></code></a> instead.</p>
<p>Plane parameters can be updated by applications while the associated CRTC is
disabled. The DRM/KMS core will store the parameters in the plane state,
which will be available to the driver when the CRTC is turned on. As a result
most drivers don&#8217;t need to be immediately notified of plane updates for a
disabled CRTC.</p>
<p>Unless otherwise needed, drivers are advised to set the ACTIVE_ONLY flag in
<strong>flags</strong> in order not to receive plane update notifications related to a
disabled CRTC. This avoids the need to manually ignore plane updates in
driver code when the driver and/or hardware can&#8217;t or just don&#8217;t need to deal
with updates on disabled CRTCs, for example when supporting runtime PM.</p>
<p>Drivers may set the NO_DISABLE_AFTER_MODESET flag in <strong>flags</strong> if the relevant
display controllers require to disable a CRTC&#8217;s planes when the CRTC is
disabled. This function would skip the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a>
call for a plane if the CRTC of the old plane state needs a modesetting
operation. Of course, the drivers need to disable the planes in their CRTC
disable callbacks since no one else would do that.</p>
<p>The <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a> default implementation doesn&#8217;t set the
ACTIVE_ONLY flag to most closely match the behaviour of the legacy helpers.
This should not be copied blindly by drivers.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes_on_crtc">
void <code class="descname">drm_atomic_helper_commit_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">old_crtc_state</span></code></dt>
<dd>atomic state object with the old crtc state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes on the specific crtc. It assumes that the atomic state
has already been pushed into the relevant object state pointers, since this
step can no longer fail.</p>
<p>This function is useful when plane updates should be done crtc-by-crtc
instead of one global step like <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> does.</p>
<p>This function can only be savely used when planes are not allowed to move
between different CRTCs because this function doesn&#8217;t handle inter-CRTC
depencies. Callers need to ensure that either no such depencies exist,
resolve them through ordering of commit calls or through some other means.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_planes_on_crtc">
void <code class="descname">drm_atomic_helper_disable_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;old_crtc_state</em>, bool<em>&nbsp;atomic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to disable CRTC&#8217;s planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">old_crtc_state</span></code></dt>
<dd>atomic state object with the old CRTC state</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">atomic</span></code></dt>
<dd>if set, synchronize with CRTC&#8217;s atomic_begin/flush hooks</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables all planes associated with the given CRTC. This can be
used for instance in the CRTC helper atomic_disable callback to disable
all planes.</p>
<p>If the atomic-parameter is set the function calls the CRTC&#8217;s
atomic_begin hook before and atomic_flush hook after disabling the
planes.</p>
<p>It is a bug to call this function without having implemented the
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a> plane hook.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_cleanup_planes">
void <code class="descname">drm_atomic_helper_cleanup_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_cleanup_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup plane resources after commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">old_state</span></code></dt>
<dd>atomic state object with old state structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up plane state, specifically framebuffers, from the old
configuration. Hence the old configuration must be perserved in <strong>old_state</strong> to
be able to call this function.</p>
<p>This function must also be called on the new state when the atomic update
fails at any point after calling <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_swap_state">
void <code class="descname">drm_atomic_helper_swap_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, bool<em>&nbsp;stall</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_swap_state" title="Permalink to this definition">¶</a></dt>
<dd><p>store atomic state into current sw state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">stall</span></code></dt>
<dd>stall for proceeding commits</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stores the atomic state into the current state pointers in all
driver objects. It should be called after all failing steps have been done
and succeeded, but before the actual hardware state is committed.</p>
<p>For cleanup and error recovery the current state for all changed objects will
be swaped into <strong>state</strong>.</p>
<p>With that sequence it fits perfectly into the plane prepare/cleanup sequence:</p>
<ol class="arabic simple">
<li>Call <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a> with the staged atomic state.</li>
<li>Do any other steps that might fail.</li>
<li>Put the staged state into the current state pointers with this function.</li>
<li>Actually commit the hardware state.</li>
</ol>
<p>5. Call <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a> with <strong>state</strong>, which since step 3
contains the old state. Also do any other cleanup required with that state.</p>
<p><strong>stall</strong> must be set when nonblocking commits for this driver directly access
the <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a> pointer. With
the current atomic helpers this is almost always the case, since the helpers
don&#8217;t pass the right state structures to the callbacks.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_update_plane">
int <code class="descname">drm_atomic_helper_update_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;crtc_x</em>, int<em>&nbsp;crtc_y</em>, unsigned int<em>&nbsp;crtc_w</em>, unsigned int<em>&nbsp;crtc_h</em>, uint32_t<em>&nbsp;src_x</em>, uint32_t<em>&nbsp;src_y</em>, uint32_t<em>&nbsp;src_w</em>, uint32_t<em>&nbsp;src_h</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane update using atomic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>owning CRTC of owning plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to flip onto plane</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt>
<dd>x offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt>
<dd>y offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt>
<dd>width of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt>
<dd>height of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt>
<dd>x offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt>
<dd>y offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt>
<dd>width of source rectangle in <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt>
<dd>height of source rectangle in <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane update handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_plane">
int <code class="descname">drm_atomic_helper_disable_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane disable using * atomic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to disable</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane disable handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_set_config">
int <code class="descname">drm_atomic_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em>&nbsp;set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt>
<dd>mode set configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default crtc set_config handler using the atomic driver interface.</p>
<p><strong>NOTE</strong></p>
<p>For backwards compatibility with old userspace this automatically
resets the &#8220;link-status&#8221; property to GOOD, to force any link
re-training. The SETCRTC ioctl does not define whether an update does
need a full modeset or just a plane update, hence we&#8217;re allowed to do
that. See also <a class="reference internal" href="drm-kms.html#c.drm_mode_connector_set_link_status_property" title="drm_mode_connector_set_link_status_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_set_link_status_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_all">
int <code class="descname">drm_atomic_helper_disable_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all currently active outputs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Loops through all connectors, finding those that aren&#8217;t turned off and then
turns them off by setting their DPMS mode to OFF and deactivating the CRTC
that they are connected to.</p>
<p>This is used for example in suspend/resume to disable all currently active
functions when suspending. If you just want to shut down everything at e.g.
driver unload, look at <a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p>Note that if callers haven&#8217;t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_shutdown">
void <code class="descname">drm_atomic_helper_shutdown</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown all CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This shuts down all CRTC, which is useful for driver unloading. Shutdown on
suspend should instead be handled with <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, since
that also takes a snapshot of the modeset state to be restored on resume.</p>
<p>This is just a convenience wrapper around <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
and it is the atomic version of <a class="reference internal" href="drm-kms.html#c.drm_crtc_force_disable_all" title="drm_crtc_force_disable_all"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_force_disable_all()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_suspend">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_helper_suspend</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level suspend helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicates the current atomic state, disables all active outputs and then
returns a pointer to the original atomic state to the caller. Drivers can
pass this pointer to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon resume to
restore the output configuration that was active at the time the system
entered suspend.</p>
<p>Note that it is potentially unsafe to use this. The atomic state object
returned by this function is assumed to be persistent. Drivers must ensure
that this holds true. Before calling this function, drivers must make sure
to suspend fbdev emulation so that nothing can be using the device.</p>
<p><strong>Return</strong></p>
<p>A pointer to a copy of the state before suspend on success or an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>-
encoded error code on failure. Drivers should store the returned atomic
state object and pass it to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon
resume.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_commit_duplicated_state" title="drm_atomic_helper_commit_duplicated_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_duplicated_state()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_duplicated_state">
int <code class="descname">drm_atomic_helper_commit_duplicated_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_duplicated_state" title="Permalink to this definition">¶</a></dt>
<dd><p>commit duplicated state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>duplicated atomic state to commit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>pointer to acquire_ctx to use for commit.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state returned by <a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a> is partially invalid, and needs to
be fixed up before commit.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_resume">
int <code class="descname">drm_atomic_helper_resume</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level resume helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state to resume to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a> to synchronize hardware and software states,
grabs all modeset locks and commits the atomic state object. This can be
used in conjunction with the <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a> helper to
implement suspend/resume for drivers that support atomic mode-setting.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_set_property">
int <code class="descname">drm_atomic_helper_crtc_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for crtc properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>DRM property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value of property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default crtc set_property handler using the atomic driver
interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_set_property">
int <code class="descname">drm_atomic_helper_plane_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for plane properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>DRM plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>DRM property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value of property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane set_property handler using the atomic driver
interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_set_property">
int <code class="descname">drm_atomic_helper_connector_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>DRM property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value of property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default connector set_property handler using the atomic driver
interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip">
int <code class="descname">drm_atomic_helper_page_flip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;event</em>, uint32_t<em>&nbsp;flags</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a legacy page flip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>optional DRM event to signal upon completion</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>flip flags for non-vblank sync&#8217;ed updates</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> implementation
using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_page_flip_target" title="drm_atomic_helper_page_flip_target"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_page_flip_target()</span></code></a></p>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip_target">
int <code class="descname">drm_atomic_helper_page_flip_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;event</em>, uint32_t<em>&nbsp;flags</em>, uint32_t<em>&nbsp;target</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip_target" title="Permalink to this definition">¶</a></dt>
<dd><p>do page flip on target vblank period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>optional DRM event to signal upon completion</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>flip flags for non-vblank sync&#8217;ed updates</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">target</span></code></dt>
<dd>specifying the target vblank period when the flip to take effect</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip_target</span></code></a> implementation.
Similar to <a class="reference internal" href="#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> with extra parameter to specify
target vblank period to flip.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_dpms">
int <code class="descname">drm_atomic_helper_connector_dpms</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_dpms" title="Permalink to this definition">¶</a></dt>
<dd><p>connector dpms helper implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>affected connector</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>DPMS mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main helper function provided by the atomic helper framework for
implementing the legacy DPMS connector interface. It computes the new desired
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.active</span></code></a> state for the corresponding CRTC (if the connector is
enabled) and updates it.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_best_encoder">
struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> * <code class="descname">drm_atomic_helper_best_encoder</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_best_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.best_encoder</span></code></a> callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>Connector control structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.best_encoder</span></code></a> callback helper for
connectors that support exactly 1 encoder, statically determined at driver
init time.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_reset">
void <code class="descname">drm_atomic_helper_crtc_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.reset</span></code></a> hook for CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>drm CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>crtc</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_duplicate_state">
void <code class="descname">__drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic CRTC state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a CRTC&#8217;s current state and resets inferred values.
This is useful for drivers that subclass the CRTC state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>drm CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state duplicate hook for drivers which don&#8217;t have their own
subclassed CRTC state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_destroy_state">
void <code class="descname">__drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>CRTC state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the CRTC state without actually freeing
the memory of the CRTC state. This is useful for drivers that subclass the
CRTC state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_destroy_state">
void <code class="descname">drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>drm CRTC</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>CRTC state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state destroy hook for drivers which don&#8217;t have their own
subclassed CRTC state structure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_reset">
void <code class="descname">drm_atomic_helper_plane_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.reset</span></code></a> hook for planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>plane</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_duplicate_state">
void <code class="descname">__drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic plane state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a plane&#8217;s current state. This is useful for
drivers that subclass the plane state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state duplicate hook for drivers which don&#8217;t have their own
subclassed plane state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_destroy_state">
void <code class="descname">__drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>plane state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the plane state without actually freeing
the memory of the plane state. This is useful for drivers that subclass the
plane state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_destroy_state">
void <code class="descname">drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>plane state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state destroy hook for drivers which don&#8217;t have their own
subclassed plane state structure.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_reset">
void <code class="descname">__drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>connector state to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>conn_state</strong> and assigns it to
the <code class="xref c c-type docutils literal"><span class="pre">drm_conector-&gt;state</span></code> pointer of <strong>connector</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_reset">
void <code class="descname">drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.reset</span></code></a> hook for connectors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>connector</strong> by freeing the state pointer (which
might be NULL, e.g. at driver load time) and allocating a new empty state
object.</p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_duplicate_state">
void <code class="descname">__drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic connector state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a connector&#8217;s current state. This is useful for
drivers that subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state duplicate hook for drivers which don&#8217;t have their own
subclassed connector state structure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_helper_duplicate_state</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an atomic state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes a copy of the current atomic state by looping over all objects and
duplicating their respective states. This is used for example by suspend/
resume support code to save the state prior to suspend such that it can
be restored upon resume.</p>
<p>Note that this treats atomic state as persistent between save and restore.
Drivers must make sure that this is possible and won&#8217;t result in confusion
or erroneous behaviour.</p>
<p>Note that if callers haven&#8217;t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the copy of the atomic state object on success or an
<code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>-encoded error code on failure.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_destroy_state">
void <code class="descname">__drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>connector state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the connector state without actually
freeing the memory of the connector state. This is useful for drivers that
subclass the connector state.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_destroy_state">
void <code class="descname">drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>connector state object to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state destroy hook for drivers which don&#8217;t have their own
subclassed connector state structure.</p>
<dl class="function">
<dt id="c.drm_atomic_helper_legacy_gamma_set">
int <code class="descname">drm_atomic_helper_legacy_gamma_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, u16 *<em>&nbsp;red</em>, u16 *<em>&nbsp;green</em>, u16 *<em>&nbsp;blue</em>, uint32_t<em>&nbsp;size</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_legacy_gamma_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set the legacy gamma correction table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC object</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">red</span></code></dt>
<dd>red correction table</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">green</span></code></dt>
<dd>green correction table</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">blue</span></code></dt>
<dd>green correction table</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">size</span></code></dt>
<dd>size of the tables</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements support for legacy gamma correction table for drivers
that support color management through the DEGAMMA_LUT/GAMMA_LUT
properties. See <a class="reference internal" href="drm-kms.html#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a> and the containing chapter for
how the atomic color management and gamma tables work.</p>
</div>
</div>
<div class="section" id="legacy-crtc-modeset-helper-functions-reference">
<h2>Legacy CRTC/Modeset Helper Functions Reference<a class="headerlink" href="#legacy-crtc-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The CRTC modeset helper library provides a default set_config implementation
in <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code></a>. Plus a few other convenience functions using
the same callbacks which drivers can use to e.g. restore the modeset
configuration on resume with <a class="reference internal" href="#c.drm_helper_resume_force_mode" title="drm_helper_resume_force_mode"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_resume_force_mode()</span></code></a>.</p>
<p>Note that this helper library doesn&#8217;t track the current power state of CRTCs
and encoders. It can call callbacks like <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> even
though the hardware is already in the desired state. This deficiency has been
fixed in the atomic helpers.</p>
<p>The driver callbacks are mostly compatible with the atomic modeset helpers,
except for the handling of the primary plane: Atomic helpers require that the
primary plane is implemented as a real standalone plane and not directly tied
to the CRTC state. For easier transition this library provides functions to
implement the old semantics required by the CRTC helpers using the new plane
and atomic helper callbacks.</p>
<p>Drivers are strongly urged to convert to the atomic helpers (by way of first
converting to the plane helpers). New drivers must not use these functions
but need to implement the atomic interface instead, potentially using the
atomic helpers for that.</p>
<p>These legacy modeset helpers use the same function table structures as
all other modesetting helpers. See the documentation for struct
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_helper_encoder_in_use">
bool <code class="descname">drm_helper_encoder_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_encoder_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given encoder is in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>encoder</strong> is with the current mode setting output configuration
in use by any connector. This doesn&#8217;t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>encoder</strong> is used, false otherwise.</p>
<dl class="function">
<dt id="c.drm_helper_crtc_in_use">
bool <code class="descname">drm_helper_crtc_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_crtc_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given CRTC is in a mode_config</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>crtc</strong> is with the current mode setting output configuration
in use by any connector. This doesn&#8217;t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>crtc</strong> is used, false otherwise.</p>
<dl class="function">
<dt id="c.drm_helper_disable_unused_functions">
void <code class="descname">drm_helper_disable_unused_functions</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_disable_unused_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unused objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks through the entire mode setting configuration of <strong>dev</strong>. It
will remove any CRTC links of unused encoders and encoder links of
disconnected connectors. Then it will disable all unused encoders and CRTCs
either by calling their disable callback if available or by calling their
dpms callback with DRM_MODE_DPMS_OFF.</p>
<p><strong>NOTE</strong></p>
<p>This function is part of the legacy modeset helper library and will cause
major confusion with atomic drivers. This is because atomic helpers guarantee
to never call -&gt;:c:func:<cite>disable()</cite> hooks on a disabled function, or -&gt;:c:func:<cite>enable()</cite> hooks
on an enabled functions. <a class="reference internal" href="#c.drm_helper_disable_unused_functions" title="drm_helper_disable_unused_functions"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_disable_unused_functions()</span></code></a> on the other
hand throws such guarantees into the wind and calls disable hooks
unconditionally on unused functions.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_set_mode">
bool <code class="descname">drm_crtc_helper_set_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, int<em>&nbsp;x</em>, int<em>&nbsp;y</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;old_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>internal helper to set a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to program</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>horizontal offset into the surface</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span></code></dt>
<dd>vertical offset into the surface</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">old_fb</span></code></dt>
<dd>old framebuffer, for cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to set <strong>mode</strong> on <strong>crtc</strong>.  Give <strong>crtc</strong> and its associated connectors a chance
to fixup or reject the mode prior to trying to set it. This is an internal
helper that drivers could e.g. use to update properties that require the
entire output pipe to be disabled and re-enabled in a new configuration. For
example for changing whether audio is enabled on a hdmi link or for changing
panel fitter or dither attributes. It is also called by the
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function to drive the mode setting
sequence.</p>
<p><strong>Return</strong></p>
<p>True if the mode was set successfully, false otherwise.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_set_config">
int <code class="descname">drm_crtc_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em>&nbsp;set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt>
<dd>mode set configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context, not used here</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function implements the of
<a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>It first tries to locate the best encoder for each connector by calling the
connector <strong>drm_connector_helper_funcs</strong>.best_encoder helper operation.</p>
<p>After locating the appropriate encoders, the helper function will call the
mode_fixup encoder and CRTC helper operations to adjust the requested mode,
or reject it completely in which case an error will be returned to the
application. If the new configuration after mode adjustment is identical to
the current configuration the helper function will return without performing
any other operation.</p>
<p>If the adjusted mode is identical to the current mode but changes to the
frame buffer need to be applied, the <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code></a> function
will call the CRTC <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_set_base</span></code></a> helper operation.</p>
<p>If the adjusted mode differs from the current mode, or if the
-&gt;:c:func:<cite>mode_set_base()</cite> helper operation is not provided, the helper function
performs a full mode set sequence by calling the -&gt;:c:func:<cite>prepare()</cite>, -&gt;:c:func:<cite>mode_set()</cite>
and -&gt;:c:func:<cite>commit()</cite> CRTC and encoder helper operations, in that order.
Alternatively it can also use the dpms and disable helper operations. For
details see <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs</span></code></a>.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, for which this function is unsuitable. Instead drivers should use
<a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_set_config()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
<dl class="function">
<dt id="c.drm_helper_connector_dpms">
int <code class="descname">drm_helper_connector_dpms</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_connector_dpms" title="Permalink to this definition">¶</a></dt>
<dd><p>connector dpms helper implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>affected connector</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>DPMS mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_connector_dpms()</span></code></a> helper function implements the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.dpms</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>This is the main helper function provided by the CRTC helper framework for
implementing the DPMS connector attribute. It computes the new desired DPMS
state for all encoders and CRTCs in the output mesh and calls the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.dpms</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> callbacks
provided by the driver.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, for which this function is unsuitable. Instead drivers should use
<a class="reference internal" href="#c.drm_atomic_helper_connector_dpms" title="drm_atomic_helper_connector_dpms"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_dpms()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Always returns 0.</p>
<dl class="function">
<dt id="c.drm_helper_resume_force_mode">
void <code class="descname">drm_helper_resume_force_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_resume_force_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>force-restore mode setting configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device which should be restored</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which use the mode setting helpers can use this function to
force-restore the mode setting configuration e.g. on resume or when something
else might have trampled over the hw state (like some overzealous old BIOSen
tended to do).</p>
<p>This helper doesn&#8217;t provide a error return value since restoring the old
config should never fail due to resource allocation issues since the driver
has successfully set the restored configuration already. Hence this should
boil down to the equivalent of a few dpms on calls, which also don&#8217;t provide
an error code.</p>
<p>Drivers where simply restoring an old configuration again might fail (e.g.
due to slight differences in allocating shared resources when the
configuration is restored in a different order than when userspace set it up)
need to use their own restore logic.</p>
<p>This function is deprecated. New drivers should implement atomic mode-
setting and use the atomic suspend/resume helpers.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
<dl class="function">
<dt id="c.drm_helper_crtc_mode_set">
int <code class="descname">drm_helper_crtc_mode_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;adjusted_mode</em>, int<em>&nbsp;x</em>, int<em>&nbsp;y</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;old_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_crtc_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>mode_set implementation for atomic plane helpers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>DRM display mode which userspace requested</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">adjusted_mode</span></code></dt>
<dd>DRM display mode adjusted by -&gt;mode_fixup callbacks</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>x offset of the CRTC scanout area on the underlying framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span></code></dt>
<dd>y offset of the CRTC scanout area on the underlying framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">old_fb</span></code></dt>
<dd>previous framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements a callback useable as the -&gt;mode_set callback
required by the CRTC helpers. Besides the atomic plane helper functions for
the primary plane the driver must also provide the -&gt;mode_set_nofb callback
to set up the CRTC.</p>
<p>This is a transitional helper useful for converting drivers to the atomic
interfaces.</p>
<dl class="function">
<dt id="c.drm_helper_crtc_mode_set_base">
int <code class="descname">drm_helper_crtc_mode_set_base</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, int<em>&nbsp;x</em>, int<em>&nbsp;y</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;old_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_crtc_mode_set_base" title="Permalink to this definition">¶</a></dt>
<dd><p>mode_set_base implementation for atomic plane helpers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>x offset of the CRTC scanout area on the underlying framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span></code></dt>
<dd>y offset of the CRTC scanout area on the underlying framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">old_fb</span></code></dt>
<dd>previous framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements a callback useable as the -&gt;mode_set_base used
required by the CRTC helpers. The driver must provide the atomic plane helper
functions for the primary plane.</p>
<p>This is a transitional helper useful for converting drivers to the atomic
interfaces.</p>
</div>
<div class="section" id="simple-kms-helper-reference">
<h2>Simple KMS Helper Reference<a class="headerlink" href="#simple-kms-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library provides helpers for drivers for simple display
hardware.</p>
<p><a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code></a> initializes a simple display pipeline
which has only one full-screen scanout buffer feeding one output. The
pipeline is represented by <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span></code></a> and binds
together <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> structures into one fixed
entity. Some flexibility for code reuse is provided through a separately
allocated <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> object and supporting optional <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>
encoder drivers.</p>
<dl class="type">
<dt id="c.drm_simple_display_pipe_funcs">
struct <code class="descname">drm_simple_display_pipe_funcs</code><a class="headerlink" href="#c.drm_simple_display_pipe_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for a simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe_funcs {
  void (* enable) (struct drm_simple_display_pipe *pipe,struct drm_crtc_state *crtc_state);
  void (* disable) (struct drm_simple_display_pipe *pipe);
  int (* check) (struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state,struct drm_crtc_state *crtc_state);
  void (* update) (struct drm_simple_display_pipe *pipe,struct drm_plane_state *old_plane_state);
  int (* prepare_fb) (struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state);
  void (* cleanup_fb) (struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>This function should be used to enable the pipeline.
It is called when the underlying crtc is enabled.
This hook is optional.</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>This function should be used to disable the pipeline.
It is called when the underlying crtc is disabled.
This hook is optional.</dd>
<dt><code class="docutils literal"><span class="pre">check</span></code></dt>
<dd><p class="first">This function is called in the check phase of an atomic update,
specifically when the underlying plane is checked.
The simple display pipeline helpers already check that the plane is
not scaled, fills the entire visible area and is always enabled
when the crtc is also enabled.
This hook is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">update</span></code></dt>
<dd><p class="first">This function is called when the underlying plane state is updated.
This hook is optional.</p>
<p class="last">This is the function drivers should submit the
<a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_vblank_event</span></code></a> from. Using either
<a class="reference internal" href="drm-kms.html#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>, when the driver supports vblank
interrupt handling, or <a class="reference internal" href="drm-kms.html#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> directly in case
the hardware lacks vblank support entirely.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare_fb</span></code></dt>
<dd>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> hook for
more details.</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_fb</span></code></dt>
<dd>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for
more details.</dd>
</dl>
<dl class="type">
<dt id="c.drm_simple_display_pipe">
struct <code class="descname">drm_simple_display_pipe</code><a class="headerlink" href="#c.drm_simple_display_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe {
  struct drm_crtc crtc;
  struct drm_plane plane;
  struct drm_encoder encoder;
  struct drm_connector * connector;
  const struct drm_simple_display_pipe_funcs * funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>CRTC control structure</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>Plane control structure</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>Encoder control structure</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>Connector control structure</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>Pipeline control functions (optional)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple display pipeline with plane, crtc and encoder collapsed into one
entity. It should be initialized by calling <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_simple_display_pipe_attach_bridge">
int <code class="descname">drm_simple_display_pipe_attach_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_attach_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a bridge to the display pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>simple display pipe object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge to attach</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes it possible to still use the drm_simple_display_pipe helpers when
a DRM bridge has to be used.</p>
<p>Note that you probably want to initialize the pipe by passing a NULL
connector to <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_simple_display_pipe_init">
int <code class="descname">drm_simple_display_pipe_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a> *<em>&nbsp;pipe</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a> *<em>&nbsp;funcs</em>, const uint32_t *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;format_count</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a simple display pipeline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>simple display pipe object to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the display pipe (optional)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array of supported formats (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt>
<dd>number of elements in <strong>formats</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach and register (optional)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a display pipeline which consist of a really simple
plane-crtc-encoder pipe.</p>
<p>If a connector is supplied, the pipe will be coupled with the provided
connector. You may supply a NULL connector when using drm bridges, that
handle connectors themselves (see <a class="reference internal" href="#c.drm_simple_display_pipe_attach_bridge" title="drm_simple_display_pipe_attach_bridge"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_attach_bridge()</span></code></a>).</p>
<p>Teardown of a simple display pipe is all handled automatically by the drm
core through calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>. Drivers afterwards need to
release the memory for the structure themselves.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<div class="section" id="fbdev-helper-functions-reference">
<h2>fbdev Helper Functions Reference<a class="headerlink" href="#fbdev-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The fb helper functions are useful to provide an fbdev on top of a drm kernel
mode setting driver. They can be used mostly independently from the crtc
helper functions used by many drivers to implement the kernel mode setting
interfaces.</p>
<p>Initialization is done as a four-step process with <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_prepare()</span></code></a>,
<a class="reference internal" href="#c.drm_fb_helper_init" title="drm_fb_helper_init"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_init()</span></code></a>, <a class="reference internal" href="#c.drm_fb_helper_single_add_all_connectors" title="drm_fb_helper_single_add_all_connectors"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_single_add_all_connectors()</span></code></a> and
<a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_initial_config()</span></code></a>. Drivers with fancier requirements than the
default behaviour can override the third step with their own code.
Teardown is done with <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fini()</span></code></a> after the fbdev device is
unregisters using <a class="reference internal" href="#c.drm_fb_helper_unregister_fbi" title="drm_fb_helper_unregister_fbi"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_unregister_fbi()</span></code></a>.</p>
<p>At runtime drivers should restore the fbdev console by calling
<a class="reference internal" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="drm_fb_helper_restore_fbdev_mode_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_restore_fbdev_mode_unlocked()</span></code></a> from their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.lastclose</span></code></a>
callback.  They should also notify the fb helper code from updates to the
output configuration by calling <a class="reference internal" href="#c.drm_fb_helper_hotplug_event" title="drm_fb_helper_hotplug_event"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_hotplug_event()</span></code></a>. For easier
integration with the output polling code in drm_crtc_helper.c the modeset
code provides a <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.output_poll_changed</span></code></a> callback.</p>
<p>All other functions exported by the fb helper library can be used to
implement the fbdev driver interface by the driver.</p>
<p>It is possible, though perhaps somewhat tricky, to implement race-free
hotplug detection using the fbdev helpers. The <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_prepare()</span></code></a>
helper must be called first to initialize the minimum required to make
hotplug detection work. Drivers also need to make sure to properly set up
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.funcs</span></code></a> member. After calling <a class="reference internal" href="#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_init()</span></code></a>
it is safe to enable interrupts and start processing hotplug events. At the
same time, drivers should initialize all modeset objects such as CRTCs,
encoders and connectors. To finish up the fbdev helper initialization, the
<a class="reference internal" href="#c.drm_fb_helper_init" title="drm_fb_helper_init"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_init()</span></code></a> function is called. To probe for all attached displays
and set up an initial configuration using the detected hardware, drivers
should call <a class="reference internal" href="#c.drm_fb_helper_single_add_all_connectors" title="drm_fb_helper_single_add_all_connectors"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_single_add_all_connectors()</span></code></a> followed by
<a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_initial_config()</span></code></a>.</p>
<p>If <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> is set, the
drm_fb_helper_{cfb,sys}_{write,fillrect,copyarea,imageblit} functions will
accumulate changes and schedule <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper.dirty_work</span></code></a> to run right
away. This worker then calls the <code class="xref c c-func docutils literal"><span class="pre">dirty()</span></code> function ensuring that it will
always run in process context since the fb_*() function could be running in
atomic context. If <a class="reference internal" href="#c.drm_fb_helper_deferred_io" title="drm_fb_helper_deferred_io"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_deferred_io()</span></code></a> is used as the deferred_io
callback it will also schedule dirty_work with the damage collected from the
mmap page writes.</p>
<dl class="type">
<dt id="c.drm_fb_helper_surface_size">
struct <code class="descname">drm_fb_helper_surface_size</code><a class="headerlink" href="#c.drm_fb_helper_surface_size" title="Permalink to this definition">¶</a></dt>
<dd><p>describes fbdev size and scanout surface size</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_fb_helper_surface_size {
  u32 fb_width;
  u32 fb_height;
  u32 surface_width;
  u32 surface_height;
  u32 surface_bpp;
  u32 surface_depth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_width</span></code></dt>
<dd>fbdev width</dd>
<dt><code class="docutils literal"><span class="pre">fb_height</span></code></dt>
<dd>fbdev height</dd>
<dt><code class="docutils literal"><span class="pre">surface_width</span></code></dt>
<dd>scanout buffer width</dd>
<dt><code class="docutils literal"><span class="pre">surface_height</span></code></dt>
<dd>scanout buffer height</dd>
<dt><code class="docutils literal"><span class="pre">surface_bpp</span></code></dt>
<dd>scanout buffer bpp</dd>
<dt><code class="docutils literal"><span class="pre">surface_depth</span></code></dt>
<dd>scanout buffer depth</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the scanout surface width/height may be larger than the fbdev
width/height.  In case of multiple displays, the scanout surface is sized
according to the largest width/height (so it is large enough for all CRTCs
to scanout).  But the fbdev width/height is sized to the minimum width/
height of all the displays.  This ensures that fbcon fits on the smallest
of the attached displays.</p>
<p>So what is passed to <a class="reference internal" href="#c.drm_fb_helper_fill_var" title="drm_fb_helper_fill_var"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fill_var()</span></code></a> should be fb_width/fb_height,
rather than the surface size.</p>
<dl class="type">
<dt id="c.drm_fb_helper_funcs">
struct <code class="descname">drm_fb_helper_funcs</code><a class="headerlink" href="#c.drm_fb_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver callbacks for the fbdev emulation library</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_fb_helper_funcs {
  void (* gamma_set) (struct drm_crtc *crtc, u16 red, u16 green,u16 blue, int regno);
  void (* gamma_get) (struct drm_crtc *crtc, u16 *red, u16 *green,u16 *blue, int regno);
  int (* fb_probe) (struct drm_fb_helper *helper,struct drm_fb_helper_surface_size *sizes);
  bool (* initial_config) (struct drm_fb_helper *fb_helper,struct drm_fb_helper_crtc **crtcs,struct drm_display_mode **modes,struct drm_fb_offset *offsets,bool *enabled, int width, int height);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gamma_set</span></code></dt>
<dd><p class="first">Set the given gamma LUT register on the given CRTC.</p>
<p>This callback is optional.</p>
<p>FIXME:</p>
<p class="last">This callback is functionally redundant with the core gamma table
support and simply exists because the fbdev hasn&#8217;t yet been
refactored to use the core gamma table interfaces.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gamma_get</span></code></dt>
<dd><p class="first">Read the given gamma LUT register on the given CRTC, used to save the
current LUT when force-restoring the fbdev for e.g. kdbg.</p>
<p>This callback is optional.</p>
<p>FIXME:</p>
<p class="last">This callback is functionally redundant with the core gamma table
support and simply exists because the fbdev hasn&#8217;t yet been
refactored to use the core gamma table interfaces.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">fb_probe</span></code></dt>
<dd><p class="first">Driver callback to allocate and initialize the fbdev info structure.
Furthermore it also needs to allocate the DRM framebuffer used to
back the fbdev.</p>
<p>This callback is mandatory.</p>
<p>RETURNS:</p>
<p class="last">The driver should return 0 on success and a negative error code on
failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">initial_config</span></code></dt>
<dd><p class="first">Driver callback to setup an initial fbdev display configuration.
Drivers can use this callback to tell the fbdev emulation what the
preferred initial configuration is. This is useful to implement
smooth booting where the fbdev (and subsequently all userspace) never
changes the mode, but always inherits the existing configuration.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">The driver should return true if a suitable initial configuration has
been filled out and false when the fbdev helper should fall back to
the default probing logic.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver callbacks used by the fbdev emulation helper library.</p>
<dl class="type">
<dt id="c.drm_fb_helper">
struct <code class="descname">drm_fb_helper</code><a class="headerlink" href="#c.drm_fb_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>main structure to emulate fbdev on top of KMS</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_fb_helper {
  struct drm_framebuffer * fb;
  struct drm_device * dev;
  int crtc_count;
  struct drm_fb_helper_crtc * crtc_info;
  int connector_count;
  int connector_info_alloc_count;
  struct drm_fb_helper_connector ** connector_info;
  const struct drm_fb_helper_funcs * funcs;
  struct fb_info * fbdev;
  u32 pseudo_palette;
  struct drm_clip_rect dirty_clip;
  spinlock_t dirty_lock;
  struct work_struct dirty_work;
  struct work_struct resume_work;
  struct list_head kernel_fb_list;
  bool delayed_hotplug;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Scanout framebuffer object</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">crtc_count</span></code></dt>
<dd>number of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">crtc_info</span></code></dt>
<dd>per-CRTC helper state (mode, x/y offset, etc)</dd>
<dt><code class="docutils literal"><span class="pre">connector_count</span></code></dt>
<dd>number of connected connectors</dd>
<dt><code class="docutils literal"><span class="pre">connector_info_alloc_count</span></code></dt>
<dd>size of connector_info</dd>
<dt><code class="docutils literal"><span class="pre">connector_info</span></code></dt>
<dd>array of per-connector information</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>driver callbacks for fb helper</dd>
<dt><code class="docutils literal"><span class="pre">fbdev</span></code></dt>
<dd>emulated fbdev device info struct</dd>
<dt><code class="docutils literal"><span class="pre">pseudo_palette</span></code></dt>
<dd>fake palette of 16 colors</dd>
<dt><code class="docutils literal"><span class="pre">dirty_clip</span></code></dt>
<dd>clip rectangle used with deferred_io to accumulate damage to
the screen buffer</dd>
<dt><code class="docutils literal"><span class="pre">dirty_lock</span></code></dt>
<dd>spinlock protecting <strong>dirty_clip</strong></dd>
<dt><code class="docutils literal"><span class="pre">dirty_work</span></code></dt>
<dd>worker used to flush the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">resume_work</span></code></dt>
<dd>worker used during resume if the console lock is already taken</dd>
<dt><code class="docutils literal"><span class="pre">kernel_fb_list</span></code></dt>
<dd>Entry on the global kernel_fb_helper_list, used for kgdb entry/exit.</dd>
<dt><code class="docutils literal"><span class="pre">delayed_hotplug</span></code></dt>
<dd>A hotplug was received while fbdev wasn&#8217;t in control of the DRM
device, i.e. another KMS master was active. The output configuration
needs to be reprobe when fbdev is in control again.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main structure used by the fbdev helpers. Drivers supporting
fbdev emulation should embedded this into their overall driver structure.
Drivers must also fill out a <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span></code></a> with a few
operations.</p>
<dl class="function">
<dt id="c.DRM_FB_HELPER_DEFAULT_OPS">
<code class="descname">DRM_FB_HELPER_DEFAULT_OPS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_FB_HELPER_DEFAULT_OPS" title="Permalink to this definition">¶</a></dt>
<dd><p>helper define for drm drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Helper define to register default implementations of drm_fb_helper
functions. To be used in struct fb_ops of drm drivers.</p>
<dl class="function">
<dt id="c.drm_fb_helper_single_add_all_connectors">
int <code class="descname">drm_fb_helper_single_add_all_connectors</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_single_add_all_connectors" title="Permalink to this definition">¶</a></dt>
<dd><p>add all connectors to fbdev emulation helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>fbdev initialized with drm_fb_helper_init</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions adds all the available connectors for use with the given
fb_helper. This is a separate step to allow drivers to freely assign
connectors to the fbdev, e.g. if some are reserved for special purposes or
not adequate to be used for the fbcon.</p>
<p>This function is protected against concurrent connector hotadds/removals
using <code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_add_one_connector()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_remove_one_connector()</span></code>.</p>
<dl class="function">
<dt id="c.drm_fb_helper_debug_enter">
int <code class="descname">drm_fb_helper_debug_enter</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_debug_enter</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_debug_leave">
int <code class="descname">drm_fb_helper_debug_leave</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_leave" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_debug_leave</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_restore_fbdev_mode_unlocked">
int <code class="descname">drm_fb_helper_restore_fbdev_mode_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>restore fbdev configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>fbcon to restore</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from driver&#8217;s drm <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.lastclose</span></code></a> callback
when implementing an fbcon on top of kms using this helper. This ensures that
the user isn&#8217;t greeted with a black screen when e.g. X dies.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, negative error code otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_blank">
int <code class="descname">drm_fb_helper_blank</code><span class="sig-paren">(</span>int<em>&nbsp;blank</em>, struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_blank" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_blank</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">blank</span></code></dt>
<dd>desired blanking state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_prepare">
void <code class="descname">drm_fb_helper_prepare</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;helper</em>, const struct <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs">drm_fb_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a drm_fb_helper structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">helper</span></code></dt>
<dd>driver-allocated fbdev helper structure to set up</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>pointer to structure of functions associate with this helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the bare minimum to make the framebuffer helper usable. This is
useful to implement race-free initialization of the polling helpers.</p>
<dl class="function">
<dt id="c.drm_fb_helper_init">
int <code class="descname">drm_fb_helper_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em>, int<em>&nbsp;max_conn_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper structure to initialize</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_conn_count</span></code></dt>
<dd>max connector count</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates the structures for the fbdev helper with the given limits.
Note that this won&#8217;t yet touch the hardware (through the driver interfaces)
nor register the fbdev. This is only done in <a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_initial_config()</span></code></a>
to allow driver writes more control over the exact init sequence.</p>
<p>Drivers must call <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_prepare()</span></code></a> before calling this function.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_alloc_fbi">
struct fb_info * <code class="descname">drm_fb_helper_alloc_fbi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_alloc_fbi" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate fb_info and some of its members</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to alloc fb_info and the members cmap and apertures. Called
by the driver within the fb_probe fb_helper callback function. Drivers do not
need to release the allocated fb_info structure themselves, this is
automatically done when calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>fb_info pointer if things went okay, pointer containing error code
otherwise</p>
<dl class="function">
<dt id="c.drm_fb_helper_unregister_fbi">
void <code class="descname">drm_fb_helper_unregister_fbi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_unregister_fbi" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister fb_info framebuffer device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around unregister_framebuffer, to release the fb_info
framebuffer device. This must be called before releasing all resources for
<strong>fb_helper</strong> by calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fb_helper_fini">
void <code class="descname">drm_fb_helper_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>This cleans up all remaining resources associated with <strong>fb_helper</strong>. Must be
called after <a class="reference internal" href="#c.drm_fb_helper_unlink_fbi" title="drm_fb_helper_unlink_fbi"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_unlink_fbi()</span></code></a> was called.</p>
<dl class="function">
<dt id="c.drm_fb_helper_unlink_fbi">
void <code class="descname">drm_fb_helper_unlink_fbi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_unlink_fbi" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around unlink_framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around unlink_framebuffer implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_deferred_io">
void <code class="descname">drm_fb_helper_deferred_io</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, struct list_head *<em>&nbsp;pagelist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_deferred_io" title="Permalink to this definition">¶</a></dt>
<dd><p>fbdev deferred_io callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fb_info struct pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pagelist</span></code></dt>
<dd>list of dirty mmap framebuffer pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used as the <code class="xref c c-type docutils literal"><span class="pre">fb_deferred_io.deferred_io</span></code>
callback function for flushing the fbdev mmap writes.</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_read">
ssize_t <code class="descname">drm_fb_helper_sys_read</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, char __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_read" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_sys_read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fb_info struct pointer</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>userspace buffer to read from framebuffer memory</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read from framebuffer memory</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>read offset within framebuffer memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_sys_read implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_write">
ssize_t <code class="descname">drm_fb_helper_sys_write</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const char __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_write" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_sys_write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fb_info struct pointer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>userspace buffer to write to framebuffer memory</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to write to framebuffer memory</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>write offset within framebuffer memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_sys_write implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_fillrect">
void <code class="descname">drm_fb_helper_sys_fillrect</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_fillrect *<em>&nbsp;rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_fillrect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*</span> <span class="pre">rect</span></code></dt>
<dd>info about rectangle to fill</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_fillrect implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_copyarea">
void <code class="descname">drm_fb_helper_sys_copyarea</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_copyarea *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_copyarea</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>info about area to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_copyarea implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_sys_imageblit">
void <code class="descname">drm_fb_helper_sys_imageblit</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_image *<em>&nbsp;image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_imageblit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*</span> <span class="pre">image</span></code></dt>
<dd>info about image to blit</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_imageblit implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_fillrect">
void <code class="descname">drm_fb_helper_cfb_fillrect</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_fillrect *<em>&nbsp;rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_fillrect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*</span> <span class="pre">rect</span></code></dt>
<dd>info about rectangle to fill</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_imageblit implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_copyarea">
void <code class="descname">drm_fb_helper_cfb_copyarea</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_copyarea *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_copyarea</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>info about area to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_copyarea implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_imageblit">
void <code class="descname">drm_fb_helper_cfb_imageblit</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, const struct fb_image *<em>&nbsp;image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_imageblit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*</span> <span class="pre">image</span></code></dt>
<dd>info about image to blit</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_imageblit implemented by fbdev core</p>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend">
void <code class="descname">drm_fb_helper_set_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em>, bool<em>&nbsp;suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt>
<dd>whether to suspend or resume</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_set_suspend implemented by fbdev core.
Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> if you don&#8217;t need to take
the lock yourself</p>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend_unlocked">
void <code class="descname">drm_fb_helper_set_suspend_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em>, bool<em>&nbsp;suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend that also takes the console lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>driver-allocated fbdev helper</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt>
<dd>whether to suspend or resume</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around <a class="reference internal" href="../driver-api/frame-buffer.html#c.fb_set_suspend" title="fb_set_suspend"><code class="xref c c-func docutils literal"><span class="pre">fb_set_suspend()</span></code></a> that takes the console lock. If the lock
isn&#8217;t available on resume, a worker is tasked with waiting for the lock
to become available. The console lock can be pretty contented on resume
due to all the printk activity.</p>
<p>This function can be called multiple times with the same state since
<code class="xref c c-type docutils literal"><span class="pre">fb_info.state</span></code> is checked to see if fbdev is running or not before locking.</p>
<p>Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend" title="drm_fb_helper_set_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_set_suspend()</span></code></a> if you need to take the lock yourself.</p>
<dl class="function">
<dt id="c.drm_fb_helper_setcmap">
int <code class="descname">drm_fb_helper_setcmap</code><span class="sig-paren">(</span>struct fb_cmap *<em>&nbsp;cmap</em>, struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_setcmap" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_setcmap</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_cmap</span> <span class="pre">*</span> <span class="pre">cmap</span></code></dt>
<dd>cmap to set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_ioctl">
int <code class="descname">drm_fb_helper_ioctl</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>legacy ioctl implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl command</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>ioctl argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to implement the standard fbdev ioctl. Only
FBIO_WAITFORVSYNC is implemented for now.</p>
<dl class="function">
<dt id="c.drm_fb_helper_check_var">
int <code class="descname">drm_fb_helper_check_var</code><span class="sig-paren">(</span>struct fb_var_screeninfo *<em>&nbsp;var</em>, struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_check_var" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_check_var</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*</span> <span class="pre">var</span></code></dt>
<dd>screeninfo to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_set_par">
int <code class="descname">drm_fb_helper_set_par</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_par" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_set_par</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will let fbcon do the mode init and is called at initialization time by
the fbdev core when registering the driver, and later on through the hotplug
callback.</p>
<dl class="function">
<dt id="c.drm_fb_helper_pan_display">
int <code class="descname">drm_fb_helper_pan_display</code><span class="sig-paren">(</span>struct fb_var_screeninfo *<em>&nbsp;var</em>, struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_pan_display" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal"><span class="pre">fb_ops.fb_pan_display</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*</span> <span class="pre">var</span></code></dt>
<dd>updated screen information</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
</dl>
<dl class="function">
<dt id="c.drm_fb_helper_fill_fix">
void <code class="descname">drm_fb_helper_fill_fix</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, uint32_t<em>&nbsp;pitch</em>, uint32_t<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fill_fix" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes fixed fbdev information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev registered by the helper</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">pitch</span></code></dt>
<dd>desired pitch</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">depth</span></code></dt>
<dd>desired depth</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to fill in the fixed fbdev information useful for a non-accelerated
fbdev emulations. Drivers which support acceleration methods which impose
additional constraints need to set up their own limits.</p>
<p>Drivers should call this (or their equivalent setup code) from their
<a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_fb_helper_fill_var">
void <code class="descname">drm_fb_helper_fill_var</code><span class="sig-paren">(</span>struct fb_info *<em>&nbsp;info</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em>, uint32_t<em>&nbsp;fb_width</em>, uint32_t<em>&nbsp;fb_height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fill_var" title="Permalink to this definition">¶</a></dt>
<dd><p>initalizes variable fbdev information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>fbdev instance to set up</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>fb helper instance to use as template</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">fb_width</span></code></dt>
<dd>desired fb width</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">fb_height</span></code></dt>
<dd>desired fb height</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the variable fbdev metainformation from the given fb helper instance
and the drm framebuffer allocated in <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper.fb</span></code></a>.</p>
<p>Drivers should call this (or their equivalent setup code) from their
<a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback after having allocated the fbdev
backing storage framebuffer.</p>
<dl class="function">
<dt id="c.drm_fb_helper_initial_config">
int <code class="descname">drm_fb_helper_initial_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em>, int<em>&nbsp;bpp_sel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_initial_config" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a sane initial connector configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>fb_helper device struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bpp_sel</span></code></dt>
<dd>bpp value to use for the framebuffer configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans the CRTCs and connectors and tries to put together an initial setup.
At the moment, this is a cloned configuration across all heads with
a new framebuffer object as the backing store.</p>
<p>Note that this also registers the fbdev and so allows userspace to call into
the driver through the fbdev interfaces.</p>
<p>This function will call down into the <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback
to let the driver allocate and initialize the fbdev info structure and the
drm framebuffer used to back the fbdev. <a class="reference internal" href="#c.drm_fb_helper_fill_var" title="drm_fb_helper_fill_var"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fill_var()</span></code></a> and
<a class="reference internal" href="#c.drm_fb_helper_fill_fix" title="drm_fb_helper_fill_fix"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fill_fix()</span></code></a> are provided as helpers to setup simple default
values for the fbdev info structure.</p>
<p>HANG DEBUGGING:</p>
<p>When you have fbcon support built-in or already loaded, this function will do
a full modeset to setup the fbdev console. Due to locking misdesign in the
VT/fbdev subsystem that entire modeset sequence has to be done while holding
console_lock. Until console_unlock is called no dmesg lines will be sent out
to consoles, not even serial console. This means when your driver crashes,
you will see absolutely nothing else but a system stuck in this function,
with no further output. Any kind of <a class="reference internal" href="../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal"><span class="pre">printk()</span></code></a> you place within your own driver
or in the drm core modeset code will also never show up.</p>
<p>Standard debug practice is to run the fbcon setup without taking the
console_lock as a hack, to be able to see backtraces and crashes on the
serial line. This can be done by setting the fb.lockless_register_fb=1 kernel
cmdline option.</p>
<p>The other option is to just disable fbdev emulation since very likely the
first modeset from userspace will crash in the same way, and is even easier
to debug. This can be done by setting the drm_kms_helper.fbdev_emulation=0
kernel cmdline option.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
<dl class="function">
<dt id="c.drm_fb_helper_hotplug_event">
int <code class="descname">drm_fb_helper_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a> *<em>&nbsp;fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>respond to a hotplug notification by probing all the outputs attached to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*</span> <span class="pre">fb_helper</span></code></dt>
<dd>the drm_fb_helper</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan the connectors attached to the fb_helper and try to put together a
setup after notification of a change in output configuration.</p>
<p>Called at runtime, takes the mode config locks to be able to check/change the
modeset configuration. Must be run from process context (which usually means
either the output polling work or a work item launched from the driver&#8217;s
hotplug interrupt).</p>
<p>Note that drivers may call this even before calling
drm_fb_helper_initial_config but only after drm_fb_helper_init. This allows
for a race-free fbcon setup and will make sure that the fbdev emulation will
not miss any hotplug events.</p>
<p><strong>Return</strong></p>
<p>0 on success and a non-zero error code otherwise.</p>
</div>
<div class="section" id="framebuffer-cma-helper-functions-reference">
<h2>Framebuffer CMA Helper Functions Reference<a class="headerlink" href="#framebuffer-cma-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Provides helper functions for creating a cma (contiguous memory allocator)
backed framebuffer.</p>
<p><a class="reference internal" href="#c.drm_fb_cma_create" title="drm_fb_cma_create"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_cma_create()</span></code></a> is used in the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>
callback function to create a cma backed framebuffer.</p>
<p>An fbdev framebuffer backed by cma is also available by calling
<a class="reference internal" href="#c.drm_fbdev_cma_init" title="drm_fbdev_cma_init"><code class="xref c c-func docutils literal"><span class="pre">drm_fbdev_cma_init()</span></code></a>. <a class="reference internal" href="#c.drm_fbdev_cma_fini" title="drm_fbdev_cma_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_fbdev_cma_fini()</span></code></a> tears it down.
If the <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> callback is set, fb_deferred_io will be
set up automatically. <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> is called by
<a class="reference internal" href="#c.drm_fb_helper_deferred_io" title="drm_fb_helper_deferred_io"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_deferred_io()</span></code></a> in process context (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span></code>).</p>
<p>Example fbdev deferred io code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static int driver_fb_dirty(struct drm_framebuffer *fb,
                           struct drm_file *file_priv,
                           unsigned flags, unsigned color,
                           struct drm_clip_rect *clips,
                           unsigned num_clips)
{
    struct drm_gem_cma_object *cma = drm_fb_cma_get_gem_obj(fb, 0);
    ... push changes ...
    return 0;
}

static struct drm_framebuffer_funcs driver_fb_funcs = {
    .destroy       = drm_fb_cma_destroy,
    .create_handle = drm_fb_cma_create_handle,
    .dirty         = driver_fb_dirty,
};
</pre></div>
</div>
<p>Initialize:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>fbdev = drm_fbdev_cma_init_with_funcs(dev, 16,
                                      dev-&gt;mode_config.num_crtc,
                                      dev-&gt;mode_config.num_connector,
                                      :c:type:`driver_fb_funcs`);
</pre></div>
</div>
<dl class="function">
<dt id="c.drm_fb_cma_create_with_funcs">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="descname">drm_fb_cma_create_with_funcs</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, const struct drm_mode_fb_cmd2 *<em>&nbsp;mode_cmd</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_create_with_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file for the ioctl call</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt>
<dd>metadata from the userspace fb creation request</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>vtable to be used for the new framebuffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to set <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs</span></code></a> for drivers that need the
<a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> callback. Use <a class="reference internal" href="#c.drm_fb_cma_create" title="drm_fb_cma_create"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_cma_create()</span></code></a> if you don&#8217;t
need to change <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fb_cma_create">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="descname">drm_fb_cma_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, const struct drm_mode_fb_cmd2 *<em>&nbsp;mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_create" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file for the ioctl call</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt>
<dd>metadata from the userspace fb creation request</dd>
</dl>
<p><strong>Description</strong></p>
<p>If your hardware has special alignment or pitch requirements these should be
checked before calling this function. Use <a class="reference internal" href="#c.drm_fb_cma_create_with_funcs" title="drm_fb_cma_create_with_funcs"><code class="xref c c-func docutils literal"><span class="pre">drm_fb_cma_create_with_funcs()</span></code></a> if
you need to set <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_fb_cma_get_gem_obj">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_cma_object" title="drm_gem_cma_object">drm_gem_cma_object</a> * <code class="descname">drm_fb_cma_get_gem_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, unsigned int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_get_gem_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get CMA GEM object for framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>The framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>Which plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the CMA GEM object for given framebuffer.</p>
<p>This function will usually be called from the CRTC callback functions.</p>
<dl class="function">
<dt id="c.drm_fb_cma_get_gem_addr">
dma_addr_t <code class="descname">drm_fb_cma_get_gem_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, unsigned int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_get_gem_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get physical address for framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>The framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>Which state of drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>Which plane
Return the CMA GEM address for given framebuffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will usually be called from the PLANE callback functions.</p>
<dl class="function">
<dt id="c.drm_fb_cma_prepare_fb">
int <code class="descname">drm_fb_cma_prepare_fb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_prepare_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare CMA framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>Which plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>Plane state attach fence to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be set as the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a>.prepare_fb hook.</p>
<p>This function checks if the plane FB has an dma-buf attached, extracts
the exclusive fence and attaches it to plane state for the atomic helper
to wait on.</p>
<p>There is no need for cleanup_fb for CMA based framebuffer drivers.</p>
<dl class="function">
<dt id="c.drm_fb_cma_debugfs_show">
int <code class="descname">drm_fb_cma_debugfs_show</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_cma_debugfs_show" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to list CMA framebuffer objects in debugfs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>output file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>private data for the callback</dd>
</dl>
<dl class="function">
<dt id="c.drm_fbdev_cma_init_with_funcs">
struct drm_fbdev_cma * <code class="descname">drm_fbdev_cma_init_with_funcs</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;preferred_bpp</em>, unsigned int<em>&nbsp;max_conn_count</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_init_with_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initializes a drm_fbdev_cma struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">preferred_bpp</span></code></dt>
<dd>Preferred bits per pixel for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_conn_count</span></code></dt>
<dd>Maximum number of connectors</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>fb helper functions, in particular a custom <code class="xref c c-func docutils literal"><span class="pre">dirty()</span></code> callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a newly allocated drm_fbdev_cma struct or a ERR_PTR.</p>
<dl class="function">
<dt id="c.drm_fbdev_cma_init">
struct drm_fbdev_cma * <code class="descname">drm_fbdev_cma_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;preferred_bpp</em>, unsigned int<em>&nbsp;max_conn_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initializes a drm_fbdev_cma struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">preferred_bpp</span></code></dt>
<dd>Preferred bits per pixel for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_conn_count</span></code></dt>
<dd>Maximum number of connectors</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a newly allocated drm_fbdev_cma struct or a ERR_PTR.</p>
<dl class="function">
<dt id="c.drm_fbdev_cma_fini">
void <code class="descname">drm_fbdev_cma_fini</code><span class="sig-paren">(</span>struct drm_fbdev_cma *<em>&nbsp;fbdev_cma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>Free drm_fbdev_cma struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fbdev_cma</span> <span class="pre">*</span> <span class="pre">fbdev_cma</span></code></dt>
<dd>The drm_fbdev_cma struct</dd>
</dl>
<dl class="function">
<dt id="c.drm_fbdev_cma_restore_mode">
void <code class="descname">drm_fbdev_cma_restore_mode</code><span class="sig-paren">(</span>struct drm_fbdev_cma *<em>&nbsp;fbdev_cma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_restore_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Restores initial framebuffer mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fbdev_cma</span> <span class="pre">*</span> <span class="pre">fbdev_cma</span></code></dt>
<dd>The drm_fbdev_cma struct, may be NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is usually called from the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.lastclose</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_fbdev_cma_hotplug_event">
void <code class="descname">drm_fbdev_cma_hotplug_event</code><span class="sig-paren">(</span>struct drm_fbdev_cma *<em>&nbsp;fbdev_cma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll for hotpulug events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fbdev_cma</span> <span class="pre">*</span> <span class="pre">fbdev_cma</span></code></dt>
<dd>The drm_fbdev_cma struct, may be NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is usually called from the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.output_poll_changed</span></code></a>
callback.</p>
<dl class="function">
<dt id="c.drm_fbdev_cma_set_suspend">
void <code class="descname">drm_fbdev_cma_set_suspend</code><span class="sig-paren">(</span>struct drm_fbdev_cma *<em>&nbsp;fbdev_cma</em>, int<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_set_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around drm_fb_helper_set_suspend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fbdev_cma</span> <span class="pre">*</span> <span class="pre">fbdev_cma</span></code></dt>
<dd>The drm_fbdev_cma struct, may be NULL</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">state</span></code></dt>
<dd>desired state, zero to resume, non-zero to suspend</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls drm_fb_helper_set_suspend, which is a wrapper around
fb_set_suspend implemented by fbdev core.</p>
<dl class="function">
<dt id="c.drm_fbdev_cma_set_suspend_unlocked">
void <code class="descname">drm_fbdev_cma_set_suspend_unlocked</code><span class="sig-paren">(</span>struct drm_fbdev_cma *<em>&nbsp;fbdev_cma</em>, int<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_cma_set_suspend_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around drm_fb_helper_set_suspend_unlocked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_fbdev_cma</span> <span class="pre">*</span> <span class="pre">fbdev_cma</span></code></dt>
<dd>The drm_fbdev_cma struct, may be NULL</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">state</span></code></dt>
<dd>desired state, zero to resume, non-zero to suspend</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls drm_fb_helper_set_suspend, which is a wrapper around
fb_set_suspend implemented by fbdev core.</p>
</div>
<div class="section" id="bridges">
<span id="drm-bridges"></span><h2>Bridges<a class="headerlink" href="#bridges" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a> represents a device that hangs on to an encoder. These are
handy when a regular <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> entity isn&#8217;t enough to represent the entire
encoder chain.</p>
<p>A bridge is always attached to a single <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> at a time, but can be
either connected to it directly, or through an intermediate bridge:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>encoder ---&gt; bridge B ---&gt; bridge A
</pre></div>
</div>
<p>Here, the output of the encoder feeds to bridge B, and that furthers feeds to
bridge A.</p>
<p>The driver using the bridge is responsible to make the associations between
the encoder and bridges. Once these links are made, the bridges will
participate along with encoder functions to perform mode_set/enable/disable
through the ops provided in <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs</span></code></a>.</p>
<p>drm_bridge, like drm_panel, aren&#8217;t drm_mode_object entities like planes,
CRTCs, encoders or connectors and hence are not visible to userspace. They
just provide additional hooks to get the desired output at the end of the
encoder chain.</p>
<p>Bridges can also be chained up using the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge.next</span></code></a> pointer.</p>
<p>Both legacy CRTC helpers and the new atomic modeset helpers support bridges.</p>
</div>
<div class="section" id="default-bridge-callback-sequence">
<h3>Default bridge callback sequence<a class="headerlink" href="#default-bridge-callback-sequence" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs</span></code></a> ops are populated by the bridge driver. The DRM
internals (atomic and CRTC helpers) use the helpers defined in drm_bridge.c
These helpers call a specific <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs</span></code></a> op for all the bridges
during encoder configuration.</p>
<p>For detailed specification of the bridge callbacks see <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs</span></code></a>.</p>
</div>
<div class="section" id="bridge-helper-reference">
<h3>Bridge Helper Reference<a class="headerlink" href="#bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_bridge_funcs">
struct <code class="descname">drm_bridge_funcs</code><a class="headerlink" href="#c.drm_bridge_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>drm_bridge control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_bridge_funcs {
  int (* attach) (struct drm_bridge *bridge);
  void (* detach) (struct drm_bridge *bridge);
  enum drm_mode_status (* mode_valid) (struct drm_bridge *crtc,const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_bridge *bridge,const struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode);
  void (* disable) (struct drm_bridge *bridge);
  void (* post_disable) (struct drm_bridge *bridge);
  void (* mode_set) (struct drm_bridge *bridge,struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode);
  void (* pre_enable) (struct drm_bridge *bridge);
  void (* enable) (struct drm_bridge *bridge);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">attach</span></code></dt>
<dd><p class="first">This callback is invoked whenever our bridge is being attached to a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>.</p>
<p>The attach callback is optional.</p>
<p>RETURNS:</p>
<p class="last">Zero on success, error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd><p class="first">This callback is invoked whenever our bridge is being detached from a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>.</p>
<p class="last">The detach callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
bridge. This should be implemented if the bridge has some sort of
restriction in the modes it can display. For example, a given bridge
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate and adjust a mode. The paramater
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> or the next
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>. The parameter adjusted_mode is the input mode the bridge
requires. It can be modified by this callback and does not need to
match mode. See also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This is the only hook that allows a bridge to reject a modeset. If
this function passes all other callbacks must succeed for this
configuration.</p>
<p>The mode_fixup callback is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Drivers MUST
NOT touch any persistent state (hardware or software) or data
structures except the passed in <strong>state</strong> parameter.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any bridge constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it&#8217;s called before that
bridge&#8217;s <strong>disable</strong> vfunc. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>
it&#8217;s called right before the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>,
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a> or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a>
hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p class="last">The disable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">post_disable</span></code></dt>
<dd><p class="first">This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it&#8217;s called after that bridge&#8217;s
<strong>post_disable</strong> function. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>
it&#8217;s called right after the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a>
or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
singals) feeding it is no longer running when this callback is
called.</p>
<p class="last">The post_disable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd>This callback should set the given mode on the bridge. It is called
after the <strong>mode_set</strong> callback for the preceding element in the display
pipeline has been called already. If the bridge is the first element
then this would be <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_set</span></code></a>. The display
pipe (i.e.  clocks and timing signals) is off when this function is
called.</dd>
<dt><code class="docutils literal"><span class="pre">pre_enable</span></code></dt>
<dd><p class="first">This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it&#8217;s called before that
bridge&#8217;s <strong>pre_enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> it&#8217;s called right before the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p class="last">The pre_enable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd><p class="first">This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it&#8217;s called after that
bridge&#8217;s <strong>enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> it&#8217;s called right after the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p class="last">The enable callback is optional.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge">
struct <code class="descname">drm_bridge</code><a class="headerlink" href="#c.drm_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM bridge control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_bridge {
  struct drm_device * dev;
  struct drm_encoder * encoder;
  struct drm_bridge * next;
#ifdef CONFIG_OF
  struct device_node * of_node;
#endif
  struct list_head list;
  const struct drm_bridge_funcs * funcs;
  void * driver_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this bridge belongs to</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>encoder to which this bridge is connected</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd>the next bridge in the encoder chain</dd>
<dt><code class="docutils literal"><span class="pre">of_node</span></code></dt>
<dd>device node pointer to the bridge</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>to keep track of all added bridges</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>control functions</dd>
<dt><code class="docutils literal"><span class="pre">driver_private</span></code></dt>
<dd>pointer to the bridge driver&#8217;s internal context</dd>
</dl>
<dl class="function">
<dt id="c.drm_bridge_add">
int <code class="descname">drm_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the given bridge to the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>Unconditionally returns Zero.</p>
<dl class="function">
<dt id="c.drm_bridge_remove">
void <code class="descname">drm_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given bridge from the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<dl class="function">
<dt id="c.drm_bridge_attach">
int <code class="descname">drm_bridge_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;previous</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach the bridge to an encoder&#8217;s chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>DRM encoder</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">previous</span></code></dt>
<dd>previous bridge in the chain (optional)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a kms driver to link the bridge to an encoder&#8217;s chain. The previous
argument specifies the previous bridge in the chain. If NULL, the bridge is
linked directly at the encoder&#8217;s output. Otherwise it is linked at the
previous bridge&#8217;s output.</p>
<p>If non-NULL the previous bridge must be already attached by a call to this
function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_bridge_mode_fixup">
bool <code class="descname">drm_bridge_mode_fixup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_mode_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>fixup proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>desired mode to be set for the bridge</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">adjusted_mode</span></code></dt>
<dd>updated mode that works for this bridge</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<p><strong>Return</strong></p>
<p>true on success, false on failure</p>
<dl class="function">
<dt id="c.drm_bridge_mode_valid">
enum <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_bridge_mode_valid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_mode_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the mode against all bridges in the encoder chain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>desired mode to be validated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> for all the bridges in the encoder
chain, starting from the first bridge to the last. If at least one bridge
does not accept the mode the function returns the error code.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder.</p>
<p><strong>Return</strong></p>
<p>MODE_OK on success, drm_mode_status Enum error code on failure</p>
<dl class="function">
<dt id="c.drm_bridge_disable">
void <code class="descname">drm_bridge_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.disable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called before
calling the encoder&#8217;s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_post_disable">
void <code class="descname">drm_bridge_post_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_post_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up after disabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.post_disable</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last. These are called
after completing the encoder&#8217;s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_mode_set">
void <code class="descname">drm_bridge_mode_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>desired mode to be set for the bridge</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">adjusted_mode</span></code></dt>
<dd>updated mode that works for this bridge</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_set</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_pre_enable">
void <code class="descname">drm_bridge_pre_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_pre_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares for enabling all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called
before calling the encoder&#8217;s commit op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.drm_bridge_enable">
void <code class="descname">drm_bridge_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enables all bridges in the encoder chain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>bridge control structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.enable</span></code></a> op for all the bridges in the encoder
chain, starting from the first bridge to the last. These are called
after completing the encoder&#8217;s commit op.</p>
<p>Note that the bridge passed should be the one closest to the encoder</p>
<dl class="function">
<dt id="c.of_drm_find_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="descname">of_drm_find_bridge</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bridge corresponding to the device node in the global bridge list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device node</dd>
</dl>
<p><strong>Return</strong></p>
<p>drm_bridge control struct on success, NULL on failure</p>
</div>
<div class="section" id="panel-bridge-helper-reference">
<h3>Panel-Bridge Helper Reference<a class="headerlink" href="#panel-bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="descname">drm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em>, u32<em>&nbsp;connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a drm_bridge and drm_connector that just calls the appropriate functions from drm_panel.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>The drm_panel being wrapped.  Must be non-NULL.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">connector_type</span></code></dt>
<dd>The DRM_MODE_CONNECTOR_* for the connector to be
created.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For drivers converting from directly using drm_panel: The expected
usage pattern is that during either encoder module probe or DSI
host attach, a drm_panel will be looked up through
<code class="xref c c-func docutils literal"><span class="pre">drm_of_find_panel_or_bridge()</span></code>.  <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_bridge_add()</span></code></a> is used to
wrap that panel in the new bridge, and the result can then be
passed to <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal"><span class="pre">drm_bridge_attach()</span></code></a>.  The <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_prepare()</span></code></a> and related
functions can be dropped from the encoder driver (they&#8217;re now
called by the KMS helpers before calling into the encoder), along
with connector creation.  When done with the bridge,
<code class="xref c c-func docutils literal"><span class="pre">drm_bridge_detach()</span></code> should be called as normal, then
<a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_bridge_remove()</span></code></a> to free it.</p>
<dl class="function">
<dt id="c.drm_panel_bridge_remove">
void <code class="descname">drm_panel_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> *<em>&nbsp;bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters and frees a drm_bridge created by <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_bridge_add()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*</span> <span class="pre">bridge</span></code></dt>
<dd>The drm_bridge being freed.</dd>
</dl>
</div>
</div>
<div class="section" id="panel-helper-reference">
<span id="drm-panel-helper"></span><h2>Panel Helper Reference<a class="headerlink" href="#panel-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>The DRM panel helpers allow drivers to register panel objects with a
central registry and provide functions to retrieve those panels in display
drivers.</p>
<dl class="type">
<dt id="c.drm_panel_funcs">
struct <code class="descname">drm_panel_funcs</code><a class="headerlink" href="#c.drm_panel_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>perform operations on a given panel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_panel_funcs {
  int (* disable) (struct drm_panel *panel);
  int (* unprepare) (struct drm_panel *panel);
  int (* prepare) (struct drm_panel *panel);
  int (* enable) (struct drm_panel *panel);
  int (* get_modes) (struct drm_panel *panel);
  int (* get_timings) (struct drm_panel *panel, unsigned int num_timings,struct display_timing *timings);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>disable panel (turn off back light, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">unprepare</span></code></dt>
<dd>turn off panel</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd>turn on panel and perform set up</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>enable panel (turn on back light, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">get_modes</span></code></dt>
<dd>add modes to the connector that the panel is attached to and
return the number of modes added</dd>
<dt><code class="docutils literal"><span class="pre">get_timings</span></code></dt>
<dd>copy display timings into the provided array and return
the number of display timings available</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .:c:func:<cite>prepare()</cite> function is typically called before the display controller
starts to transmit video data. Panel drivers can use this to turn the panel
on and wait for it to become ready. If additional configuration is required
(via a control bus such as I2C, SPI or DSI for example) this is a good time
to do that.</p>
<p>After the display controller has started transmitting video data, it&#8217;s safe
to call the .:c:func:<cite>enable()</cite> function. This will typically enable the backlight to
make the image on screen visible. Some panels require a certain amount of
time or frames before the image is displayed. This function is responsible
for taking this into account before enabling the backlight to avoid visual
glitches.</p>
<p>Before stopping video transmission from the display controller it can be
necessary to turn off the panel to avoid visual glitches. This is done in
the .:c:func:<cite>disable()</cite> function. Analogously to .:c:func:<cite>enable()</cite> this typically involves
turning off the backlight and waiting for some time to make sure no image
is visible on the panel. It is then safe for the display controller to
cease transmission of video data.</p>
<p>To save power when no video data is transmitted, a driver can power down
the panel. This is the job of the .:c:func:<cite>unprepare()</cite> function.</p>
<dl class="type">
<dt id="c.drm_panel">
struct <code class="descname">drm_panel</code><a class="headerlink" href="#c.drm_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM panel object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_panel {
  struct drm_device * drm;
  struct drm_connector * connector;
  struct device * dev;
  const struct drm_panel_funcs * funcs;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">drm</span></code></dt>
<dd>DRM device owning the panel</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>DRM connector that the panel is attached to</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent device of the panel</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>operations that can be performed on the panel</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>panel entry in registry</dd>
</dl>
<dl class="function">
<dt id="c.drm_panel_unprepare">
int <code class="descname">drm_panel_unprepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power off a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will completely power off a panel (assert the panel&#8217;s
reset, turn off power supplies, ...). After this function has completed, it
is usually no longer possible to communicate with the panel until another
call to <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_prepare()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_disable">
int <code class="descname">drm_panel_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will typically turn off the panel&#8217;s backlight or disable the display
drivers. For smart panels it should still be possible to communicate with
the integrated circuitry via any command bus after this call.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_prepare">
int <code class="descname">drm_panel_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power on a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will enable power and deassert any reset signals to
the panel. After this has completed it is possible to communicate with any
integrated circuitry via a command bus.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_enable">
int <code class="descname">drm_panel_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the panel display drivers to be turned on
and the backlight to be enabled. Content will be visible on screen after
this call completes.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_get_modes">
int <code class="descname">drm_panel_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>probe the available display modes of a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>The modes probed from the panel are automatically added to the connector
that the panel is attached to.</p>
<p><strong>Return</strong></p>
<p>The number of modes available from the panel on success or a
negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_init">
void <code class="descname">drm_panel_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up internal fields of the panel so that it can subsequently be added
to the registry.</p>
<dl class="function">
<dt id="c.drm_panel_add">
int <code class="descname">drm_panel_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a panel to the global registry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>panel to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a panel to the global registry so that it can be looked up by display
drivers.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_remove">
void <code class="descname">drm_panel_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a panel from the global registry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a panel from the global registry.</p>
<dl class="function">
<dt id="c.drm_panel_attach">
int <code class="descname">drm_panel_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a panel to a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>After obtaining a pointer to a DRM panel a display driver calls this
function to attach a panel to a connector.</p>
<p>An error is returned if the panel is already attached to another connector.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_detach">
int <code class="descname">drm_panel_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a panel from a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detaches a panel from the connector it is attached to. If a panel is not
attached to any connector this is effectively a no-op.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.of_drm_find_panel">
struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> * <code class="descname">of_drm_find_panel</code><span class="sig-paren">(</span>const struct device_node *<em>&nbsp;np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a panel using a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device tree node of the panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the set of registered panels for one that matches the given device
tree node. If a matching panel is found, return a pointer to it.</p>
<p><strong>Return</strong></p>
<p>A pointer to the panel registered for the specified device tree
node or NULL if no panel matching the device tree node can be found.</p>
</div>
<div class="section" id="display-port-helper-functions-reference">
<h2>Display Port Helper Functions Reference<a class="headerlink" href="#display-port-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers at various abstraction
levels to deal with Display Port sink devices and related things like DP aux
channel transfers, EDID reading over DP aux channels, decoding certain DPCD
blocks, ...</p>
<p>The DisplayPort AUX channel is an abstraction to allow generic, driver-
independent access to AUX functionality. Drivers can take advantage of
this by filling in the fields of the drm_dp_aux structure.</p>
<p>Transactions are described using a hardware-independent drm_dp_aux_msg
structure, which is passed into a driver&#8217;s .:c:func:<cite>transfer()</cite> implementation.
Both native and I2C-over-AUX transactions are supported.</p>
<dl class="type">
<dt id="c.drm_dp_aux_msg">
struct <code class="descname">drm_dp_aux_msg</code><a class="headerlink" href="#c.drm_dp_aux_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel transaction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_aux_msg {
  unsigned int address;
  u8 request;
  u8 reply;
  void * buffer;
  size_t size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">address</span></code></dt>
<dd>address of the (first) register to access</dd>
<dt><code class="docutils literal"><span class="pre">request</span></code></dt>
<dd>contains the type of transaction (see DP_AUX_* macros)</dd>
<dt><code class="docutils literal"><span class="pre">reply</span></code></dt>
<dd>upon completion, contains the reply type of the transaction</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>pointer to a transmission or reception buffer</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of <strong>buffer</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_aux">
struct <code class="descname">drm_dp_aux</code><a class="headerlink" href="#c.drm_dp_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_aux {
  const char * name;
  struct i2c_adapter ddc;
  struct device * dev;
  struct drm_crtc * crtc;
  struct mutex hw_mutex;
  struct work_struct crc_work;
  u8 crc_count;
  ssize_t (* transfer) (struct drm_dp_aux *aux,struct drm_dp_aux_msg *msg);
  unsigned i2c_nack_count;
  unsigned i2c_defer_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>user-visible name of this AUX channel and the I2C-over-AUX adapter</dd>
<dt><code class="docutils literal"><span class="pre">ddc</span></code></dt>
<dd>I2C adapter that can be used for I2C-over-AUX communication</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>pointer to struct device that is the parent for this AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>backpointer to the crtc that is currently using this AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">hw_mutex</span></code></dt>
<dd>internal mutex used for locking transfers</dd>
<dt><code class="docutils literal"><span class="pre">crc_work</span></code></dt>
<dd>worker that captures CRCs for each frame</dd>
<dt><code class="docutils literal"><span class="pre">crc_count</span></code></dt>
<dd>counter of captured frame CRCs</dd>
<dt><code class="docutils literal"><span class="pre">transfer</span></code></dt>
<dd>transfers a message representing a single AUX transaction</dd>
<dt><code class="docutils literal"><span class="pre">i2c_nack_count</span></code></dt>
<dd>Counts I2C NACKs, used for DP validation.</dd>
<dt><code class="docutils literal"><span class="pre">i2c_defer_count</span></code></dt>
<dd>Counts I2C DEFERs, used for DP validation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .dev field should be set to a pointer to the device that implements
the AUX channel.</p>
<p>The .name field may be used to specify the name of the I2C adapter. If set to
NULL, <code class="xref c c-func docutils literal"><span class="pre">dev_name()</span></code> of .dev will be used.</p>
<p>Drivers provide a hardware-specific implementation of how transactions
are executed via the .:c:func:<cite>transfer()</cite> function. A pointer to a drm_dp_aux_msg
structure describing the transaction is passed into this function. Upon
success, the implementation should return the number of payload bytes
that were transferred, or a negative error-code on failure. Helpers
propagate errors from the .:c:func:<cite>transfer()</cite> function, with the exception of
the -EBUSY error, which causes a transaction to be retried. On a short,
helpers will return -EPROTO to make it simpler to check for failure.</p>
<p>An AUX channel can also be used to transport I2C messages to a sink. A
typical application of that is to access an EDID that&#8217;s present in the
sink device. The .:c:func:<cite>transfer()</cite> function can also be used to execute such
transactions. The <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_register()</span></code></a> function registers an I2C
adapter that can be passed to <a class="reference internal" href="#c.drm_probe_ddc" title="drm_probe_ddc"><code class="xref c c-func docutils literal"><span class="pre">drm_probe_ddc()</span></code></a>. Upon removal, drivers
should call <a class="reference internal" href="#c.drm_dp_aux_unregister" title="drm_dp_aux_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_unregister()</span></code></a> to remove the I2C adapter.
The I2C adapter uses long transfers by default; if a partial response is
received, the adapter will drop down to the size given by the partial
response for this transaction only.</p>
<p>Note that the aux helper code assumes that the .:c:func:<cite>transfer()</cite> function
only modifies the reply field of the drm_dp_aux_msg structure.  The
retry logic and i2c helpers assume this is the case.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_readb">
ssize_t <code class="descname">drm_dp_dpcd_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, u8 *<em>&nbsp;valuep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">valuep</span></code></dt>
<dd>location where the value of the register will be stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_writeb">
ssize_t <code class="descname">drm_dp_dpcd_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the register to write</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>value to write to the register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="type">
<dt id="c.drm_dp_desc">
struct <code class="descname">drm_dp_desc</code><a class="headerlink" href="#c.drm_dp_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DP branch/sink device descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_desc {
  struct drm_dp_dpcd_ident ident;
  u32 quirks;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ident</span></code></dt>
<dd>DP device identification from DPCD 0x400 (sink) or 0x500 (branch).</dd>
<dt><code class="docutils literal"><span class="pre">quirks</span></code></dt>
<dd>Quirks; use <a class="reference internal" href="#c.drm_dp_has_quirk" title="drm_dp_has_quirk"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_has_quirk()</span></code></a> to query for the quirks.</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_quirk">
enum <code class="descname">drm_dp_quirk</code><a class="headerlink" href="#c.drm_dp_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Port sink/branch device specific quirks</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DP_DPCD_QUIRK_LIMITED_M_N</span></code></dt>
<dd>The device requires main link attributes Mvid and Nvid to be limited
to 16 bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Display Port sink and branch devices in the wild have a variety of bugs, try
to collect them here. The quirks are shared, but it&#8217;s up to the drivers to
implement workarounds for them.</p>
<dl class="function">
<dt id="c.drm_dp_has_quirk">
bool <code class="descname">drm_dp_has_quirk</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a> *<em>&nbsp;desc</em>, enum <a class="reference internal" href="#c.drm_dp_quirk" title="drm_dp_quirk">drm_dp_quirk</a><em>&nbsp;quirk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_has_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>does the DP device have a specific quirk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Device decriptor filled by <a class="reference internal" href="#c.drm_dp_read_desc" title="drm_dp_read_desc"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_read_desc()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_quirk</span> <span class="pre">quirk</span></code></dt>
<dd>Quirk to query for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DP device identified by <strong>desc</strong> has <strong>quirk</strong>.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_read">
ssize_t <code class="descname">drm_dp_dpcd_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a series of bytes from the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the (first) register to read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>buffer to store the register values</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes in <strong>buffer</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_write">
ssize_t <code class="descname">drm_dp_dpcd_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a series of bytes to the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the (first) register to write</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>buffer containing the values to write</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes in <strong>buffer</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_read_link_status">
int <code class="descname">drm_dp_dpcd_read_link_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, u8<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>read DPCD link status (bytes 0x202-0x207)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">status</span></code></dt>
<dd>buffer to store the link status in (must be at least 6 bytes)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_link_probe">
int <code class="descname">drm_dp_link_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct drm_dp_link *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_link_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a DisplayPort link for capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to structure in which to return link capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>The structure filled in by this function can usually be passed directly
into <a class="reference internal" href="#c.drm_dp_link_power_up" title="drm_dp_link_power_up"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_link_power_up()</span></code></a> and <a class="reference internal" href="#c.drm_dp_link_configure" title="drm_dp_link_configure"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_link_configure()</span></code></a> to power up and
configure the link based on the link&#8217;s capabilities.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_link_power_up">
int <code class="descname">drm_dp_link_power_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct drm_dp_link *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_link_power_up" title="Permalink to this definition">¶</a></dt>
<dd><p>power up a DisplayPort link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to a structure containing the link configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_link_power_down">
int <code class="descname">drm_dp_link_power_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct drm_dp_link *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_link_power_down" title="Permalink to this definition">¶</a></dt>
<dd><p>power down a DisplayPort link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to a structure containing the link configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_link_configure">
int <code class="descname">drm_dp_link_configure</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct drm_dp_link *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_link_configure" title="Permalink to this definition">¶</a></dt>
<dd><p>configure a DisplayPort link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to a structure containing the link configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_downstream_max_clock">
int <code class="descname">drm_dp_downstream_max_clock</code><span class="sig-paren">(</span>const u8<em>&nbsp;dpcd</em>, const u8<em>&nbsp;port_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>extract branch device max pixel rate for legacy VGA converter or max TMDS clock rate for others</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt>
<dd>DisplayPort configuration data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt>
<dd>port capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns max clock in kHz on success or 0 if max clock not defined</p>
<dl class="function">
<dt id="c.drm_dp_downstream_max_bpc">
int <code class="descname">drm_dp_downstream_max_bpc</code><span class="sig-paren">(</span>const u8<em>&nbsp;dpcd</em>, const u8<em>&nbsp;port_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_bpc" title="Permalink to this definition">¶</a></dt>
<dd><p>extract branch device max bits per component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt>
<dd>DisplayPort configuration data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt>
<dd>port capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns max bpc on success or 0 if max bpc not defined</p>
<dl class="function">
<dt id="c.drm_dp_downstream_id">
int <code class="descname">drm_dp_downstream_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, char<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identify branch device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">id</span></code></dt>
<dd>DisplayPort branch device id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns branch device id on success or NULL on failure</p>
<dl class="function">
<dt id="c.drm_dp_downstream_debug">
void <code class="descname">drm_dp_downstream_debug</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, const u8<em>&nbsp;dpcd</em>, const u8<em>&nbsp;port_cap</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_debug" title="Permalink to this definition">¶</a></dt>
<dd><p>debug DP branch devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>pointer for debugfs file</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd</span></code></dt>
<dd>DisplayPort configuration data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap</span></code></dt>
<dd>port capabilities</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_aux_init">
void <code class="descname">drm_dp_aux_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_init" title="Permalink to this definition">¶</a></dt>
<dd><p>minimally initialise an aux channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you need to use the drm_dp_aux&#8217;s i2c adapter prior to registering it
with the outside world, call <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_init()</span></code></a> first. You must still
call <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_register()</span></code></a> once the connector has been registered to
allow userspace access to the auxiliary DP channel.</p>
<dl class="function">
<dt id="c.drm_dp_aux_register">
int <code class="descname">drm_dp_aux_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_register" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise and register aux channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Automatically calls <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_init()</span></code></a> if this hasn&#8217;t been done yet.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_aux_unregister">
void <code class="descname">drm_dp_aux_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an AUX adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_psr_setup_time">
int <code class="descname">drm_dp_psr_setup_time</code><span class="sig-paren">(</span>const u8<em>&nbsp;psr_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_psr_setup_time" title="Permalink to this definition">¶</a></dt>
<dd><p>PSR setup in time usec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">psr_cap</span></code></dt>
<dd>PSR capabilities from DPCD</dd>
</dl>
<p><strong>Return</strong></p>
<p>PSR setup time for the panel in microseconds,  negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_start_crc">
int <code class="descname">drm_dp_start_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_start_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>start capture of frame CRCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC displaying the frames whose CRCs are to be captured</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_stop_crc">
int <code class="descname">drm_dp_stop_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_stop_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>stop capture of frame CRCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_read_desc">
int <code class="descname">drm_dp_read_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a> *<em>&nbsp;desc</em>, bool<em>&nbsp;is_branch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>read sink/branch descriptor from DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Device decriptor to fill from DPCD</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_branch</span></code></dt>
<dd>true for branch devices, false for sink devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read DPCD 0x400 (sink) or 0x500 (branch) into <strong>desc</strong>. Also debug log the
identification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="display-port-dual-mode-adaptor-helper-functions-reference">
<h2>Display Port Dual Mode Adaptor Helper Functions Reference<a class="headerlink" href="#display-port-dual-mode-adaptor-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Helper functions to deal with DP dual mode (aka. DP++) adaptors.</p>
<p>Type 1:
Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.</p>
<p>Type 2:
Adaptor registers and sink DDC bus can be accessed either via I2C or
I2C-over-AUX. Source devices may choose to implement either of these
access methods.</p>
<dl class="type">
<dt id="c.drm_lspcon_mode">
enum <code class="descname">drm_lspcon_mode</code><a class="headerlink" href="#c.drm_lspcon_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_INVALID</span></code></dt>
<dd>No LSPCON.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_LS</span></code></dt>
<dd>Level shifter mode of LSPCON
which drives DP++ to HDMI 1.4 conversion.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_PCON</span></code></dt>
<dd>Protocol converter mode of LSPCON
which drives DP++ to HDMI 2.0 active conversion.</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_dual_mode_type">
enum <code class="descname">drm_dp_dual_mode_type</code><a class="headerlink" href="#c.drm_dp_dual_mode_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_NONE</span></code></dt>
<dd>No DP dual mode adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_UNKNOWN</span></code></dt>
<dd>Could be either none or type 1 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_DVI</span></code></dt>
<dd>Type 1 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_HDMI</span></code></dt>
<dd>Type 1 HDMI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_DVI</span></code></dt>
<dd>Type 2 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_HDMI</span></code></dt>
<dd>Type 2 HDMI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_LSPCON</span></code></dt>
<dd>Level shifter / protocol converter</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_dual_mode_read">
ssize_t <code class="descname">drm_dp_dual_mode_read</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the DP dual mode adaptor register(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>register offset</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>buffer for return data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>sizo of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads <strong>size</strong> bytes from the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_write">
ssize_t <code class="descname">drm_dp_dual_mode_write</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, const void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to the DP dual mode adaptor register(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>register offset</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>buffer for write data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>sizo of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes <strong>size</strong> bytes to the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_detect">
enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a> <code class="descname">drm_dp_dual_mode_detect</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to identify the type of the DP dual mode adaptor used.</p>
<p>Note that when the answer is <strong>DRM_DP_DUAL_MODE_UNKNOWN</strong> it&#8217;s not
certain whether we&#8217;re dealing with a native HDMI port or
a type 1 DVI dual mode adaptor. The driver will have to use
some other hardware/driver specific mechanism to make that
distinction.</p>
<p><strong>Return</strong></p>
<p>The type of the DP dual mode adaptor used</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_max_tmds_clock">
int <code class="descname">drm_dp_dual_mode_max_tmds_clock</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em>&nbsp;type</em>, struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_max_tmds_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Max TMDS clock for DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt>
<dd>DP dual mode adaptor type</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the max TMDS clock the adaptor supports based on the
type of the dual mode adaptor and the DP_DUAL_MODE_MAX_TMDS_CLOCK
register (on type2 adaptors). As some type 1 adaptors have
problems with registers (see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>)
we don&#8217;t read the register on those, instead we simply assume
a 165 MHz limit based on the specification.</p>
<p><strong>Return</strong></p>
<p>Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_get_tmds_output">
int <code class="descname">drm_dp_dual_mode_get_tmds_output</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em>&nbsp;type</em>, struct i2c_adapter *<em>&nbsp;adapter</em>, bool *<em>&nbsp;enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_get_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the state of the TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt>
<dd>DP dual mode adaptor type</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">enabled</span></code></dt>
<dd>current state of the TMDS output buffers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the state of the TMDS output buffers in the adaptor. For
type2 adaptors this is queried from the DP_DUAL_MODE_TMDS_OEN
register. As some type 1 adaptors have problems with registers
(see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>) we don&#8217;t read the
register on those, instead we simply assume that the buffers
are always enabled.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_dual_mode_set_tmds_output">
int <code class="descname">drm_dp_dual_mode_set_tmds_output</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em>&nbsp;type</em>, struct i2c_adapter *<em>&nbsp;adapter</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_set_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable/disable TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt>
<dd>DP dual mode adaptor type</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for the DDC bus</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>enable (as opposed to disable) the TMDS output buffers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the state of the TMDS output buffers in the adaptor. For
type2 this is set via the DP_DUAL_MODE_TMDS_OEN register. As
some type 1 adaptors have problems with registers (see comments
in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>) we avoid touching the register,
making this function a no-op on type 1 adaptors.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_get_dual_mode_type_name">
const char * <code class="descname">drm_dp_get_dual_mode_type_name</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_dual_mode_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the DP dual mode adaptor type as a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt>
<dd>DP dual mode adaptor type</dd>
</dl>
<p><strong>Return</strong></p>
<p>String representation of the DP dual mode adaptor type</p>
<dl class="function">
<dt id="c.drm_lspcon_get_mode">
int <code class="descname">drm_lspcon_get_mode</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_get_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C-over-aux adapter</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>current lspcon mode of operation output variable</dd>
</dl>
<p><strong>Description</strong></p>
<p>reading offset (0x80, 0x41)</p>
<p><strong>Return</strong></p>
<p>0 on success, sets the current_mode value to appropriate mode
-error on failure</p>
<dl class="function">
<dt id="c.drm_lspcon_set_mode">
int <code class="descname">drm_lspcon_set_mode</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_set_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C-over-aux adapter</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">mode</span></code></dt>
<dd>required mode of operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>writing offset (0x80, 0x40)</p>
<p><strong>Return</strong></p>
<p>0 on success, -error on failure/timeout</p>
</div>
<div class="section" id="display-port-mst-helper-functions-reference">
<h2>Display Port MST Helper Functions Reference<a class="headerlink" href="#display-port-mst-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain parts of the DisplayPort 1.2a MultiStream Transport
protocol. The helpers contain a topology manager and bandwidth manager.
The helpers encapsulate the sending and received of sideband msgs.</p>
<dl class="type">
<dt id="c.drm_dp_vcpi">
struct <code class="descname">drm_dp_vcpi</code><a class="headerlink" href="#c.drm_dp_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Virtual Channel Payload Identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_vcpi {
  int vcpi;
  int pbn;
  int aligned_pbn;
  int num_slots;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vcpi</span></code></dt>
<dd>Virtual channel ID.</dd>
<dt><code class="docutils literal"><span class="pre">pbn</span></code></dt>
<dd>Payload Bandwidth Number for this channel</dd>
<dt><code class="docutils literal"><span class="pre">aligned_pbn</span></code></dt>
<dd>PBN aligned with slot size</dd>
<dt><code class="docutils literal"><span class="pre">num_slots</span></code></dt>
<dd>number of slots for this PBN</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_mst_port">
struct <code class="descname">drm_dp_mst_port</code><a class="headerlink" href="#c.drm_dp_mst_port" title="Permalink to this definition">¶</a></dt>
<dd><p>MST port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_mst_port {
  struct kref kref;
  u8 port_num;
  bool input;
  bool mcs;
  bool ddps;
  u8 pdt;
  bool ldps;
  u8 dpcd_rev;
  u8 num_sdp_streams;
  u8 num_sdp_stream_sinks;
  uint16_t available_pbn;
  struct list_head next;
  struct drm_dp_mst_branch * mstb;
  struct drm_dp_aux aux;
  struct drm_dp_mst_branch * parent;
  struct drm_dp_vcpi vcpi;
  struct drm_connector * connector;
  struct drm_dp_mst_topology_mgr * mgr;
  struct edid * cached_edid;
  bool has_audio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>reference count for this port.</dd>
<dt><code class="docutils literal"><span class="pre">port_num</span></code></dt>
<dd>port number</dd>
<dt><code class="docutils literal"><span class="pre">input</span></code></dt>
<dd>if this port is an input port.</dd>
<dt><code class="docutils literal"><span class="pre">mcs</span></code></dt>
<dd>message capability status - DP 1.2 spec.</dd>
<dt><code class="docutils literal"><span class="pre">ddps</span></code></dt>
<dd>DisplayPort Device Plug Status - DP 1.2</dd>
<dt><code class="docutils literal"><span class="pre">pdt</span></code></dt>
<dd>Peer Device Type</dd>
<dt><code class="docutils literal"><span class="pre">ldps</span></code></dt>
<dd>Legacy Device Plug Status</dd>
<dt><code class="docutils literal"><span class="pre">dpcd_rev</span></code></dt>
<dd>DPCD revision of device on this port</dd>
<dt><code class="docutils literal"><span class="pre">num_sdp_streams</span></code></dt>
<dd>Number of simultaneous streams</dd>
<dt><code class="docutils literal"><span class="pre">num_sdp_stream_sinks</span></code></dt>
<dd>Number of stream sinks</dd>
<dt><code class="docutils literal"><span class="pre">available_pbn</span></code></dt>
<dd>Available bandwidth for this port.</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd>link to next port on this branch device</dd>
<dt><code class="docutils literal"><span class="pre">mstb</span></code></dt>
<dd>branch device attach below this port</dd>
<dt><code class="docutils literal"><span class="pre">aux</span></code></dt>
<dd>i2c aux transport to talk to device connected to this port.</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>branch device parent of this port</dd>
<dt><code class="docutils literal"><span class="pre">vcpi</span></code></dt>
<dd>Virtual Channel Payload info for this port.</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>DRM connector this port is connected to.</dd>
<dt><code class="docutils literal"><span class="pre">mgr</span></code></dt>
<dd>topology manager this port lives under.</dd>
<dt><code class="docutils literal"><span class="pre">cached_edid</span></code></dt>
<dd>for DP logical ports - make tiling work by ensuring
that the EDID for all connectors is read immediately.</dd>
<dt><code class="docutils literal"><span class="pre">has_audio</span></code></dt>
<dd>Tracks whether the sink connector to this port is
audio-capable.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST port endpoint on a device somewhere
in the MST topology.</p>
<dl class="type">
<dt id="c.drm_dp_mst_branch">
struct <code class="descname">drm_dp_mst_branch</code><a class="headerlink" href="#c.drm_dp_mst_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>MST branch device.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_mst_branch {
  struct kref kref;
  u8 rad;
  u8 lct;
  int num_ports;
  int msg_slots;
  struct list_head ports;
  struct drm_dp_mst_port * port_parent;
  struct drm_dp_mst_topology_mgr * mgr;
  struct drm_dp_sideband_msg_tx * tx_slots;
  int last_seqno;
  bool link_address_sent;
  u8 guid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>reference count for this port.</dd>
<dt><code class="docutils literal"><span class="pre">rad</span></code></dt>
<dd>Relative Address to talk to this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">lct</span></code></dt>
<dd>Link count total to talk to this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">num_ports</span></code></dt>
<dd>number of ports on the branch.</dd>
<dt><code class="docutils literal"><span class="pre">msg_slots</span></code></dt>
<dd>one bit per transmitted msg slot.</dd>
<dt><code class="docutils literal"><span class="pre">ports</span></code></dt>
<dd>linked list of ports on this branch.</dd>
<dt><code class="docutils literal"><span class="pre">port_parent</span></code></dt>
<dd>pointer to the port parent, NULL if toplevel.</dd>
<dt><code class="docutils literal"><span class="pre">mgr</span></code></dt>
<dd>topology manager for this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">tx_slots</span></code></dt>
<dd>transmission slots for this device.</dd>
<dt><code class="docutils literal"><span class="pre">last_seqno</span></code></dt>
<dd>last sequence number used to talk to this.</dd>
<dt><code class="docutils literal"><span class="pre">link_address_sent</span></code></dt>
<dd>if a link address message has been sent to this device yet.</dd>
<dt><code class="docutils literal"><span class="pre">guid</span></code></dt>
<dd>guid for DP 1.2 branch device. port under this branch can be
identified by port #.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST branch device, there is one
primary branch device at the root, along with any other branches connected
to downstream port of parent branches.</p>
<dl class="type">
<dt id="c.drm_dp_mst_topology_mgr">
struct <code class="descname">drm_dp_mst_topology_mgr</code><a class="headerlink" href="#c.drm_dp_mst_topology_mgr" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort MST manager</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_dp_mst_topology_mgr {
  struct drm_device * dev;
  const struct drm_dp_mst_topology_cbs * cbs;
  int max_dpcd_transaction_bytes;
  struct drm_dp_aux * aux;
  int max_payloads;
  int conn_base_id;
  struct drm_dp_sideband_msg_rx down_rep_recv;
  struct drm_dp_sideband_msg_rx up_req_recv;
  struct mutex lock;
  bool mst_state;
  struct drm_dp_mst_branch * mst_primary;
  u8 dpcd;
  u8 sink_count;
  int pbn_div;
  struct drm_dp_mst_topology_state * state;
  const struct drm_private_state_funcs * funcs;
  struct mutex qlock;
  struct list_head tx_msg_downq;
  struct mutex payload_lock;
  struct drm_dp_vcpi ** proposed_vcpis;
  struct drm_dp_payload * payloads;
  unsigned long payload_mask;
  unsigned long vcpi_mask;
  wait_queue_head_t tx_waitq;
  struct work_struct work;
  struct work_struct tx_work;
  struct list_head destroy_connector_list;
  struct mutex destroy_connector_lock;
  struct work_struct destroy_connector_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device pointer for adding i2c devices etc.</dd>
<dt><code class="docutils literal"><span class="pre">cbs</span></code></dt>
<dd>callbacks for connector addition and destruction.</dd>
<dt><code class="docutils literal"><span class="pre">max_dpcd_transaction_bytes</span></code></dt>
<dd>maximum number of bytes to read/write
in one go.</dd>
<dt><code class="docutils literal"><span class="pre">aux</span></code></dt>
<dd>AUX channel for the DP MST connector this topolgy mgr is
controlling.</dd>
<dt><code class="docutils literal"><span class="pre">max_payloads</span></code></dt>
<dd>maximum number of payloads the GPU can generate.</dd>
<dt><code class="docutils literal"><span class="pre">conn_base_id</span></code></dt>
<dd>DRM connector ID this mgr is connected to. Only used
to build the MST connector path value.</dd>
<dt><code class="docutils literal"><span class="pre">down_rep_recv</span></code></dt>
<dd>Message receiver state for down replies. This and
<strong>up_req_recv</strong> are only ever access from the work item, which is
serialised.</dd>
<dt><code class="docutils literal"><span class="pre">up_req_recv</span></code></dt>
<dd>Message receiver state for up requests. This and
<strong>down_rep_recv</strong> are only ever access from the work item, which is
serialised.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>protects mst state, primary, dpcd.</dd>
<dt><code class="docutils literal"><span class="pre">mst_state</span></code></dt>
<dd>If this manager is enabled for an MST capable port. False
if no MST sink/branch devices is connected.</dd>
<dt><code class="docutils literal"><span class="pre">mst_primary</span></code></dt>
<dd>Pointer to the primary/first branch device.</dd>
<dt><code class="docutils literal"><span class="pre">dpcd</span></code></dt>
<dd>Cache of DPCD for primary port.</dd>
<dt><code class="docutils literal"><span class="pre">sink_count</span></code></dt>
<dd>Sink count from DEVICE_SERVICE_IRQ_VECTOR_ESI0.</dd>
<dt><code class="docutils literal"><span class="pre">pbn_div</span></code></dt>
<dd>PBN to slots divisor.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>State information for topology manager</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>Atomic helper callbacks</dd>
<dt><code class="docutils literal"><span class="pre">qlock</span></code></dt>
<dd>protects <strong>tx_msg_downq</strong>, the <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal"><span class="pre">drm_dp_mst_branch.txslost</span></code></a> and
<code class="xref c c-type docutils literal"><span class="pre">drm_dp_sideband_msg_tx.state</span></code> once they are queued</dd>
<dt><code class="docutils literal"><span class="pre">tx_msg_downq</span></code></dt>
<dd>List of pending down replies.</dd>
<dt><code class="docutils literal"><span class="pre">payload_lock</span></code></dt>
<dd>Protect payload information.</dd>
<dt><code class="docutils literal"><span class="pre">proposed_vcpis</span></code></dt>
<dd>Array of pointers for the new VCPI allocation. The
VCPI structure itself is <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal"><span class="pre">drm_dp_mst_port.vcpi</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">payloads</span></code></dt>
<dd>Array of payloads.</dd>
<dt><code class="docutils literal"><span class="pre">payload_mask</span></code></dt>
<dd>Elements of <strong>payloads</strong> actually in use. Since
reallocation of active outputs isn&#8217;t possible gaps can be created by
disabling outputs out of order compared to how they&#8217;ve been enabled.</dd>
<dt><code class="docutils literal"><span class="pre">vcpi_mask</span></code></dt>
<dd>Similar to <strong>payload_mask</strong>, but for <strong>proposed_vcpis</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">tx_waitq</span></code></dt>
<dd>Wait to queue stall for the tx worker.</dd>
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>Probe work.</dd>
<dt><code class="docutils literal"><span class="pre">tx_work</span></code></dt>
<dd>Sideband transmit worker. This can nest within the main
<strong>work</strong> worker for each transaction <strong>work</strong> launches.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_list</span></code></dt>
<dd>List of to be destroyed connectors.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_lock</span></code></dt>
<dd>Protects <strong>connector_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_work</span></code></dt>
<dd>Work item to destroy connectors. Needed to
avoid locking inversion.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct represents the toplevel displayport MST topology manager.
There should be one instance of this for every MST capable DP connector
on the GPU.</p>
<dl class="function">
<dt id="c.drm_dp_update_payload_part1">
int <code class="descname">drm_dp_update_payload_part1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_update_payload_part1" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to use.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-&gt;slots transitions,
this step just writes the VCPI to the MST device. For slots-&gt;0
transitions, this writes the updated VCPIs and removes the
remote VC payloads.</p>
<p>after calling this the driver should generate ACT and payload
packets.</p>
<dl class="function">
<dt id="c.drm_dp_update_payload_part2">
int <code class="descname">drm_dp_update_payload_part2</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_update_payload_part2" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to use.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-&gt;slots transitions,
this step writes the remote VC payload commands. For slots-&gt;0
this just resets some internal state.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_set_mst">
int <code class="descname">drm_dp_mst_topology_mgr_set_mst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, bool<em>&nbsp;mst_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_set_mst" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the MST state for a topology manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to set state for</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">mst_state</span></code></dt>
<dd>true to enable MST on this connector - false to disable.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called by the driver when it detects an MST capable device plugged
into a DP MST capable port, or when a DP MST capable device is unplugged.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_suspend">
void <code class="descname">drm_dp_mst_topology_mgr_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend the MST manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to suspend</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tells the MST device that we can&#8217;t handle UP messages
anymore. This should stop it from sending any since we are suspended.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_resume">
int <code class="descname">drm_dp_mst_topology_mgr_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>resume the MST manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to resume</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will fetch DPCD and see if the device is still there,
if it is, it will rewrite the MSTM control bits, and return.</p>
<p>if the device fails this returns -1, and the driver should do
a full MST reprobe, in case we were undocked.</p>
<dl class="function">
<dt id="c.drm_dp_mst_hpd_irq">
int <code class="descname">drm_dp_mst_hpd_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, u8 *<em>&nbsp;esi</em>, bool *<em>&nbsp;handled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_hpd_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>MST hotplug IRQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to notify irq for.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">esi</span></code></dt>
<dd>4 bytes from SINK_COUNT_ESI</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">handled</span></code></dt>
<dd>whether the hpd interrupt was consumed or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from the driver when it detects a short IRQ,
along with the value of the DEVICE_SERVICE_IRQ_VECTOR_ESI0. The
topology manager will process the sideband messages received as a result
of this.</p>
<dl class="function">
<dt id="c.drm_dp_mst_detect_port">
enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> <code class="descname">drm_dp_mst_detect_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_detect_port" title="Permalink to this definition">¶</a></dt>
<dd><p>get connection status for an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>unverified pointer to a port</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current connection state for a port. It validates the
port pointer still exists so the caller doesn&#8217;t require a reference</p>
<dl class="function">
<dt id="c.drm_dp_mst_port_has_audio">
bool <code class="descname">drm_dp_mst_port_has_audio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_port_has_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether port has audio capability or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>unverified pointer to a port.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns whether the port supports audio or not.</p>
<dl class="function">
<dt id="c.drm_dp_mst_get_edid">
struct edid * <code class="descname">drm_dp_mst_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID for an MST port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>toplevel connector to get EDID for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>unverified pointer to a port.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns an EDID for the port connected to a connector,
It validates the pointer still exists so the caller doesn&#8217;t require a
reference.</p>
<dl class="function">
<dt id="c.drm_dp_find_vcpi_slots">
int <code class="descname">drm_dp_find_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, int<em>&nbsp;pbn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_find_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>find slots for this PBN value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pbn</span></code></dt>
<dd>payload bandwidth to convert into slots.</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_atomic_find_vcpi_slots">
int <code class="descname">drm_dp_atomic_find_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em>, int<em>&nbsp;pbn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_find_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and add vcpi slots to the state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>MST topology manager for the port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to find vcpi slots for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pbn</span></code></dt>
<dd>bandwidth required for the mode in PBN</dd>
</dl>
<p><strong>Return</strong></p>
<p>Total slots in the atomic state assigned for this port or error</p>
<dl class="function">
<dt id="c.drm_dp_atomic_release_vcpi_slots">
int <code class="descname">drm_dp_atomic_release_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, int<em>&nbsp;slots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_release_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Release allocated vcpi slots</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>MST topology manager for the port</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">slots</span></code></dt>
<dd>number of vcpi slots to release</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if <strong>slots</strong> were added back to <code class="xref c c-type docutils literal"><span class="pre">drm_dp_mst_topology_state-&gt;avail_slots</span></code> or
negative error code</p>
<dl class="function">
<dt id="c.drm_dp_mst_allocate_vcpi">
bool <code class="descname">drm_dp_mst_allocate_vcpi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em>, int<em>&nbsp;pbn</em>, int<em>&nbsp;slots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_allocate_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a virtual channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>port to allocate a virtual channel for.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pbn</span></code></dt>
<dd>payload bandwidth number to request</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">slots</span></code></dt>
<dd>returned number of slots for this PBN.</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_mst_reset_vcpi_slots">
void <code class="descname">drm_dp_mst_reset_vcpi_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_reset_vcpi_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset number of slots to 0 for VCPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>unverified pointer to a port.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This just resets the number of slots for the ports VCPI for later programming.</p>
<dl class="function">
<dt id="c.drm_dp_mst_deallocate_vcpi">
void <code class="descname">drm_dp_mst_deallocate_vcpi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_deallocate_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate a VCPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager for this port</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>unverified port to deallocate vcpi for</dd>
</dl>
<dl class="function">
<dt id="c.drm_dp_check_act_status">
int <code class="descname">drm_dp_check_act_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_check_act_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Check ACT handled status.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the payload status bits in the DPCD for ACT handled completion.</p>
<dl class="function">
<dt id="c.drm_dp_calc_pbn_mode">
int <code class="descname">drm_dp_calc_pbn_mode</code><span class="sig-paren">(</span>int<em>&nbsp;clock</em>, int<em>&nbsp;bpp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_calc_pbn_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the PBN for a mode.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">clock</span></code></dt>
<dd>dot clock for the mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bpp</span></code></dt>
<dd>bpp for the mode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This uses the formula in the spec to calculate the PBN value for a mode.</p>
<dl class="function">
<dt id="c.drm_dp_mst_dump_topology">
void <code class="descname">drm_dp_mst_dump_topology</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_dump_topology" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>seq_file to dump output to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to dump current topology for.</dd>
</dl>
<p><strong>Description</strong></p>
<p>helper to dump MST topology to a seq file for debugfs.</p>
<dl class="function">
<dt id="c.drm_atomic_get_mst_topology_state">
struct drm_dp_mst_topology_state * <code class="descname">drm_atomic_get_mst_topology_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_mst_topology_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>MST topology manager, also the private object in this case</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_priv_obj_state()</span></code> passing in the MST atomic
state vtable so that the private object state returned is that of a MST
topology object. Also, <a class="reference internal" href="drm-kms.html#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a> expects the caller
to care of the locking, so warn if don&#8217;t hold the connection_mutex.</p>
<p><strong>Return</strong></p>
<p>The MST topology state or error pointer.</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_init">
int <code class="descname">drm_dp_mst_topology_mgr_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em>, struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, int<em>&nbsp;max_dpcd_transaction_bytes</em>, int<em>&nbsp;max_payloads</em>, int<em>&nbsp;conn_base_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a topology manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager struct to initialise</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device providing this structure - for i2c addition.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DP helper aux channel to talk to this device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_dpcd_transaction_bytes</span></code></dt>
<dd>hw specific DPCD transaction limit</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_payloads</span></code></dt>
<dd>maximum number of payloads this GPU can source</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">conn_base_id</span></code></dt>
<dd>the connector object ID the MST device is connected to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, or negative error code on failure</p>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_destroy">
void <code class="descname">drm_dp_mst_topology_mgr_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a> *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy topology manager.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>manager to destroy</dd>
</dl>
</div>
<div class="section" id="mipi-dsi-helper-functions-reference">
<h2>MIPI DSI Helper Functions Reference<a class="headerlink" href="#mipi-dsi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers to deal with MIPI DSI
peripherals.</p>
<p>Helpers are provided for a number of standard MIPI DSI command as well as a
subset of the MIPI DCS command set.</p>
<dl class="type">
<dt id="c.mipi_dsi_msg">
struct <code class="descname">mipi_dsi_msg</code><a class="headerlink" href="#c.mipi_dsi_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write DSI buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_msg {
  u8 channel;
  u8 type;
  u16 flags;
  size_t tx_len;
  const void * tx_buf;
  size_t rx_len;
  void * rx_buf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>virtual channel id</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>payload data type</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>flags controlling this message transmission</dd>
<dt><code class="docutils literal"><span class="pre">tx_len</span></code></dt>
<dd>length of <strong>tx_buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">tx_buf</span></code></dt>
<dd>data to be written</dd>
<dt><code class="docutils literal"><span class="pre">rx_len</span></code></dt>
<dd>length of <strong>rx_buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">rx_buf</span></code></dt>
<dd>data to be read, or NULL</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_packet">
struct <code class="descname">mipi_dsi_packet</code><a class="headerlink" href="#c.mipi_dsi_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a MIPI DSI packet in protocol format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_packet {
  size_t size;
  u8 header;
  size_t payload_length;
  const u8 * payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size (in bytes) of the packet</dd>
<dt><code class="docutils literal"><span class="pre">header</span></code></dt>
<dd>the four bytes that make up the header (Data ID, Word Count or
Packet Data, and ECC)</dd>
<dt><code class="docutils literal"><span class="pre">payload_length</span></code></dt>
<dd>number of bytes in the payload</dd>
<dt><code class="docutils literal"><span class="pre">payload</span></code></dt>
<dd>a pointer to a buffer containing the payload, if any</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_host_ops">
struct <code class="descname">mipi_dsi_host_ops</code><a class="headerlink" href="#c.mipi_dsi_host_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI bus operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_host_ops {
  int (* attach) (struct mipi_dsi_host *host,struct mipi_dsi_device *dsi);
  int (* detach) (struct mipi_dsi_host *host,struct mipi_dsi_device *dsi);
  ssize_t (* transfer) (struct mipi_dsi_host *host,const struct mipi_dsi_msg *msg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">attach</span></code></dt>
<dd>attach DSI device to DSI host</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd>detach DSI device from DSI host</dd>
<dt><code class="docutils literal"><span class="pre">transfer</span></code></dt>
<dd>transmit a DSI packet</dd>
</dl>
<p><strong>Description</strong></p>
<p>DSI packets transmitted by .:c:func:<cite>transfer()</cite> are passed in as mipi_dsi_msg
structures. This structure contains information about the type of packet
being transmitted as well as the transmit and receive buffers. When an
error is encountered during transmission, this function will return a
negative error code. On success it shall return the number of bytes
transmitted for write packets or the number of bytes received for read
packets.</p>
<p>Note that typically DSI packet transmission is atomic, so the .:c:func:<cite>transfer()</cite>
function will seldomly return anything other than the number of bytes
contained in the transmit buffer on success.</p>
<dl class="type">
<dt id="c.mipi_dsi_host">
struct <code class="descname">mipi_dsi_host</code><a class="headerlink" href="#c.mipi_dsi_host" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI host device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_host {
  struct device * dev;
  const struct mipi_dsi_host_ops * ops;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>driver model device node for this DSI host</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>DSI host operations</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>list management</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_device_info">
struct <code class="descname">mipi_dsi_device_info</code><a class="headerlink" href="#c.mipi_dsi_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for creating a mipi_dsi_device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_device_info {
  char type;
  u32 channel;
  struct device_node * node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>DSI peripheral chip type</dd>
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>DSI virtual channel assigned to peripheral</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>pointer to OF device node or NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is populated and passed to mipi_dsi_device_new to create a new
DSI device</p>
<dl class="type">
<dt id="c.mipi_dsi_device">
struct <code class="descname">mipi_dsi_device</code><a class="headerlink" href="#c.mipi_dsi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI peripheral device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_device {
  struct mipi_dsi_host * host;
  struct device dev;
  char name;
  unsigned int channel;
  unsigned int lanes;
  enum mipi_dsi_pixel_format format;
  unsigned long mode_flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">host</span></code></dt>
<dd>DSI host for this peripheral</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>driver model device node for this peripheral</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>DSI peripheral chip type</dd>
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>virtual channel assigned to the peripheral</dd>
<dt><code class="docutils literal"><span class="pre">lanes</span></code></dt>
<dd>number of active data lanes</dd>
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>pixel format for video mode</dd>
<dt><code class="docutils literal"><span class="pre">mode_flags</span></code></dt>
<dd>DSI operation mode related flags</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_pixel_format_to_bpp">
int <code class="descname">mipi_dsi_pixel_format_to_bpp</code><span class="sig-paren">(</span>enum mipi_dsi_pixel_format<em>&nbsp;fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_pixel_format_to_bpp" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the number of bits per pixel for any given pixel format defined by the MIPI DSI specification</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">mipi_dsi_pixel_format</span> <span class="pre">fmt</span></code></dt>
<dd>MIPI DSI pixel format</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits per pixel of the given pixel format.</p>
<dl class="type">
<dt id="c.mipi_dsi_dcs_tear_mode">
enum <code class="descname">mipi_dsi_dcs_tear_mode</code><a class="headerlink" href="#c.mipi_dsi_dcs_tear_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Tearing Effect Output Line mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VBLANK</span></code></dt>
<dd>the TE output line consists of V-Blanking
information only</dd>
<dt><code class="docutils literal"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VHBLANK</span></code></dt>
<dd>the TE output line consists of both
V-Blanking and H-Blanking information</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_driver">
struct <code class="descname">mipi_dsi_driver</code><a class="headerlink" href="#c.mipi_dsi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct mipi_dsi_driver {
  struct device_driver driver;
  int(* probe) (struct mipi_dsi_device *dsi);
  int(* remove) (struct mipi_dsi_device *dsi);
  void (* shutdown) (struct mipi_dsi_device *dsi);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>device driver model driver</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>callback for device binding</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>callback for device unbinding</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>called at shutdown time to quiesce the device</dd>
</dl>
<dl class="function">
<dt id="c.of_find_mipi_dsi_device_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="descname">of_find_mipi_dsi_device_by_node</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_device_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI device matching a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device tree node</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>A pointer to the MIPI DSI device corresponding to <strong>np</strong> or NULL if no</dt>
<dd>such device exists (or has not been registered yet).</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_device_register_full">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="descname">mipi_dsi_device_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a> *<em>&nbsp;host</em>, const struct <a class="reference internal" href="#c.mipi_dsi_device_info" title="mipi_dsi_device_info">mipi_dsi_device_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>create a MIPI DSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_host</span> <span class="pre">*</span> <span class="pre">host</span></code></dt>
<dd>DSI host to which this device is connected</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_device_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to template containing DSI device information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a MIPI DSI device by using the device information provided by
mipi_dsi_device_info template</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created MIPI DSI device, or, a pointer encoded
with an error</p>
<dl class="function">
<dt id="c.mipi_dsi_device_unregister">
void <code class="descname">mipi_dsi_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister MIPI DSI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<dl class="function">
<dt id="c.of_find_mipi_dsi_host_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a> * <code class="descname">of_find_mipi_dsi_host_by_node</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_host_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI host matching a device tree node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>device tree node</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the MIPI DSI host corresponding to <strong>node</strong> or NULL if no
such device exists (or has not been registered yet).</p>
<dl class="function">
<dt id="c.mipi_dsi_attach">
int <code class="descname">mipi_dsi_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a DSI device to its DSI host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_detach">
int <code class="descname">mipi_dsi_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a DSI device from its DSI host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_short">
bool <code class="descname">mipi_dsi_packet_format_is_short</code><span class="sig-paren">(</span>u8<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_short" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the short format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">type</span></code></dt>
<dd>MIPI DSI data type of the packet</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a short packet, false
otherwise.</p>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_long">
bool <code class="descname">mipi_dsi_packet_format_is_long</code><span class="sig-paren">(</span>u8<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_long" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the long format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">type</span></code></dt>
<dd>MIPI DSI data type of the packet</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a long packet, false
otherwise.</p>
<dl class="function">
<dt id="c.mipi_dsi_create_packet">
int <code class="descname">mipi_dsi_create_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_packet" title="mipi_dsi_packet">mipi_dsi_packet</a> *<em>&nbsp;packet</em>, const struct <a class="reference internal" href="#c.mipi_dsi_msg" title="mipi_dsi_msg">mipi_dsi_msg</a> *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_create_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>create a packet from a message according to the DSI protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_packet</span> <span class="pre">*</span> <span class="pre">packet</span></code></dt>
<dd>pointer to a DSI packet structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message to translate into a packet</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_shutdown_peripheral">
int <code class="descname">mipi_dsi_shutdown_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_shutdown_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Shutdown Peripheral command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_turn_on_peripheral">
int <code class="descname">mipi_dsi_turn_on_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_turn_on_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Turn On Peripheral command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_generic_write">
ssize_t <code class="descname">mipi_dsi_generic_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, const void *<em>&nbsp;payload</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_write" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit data using a generic write packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">payload</span></code></dt>
<dd>buffer containing the payload</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of payload buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes transmitted on success or a negative error code
on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_generic_read">
ssize_t <code class="descname">mipi_dsi_generic_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, const void *<em>&nbsp;params</em>, size_t<em>&nbsp;num_params</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_read" title="Permalink to this definition">¶</a></dt>
<dd><p>receive data using a generic read packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>buffer containing the request parameters</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">num_params</span></code></dt>
<dd>number of request parameters</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>buffer in which to return the received data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of receive buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the number of parameters passed in.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully read or a negative error code on
failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write_buffer">
ssize_t <code class="descname">mipi_dsi_dcs_write_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit a DCS command with payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>buffer containing data to be transmitted</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>size of transmission buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write">
ssize_t <code class="descname">mipi_dsi_dcs_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u8<em>&nbsp;cmd</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS write command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>DCS command</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>buffer containing the command payload</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>command payload length</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_read">
ssize_t <code class="descname">mipi_dsi_dcs_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u8<em>&nbsp;cmd</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_read" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS read request command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>DCS command</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>buffer in which to receive data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>size of receive buffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes read or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_nop">
int <code class="descname">mipi_dsi_dcs_nop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_nop" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS nop packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_soft_reset">
int <code class="descname">mipi_dsi_dcs_soft_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a software reset of the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_power_mode">
int <code class="descname">mipi_dsi_dcs_get_power_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u8 *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_power_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>query the display module&#8217;s current power mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>return location for the current power mode</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_pixel_format">
int <code class="descname">mipi_dsi_dcs_get_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u8 *<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">format</span></code></dt>
<dd>return location for the pixel format</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_enter_sleep_mode">
int <code class="descname">mipi_dsi_dcs_enter_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_enter_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all unnecessary blocks inside the display module except interface communication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_exit_sleep_mode">
int <code class="descname">mipi_dsi_dcs_exit_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_exit_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>enable all blocks inside the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_off">
int <code class="descname">mipi_dsi_dcs_set_display_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_off" title="Permalink to this definition">¶</a></dt>
<dd><p>stop displaying the image data on the display device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_on">
int <code class="descname">mipi_dsi_dcs_set_display_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_on" title="Permalink to this definition">¶</a></dt>
<dd><p>start displaying the image data on the display device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_column_address">
int <code class="descname">mipi_dsi_dcs_set_column_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u16<em>&nbsp;start</em>, u16<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_column_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the column extent of the frame memory accessed by the host processor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">start</span></code></dt>
<dd>first column of frame memory</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">end</span></code></dt>
<dd>last column of frame memory</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_page_address">
int <code class="descname">mipi_dsi_dcs_set_page_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u16<em>&nbsp;start</em>, u16<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_page_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the page extent of the frame memory accessed by the host processor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">start</span></code></dt>
<dd>first page of frame memory</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">end</span></code></dt>
<dd>last page of frame memory</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_off">
int <code class="descname">mipi_dsi_dcs_set_tear_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_off" title="Permalink to this definition">¶</a></dt>
<dd><p>turn off the display module&#8217;s Tearing Effect output signal on the TE signal line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_on">
int <code class="descname">mipi_dsi_dcs_set_tear_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, enum <a class="reference internal" href="#c.mipi_dsi_dcs_tear_mode" title="mipi_dsi_dcs_tear_mode">mipi_dsi_dcs_tear_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_on" title="Permalink to this definition">¶</a></dt>
<dd><p>turn on the display module&#8217;s Tearing Effect output signal on the TE signal line.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">mipi_dsi_dcs_tear_mode</span> <span class="pre">mode</span></code></dt>
<dd>the Tearing Effect Output Line mode</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_pixel_format">
int <code class="descname">mipi_dsi_dcs_set_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u8<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">format</span></code></dt>
<dd>pixel format</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_scanline">
int <code class="descname">mipi_dsi_dcs_set_tear_scanline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u16<em>&nbsp;scanline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_scanline" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scanline to use as trigger for the Tearing Effect output signal of the display module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">scanline</span></code></dt>
<dd>scanline to use as trigger</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_brightness">
int <code class="descname">mipi_dsi_dcs_set_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u16<em>&nbsp;brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the brightness value of the display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">brightness</span></code></dt>
<dd>brightness value</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_display_brightness">
int <code class="descname">mipi_dsi_dcs_get_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> *<em>&nbsp;dsi</em>, u16 *<em>&nbsp;brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the current brightness value of the display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*</span> <span class="pre">dsi</span></code></dt>
<dd>DSI peripheral device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">brightness</span></code></dt>
<dd>brightness value</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_driver_register_full">
int <code class="descname">mipi_dsi_driver_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a> *<em>&nbsp;drv</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver for DSI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>DSI driver structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.mipi_dsi_driver_unregister">
void <code class="descname">mipi_dsi_driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a driver for DSI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>DSI driver structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="output-probing-helper-functions-reference">
<h2>Output Probing Helper Functions Reference<a class="headerlink" href="#output-probing-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides some helper code for output probing. It provides an
implementation of the core <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.fill_modes</span></code></a> interface with
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>It also provides support for polling connectors with a work item and for
generic hotplug interrupt handling where the driver doesn&#8217;t or cannot keep
track of a per-connector hpd interrupt.</p>
<p>This helper library can be used independently of the modeset helper library.
Drivers can also overwrite different parts e.g. use their own hotplug
handling code to avoid probing unrelated outputs.</p>
<p>The probe helpers share the function table structures with other display
helper libraries. See <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a> for the details.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_enable">
void <code class="descname">drm_kms_helper_poll_enable</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>re-enable output polling.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function re-enables the output polling work, after it has been
temporarily disabled using <a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_disable()</span></code></a>, for example over
suspend/resume.</p>
<p>Drivers can call this helper from their device resume implementation. It is
an error to call this when the output polling support has not yet been set
up.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they&#8217;re only call from suspend/resume
callbacks.</p>
<dl class="function">
<dt id="c.drm_helper_probe_detect">
int <code class="descname">drm_helper_probe_detect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em>, bool<em>&nbsp;force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>probe connector status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to probe</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>acquire_ctx, or NULL to let this function handle locking.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">force</span></code></dt>
<dd>Whether destructive probe operations should be performed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls the detect callbacks of the connector.
This function returns <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_status</span></code></a>, or
if <strong>ctx</strong> is set, it might also return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_helper_probe_single_connector_modes">
int <code class="descname">drm_helper_probe_single_connector_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, uint32_t<em>&nbsp;maxX</em>, uint32_t<em>&nbsp;maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_single_connector_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>get complete set of display modes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to probe</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">maxX</span></code></dt>
<dd>max width for modes</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">maxY</span></code></dt>
<dd>max height for modes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the helper callbacks implemented by <strong>connector</strong> in struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs</span></code></a> try to detect all valid modes.  Modes will first
be added to the connector&#8217;s probed_modes list, then culled (based on validity
and the <strong>maxX</strong>, <strong>maxY</strong> parameters) and put into the normal modes list.</p>
<p>Intended to be used as a generic implementation of the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.fill_modes()</span></code></a> vfunc for drivers that use the CRTC helpers
for output mode filtering and detection.</p>
<p>The basic procedure is as follows</p>
<ol class="arabic">
<li><p class="first">All modes currently on the connector&#8217;s modes list are marked as stale</p>
</li>
<li><p class="first">New modes are added to the connector&#8217;s probed_modes list with
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_probed_add()</span></code></a>. New modes start their life with status as OK.
Modes are added from a single source using the following priority order.</p>
<ul class="simple">
<li>debugfs &#8216;override_edid&#8217; (used for testing only)</li>
<li>firmware EDID (<code class="xref c c-func docutils literal"><span class="pre">drm_load_edid_firmware()</span></code>)</li>
<li><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.get_modes</span></code></a> vfunc</li>
<li>if the connector status is connector_status_connected, standard
VESA DMT modes up to 1024x768 are automatically added
(<a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal"><span class="pre">drm_add_modes_noedid()</span></code></a>)</li>
</ul>
<p>Finally modes specified via the kernel command line (video=...) are
added in addition to what the earlier probes produced
(<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_add_cmdline_mode()</span></code>). These modes are generated
using the VESA GTF/CVT formulas.</p>
</li>
<li><p class="first">Modes are moved from the probed_modes list to the modes list. Potential
duplicates are merged together (see <a class="reference internal" href="drm-kms.html#c.drm_mode_connector_list_update" title="drm_mode_connector_list_update"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_list_update()</span></code></a>).
After this step the probed_modes list will be empty again.</p>
</li>
<li><p class="first">Any non-stale mode on the modes list then undergoes validation</p>
<ul class="simple">
<li><a class="reference internal" href="drm-kms.html#c.drm_mode_validate_basic" title="drm_mode_validate_basic"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_validate_basic()</span></code></a> performs basic sanity checks</li>
<li><a class="reference internal" href="drm-kms.html#c.drm_mode_validate_size" title="drm_mode_validate_size"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_validate_size()</span></code></a> filters out modes larger than <strong>maxX</strong> and <strong>maxY</strong>
(if specified)</li>
<li><code class="xref c c-func docutils literal"><span class="pre">drm_mode_validate_flag()</span></code> checks the modes against basic connector
capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)</li>
<li>the optional <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.mode_valid</span></code></a> helper can perform
driver and/or sink specific checks</li>
<li>the optional <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>
helpers can perform driver and/or source specific checks which are also
enforced by the modeset/atomic helpers</li>
</ul>
</li>
<li><p class="first">Any mode whose status is not OK is pruned from the connector&#8217;s modes list,
accompanied by a debug message indicating the reason for the mode&#8217;s
rejection (see <a class="reference internal" href="drm-kms.html#c.drm_mode_prune_invalid" title="drm_mode_prune_invalid"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_prune_invalid()</span></code></a>).</p>
</li>
</ol>
<p><strong>Return</strong></p>
<p>The number of modes found on <strong>connector</strong>.</p>
<dl class="function">
<dt id="c.drm_kms_helper_hotplug_event">
void <code class="descname">drm_kms_helper_hotplug_event</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>fire off KMS hotplug events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device whose connector state changed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function fires off the uevent for userspace and also calls the
output_poll_changed function, which is most commonly used to inform the fbdev
emulation code and allow it to update the fbcon output configuration.</p>
<p>Drivers should call this from their hotplug handling code when a change is
detected. Note that this function does not do any output detection of its
own, like <a class="reference internal" href="#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_hpd_irq_event()</span></code></a> does - this is assumed to be done by the
driver already.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_disable">
void <code class="descname">drm_kms_helper_poll_disable</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables the output polling work.</p>
<p>Drivers can call this helper from their device suspend implementation. It is
not an error to call this even when output polling isn&#8217;t enabled or already
disabled. Polling is re-enabled by calling <a class="reference internal" href="#c.drm_kms_helper_poll_enable" title="drm_kms_helper_poll_enable"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_enable()</span></code></a>.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they&#8217;re only call from suspend/resume
callbacks.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_init">
void <code class="descname">drm_kms_helper_poll_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize and enable output polling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function intializes and then also enables output polling support for
<strong>dev</strong>. Drivers which do not have reliable hotplug support in hardware can use
this helper infrastructure to regularly poll such connectors for changes in
their connection state.</p>
<p>Drivers can control which connectors are polled by setting the
DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
connectors where probing live outputs can result in visual distortion drivers
should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
completely ignored by the polling logic.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_fini">
void <code class="descname">drm_kms_helper_poll_fini</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling and clean it up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device</dd>
</dl>
<dl class="function">
<dt id="c.drm_helper_hpd_irq_event">
bool <code class="descname">drm_helper_hpd_irq_event</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_hpd_irq_event" title="Permalink to this definition">¶</a></dt>
<dd><p>hotplug processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this helper function to run a detect cycle on all connectors
which have the DRM_CONNECTOR_POLL_HPD flag set in their <code class="xref c c-type docutils literal"><span class="pre">polled</span></code> member. All
other connectors are ignored, which is useful to avoid reprobing fixed
panels.</p>
<p>This helper function is useful for drivers which can&#8217;t or don&#8217;t track hotplug
interrupts for each connector.</p>
<p>Drivers which support hotplug interrupts for each connector individually and
which have a more fine-grained detect logic should bypass this code and
directly call <a class="reference internal" href="#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a> in case the connector state
changed.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
</div>
<div class="section" id="edid-helper-functions-reference">
<h2>EDID Helper Functions Reference<a class="headerlink" href="#edid-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_eld_mnl">
int <code class="descname">drm_eld_mnl</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD monitor name length in bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with mnl set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad">
const uint8_t * <code class="descname">drm_eld_sad</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD structures.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with sad_count set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad_count">
int <code class="descname">drm_eld_sad_count</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with sad_count set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_calc_baseline_block_size">
int <code class="descname">drm_eld_calc_baseline_block_size</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_calc_baseline_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate baseline block size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with mnl and sad_count set</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for determining the payload size of the baseline block, in
bytes, for e.g. setting the Baseline_ELD_Len field in the ELD header block.</p>
<dl class="function">
<dt id="c.drm_eld_size">
int <code class="descname">drm_eld_size</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to a complete eld memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value does not include the vendor block. It&#8217;s vendor specific,
and comprises of the remaining bytes in the ELD memory buffer after
<a class="reference internal" href="#c.drm_eld_size" title="drm_eld_size"><code class="xref c c-func docutils literal"><span class="pre">drm_eld_size()</span></code></a> bytes of header and baseline block.</p>
<p>The returned value is guaranteed to be a multiple of 4.</p>
<dl class="function">
<dt id="c.drm_eld_get_spk_alloc">
u8 <code class="descname">drm_eld_get_spk_alloc</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_spk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get speaker allocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an ELD memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value is the speakers mask. User has to use <code class="docutils literal"><span class="pre">DRM_ELD_SPEAKER</span></code>
field definitions to identify speakers.</p>
<dl class="function">
<dt id="c.drm_eld_get_conn_type">
u8 <code class="descname">drm_eld_get_conn_type</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_conn_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device type hdmi/dp connected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an ELD memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller need to use <code class="docutils literal"><span class="pre">DRM_ELD_CONN_TYPE_HDMI</span></code> or <code class="docutils literal"><span class="pre">DRM_ELD_CONN_TYPE_DP</span></code> to
identify the display type connected.</p>
<dl class="function">
<dt id="c.drm_edid_header_is_valid">
int <code class="descname">drm_edid_header_is_valid</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;raw_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_header_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check the header of the base EDID block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">raw_edid</span></code></dt>
<dd>pointer to raw base EDID block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity check the header of the base EDID block.</p>
<p><strong>Return</strong></p>
<p>8 if the header is perfect, down to 0 if it&#8217;s totally wrong.</p>
<dl class="function">
<dt id="c.drm_edid_block_valid">
bool <code class="descname">drm_edid_block_valid</code><span class="sig-paren">(</span>u8 *<em>&nbsp;raw_edid</em>, int<em>&nbsp;block</em>, bool<em>&nbsp;print_bad_edid</em>, bool *<em>&nbsp;edid_corrupt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_block_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check the EDID block (base or extension)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">raw_edid</span></code></dt>
<dd>pointer to raw EDID block</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">block</span></code></dt>
<dd>type of block to validate (0 for base, extension otherwise)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">print_bad_edid</span></code></dt>
<dd>if true, dump bad EDID blocks to the console</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">edid_corrupt</span></code></dt>
<dd>if true, the header or checksum is invalid</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate a base or extension EDID block and optionally dump bad blocks to
the console.</p>
<p><strong>Return</strong></p>
<p>True if the block is valid, false otherwise.</p>
<dl class="function">
<dt id="c.drm_edid_is_valid">
bool <code class="descname">drm_edid_is_valid</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check EDID data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity-check an entire EDID record (including extensions)</p>
<p><strong>Return</strong></p>
<p>True if the EDID data is valid, false otherwise.</p>
<dl class="function">
<dt id="c.drm_do_get_edid">
struct edid * <code class="descname">drm_do_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int (*get_edid_block) (void<em>&nbsp;*data</em>, u8<em>&nbsp;*buf</em>, unsigned int<em>&nbsp;block</em>, size_t<em>&nbsp;len</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_do_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data using a custom EDID block read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector we&#8217;re probing</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*data,</span> <span class="pre">u8</span> <span class="pre">*buf,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">block,</span> <span class="pre">size_t</span> <span class="pre">len)</span> <span class="pre">get_edid_block</span></code></dt>
<dd>EDID block read function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data passed to the block read function</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the I2C adapter connected to the DDC bus is hidden behind a device that
exposes a different interface to read EDID blocks this function can be used
to get EDID data using a custom block read function.</p>
<p>As in the general case the DDC bus is accessible by the kernel at the I2C
level, drivers must make all reasonable efforts to expose it as an I2C
adapter and use <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal"><span class="pre">drm_get_edid()</span></code></a> instead of abusing this function.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn&#8217;t find any.</p>
<dl class="function">
<dt id="c.drm_probe_ddc">
bool <code class="descname">drm_probe_ddc</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_probe_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>probe DDC presence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter to probe</dd>
</dl>
<p><strong>Return</strong></p>
<p>True on success, false on failure.</p>
<dl class="function">
<dt id="c.drm_get_edid">
struct edid * <code class="descname">drm_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data, if available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector we&#8217;re probing</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter to use for DDC</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poke the given I2C channel to grab EDID data if possible.  If found,
attach it to the connector.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn&#8217;t find any.</p>
<dl class="function">
<dt id="c.drm_get_edid_switcheroo">
struct edid * <code class="descname">drm_get_edid_switcheroo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid_switcheroo" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data for a vga_switcheroo output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector we&#8217;re probing</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter to use for DDC</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal"><span class="pre">drm_get_edid()</span></code></a> for laptops with dual GPUs using one set of
outputs. The wrapper adds the requisite vga_switcheroo calls to temporarily
switch DDC to the GPU which is retrieving EDID.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or <code class="docutils literal"><span class="pre">NULL</span></code> if we couldn&#8217;t find any.</p>
<dl class="function">
<dt id="c.drm_edid_duplicate">
struct edid * <code class="descname">drm_edid_duplicate</code><span class="sig-paren">(</span>const struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an EDID and the extensions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID to duplicate</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to duplicated EDID or NULL on allocation failure.</p>
<dl class="function">
<dt id="c.drm_match_cea_mode">
u8 <code class="descname">drm_match_cea_mode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;to_match</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_match_cea_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>look for a CEA mode matching given mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">to_match</span></code></dt>
<dd>display mode</dd>
</dl>
<p><strong>Return</strong></p>
<p>The CEA Video ID (VIC) of the mode or 0 if it isn&#8217;t a CEA-861
mode.</p>
<dl class="function">
<dt id="c.drm_get_cea_aspect_ratio">
enum hdmi_picture_aspect <code class="descname">drm_get_cea_aspect_ratio</code><span class="sig-paren">(</span>const u8<em>&nbsp;video_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_cea_aspect_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>get the picture aspect ratio corresponding to the input VIC from the CEA mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">video_code</span></code></dt>
<dd>ID given to each of the CEA modes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns picture aspect ratio</p>
<dl class="function">
<dt id="c.drm_edid_get_monitor_name">
void <code class="descname">drm_edid_get_monitor_name</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em>, char *<em>&nbsp;name</em>, int<em>&nbsp;bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_get_monitor_name" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch the monitor name from the edid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>monitor EDID information</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pointer to a character array to hold the name of the monitor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bufsize</span></code></dt>
<dd>The size of the name buffer (should be at least 14 chars.)</dd>
</dl>
<dl class="function">
<dt id="c.drm_edid_to_eld">
void <code class="descname">drm_edid_to_eld</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_eld" title="Permalink to this definition">¶</a></dt>
<dd><p>build ELD from EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector corresponding to the HDMI/DP sink</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID to parse</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill the ELD (EDID-Like Data) buffer for passing to the audio driver. The
Conn_Type, HDCP and Port_ID ELD fields are left for the graphics driver to
fill in.</p>
<dl class="function">
<dt id="c.drm_edid_to_sad">
int <code class="descname">drm_edid_to_sad</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em>, struct cea_sad **<em>&nbsp;sads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts SADs from EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID to parse</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cea_sad</span> <span class="pre">**</span> <span class="pre">sads</span></code></dt>
<dd>pointer that will be set to the extracted SADs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/kernel-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found SADs or negative number on error.</p>
<dl class="function">
<dt id="c.drm_edid_to_speaker_allocation">
int <code class="descname">drm_edid_to_speaker_allocation</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em>, u8 **<em>&nbsp;sadb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_speaker_allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts Speaker Allocation Data Blocks from EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID to parse</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">**</span> <span class="pre">sadb</span></code></dt>
<dd>pointer to the speaker block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/kernel-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found Speaker Allocation Blocks or negative number on
error.</p>
<dl class="function">
<dt id="c.drm_av_sync_delay">
int <code class="descname">drm_av_sync_delay</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_av_sync_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the HDMI/DP sink audio-video sync delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector associated with the HDMI/DP sink</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>the display mode</dd>
</dl>
<p><strong>Return</strong></p>
<p>The HDMI/DP sink&#8217;s audio-video sync delay in milliseconds or 0 if
the sink doesn&#8217;t support audio or video.</p>
<dl class="function">
<dt id="c.drm_detect_hdmi_monitor">
bool <code class="descname">drm_detect_hdmi_monitor</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_hdmi_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>detect whether monitor is HDMI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>monitor EDID information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the CEA extension according to CEA-861-B.</p>
<p><strong>Return</strong></p>
<p>True if the monitor is HDMI, false if not or unknown.</p>
<dl class="function">
<dt id="c.drm_detect_monitor_audio">
bool <code class="descname">drm_detect_monitor_audio</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_monitor_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>check monitor audio capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID block to scan</dd>
</dl>
<p><strong>Description</strong></p>
<p>Monitor should have CEA extension block.
If monitor has &#8216;basic audio&#8217;, but no CEA audio blocks, it&#8217;s &#8216;basic
audio&#8217; only. If there is any audio extension block and supported
audio format, assume at least &#8216;basic audio&#8217; support, even if &#8216;basic
audio&#8217; is not defined in EDID.</p>
<p><strong>Return</strong></p>
<p>True if the monitor supports audio, false otherwise.</p>
<dl class="function">
<dt id="c.drm_rgb_quant_range_selectable">
bool <code class="descname">drm_rgb_quant_range_selectable</code><span class="sig-paren">(</span>struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rgb_quant_range_selectable" title="Permalink to this definition">¶</a></dt>
<dd><p>is RGB quantization range selectable?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID block to scan</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the monitor reports the RGB quantization range selection
as supported. The AVI infoframe can then be used to inform the monitor
which quantization range (full or limited) is used.</p>
<p><strong>Return</strong></p>
<p>True if the RGB quantization range is selectable, false otherwise.</p>
<dl class="function">
<dt id="c.drm_default_rgb_quant_range">
enum hdmi_quantization_range <code class="descname">drm_default_rgb_quant_range</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_default_rgb_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>default RGB quantization range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>display mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the default RGB quantization range for the mode,
as specified in CEA-861.</p>
<p><strong>Return</strong></p>
<p>The default RGB quantization range for the mode</p>
<dl class="function">
<dt id="c.drm_add_edid_modes">
int <code class="descname">drm_add_edid_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_edid_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes from EDID data, if available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector we&#8217;re probing</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>EDID data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector&#8217;s mode list. Also fills out the
<a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info</span></code></a> structure in <strong>connector</strong> with any information which can be
derived from the edid.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn&#8217;t find any.</p>
<dl class="function">
<dt id="c.drm_add_modes_noedid">
int <code class="descname">drm_add_modes_noedid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_modes_noedid" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes for the connectors without EDID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector we&#8217;re probing</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>the horizontal display limit</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>the vertical display limit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector&#8217;s mode list. Only when the
hdisplay/vdisplay is not beyond the given limit, it will be added.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn&#8217;t find any.</p>
<dl class="function">
<dt id="c.drm_set_preferred_mode">
void <code class="descname">drm_set_preferred_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int<em>&nbsp;hpref</em>, int<em>&nbsp;vpref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_set_preferred_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the preferred mode of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector whose mode list should be processed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hpref</span></code></dt>
<dd>horizontal resolution of preferred mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vpref</span></code></dt>
<dd>vertical resolution of preferred mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks a mode as preferred if it matches the resolution specified by <strong>hpref</strong>
and <strong>vpref</strong>.</p>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_from_display_mode">
int <code class="descname">drm_hdmi_avi_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em>&nbsp;frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI AVI infoframe with data from a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI AVI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>DRM display mode</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_quant_range">
void <code class="descname">drm_hdmi_avi_infoframe_quant_range</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em>&nbsp;frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, enum hdmi_quantization_range<em>&nbsp;rgb_quant_range</em>, bool<em>&nbsp;rgb_quant_range_selectable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe quantization range information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI AVI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>DRM display mode</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">hdmi_quantization_range</span> <span class="pre">rgb_quant_range</span></code></dt>
<dd>RGB quantization range (Q)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">rgb_quant_range_selectable</span></code></dt>
<dd>Sink support selectable RGB quantization range (QS)</dd>
</dl>
<dl class="function">
<dt id="c.drm_hdmi_vendor_infoframe_from_display_mode">
int <code class="descname">drm_hdmi_vendor_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em>&nbsp;frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_vendor_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI infoframe with data from a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI vendor infoframe</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>DRM display mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that there&#8217;s is a need to send HDMI vendor infoframes only when using a
4k or stereoscopic 3D mode. So when giving any other mode as input this
function will return -EINVAL, error that can be safely ignored.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="scdc-helper-functions-reference">
<h2>SCDC Helper Functions Reference<a class="headerlink" href="#scdc-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Status and Control Data Channel (SCDC) is a mechanism introduced by the
HDMI 2.0 specification. It is a point-to-point protocol that allows the
HDMI source and HDMI sink to exchange data. The same I2C interface that
is used to access EDID serves as the transport mechanism for SCDC.</p>
<dl class="function">
<dt id="c.drm_scdc_readb">
int <code class="descname">drm_scdc_readb</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>offset of register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>return location for the register value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a single byte from SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_read" title="drm_scdc_read"><code class="xref c c-func docutils literal"><span class="pre">drm_scdc_read()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_writeb">
int <code class="descname">drm_scdc_writeb</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>offset of register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>return location for the register value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a single byte to SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_write" title="drm_scdc_write"><code class="xref c c-func docutils literal"><span class="pre">drm_scdc_write()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_set_scrambling">
bool <code class="descname">drm_scdc_set_scrambling</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_scrambling" title="Permalink to this definition">¶</a></dt>
<dd><p>enable scrambling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for DDC channel</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>bool to indicate if scrambling is to be enabled/disabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes the TMDS config register over SCDC channel, and:
enables scrambling when enable = 1
disables scrambling when enable = 0</p>
<p><strong>Return</strong></p>
<p>True if scrambling is set/reset successfully, false otherwise.</p>
<dl class="function">
<dt id="c.drm_scdc_set_high_tmds_clock_ratio">
bool <code class="descname">drm_scdc_set_high_tmds_clock_ratio</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, bool<em>&nbsp;set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_high_tmds_clock_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>set TMDS clock ratio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for DDC channel</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">set</span></code></dt>
<dd>ret or reset the high clock ratio</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes to the TMDS config register over SCDC channel, and:
sets TMDS clock ratio to 1/40 when set = 1
sets TMDS clock ratio to 1/10 when set = 0</p>
<p><strong>Return</strong></p>
<p>True if write is successful, false otherwise.</p>
<dl class="function">
<dt id="c.drm_scdc_read">
ssize_t <code class="descname">drm_scdc_read</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a block of data from SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C controller</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>start offset of block to read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>return location for the block to read</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the block to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of data from SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_write">
ssize_t <code class="descname">drm_scdc_write</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, const void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a block of data to SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C controller</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>start offset of block to write</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>block of data to write</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the block to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a block of data to SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_get_scrambling_status">
bool <code class="descname">drm_scdc_get_scrambling_status</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_get_scrambling_status" title="Permalink to this definition">¶</a></dt>
<dd><p>what is status of scrambling?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for DDC channel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the scrambler status over SCDC, and checks the
scrambling status.</p>
<p><strong>Return</strong></p>
<p>True if the scrambling is enabled, false otherwise.</p>
<dl class="function">
<dt>
bool <code class="descname">drm_scdc_set_scrambling</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span></dt>
<dd><p>enable scrambling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for DDC channel</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>bool to indicate if scrambling is to be enabled/disabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes the TMDS config register over SCDC channel, and:
enables scrambling when enable = 1
disables scrambling when enable = 0</p>
<p><strong>Return</strong></p>
<p>True if scrambling is set/reset successfully, false otherwise.</p>
<dl class="function">
<dt>
bool <code class="descname">drm_scdc_set_high_tmds_clock_ratio</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, bool<em>&nbsp;set</em><span class="sig-paren">)</span></dt>
<dd><p>set TMDS clock ratio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter for DDC channel</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">set</span></code></dt>
<dd>ret or reset the high clock ratio</dd>
</dl>
<p><strong>Description</strong></p>
<p>TMDS clock ratio calculations go like this:
TMDS character = 10 bit TMDS encoded value
TMDS character rate = The rate at which TMDS characters are transmitted(Mcsc)
TMDS bit rate = 10x TMDS character rate
As per the spec:
TMDS clock rate for pixel clock &lt; 340 MHz = 1x the character rate</p>
<blockquote>
<div>= 1/10 pixel clock rate</div></blockquote>
<dl class="docutils">
<dt>TMDS clock rate for pixel clock &gt; 340 MHz = 0.25x the character rate</dt>
<dd>= 1/40 pixel clock rate</dd>
</dl>
<p>Writes to the TMDS config register over SCDC channel, and:
sets TMDS clock ratio to 1/40 when set = 1
sets TMDS clock ratio to 1/10 when set = 0</p>
<p><strong>Return</strong></p>
<p>True if write is successful, false otherwise.</p>
</div>
<div class="section" id="rectangle-utilities-reference">
<h2>Rectangle Utilities Reference<a class="headerlink" href="#rectangle-utilities-reference" title="Permalink to this headline">¶</a></h2>
<p>Utility functions to help manage rectangular areas for
clipping, scaling, etc. calculations.</p>
<dl class="type">
<dt id="c.drm_rect">
struct <code class="descname">drm_rect</code><a class="headerlink" href="#c.drm_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>two dimensional rectangle</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_rect {
  int x1;
  int y1;
  int x2;
  int y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x1</span></code></dt>
<dd>horizontal starting coordinate (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">y1</span></code></dt>
<dd>vertical starting coordinate (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">x2</span></code></dt>
<dd>horizontal ending coordinate (exclusive)</dd>
<dt><code class="docutils literal"><span class="pre">y2</span></code></dt>
<dd>vertical ending coordinate (exclusive)</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FMT">
<code class="descname">DRM_RECT_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_ARG">
<code class="descname">DRM_RECT_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>rectangle struct</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FP_FMT">
<code class="descname">DRM_RECT_FP_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_FP_ARG">
<code class="descname">DRM_RECT_FP_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>rectangle struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for e.g. printing plane source rectangles, which are in 16.16
fixed point.</p>
<dl class="function">
<dt id="c.drm_rect_adjust_size">
void <code class="descname">drm_rect_adjust_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;dw</em>, int<em>&nbsp;dh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the size of the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be adjusted</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dw</span></code></dt>
<dd>horizontal adjustment</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dh</span></code></dt>
<dd>vertical adjustment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the size of rectangle <strong>r</strong> by <strong>dw</strong> in the horizontal direction,
and by <strong>dh</strong> in the vertical direction, while keeping the center
of <strong>r</strong> stationary.</p>
<p>Positive <strong>dw</strong> and <strong>dh</strong> increase the size, negative values decrease it.</p>
<dl class="function">
<dt id="c.drm_rect_translate">
void <code class="descname">drm_rect_translate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;dx</em>, int<em>&nbsp;dy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be tranlated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dx</span></code></dt>
<dd>horizontal translation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dy</span></code></dt>
<dd>vertical translation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> by <strong>dx</strong> in the horizontal direction,
and by <strong>dy</strong> in the vertical direction.</p>
<dl class="function">
<dt id="c.drm_rect_downscale">
void <code class="descname">drm_rect_downscale</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;horz</em>, int<em>&nbsp;vert</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_downscale" title="Permalink to this definition">¶</a></dt>
<dd><p>downscale a rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be downscaled</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">horz</span></code></dt>
<dd>horizontal downscale factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vert</span></code></dt>
<dd>vertical downscale factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide the coordinates of rectangle <strong>r</strong> by <strong>horz</strong> and <strong>vert</strong>.</p>
<dl class="function">
<dt id="c.drm_rect_width">
int <code class="descname">drm_rect_width</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_width" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle width</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose width is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_height">
int <code class="descname">drm_rect_height</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_height" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle height</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose height is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_visible">
bool <code class="descname">drm_rect_visible</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_visible" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if the the rectangle is visible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose visibility is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the rectangle is visible, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_equals">
bool <code class="descname">drm_rect_equals</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_equals" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if two rectangles are equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r1</span></code></dt>
<dd>first rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r2</span></code></dt>
<dd>second rectangle</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the rectangles are equal, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_intersect">
bool <code class="descname">drm_rect_intersect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>intersect two rectangles</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r1</span></code></dt>
<dd>first rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r2</span></code></dt>
<dd>second rectangle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the intersection of rectangles <strong>r1</strong> and <strong>r2</strong>.
<strong>r1</strong> will be overwritten with the intersection.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if rectangle <strong>r1</strong> is still visible after the operation,
<code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_clip_scaled">
bool <code class="descname">drm_rect_clip_scaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;clip</em>, int<em>&nbsp;hscale</em>, int<em>&nbsp;vscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_clip_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a scaled clip operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt>
<dd>clip rectangle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hscale</span></code></dt>
<dd>horizontal scaling factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vscale</span></code></dt>
<dd>vertical scaling factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clip rectangle <strong>dst</strong> by rectangle <strong>clip</strong>. Clip rectangle <strong>src</strong> by the
same amounts multiplied by <strong>hscale</strong> and <strong>vscale</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if rectangle <strong>dst</strong> is still visible after being clipped,
<code class="docutils literal"><span class="pre">false</span></code> otherwise</p>
<dl class="function">
<dt id="c.drm_rect_calc_hscale">
int <code class="descname">drm_rect_calc_hscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, int<em>&nbsp;min_hscale</em>, int<em>&nbsp;max_hscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_hscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the horizontal scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_hscale</span></code></dt>
<dd>minimum allowed horizontal scaling factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_hscale</span></code></dt>
<dd>maximum allowed horizontal scaling factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the horizontal scaling factor as
(<strong>src</strong> width) / (<strong>dst</strong> width).</p>
<p><strong>Return</strong></p>
<p>The horizontal scaling factor, or errno of out of limits.</p>
<dl class="function">
<dt id="c.drm_rect_calc_vscale">
int <code class="descname">drm_rect_calc_vscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, int<em>&nbsp;min_vscale</em>, int<em>&nbsp;max_vscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_vscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the vertical scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_vscale</span></code></dt>
<dd>minimum allowed vertical scaling factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_vscale</span></code></dt>
<dd>maximum allowed vertical scaling factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the vertical scaling factor as
(<strong>src</strong> height) / (<strong>dst</strong> height).</p>
<p><strong>Return</strong></p>
<p>The vertical scaling factor, or errno of out of limits.</p>
<dl class="function">
<dt id="c.drm_rect_calc_hscale_relaxed">
int <code class="descname">drm_rect_calc_hscale_relaxed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, int<em>&nbsp;min_hscale</em>, int<em>&nbsp;max_hscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_hscale_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the horizontal scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_hscale</span></code></dt>
<dd>minimum allowed horizontal scaling factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_hscale</span></code></dt>
<dd>maximum allowed horizontal scaling factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the horizontal scaling factor as
(<strong>src</strong> width) / (<strong>dst</strong> width).</p>
<p>If the calculated scaling factor is below <strong>min_vscale</strong>,
decrease the height of rectangle <strong>dst</strong> to compensate.</p>
<p>If the calculated scaling factor is above <strong>max_vscale</strong>,
decrease the height of rectangle <strong>src</strong> to compensate.</p>
<p><strong>Return</strong></p>
<p>The horizontal scaling factor.</p>
<dl class="function">
<dt id="c.drm_rect_calc_vscale_relaxed">
int <code class="descname">drm_rect_calc_vscale_relaxed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, int<em>&nbsp;min_vscale</em>, int<em>&nbsp;max_vscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_vscale_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the vertical scaling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination window rectangle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_vscale</span></code></dt>
<dd>minimum allowed vertical scaling factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_vscale</span></code></dt>
<dd>maximum allowed vertical scaling factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the vertical scaling factor as
(<strong>src</strong> height) / (<strong>dst</strong> height).</p>
<p>If the calculated scaling factor is below <strong>min_vscale</strong>,
decrease the height of rectangle <strong>dst</strong> to compensate.</p>
<p>If the calculated scaling factor is above <strong>max_vscale</strong>,
decrease the height of rectangle <strong>src</strong> to compensate.</p>
<p><strong>Return</strong></p>
<p>The vertical scaling factor.</p>
<dl class="function">
<dt id="c.drm_rect_debug_print">
void <code class="descname">drm_rect_debug_print</code><span class="sig-paren">(</span>const char *<em>&nbsp;prefix</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, bool<em>&nbsp;fixed_point</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_debug_print" title="Permalink to this definition">¶</a></dt>
<dd><p>print the rectangle information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt>
<dd>prefix string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to print</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">fixed_point</span></code></dt>
<dd>rectangle is in 16.16 fixed point format</dd>
</dl>
<dl class="function">
<dt id="c.drm_rect_rotate">
void <code class="descname">drm_rect_rotate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;width</em>, int<em>&nbsp;height</em>, unsigned int<em>&nbsp;rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be rotated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>Width of the coordinate space</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>Height of the coordinate space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>Transformation to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply <strong>rotation</strong> to the coordinates of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the untransformed coordinate
space.</p>
<dl class="function">
<dt id="c.drm_rect_rotate_inv">
void <code class="descname">drm_rect_rotate_inv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;width</em>, int<em>&nbsp;height</em>, unsigned int<em>&nbsp;rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse rotate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be rotated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>Width of the coordinate space</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>Height of the coordinate space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>Transformation whose inverse is to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the inverse of <strong>rotation</strong> to the coordinates
of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the original untransformed
coordinate space, so that you never have to flip
them when doing a rotatation and its inverse.
That is, if you do</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>DRM_MODE_PROP_ROTATE(:c:type:`r`, width, height, rotation);
DRM_MODE_ROTATE_inv(:c:type:`r`, width, height, rotation);
</pre></div>
</div>
<p>you will always get back the original rectangle.</p>
</div>
<div class="section" id="hdmi-infoframes-helper-reference">
<h2>HDMI Infoframes Helper Reference<a class="headerlink" href="#hdmi-infoframes-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Strictly speaking this is not a DRM helper library but generally useable
by any driver interfacing with HDMI outputs like v4l or alsa drivers.
But it nicely fits into the overall topic of mode setting helper
libraries and hence is also included here.</p>
<dl class="type">
<dt id="c.hdmi_infoframe">
union <code class="descname">hdmi_infoframe</code><a class="headerlink" href="#c.hdmi_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>overall union of all abstract infoframe representations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>union hdmi_infoframe {
  struct hdmi_any_infoframe any;
  struct hdmi_avi_infoframe avi;
  struct hdmi_spd_infoframe spd;
  union hdmi_vendor_any_infoframe vendor;
  struct hdmi_audio_infoframe audio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">any</span></code></dt>
<dd>generic infoframe</dd>
<dt><code class="docutils literal"><span class="pre">avi</span></code></dt>
<dd>avi infoframe</dd>
<dt><code class="docutils literal"><span class="pre">spd</span></code></dt>
<dd>spd infoframe</dd>
<dt><code class="docutils literal"><span class="pre">vendor</span></code></dt>
<dd>union of all vendor infoframes</dd>
<dt><code class="docutils literal"><span class="pre">audio</span></code></dt>
<dd>audio infoframe</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used by the generic pack function. This works since all infoframes
have the same header which also indicates which type of infoframe should be
packed.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_init">
int <code class="descname">hdmi_avi_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em>&nbsp;frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI AVI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI AVI infoframe</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_pack">
ssize_t <code class="descname">hdmi_avi_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI AVI infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI AVI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_init">
int <code class="descname">hdmi_spd_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe *<em>&nbsp;frame</em>, const char *<em>&nbsp;vendor</em>, const char *<em>&nbsp;product</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI SPD infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI SPD infoframe</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">vendor</span></code></dt>
<dd>vendor string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">product</span></code></dt>
<dd>product string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_pack">
ssize_t <code class="descname">hdmi_spd_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI SPD infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI SPD infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_init">
int <code class="descname">hdmi_audio_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe *<em>&nbsp;frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI audio infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI audio infoframe</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack">
ssize_t <code class="descname">hdmi_audio_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI audio infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI audio infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_init">
int <code class="descname">hdmi_vendor_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em>&nbsp;frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI vendor infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI vendor infoframe</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_pack">
ssize_t <code class="descname">hdmi_vendor_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI vendor infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_pack">
ssize_t <code class="descname">hdmi_infoframe_pack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI infoframe to binary buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.hdmi_infoframe_log">
void <code class="descname">hdmi_infoframe_log</code><span class="sig-paren">(</span>const char *<em>&nbsp;level</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em>&nbsp;frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_log" title="Permalink to this definition">¶</a></dt>
<dd><p>log info of HDMI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">level</span></code></dt>
<dd>logging level</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI infoframe</dd>
</dl>
<dl class="function">
<dt id="c.hdmi_infoframe_unpack">
int <code class="descname">hdmi_infoframe_unpack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a> *<em>&nbsp;frame</em>, void *<em>&nbsp;buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>unpack binary buffer to a HDMI infoframe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>source buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpacks the information contained in binary buffer <strong>buffer</strong> into a structured
<strong>frame</strong> of a HDMI infoframe.
Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<div class="section" id="flip-work-helper-reference">
<h2>Flip-work Helper Reference<a class="headerlink" href="#flip-work-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Util to queue up work to run from work-queue context after flip/vblank.
Typically this can be used to defer unref of framebuffer&#8217;s, cursor
bo&#8217;s, etc until after vblank.  The APIs are all thread-safe.
Moreover, drm_flip_work_queue_task and drm_flip_work_queue can be called
in atomic context.</p>
<dl class="type">
<dt id="c.drm_flip_task">
struct <code class="descname">drm_flip_task</code><a class="headerlink" href="#c.drm_flip_task" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work task</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_flip_task {
  struct list_head node;
  void * data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>list entry element</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>data to pass to <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work"><code class="xref c c-type docutils literal"><span class="pre">drm_flip_work.func</span></code></a></dd>
</dl>
<dl class="type">
<dt id="c.drm_flip_work">
struct <code class="descname">drm_flip_work</code><a class="headerlink" href="#c.drm_flip_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work queue</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_flip_work {
  const char * name;
  drm_flip_func_t func;
  struct work_struct worker;
  struct list_head queued;
  struct list_head commited;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>debug name</dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>callback fxn called for each committed item</dd>
<dt><code class="docutils literal"><span class="pre">worker</span></code></dt>
<dd>worker which calls <strong>func</strong></dd>
<dt><code class="docutils literal"><span class="pre">queued</span></code></dt>
<dd>queued tasks</dd>
<dt><code class="docutils literal"><span class="pre">commited</span></code></dt>
<dd>commited tasks</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>lock to access queued and commited lists</dd>
</dl>
<dl class="function">
<dt id="c.drm_flip_work_allocate_task">
struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a> * <code class="descname">drm_flip_work_allocate_task</code><span class="sig-paren">(</span>void *<em>&nbsp;data</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_allocate_task" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a flip-work task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data associated to the task</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>allocator flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a drm_flip_task object and attach private data to it.</p>
<dl class="function">
<dt id="c.drm_flip_work_queue_task">
void <code class="descname">drm_flip_work_queue_task</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em>&nbsp;work</em>, struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a> *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue_task" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a specific task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the flip-work</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>the task to handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues task, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
<dl class="function">
<dt id="c.drm_flip_work_queue">
void <code class="descname">drm_flip_work_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em>&nbsp;work</em>, void *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the flip-work</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>the value to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues work, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
<dl class="function">
<dt id="c.drm_flip_work_commit">
void <code class="descname">drm_flip_work_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em>&nbsp;work</em>, struct workqueue_struct *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit queued work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the flip-work</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>the work-queue to run the queued work on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trigger work previously queued by <a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal"><span class="pre">drm_flip_work_queue()</span></code></a> to run
on a workqueue.  The typical usage would be to queue work (via
<a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal"><span class="pre">drm_flip_work_queue()</span></code></a>) at any point (from vblank irq and/or
prior), and then from vblank irq commit the queued work.</p>
<dl class="function">
<dt id="c.drm_flip_work_init">
void <code class="descname">drm_flip_work_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em>&nbsp;work</em>, const char *<em>&nbsp;name</em>, drm_flip_func_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize flip-work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the flip-work to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>debug name</dd>
<dt><code class="docutils literal"><span class="pre">drm_flip_func_t</span> <span class="pre">func</span></code></dt>
<dd>the callback work function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes/allocates resources for the flip-work</p>
<dl class="function">
<dt id="c.drm_flip_work_cleanup">
void <code class="descname">drm_flip_work_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a> *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up flip-work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the flip-work to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy resources allocated for the flip-work</p>
</div>
<div class="section" id="plane-helper-reference">
<h2>Plane Helper Reference<a class="headerlink" href="#plane-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library has two parts. The first part has support to implement
primary plane support on top of the normal CRTC configuration interface.
Since the legacy <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> interface ties the primary
plane together with the CRTC state this does not allow userspace to disable
the primary plane itself.  To avoid too much duplicated code use
<a class="reference internal" href="#c.drm_plane_helper_check_update" title="drm_plane_helper_check_update"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_helper_check_update()</span></code></a> which can be used to enforce the same
restrictions as primary planes had thus. The default primary plane only
expose XRBG8888 and ARGB8888 as valid pixel formats for the attached
framebuffer.</p>
<p>Drivers are highly recommended to implement proper support for primary
planes, and newly merged drivers must not rely upon these transitional
helpers.</p>
<p>The second part also implements transitional helpers which allow drivers to
gradually switch to the atomic helper infrastructure for plane updates. Once
that switch is complete drivers shouldn&#8217;t use these any longer, instead using
the proper legacy implementations for update and disable plane hooks provided
by the atomic helpers.</p>
<p>Again drivers are strongly urged to switch to the new interfaces.</p>
<p>The plane helpers share the function table structures with other helpers,
specifically also the atomic helpers. See <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> for
the details.</p>
<dl class="function">
<dt id="c.drm_plane_helper_check_state">
int <code class="descname">drm_plane_helper_check_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;clip</em>, int<em>&nbsp;min_scale</em>, int<em>&nbsp;max_scale</em>, bool<em>&nbsp;can_position</em>, bool<em>&nbsp;can_update_disabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_check_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check plane state for validity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>plane state to check</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt>
<dd>integer clipping coordinates</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_scale</span></code></dt>
<dd>minimum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_scale</span></code></dt>
<dd>maximum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">can_position</span></code></dt>
<dd>is it legal to position the plane such that it
doesn&#8217;t cover the entire crtc?  This will generally
only be false for primary planes.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">can_update_disabled</span></code></dt>
<dd>can the plane be updated while the crtc
is disabled?</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a desired plane update is valid, and updates various
bits of derived state (clipped coordinates etc.). Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.</p>
<p><strong>Return</strong></p>
<p>Zero if update appears valid, error code on failure</p>
<dl class="function">
<dt id="c.drm_plane_helper_check_update">
int <code class="descname">drm_plane_helper_check_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;dst</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;clip</em>, unsigned int<em>&nbsp;rotation</em>, int<em>&nbsp;min_scale</em>, int<em>&nbsp;max_scale</em>, bool<em>&nbsp;can_position</em>, bool<em>&nbsp;can_update_disabled</em>, bool *<em>&nbsp;visible</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_check_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Check plane update for validity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>owning CRTC of owning plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to flip onto plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source coordinates in 16.16 fixed point</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>integer destination coordinates</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">clip</span></code></dt>
<dd>integer clipping coordinates</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>plane rotation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_scale</span></code></dt>
<dd>minimum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_scale</span></code></dt>
<dd>maximum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">can_position</span></code></dt>
<dd>is it legal to position the plane such that it
doesn&#8217;t cover the entire crtc?  This will generally
only be false for primary planes.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">can_update_disabled</span></code></dt>
<dd>can the plane be updated while the crtc
is disabled?</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">visible</span></code></dt>
<dd>output parameter indicating whether plane is still visible after
clipping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a desired plane update is valid.  Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.</p>
<p><strong>Return</strong></p>
<p>Zero if update appears valid, error code on failure</p>
<dl class="function">
<dt id="c.drm_primary_helper_update">
int <code class="descname">drm_primary_helper_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;crtc_x</em>, int<em>&nbsp;crtc_y</em>, unsigned int<em>&nbsp;crtc_w</em>, unsigned int<em>&nbsp;crtc_h</em>, uint32_t<em>&nbsp;src_x</em>, uint32_t<em>&nbsp;src_y</em>, uint32_t<em>&nbsp;src_w</em>, uint32_t<em>&nbsp;src_h</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_primary_helper_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>owning CRTC of owning plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to flip onto plane</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt>
<dd>x offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt>
<dd>y offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt>
<dd>width of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt>
<dd>height of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt>
<dd>x offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt>
<dd>y offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt>
<dd>width of source rectangle in <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt>
<dd>height of source rectangle in <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context, not used here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane update handler for primary planes.  This is handler
is called in response to a userspace SetPlane operation on the plane with a
non-NULL framebuffer.  We call the driver&#8217;s modeset handler to update the
framebuffer.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">SetPlane()</span></code> on a primary plane of a disabled CRTC is not supported, and will
return an error.</p>
<p>Note that we make some assumptions about hardware limitations that may not be
true for all hardware &#8211;</p>
<ol class="arabic simple">
<li>Primary plane cannot be repositioned.</li>
<li>Primary plane cannot be scaled.</li>
<li>Primary plane must cover the entire CRTC.</li>
<li>Subpixel positioning is not supported.</li>
</ol>
<p>Drivers for hardware that don&#8217;t have these restrictions can provide their
own implementation rather than using this helper.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_primary_helper_disable">
int <code class="descname">drm_primary_helper_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_primary_helper_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane disable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to disable</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquire context, not used here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane disable handler for primary planes.  This is handler
is called in response to a userspace SetPlane operation on the plane with a
NULL framebuffer parameter.  It unconditionally fails the disable call with
-EINVAL the only way to disable the primary plane without driver support is
to disable the entire CRTC. Which does not match the plane
<a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.disable_plane</span></code></a> hook.</p>
<p>Note that some hardware may be able to disable the primary plane without
disabling the whole CRTC.  Drivers for such hardware should provide their
own disable handler that disables just the primary plane (and they&#8217;ll likely
need to provide their own update handler as well to properly re-enable a
disabled primary plane).</p>
<p><strong>Return</strong></p>
<p>Unconditionally returns -EINVAL.</p>
<dl class="function">
<dt id="c.drm_primary_helper_destroy">
void <code class="descname">drm_primary_helper_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_primary_helper_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane destruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to destroy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane destroy handler for primary planes.  This handler
is called during CRTC destruction.  We disable the primary plane, remove
it from the DRM plane list, and deallocate the plane structure.</p>
<dl class="function">
<dt id="c.drm_plane_helper_update">
int <code class="descname">drm_plane_helper_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;crtc_x</em>, int<em>&nbsp;crtc_y</em>, unsigned int<em>&nbsp;crtc_w</em>, unsigned int<em>&nbsp;crtc_h</em>, uint32_t<em>&nbsp;src_x</em>, uint32_t<em>&nbsp;src_y</em>, uint32_t<em>&nbsp;src_w</em>, uint32_t<em>&nbsp;src_h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitional helper for plane update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>owning CRTC of owning plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to flip onto plane</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt>
<dd>x offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt>
<dd>y offset of primary plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt>
<dd>width of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt>
<dd>height of primary plane rectangle on crtc</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt>
<dd>x offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt>
<dd>y offset of <strong>fb</strong> for panning</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt>
<dd>width of source rectangle in <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt>
<dd>height of source rectangle in <strong>fb</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane update handler using the atomic plane update
functions. It is fully left to the driver to check plane constraints and
handle corner-cases like a fully occluded or otherwise invisible plane.</p>
<p>This is useful for piecewise transitioning of a driver to the atomic helpers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_plane_helper_disable">
int <code class="descname">drm_plane_helper_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Transitional helper for plane disable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane disable handler using the atomic plane update
functions. It is fully left to the driver to check plane constraints and
handle corner-cases like a fully occluded or otherwise invisible plane.</p>
<p>This is useful for piecewise transitioning of a driver to the atomic helpers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
</div>
<div class="section" id="auxiliary-modeset-helpers">
<h2>Auxiliary Modeset Helpers<a class="headerlink" href="#auxiliary-modeset-helpers" title="Permalink to this headline">¶</a></h2>
<p>This helper library contains various one-off functions which don&#8217;t really fit
anywhere else in the DRM modeset helper library.</p>
<dl class="function">
<dt id="c.drm_helper_move_panel_connectors_to_head">
void <code class="descname">drm_helper_move_panel_connectors_to_head</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_move_panel_connectors_to_head" title="Permalink to this definition">¶</a></dt>
<dd><p>move panels to the front in the connector list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some userspace presumes that the first connected connector is the main
display, where it&#8217;s supposed to display e.g. the login screen. For
laptops, this should be the main panel. Use this function to sort all
(eDP/LVDS/DSI) panels to the front of the connector list, instead of
painstakingly trying to initialize them in the right order.</p>
<dl class="function">
<dt id="c.drm_helper_mode_fill_fb_struct">
void <code class="descname">drm_helper_mode_fill_fb_struct</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, const struct drm_mode_fb_cmd2 *<em>&nbsp;mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_mode_fill_fb_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out framebuffer metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>drm_framebuffer object to fill out</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt>
<dd>metadata from the userspace fb creation request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper can be used in a drivers fb_create callback to pre-fill the fb&#8217;s
metadata fields.</p>
<dl class="function">
<dt id="c.drm_crtc_init">
int <code class="descname">drm_crtc_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Legacy CRTC initialization function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC object to init</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a CRTC object with a default helper-provided primary plane and no
cursor plane.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-uapi.html" class="btn btn-neutral float-right" title="Userland interfaces" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms.html" class="btn btn-neutral" title="Kernel Mode Setting (KMS)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.13.0-rc5+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>