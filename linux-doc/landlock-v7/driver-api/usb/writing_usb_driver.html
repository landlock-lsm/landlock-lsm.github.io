

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing USB Device Drivers &mdash; The Linux Kernel 4.13.0-rc5+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="The Linux Kernel 4.13.0-rc5+ documentation" href="../../index.html"/>
        <link rel="up" title="Linux USB API" href="index.html"/>
        <link rel="next" title="Synopsys DesignWare Core SuperSpeed USB 3.0 Controller" href="dwc3.html"/>
        <link rel="prev" title="USB Error codes" href="error-codes.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.13.0-rc5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux USB API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gadget.html">USB Gadget API for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="anchors.html">USB Anchors</a></li>
<li class="toctree-l3"><a class="reference internal" href="bulk-streams.html">USB bulk streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="callbacks.html">USB core callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma.html">USB DMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="URB.html">USB Request Block (URB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="power-management.html">Power Management for USB</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotplug.html">USB hotplugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="persist.html">USB device persistence during system suspend</a></li>
<li class="toctree-l3"><a class="reference internal" href="error-codes.html">USB Error codes</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Writing USB Device Drivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-usb-basics">Linux USB Basics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-operation">Device operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#isochronous-data">Isochronous Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resources">Resources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dwc3.html">Synopsys DesignWare Core SuperSpeed USB 3.0 Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_musb_glue_layer.html">Writing a MUSB Glue Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="typec.html">USB Type-C connector class</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb3-debug-port.html">USB3 debug port</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux USB API</a> &raquo;</li>
        
      <li>Writing USB Device Drivers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/usb/writing_usb_driver.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-usb-device-drivers">
<span id="writing-usb-driver"></span><h1>Writing USB Device Drivers<a class="headerlink" href="#writing-usb-device-drivers" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Greg Kroah-Hartman</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Linux USB subsystem has grown from supporting only two different
types of devices in the 2.2.7 kernel (mice and keyboards), to over 20
different types of devices in the 2.4 kernel. Linux currently supports
almost all USB class devices (standard types of devices like keyboards,
mice, modems, printers and speakers) and an ever-growing number of
vendor-specific devices (such as USB to serial converters, digital
cameras, Ethernet devices and MP3 players). For a full list of the
different USB devices currently supported, see Resources.</p>
<p>The remaining kinds of USB devices that do not have support on Linux are
almost all vendor-specific devices. Each vendor decides to implement a
custom protocol to talk to their device, so a custom driver usually
needs to be created. Some vendors are open with their USB protocols and
help with the creation of Linux drivers, while others do not publish
them, and developers are forced to reverse-engineer. See Resources for
some links to handy reverse-engineering tools.</p>
<p>Because each different protocol causes a new driver to be created, I
have written a generic USB driver skeleton, modelled after the
pci-skeleton.c file in the kernel source tree upon which many PCI
network drivers have been based. This USB skeleton can be found at
drivers/usb/usb-skeleton.c in the kernel source tree. In this article I
will walk through the basics of the skeleton driver, explaining the
different pieces and what needs to be done to customize it to your
specific device.</p>
</div>
<div class="section" id="linux-usb-basics">
<h2>Linux USB Basics<a class="headerlink" href="#linux-usb-basics" title="Permalink to this headline">¶</a></h2>
<p>If you are going to write a Linux USB driver, please become familiar
with the USB protocol specification. It can be found, along with many
other useful documents, at the USB home page (see Resources). An
excellent introduction to the Linux USB subsystem can be found at the
USB Working Devices List (see Resources). It explains how the Linux USB
subsystem is structured and introduces the reader to the concept of USB
urbs (USB Request Blocks), which are essential to USB drivers.</p>
<p>The first thing a Linux USB driver needs to do is register itself with
the Linux USB subsystem, giving it some information about which devices
the driver supports and which functions to call when a device supported
by the driver is inserted or removed from the system. All of this
information is passed to the USB subsystem in the <a class="reference internal" href="usb.html#c.usb_driver" title="usb_driver"><code class="xref c c-type docutils literal"><span class="pre">usb_driver</span></code></a>
structure. The skeleton driver declares a <a class="reference internal" href="usb.html#c.usb_driver" title="usb_driver"><code class="xref c c-type docutils literal"><span class="pre">usb_driver</span></code></a> as:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static struct usb_driver skel_driver = {
        .name        = &quot;skeleton&quot;,
        .probe       = skel_probe,
        .disconnect  = skel_disconnect,
        .fops        = &amp;skel_fops,
        .minor       = USB_SKEL_MINOR_BASE,
        .id_table    = skel_table,
};
</pre></div>
</div>
<p>The variable name is a string that describes the driver. It is used in
informational messages printed to the system log. The probe and
disconnect function pointers are called when a device that matches the
information provided in the <code class="docutils literal"><span class="pre">id_table</span></code> variable is either seen or
removed.</p>
<p>The fops and minor variables are optional. Most USB drivers hook into
another kernel subsystem, such as the SCSI, network or TTY subsystem.
These types of drivers register themselves with the other kernel
subsystem, and any user-space interactions are provided through that
interface. But for drivers that do not have a matching kernel subsystem,
such as MP3 players or scanners, a method of interacting with user space
is needed. The USB subsystem provides a way to register a minor device
number and a set of <code class="xref c c-type docutils literal"><span class="pre">file_operations</span></code> function pointers that enable
this user-space interaction. The skeleton driver needs this kind of
interface, so it provides a minor starting number and a pointer to its
<code class="xref c c-type docutils literal"><span class="pre">file_operations</span></code> functions.</p>
<p>The USB driver is then registered with a call to <code class="xref c c-func docutils literal"><span class="pre">usb_register()</span></code>,
usually in the driver&#8217;s init function, as shown here:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static int __init usb_skel_init(void)
{
        int result;

        /* register this driver with the USB subsystem */
        result = usb_register(&amp;skel_driver);
        if (result &lt; 0) {
                err(&quot;usb_register failed for the &quot;__FILE__ &quot;driver.&quot;
                    &quot;Error number %d&quot;, result);
                return -1;
        }

        return 0;
}
module_init(usb_skel_init);
</pre></div>
</div>
<p>When the driver is unloaded from the system, it needs to deregister
itself with the USB subsystem. This is done with the <a class="reference internal" href="usb.html#c.usb_deregister" title="usb_deregister"><code class="xref c c-func docutils literal"><span class="pre">usb_deregister()</span></code></a>
function:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void __exit usb_skel_exit(void)
{
        /* deregister this driver with the USB subsystem */
        usb_deregister(&amp;skel_driver);
}
module_exit(usb_skel_exit);
</pre></div>
</div>
<p>To enable the linux-hotplug system to load the driver automatically when
the device is plugged in, you need to create a <code class="docutils literal"><span class="pre">MODULE_DEVICE_TABLE</span></code>.
The following code tells the hotplug scripts that this module supports a
single device with a specific vendor and product ID:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* table of devices that work with this driver */
static struct usb_device_id skel_table [] = {
        { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
        { }                      /* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);
</pre></div>
</div>
<p>There are other macros that can be used in describing a struct
<a class="reference internal" href="../basics.html#c.usb_device_id" title="usb_device_id"><code class="xref c c-type docutils literal"><span class="pre">usb_device_id</span></code></a> for drivers that support a whole class of USB
drivers. See <a class="reference internal" href="usb.html#usb-header"><span class="std std-ref">usb.h</span></a> for more information on this.</p>
</div>
<div class="section" id="device-operation">
<h2>Device operation<a class="headerlink" href="#device-operation" title="Permalink to this headline">¶</a></h2>
<p>When a device is plugged into the USB bus that matches the device ID
pattern that your driver registered with the USB core, the probe
function is called. The <a class="reference internal" href="usb.html#c.usb_device" title="usb_device"><code class="xref c c-type docutils literal"><span class="pre">usb_device</span></code></a> structure, interface number and
the interface ID are passed to the function:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static int skel_probe(struct usb_interface *interface,
    const struct usb_device_id *id)
</pre></div>
</div>
<p>The driver now needs to verify that this device is actually one that it
can accept. If so, it returns 0. If not, or if any error occurs during
initialization, an errorcode (such as <code class="docutils literal"><span class="pre">-ENOMEM</span></code> or <code class="docutils literal"><span class="pre">-ENODEV</span></code>) is
returned from the probe function.</p>
<p>In the skeleton driver, we determine what end points are marked as
bulk-in and bulk-out. We create buffers to hold the data that will be
sent and received from the device, and a USB urb to write data to the
device is initialized.</p>
<p>Conversely, when the device is removed from the USB bus, the disconnect
function is called with the device pointer. The driver needs to clean
any private data that has been allocated at this time and to shut down
any pending urbs that are in the USB system.</p>
<p>Now that the device is plugged into the system and the driver is bound
to the device, any of the functions in the <code class="xref c c-type docutils literal"><span class="pre">file_operations</span></code> structure
that were passed to the USB subsystem will be called from a user program
trying to talk to the device. The first function called will be open, as
the program tries to open the device for I/O. We increment our private
usage count and save a pointer to our internal structure in the file
structure. This is done so that future calls to file operations will
enable the driver to determine which device the user is addressing. All
of this is done with the following code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* increment our usage count for the module */
++skel-&gt;open_count;

/* save our object in the file&#39;s private structure */
file-&gt;private_data = dev;
</pre></div>
</div>
<p>After the open function is called, the read and write functions are
called to receive and send data to the device. In the <code class="docutils literal"><span class="pre">skel_write</span></code>
function, we receive a pointer to some data that the user wants to send
to the device and the size of the data. The function determines how much
data it can send to the device based on the size of the write urb it has
created (this size depends on the size of the bulk out end point that
the device has). Then it copies the data from user space to kernel
space, points the urb to the data and submits the urb to the USB
subsystem. This can be seen in the following code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* we can only write as much as 1 urb will hold */
bytes_written = (count &gt; skel-&gt;bulk_out_size) ? skel-&gt;bulk_out_size : count;

/* copy the data from user space into our urb */
copy_from_user(skel-&gt;write_urb-&gt;transfer_buffer, buffer, bytes_written);

/* set up our urb */
usb_fill_bulk_urb(skel-&gt;write_urb,
                  skel-&gt;dev,
                  usb_sndbulkpipe(skel-&gt;dev, skel-&gt;bulk_out_endpointAddr),
                  skel-&gt;write_urb-&gt;transfer_buffer,
                  bytes_written,
                  skel_write_bulk_callback,
                  skel);

/* send the data out the bulk port */
result = usb_submit_urb(skel-&gt;write_urb);
if (result) {
        err(&quot;Failed submitting write urb, error %d&quot;, result);
}
</pre></div>
</div>
<p>When the write urb is filled up with the proper information using the
<a class="reference internal" href="usb.html#c.usb_fill_bulk_urb" title="usb_fill_bulk_urb"><code class="xref c c-func docutils literal"><span class="pre">usb_fill_bulk_urb()</span></code></a> function, we point the urb&#8217;s completion callback
to call our own <code class="docutils literal"><span class="pre">skel_write_bulk_callback</span></code> function. This function is
called when the urb is finished by the USB subsystem. The callback
function is called in interrupt context, so caution must be taken not to
do very much processing at that time. Our implementation of
<code class="docutils literal"><span class="pre">skel_write_bulk_callback</span></code> merely reports if the urb was completed
successfully or not and then returns.</p>
<p>The read function works a bit differently from the write function in
that we do not use an urb to transfer data from the device to the
driver. Instead we call the <a class="reference internal" href="usb.html#c.usb_bulk_msg" title="usb_bulk_msg"><code class="xref c c-func docutils literal"><span class="pre">usb_bulk_msg()</span></code></a> function, which can be used
to send or receive data from a device without having to create urbs and
handle urb completion callback functions. We call the <a class="reference internal" href="usb.html#c.usb_bulk_msg" title="usb_bulk_msg"><code class="xref c c-func docutils literal"><span class="pre">usb_bulk_msg()</span></code></a>
function, giving it a buffer into which to place any data received from
the device and a timeout value. If the timeout period expires without
receiving any data from the device, the function will fail and return an
error message. This can be shown with the following code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* do an immediate bulk read to get data from the device */
retval = usb_bulk_msg (skel-&gt;dev,
                       usb_rcvbulkpipe (skel-&gt;dev,
                       skel-&gt;bulk_in_endpointAddr),
                       skel-&gt;bulk_in_buffer,
                       skel-&gt;bulk_in_size,
                       &amp;count, HZ*10);
/* if the read was successful, copy the data to user space */
if (!retval) {
        if (copy_to_user (buffer, skel-&gt;bulk_in_buffer, count))
                retval = -EFAULT;
        else
                retval = count;
}
</pre></div>
</div>
<p>The <a class="reference internal" href="usb.html#c.usb_bulk_msg" title="usb_bulk_msg"><code class="xref c c-func docutils literal"><span class="pre">usb_bulk_msg()</span></code></a> function can be very useful for doing single reads
or writes to a device; however, if you need to read or write constantly to
a device, it is recommended to set up your own urbs and submit them to
the USB subsystem.</p>
<p>When the user program releases the file handle that it has been using to
talk to the device, the release function in the driver is called. In
this function we decrement our private usage count and wait for possible
pending writes:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* decrement our usage count for the device */
--skel-&gt;open_count;
</pre></div>
</div>
<p>One of the more difficult problems that USB drivers must be able to
handle smoothly is the fact that the USB device may be removed from the
system at any point in time, even if a program is currently talking to
it. It needs to be able to shut down any current reads and writes and
notify the user-space programs that the device is no longer there. The
following code (function <code class="docutils literal"><span class="pre">skel_delete</span></code>) is an example of how to do
this:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static inline void skel_delete (struct usb_skel *dev)
{
    kfree (dev-&gt;bulk_in_buffer);
    if (dev-&gt;bulk_out_buffer != NULL)
        usb_free_coherent (dev-&gt;udev, dev-&gt;bulk_out_size,
            dev-&gt;bulk_out_buffer,
            dev-&gt;write_urb-&gt;transfer_dma);
    usb_free_urb (dev-&gt;write_urb);
    kfree (dev);
}
</pre></div>
</div>
<p>If a program currently has an open handle to the device, we reset the
flag <code class="docutils literal"><span class="pre">device_present</span></code>. For every read, write, release and other
functions that expect a device to be present, the driver first checks
this flag to see if the device is still present. If not, it releases
that the device has disappeared, and a <code class="docutils literal"><span class="pre">-ENODEV</span></code> error is returned to the
user-space program. When the release function is eventually called, it
determines if there is no device and if not, it does the cleanup that
the <code class="docutils literal"><span class="pre">skel_disconnect</span></code> function normally does if there are no open files
on the device (see Listing 5).</p>
</div>
<div class="section" id="isochronous-data">
<h2>Isochronous Data<a class="headerlink" href="#isochronous-data" title="Permalink to this headline">¶</a></h2>
<p>This usb-skeleton driver does not have any examples of interrupt or
isochronous data being sent to or from the device. Interrupt data is
sent almost exactly as bulk data is, with a few minor exceptions.
Isochronous data works differently with continuous streams of data being
sent to or from the device. The audio and video camera drivers are very
good examples of drivers that handle isochronous data and will be useful
if you also need to do this.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Writing Linux USB device drivers is not a difficult task as the
usb-skeleton driver shows. This driver, combined with the other current
USB drivers, should provide enough examples to help a beginning author
create a working driver in a minimal amount of time. The linux-usb-devel
mailing list archives also contain a lot of helpful information.</p>
</div>
<div class="section" id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this headline">¶</a></h2>
<p>The Linux USB Project:
<a class="reference external" href="http://www.linux-usb.org/">http://www.linux-usb.org/</a></p>
<p>Linux Hotplug Project:
<a class="reference external" href="http://linux-hotplug.sourceforge.net/">http://linux-hotplug.sourceforge.net/</a></p>
<p>Linux USB Working Devices List:
<a class="reference external" href="http://www.qbik.ch/usb/devices/">http://www.qbik.ch/usb/devices/</a></p>
<p>linux-usb-devel Mailing List Archives:
<a class="reference external" href="http://marc.theaimsgroup.com/?l=linux-usb-devel">http://marc.theaimsgroup.com/?l=linux-usb-devel</a></p>
<p>Programming Guide for Linux USB Device Drivers:
<a class="reference external" href="http://usb.cs.tum.edu/usbdoc">http://usb.cs.tum.edu/usbdoc</a></p>
<p>USB Home Page: <a class="reference external" href="http://www.usb.org">http://www.usb.org</a></p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dwc3.html" class="btn btn-neutral float-right" title="Synopsys DesignWare Core SuperSpeed USB 3.0 Controller" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="error-codes.html" class="btn btn-neutral" title="USB Error codes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.13.0-rc5+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>