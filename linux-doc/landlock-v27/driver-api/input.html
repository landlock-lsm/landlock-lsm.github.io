

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Input Subsystem &mdash; The Linux Kernel 5.11.0-rc4+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux USB API" href="usb/index.html" />
    <link rel="prev" title="HW consumer" href="iio/hw-consumer.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0-rc4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Input Subsystem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-core">Input core</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multitouch-library">Multitouch Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-keyboards-keypads">Matrix keyboards/keypads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-keymap-support">Sparse keymap support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Input Subsystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/input.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="input-subsystem">
<h1>Input Subsystem<a class="headerlink" href="#input-subsystem" title="Permalink to this headline">¶</a></h1>
<div class="section" id="input-core">
<h2>Input core<a class="headerlink" href="#input-core" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.input_value">
<em class="property">struct </em><code class="sig-name descname">input_value</code><a class="headerlink" href="#c.input_value" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>input value representation</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_value {
  __u16 type;
  __u16 code;
  __s32 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of value (EV_KEY, EV_ABS, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt><dd><p>the value code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>the value</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.input_dev">
<em class="property">struct </em><code class="sig-name descname">input_dev</code><a class="headerlink" href="#c.input_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>represents an input device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_dev {
  const char *name;
  const char *phys;
  const char *uniq;
  struct input_id id;
  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];
  unsigned int hint_events_per_packet;
  unsigned int keycodemax;
  unsigned int keycodesize;
  void *keycode;
  int (*setkeycode)(struct input_dev *dev,const struct input_keymap_entry *ke, unsigned int *old_keycode);
  int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke);
  struct ff_device *ff;
  struct input_dev_poller *poller;
  unsigned int repeat_key;
  struct timer_list timer;
  int rep[REP_CNT];
  struct input_mt *mt;
  struct input_absinfo *absinfo;
  unsigned long key[BITS_TO_LONGS(KEY_CNT)];
  unsigned long led[BITS_TO_LONGS(LED_CNT)];
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];
  int (*open)(struct input_dev *dev);
  void (*close)(struct input_dev *dev);
  int (*flush)(struct input_dev *dev, struct file *file);
  int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
  struct input_handle __rcu *grab;
  spinlock_t event_lock;
  struct mutex mutex;
  unsigned int users;
  bool going_away;
  struct device dev;
  struct list_head        h_list;
  struct list_head        node;
  unsigned int num_vals;
  unsigned int max_vals;
  struct input_value *vals;
  bool devres_managed;
  ktime_t timestamp[INPUT_CLK_MAX];
  bool inhibited;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys</span></code></dt><dd><p>physical path to the device in the system hierarchy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uniq</span></code></dt><dd><p>unique identification code for the device (if device has it)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>id of the device (struct input_id)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">propbit</span></code></dt><dd><p>bitmap of device properties and quirks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evbit</span></code></dt><dd><p>bitmap of types of events supported by the device (EV_KEY,
EV_REL, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keybit</span></code></dt><dd><p>bitmap of keys/buttons this device has</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">relbit</span></code></dt><dd><p>bitmap of relative axes for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">absbit</span></code></dt><dd><p>bitmap of absolute axes for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mscbit</span></code></dt><dd><p>bitmap of miscellaneous events supported by the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ledbit</span></code></dt><dd><p>bitmap of leds present on the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sndbit</span></code></dt><dd><p>bitmap of sound effects supported by the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ffbit</span></code></dt><dd><p>bitmap of force feedback effects supported by the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swbit</span></code></dt><dd><p>bitmap of switches present on the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint_events_per_packet</span></code></dt><dd><p>average number of events generated by the
device in a packet (between EV_SYN/SYN_REPORT events). Used by
event handlers to estimate size of the buffer needed to hold
events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycodemax</span></code></dt><dd><p>size of keycode table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycodesize</span></code></dt><dd><p>size of elements in keycode table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycode</span></code></dt><dd><p>map of scancodes to keycodes for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setkeycode</span></code></dt><dd><p>optional method to alter current keymap, used to implement
sparse keymaps. If not supplied default mechanism will be used.
The method is being called while holding event_lock and thus must
not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">getkeycode</span></code></dt><dd><p>optional legacy method to retrieve current keymap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ff</span></code></dt><dd><p>force feedback structure associated with the device if device
supports force feedback effects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poller</span></code></dt><dd><p>poller structure associated with the device if device is
set up to use polling mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">repeat_key</span></code></dt><dd><p>stores key code of the last key pressed; used to implement
software autorepeat</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt><dd><p>timer for software autorepeat</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rep</span></code></dt><dd><p>current values for autorepeat parameters (delay, rate)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mt</span></code></dt><dd><p>pointer to multitouch state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">absinfo</span></code></dt><dd><p>array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_absinfo</span></code> elements holding information
about absolute axes (current value, min, max, flat, fuzz,
resolution)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>reflects current state of device’s keys/buttons</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">led</span></code></dt><dd><p>reflects current state of device’s LEDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd</span></code></dt><dd><p>reflects current state of sound effects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw</span></code></dt><dd><p>reflects current state of device’s switches</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>this method is called when the very first user calls
<a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_open_device()</span></code></a>. The driver must prepare the device
to start generating events (start polling thread,
request an IRQ, submit URB, etc.). The meaning of open() is
to start providing events to the input core.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p>this method is called when the very last user calls
<a class="reference internal" href="#c.input_close_device" title="input_close_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_close_device()</span></code></a>. The meaning of close() is to stop
providing events to the input core.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush</span></code></dt><dd><p>purges the device. Most commonly used to get rid of force
feedback effects loaded into the device when disconnecting
from it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>event handler for events sent _to_ the device, like EV_LED
or EV_SND. The device is expected to carry out the requested
action (turn on a LED, play sound, etc.) The call is protected
by <strong>event_lock</strong> and must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grab</span></code></dt><dd><p>input handle that currently has the device grabbed (via
EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
recipient for all input events coming from the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_lock</span></code></dt><dd><p>this spinlock is taken when input core receives
and processes a new event for the device (in <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_event()</span></code></a>).
Code that accesses and/or modifies parameters of a device
(such as keymap or absmin, absmax, absfuzz, etc.) after device
has been registered with input core must take this lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>serializes calls to open(), close() and flush() methods</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>stores number of users (input handlers) that opened this
device. It is used by <a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_open_device()</span></code></a> and <a class="reference internal" href="#c.input_close_device" title="input_close_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_close_device()</span></code></a>
to make sure that dev-&gt;open() is only called when the first
user opens device and dev-&gt;close() is called when the very
last user closes the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">going_away</span></code></dt><dd><p>marks devices that are in a middle of unregistering and
causes input_open_device*() fail with -ENODEV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model’s view of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_list</span></code></dt><dd><p>list of input handles associated with the device. When
accessing the list dev-&gt;mutex must be held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>used to place the device onto input_dev_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_vals</span></code></dt><dd><p>number of values queued in the current frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_vals</span></code></dt><dd><p>maximum number of values queued in a frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vals</span></code></dt><dd><p>array of values queued in the current frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_managed</span></code></dt><dd><p>indicates that devices is managed with devres framework
and needs not be explicitly unregistered or freed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>storage for a timestamp set by input_set_timestamp called
by a driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inhibited</span></code></dt><dd><p>indicates that the input device is inhibited. If that is
the case then input core ignores any events generated by the device.
Device’s close() is called when it is being inhibited and its open()
is called when it is being uninhibited.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.input_handler">
<em class="property">struct </em><code class="sig-name descname">input_handler</code><a class="headerlink" href="#c.input_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>implements one of interfaces for input devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_handler {
  void *private;
  void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
  void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count);
  bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);
  bool (*match)(struct input_handler *handler, struct input_dev *dev);
  int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
  void (*disconnect)(struct input_handle *handle);
  void (*start)(struct input_handle *handle);
  bool legacy_minors;
  int minor;
  const char *name;
  const struct input_device_id *id_table;
  struct list_head        h_list;
  struct list_head        node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>driver-specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>event handler. This method is being called by input core with
interrupts disabled and dev-&gt;event_lock spinlock held and so
it may not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events</span></code></dt><dd><p>event sequence handler. This method is being called by
input core with interrupts disabled and dev-&gt;event_lock
spinlock held and so it may not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filter</span></code></dt><dd><p>similar to <strong>event</strong>; separates normal event handlers from
“filters”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>called after comparing device’s id with handler’s id_table
to perform fine-grained matching between device and handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect</span></code></dt><dd><p>called when attaching a handler to an input device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>disconnects a handler from input device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>starts handler for given handle. This function is called by
input core right after connect() method and also when a process
that “grabbed” a device releases it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy_minors</span></code></dt><dd><p>set to <code class="docutils literal notranslate"><span class="pre">true</span></code> by drivers using legacy minor ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>beginning of range of 32 legacy minors for devices this driver
can provide</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the handler, to be shown in /proc/bus/input/handlers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>pointer to a table of input_device_ids this driver can
handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_list</span></code></dt><dd><p>list of input handles associated with the handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>for placing the driver onto input_handler_list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input handlers attach to input devices and create input handles. There
are likely several handlers attached to any given input device at the
same time. All of them will get their copy of input event generated by
the device.</p>
<p>The very same structure is used to implement input filters. Input core
allows filters to run first and will not pass event to regular handlers
if any of the filters indicate that the event should be filtered (by
returning <code class="docutils literal notranslate"><span class="pre">true</span></code> from their filter() method).</p>
<p>Note that input core serializes calls to connect() and disconnect()
methods.</p>
<dl class="c struct">
<dt id="c.input_handle">
<em class="property">struct </em><code class="sig-name descname">input_handle</code><a class="headerlink" href="#c.input_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>links input device with an input handler</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_handle {
  void *private;
  int open;
  const char *name;
  struct input_dev *dev;
  struct input_handler *handler;
  struct list_head        d_node;
  struct list_head        h_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>handler-specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>counter showing whether the handle is ‘open’, i.e. should deliver
events from its device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name given to the handle by handler that created it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>input device the handle is attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>handler that works with the device through this handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d_node</span></code></dt><dd><p>used to put the handle on device’s list of attached handles</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_node</span></code></dt><dd><p>used to put the handle on handler’s list of handles from which
it gets events</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.input_set_events_per_packet">
void <code class="sig-name descname">input_set_events_per_packet</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int <em>n_events</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_events_per_packet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tell handlers about the driver event rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the input device used by the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n_events</span></code></dt><dd><p>the average number of events between calls to input_sync()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the event rate sent from a device is unusually large, use this
function to set the expected event rate. This will allow handlers
to set up an appropriate buffer size for the event stream, in order
to minimize information loss.</p>
<dl class="c struct">
<dt id="c.ff_device">
<em class="property">struct </em><code class="sig-name descname">ff_device</code><a class="headerlink" href="#c.ff_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>force-feedback part of an input device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ff_device {
  int (*upload)(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old);
  int (*erase)(struct input_dev *dev, int effect_id);
  int (*playback)(struct input_dev *dev, int effect_id, int value);
  void (*set_gain)(struct input_dev *dev, u16 gain);
  void (*set_autocenter)(struct input_dev *dev, u16 magnitude);
  void (*destroy)(struct ff_device *);
  void *private;
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  struct mutex mutex;
  int max_effects;
  struct ff_effect *effects;
  struct file *effect_owners[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">upload</span></code></dt><dd><p>Called to upload an new effect into device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erase</span></code></dt><dd><p>Called to erase an effect from device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">playback</span></code></dt><dd><p>Called to request device to start playing specified effect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_gain</span></code></dt><dd><p>Called to set specified gain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_autocenter</span></code></dt><dd><p>Called to auto-center device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt><dd><p>called by input core when parent input device is being
destroyed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>driver-specific data, will be freed automatically</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ffbit</span></code></dt><dd><p>bitmap of force feedback capabilities truly supported by
device (not emulated like ones in input_dev-&gt;ffbit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>mutex for serializing access to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_effects</span></code></dt><dd><p>maximum number of effects supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">effects</span></code></dt><dd><p>pointer to an array of effects currently loaded into device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">effect_owners</span></code></dt><dd><p>array of effect owners; when file handle owning
an effect gets closed the effect is automatically erased</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every force-feedback device must implement upload() and playback()
methods; erase() is optional. set_gain() and set_autocenter() need
only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER
bits.</p>
<p>Note that playback(), set_gain() and set_autocenter() are called with
dev-&gt;event_lock spinlock held and interrupts off and thus may not
sleep.</p>
<dl class="c function">
<dt id="c.input_event">
void <code class="sig-name descname">input_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>type</em>, unsigned int <em>code</em>, int <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report new input event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device that generated the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>event code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value of the event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be used by drivers implementing various input
devices to report input events. See also <a class="reference internal" href="#c.input_inject_event" title="input_inject_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_inject_event()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_event()</span></code></a> may be safely used right after input device was
allocated with <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_allocate_device()</span></code></a>, even before it is registered
with <a class="reference internal" href="#c.input_register_device" title="input_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_register_device()</span></code></a>, but the event will not reach any of the
input handlers. Such early invocation of <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_event()</span></code></a> may be used
to ‘seed’ initial state of a switch or initial position of absolute
axis, etc.</p>
<dl class="c function">
<dt id="c.input_inject_event">
void <code class="sig-name descname">input_inject_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em>, unsigned int <em>type</em>, unsigned int <em>code</em>, int <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_inject_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send input event from input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>input handle to send event through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>event code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value of the event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_event()</span></code></a> but will ignore event if device is
“grabbed” and handle injecting event is not the one that owns
the device.</p>
<dl class="c function">
<dt id="c.input_alloc_absinfo">
void <code class="sig-name descname">input_alloc_absinfo</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_alloc_absinfo" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocates array of input_absinfo structs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the input device emitting absolute events</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the absinfo struct the caller asked for is already allocated, this
functions will not do anything.</p>
<dl class="c function">
<dt id="c.input_grab_device">
int <code class="sig-name descname">input_grab_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_grab_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>grabs device for exclusive use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>input handle that wants to own the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device is grabbed by an input handle all events generated by
the device are delivered only to this handle. Also events injected
by other input handles are ignored while device is grabbed.</p>
<dl class="c function">
<dt id="c.input_release_device">
void <code class="sig-name descname">input_release_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_release_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release previously grabbed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>input handle that owns the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases previously grabbed device so that other input handles can
start receiving input events. Upon release all handlers attached
to the device have their <a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> method called so they have a change
to synchronize device state with the rest of the system.</p>
<dl class="c function">
<dt id="c.input_open_device">
int <code class="sig-name descname">input_open_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_open_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>open input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>handle through which device is being accessed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by input handlers when they
want to start receive events from given input device.</p>
<dl class="c function">
<dt id="c.input_close_device">
void <code class="sig-name descname">input_close_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_close_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>close input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>handle through which device is being accessed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by input handlers when they
want to stop receive events from given input device.</p>
<dl class="c function">
<dt id="c.input_scancode_to_scalar">
int <code class="sig-name descname">input_scancode_to_scalar</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> input_keymap_entry *<em>ke</em>, unsigned int *<em>scancode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_scancode_to_scalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>converts scancode in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_keymap_entry</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*ke</span></code></dt><dd><p>keymap entry containing scancode to be converted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*scancode</span></code></dt><dd><p>pointer to the location where converted scancode should
be stored.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to convert scancode stored in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">keymap_entry</span></code>
into scalar form understood by legacy keymap handling methods. These
methods expect scancodes to be represented as ‘unsigned int’.</p>
<dl class="c function">
<dt id="c.input_get_keycode">
int <code class="sig-name descname">input_get_keycode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, <em class="property">struct</em> input_keymap_entry *<em>ke</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_get_keycode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve keycode currently mapped to a given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device which keymap is being queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*ke</span></code></dt><dd><p>keymap entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by anyone interested in retrieving current
keymap. Presently evdev handlers use it.</p>
<dl class="c function">
<dt id="c.input_set_keycode">
int <code class="sig-name descname">input_set_keycode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> input_keymap_entry *<em>ke</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_keycode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>attribute a keycode to a given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device which keymap is being updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_keymap_entry</span> <span class="pre">*ke</span></code></dt><dd><p>new keymap entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by anyone needing to update current
keymap. Presently keyboard and evdev handlers use it.</p>
<dl class="c function">
<dt id="c.input_reset_device">
void <code class="sig-name descname">input_reset_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_reset_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset/restore the state of input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device whose state needs to be reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to reset the state of an opened input device and
bring internal state and state if the hardware in sync with each other.
We mark all keys as released, restore LED state, repeat rate, etc.</p>
<dl class="c function">
<dt id="c.input_allocate_device">
<em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<code class="sig-name descname">input_allocate_device</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.input_allocate_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate memory for new input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns prepared <a class="reference internal" href="#c.input_dev" title="input_dev"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span></code></a> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_free_device()</span></code></a> to free devices that have not been
registered; <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_unregister_device()</span></code></a> should be used for already
registered devices.</p>
<dl class="c function">
<dt id="c.devm_input_allocate_device">
<em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<code class="sig-name descname">devm_input_allocate_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_input_allocate_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate managed input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device owning the input device being created</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns prepared <a class="reference internal" href="#c.input_dev" title="input_dev"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span></code></a> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Managed input devices do not need to be explicitly unregistered or
freed as it will be done automatically when owner device unbinds from
its driver (or binding fails). Once managed input device is allocated,
it is ready to be set up and registered in the same fashion as regular
input device. There are no special devm_input_device_[un]register()
variants, regular ones work with both managed and unmanaged devices,
should you need them. In most cases however, managed input device need
not be explicitly unregistered or freed.</p>
<p><strong>NOTE</strong></p>
<p>the owner device is set up as parent of input device and users
should not override it.</p>
<dl class="c function">
<dt id="c.input_free_device">
void <code class="sig-name descname">input_free_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_free_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free memory occupied by input_dev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should only be used if <a class="reference internal" href="#c.input_register_device" title="input_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_register_device()</span></code></a>
was not called yet or if it failed. Once device was registered
use <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_unregister_device()</span></code></a> and memory will be freed once last
reference to the device is dropped.</p>
<p>Device should be allocated by <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_allocate_device()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>If there are references to the input device then memory
will not be freed until last reference is dropped.</p>
<dl class="c function">
<dt id="c.input_set_timestamp">
void <code class="sig-name descname">input_set_timestamp</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, ktime_t <em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_timestamp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set timestamp for input events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device to set timestamp for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">timestamp</span></code></dt><dd><p>the time at which the event has occurred
in CLOCK_MONOTONIC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is intended to provide to the input system a more
accurate time of when an event actually occurred. The driver should
call this function as soon as a timestamp is acquired ensuring
clock conversions in input_set_timestamp are done correctly.</p>
<p>The system entering suspend state between timestamp acquisition and
calling input_set_timestamp can result in inaccurate conversions.</p>
<dl class="c function">
<dt id="c.input_get_timestamp">
ktime_t *<code class="sig-name descname">input_get_timestamp</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_get_timestamp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get timestamp for input events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device to get timestamp from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A valid timestamp is a timestamp of non-zero value.</p>
<dl class="c function">
<dt id="c.input_set_capability">
void <code class="sig-name descname">input_set_capability</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>type</em>, unsigned int <em>code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_set_capability" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark device as capable of a certain event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device that is capable of emitting or accepting event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of the event (EV_KEY, EV_REL, etc…)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>event code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In addition to setting up corresponding bit in appropriate capability
bitmap the function also adjusts dev-&gt;evbit.</p>
<dl class="c function">
<dt id="c.input_enable_softrepeat">
void <code class="sig-name descname">input_enable_softrepeat</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int <em>delay</em>, int <em>period</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_enable_softrepeat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable software autorepeat</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delay</span></code></dt><dd><p>repeat delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">period</span></code></dt><dd><p>repeat period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable software autorepeat on the input device.</p>
<dl class="c function">
<dt id="c.input_register_device">
int <code class="sig-name descname">input_register_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register device with input core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to be registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers device with input core. The device must be
allocated with <a class="reference internal" href="#c.input_allocate_device" title="input_allocate_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_allocate_device()</span></code></a> and all it’s capabilities
set up before registering.
If function fails the device must be freed with <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_free_device()</span></code></a>.
Once device has been successfully registered it can be unregistered
with <a class="reference internal" href="#c.input_unregister_device" title="input_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_unregister_device()</span></code></a>; <a class="reference internal" href="#c.input_free_device" title="input_free_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_free_device()</span></code></a> should not be
called in this case.</p>
<p>Note that this function is also used to register managed input devices
(ones allocated with <a class="reference internal" href="#c.devm_input_allocate_device" title="devm_input_allocate_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_input_allocate_device()</span></code></a>). Such managed input
devices need not be explicitly unregistered or freed, their tear down
is controlled by the devres infrastructure. It is also worth noting
that tear down of managed input devices is internally a 2-step process:
registered managed input device is first unregistered, but stays in
memory and can still handle <a class="reference internal" href="#c.input_event" title="input_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_event()</span></code></a> calls (although events will
not be delivered anywhere). The freeing of managed input device will
happen later, when devres stack is unwound to the point where device
allocation was made.</p>
<dl class="c function">
<dt id="c.input_unregister_device">
void <code class="sig-name descname">input_unregister_device</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister previously registered device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters an input device. Once device is unregistered
the caller should not try to access it as it may get freed at any moment.</p>
<dl class="c function">
<dt id="c.input_register_handler">
int <code class="sig-name descname">input_register_handler</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*handler</span></code></dt><dd><p>handler to be registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a new input handler (interface) for input
devices in the system and attaches it to all input devices that
are compatible with the handler.</p>
<dl class="c function">
<dt id="c.input_unregister_handler">
void <code class="sig-name descname">input_unregister_handler</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_handler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregisters an input handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*handler</span></code></dt><dd><p>handler to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disconnects a handler from its input devices and
removes it from lists of known handlers.</p>
<dl class="c function">
<dt id="c.input_handler_for_each_handle">
int <code class="sig-name descname">input_handler_for_each_handle</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handler" title="input_handler">input_handler</a> *<em>handler</em>, void *<em>data</em>, int (*<em>fn</em>)<span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a>*, void*<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.input_handler_for_each_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handler</span> <span class="pre">*handler</span></code></dt><dd><p>input handler to iterate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">input_handle</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to be called for each handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>’s list of devices, and call <strong>fn</strong> for each, passing
it <strong>data</strong> and stop when <strong>fn</strong> returns a non-zero value. The function is
using RCU to traverse the list and therefore may be using in atomic
contexts. The <strong>fn</strong> callback is invoked from RCU critical section and
thus must not sleep.</p>
<dl class="c function">
<dt id="c.input_register_handle">
int <code class="sig-name descname">input_register_handle</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_register_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new input handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>handle to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function puts a new input handle onto device’s
and handler’s lists so that events can flow through
it once it is opened using <a class="reference internal" href="#c.input_open_device" title="input_open_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_open_device()</span></code></a>.</p>
<p>This function is supposed to be called from handler’s
connect() method.</p>
<dl class="c function">
<dt id="c.input_unregister_handle">
void <code class="sig-name descname">input_unregister_handle</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_handle" title="input_handle">input_handle</a> *<em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_unregister_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister an input handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_handle</span> <span class="pre">*handle</span></code></dt><dd><p>handle to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes input handle from device’s
and handler’s lists.</p>
<p>This function is supposed to be called from handler’s
disconnect() method.</p>
<dl class="c function">
<dt id="c.input_get_new_minor">
int <code class="sig-name descname">input_get_new_minor</code><span class="sig-paren">(</span>int <em>legacy_base</em>, unsigned int <em>legacy_num</em>, bool <em>allow_dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_get_new_minor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocates a new input minor number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">legacy_base</span></code></dt><dd><p>beginning or the legacy range to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">legacy_num</span></code></dt><dd><p>size of legacy range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">allow_dynamic</span></code></dt><dd><p>whether we can also take ID from the dynamic range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a new device minor for from input major namespace.
Caller can request legacy minor by specifying <strong>legacy_base</strong> and <strong>legacy_num</strong>
parameters and whether ID can be allocated from dynamic range if there are
no free IDs in legacy range.</p>
<dl class="c function">
<dt id="c.input_free_minor">
void <code class="sig-name descname">input_free_minor</code><span class="sig-paren">(</span>unsigned int <em>minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_free_minor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release previously allocated minor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minor</span></code></dt><dd><p>minor to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases previously allocated input minor so that it can be
reused later.</p>
<dl class="c function">
<dt id="c.input_ff_upload">
int <code class="sig-name descname">input_ff_upload</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, <em class="property">struct</em> ff_effect *<em>effect</em>, <em class="property">struct</em> <a class="reference internal" href="#c.input_ff_upload" title="file">file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_upload" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>upload effect into force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ff_effect</span> <span class="pre">*effect</span></code></dt><dd><p>effect to be uploaded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>owner of the effect</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.input_ff_erase">
int <code class="sig-name descname">input_ff_erase</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int <em>effect_id</em>, <em class="property">struct</em> <a class="reference internal" href="#c.input_ff_erase" title="file">file</a> *<em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_erase" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>erase a force-feedback effect from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device to erase effect from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">effect_id</span></code></dt><dd><p>id of the effect to be erased</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>purported owner of the request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function erases a force-feedback effect from specified device.
The effect will only be erased if it was uploaded through the same
file handle that is requesting erase.</p>
<dl class="c function">
<dt id="c.input_ff_event">
int <code class="sig-name descname">input_ff_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>type</em>, unsigned int <em>code</em>, int <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generic handler for force-feedback events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device to send the effect to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>event type (anything but EV_FF is ignored)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>event code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>event value</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.input_ff_create">
int <code class="sig-name descname">input_ff_create</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>max_effects</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device supporting force-feedback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_effects</span></code></dt><dd><p>maximum number of effects supported by the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates all necessary memory for a force feedback
portion of an input device and installs all default handlers.
<strong>dev-&gt;ffbit</strong> should be already set up before calling this function.
Once ff device is created you need to setup its upload, erase,
playback and other handlers before registering input device</p>
<dl class="c function">
<dt id="c.input_ff_destroy">
void <code class="sig-name descname">input_ff_destroy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>frees force feedback portion of input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device supporting force feedback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is only needed in error path as input core will
automatically free force feedback structures when device is
destroyed.</p>
<dl class="c function">
<dt id="c.input_ff_create_memless">
int <code class="sig-name descname">input_ff_create_memless</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, void *<em>data</em>, int (*<em>play_effect</em>)<span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a>*, void*, <em class="property">struct</em> ff_effect*<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.input_ff_create_memless" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create memoryless force-feedback device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device supporting force-feedback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver-specific data to be passed into <strong>play_effect</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*play_effect)(struct</span> <span class="pre">input_dev</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">ff_effect</span> <span class="pre">*)</span></code></dt><dd><p>driver-specific method for playing FF effect</p>
</dd>
</dl>
</div>
<div class="section" id="multitouch-library">
<h2>Multitouch Library<a class="headerlink" href="#multitouch-library" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.input_mt_slot">
<em class="property">struct </em><code class="sig-name descname">input_mt_slot</code><a class="headerlink" href="#c.input_mt_slot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>represents the state of an input MT slot</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_mt_slot {
  int abs[ABS_MT_LAST - ABS_MT_FIRST + 1];
  unsigned int frame;
  unsigned int key;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">abs</span></code></dt><dd><p>holds current values of ABS_MT axes for this slot</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame</span></code></dt><dd><p>last frame at which <a class="reference internal" href="#c.input_mt_report_slot_state" title="input_mt_report_slot_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_mt_report_slot_state()</span></code></a> was called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>optional driver designation of this slot</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.input_mt">
<em class="property">struct </em><code class="sig-name descname">input_mt</code><a class="headerlink" href="#c.input_mt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>state of tracked contacts</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_mt {
  int trkid;
  int num_slots;
  int slot;
  unsigned int flags;
  unsigned int frame;
  int *red;
  struct input_mt_slot slots[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">trkid</span></code></dt><dd><p>stores MT tracking ID for the next contact</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_slots</span></code></dt><dd><p>number of MT slots the device uses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slot</span></code></dt><dd><p>MT slot currently being transmitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>input_mt operation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame</span></code></dt><dd><p>increases every time <a class="reference internal" href="#c.input_mt_sync_frame" title="input_mt_sync_frame"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_mt_sync_frame()</span></code></a> is called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">red</span></code></dt><dd><p>reduced cost matrix for in-kernel tracking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slots</span></code></dt><dd><p>array of slots holding current values of tracked contacts</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.input_mt_pos">
<em class="property">struct </em><code class="sig-name descname">input_mt_pos</code><a class="headerlink" href="#c.input_mt_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>contact position</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct input_mt_pos {
  s16 x, y;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>horizontal coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>vertical coordinate</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.input_mt_init_slots">
int <code class="sig-name descname">input_mt_init_slots</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>num_slots</em>, unsigned int <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_init_slots" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize MT input slots</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device supporting MT events and finger tracking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_slots</span></code></dt><dd><p>number of slots used by the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>mt tasks to handle in core</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates all necessary memory for MT slot handling
in the input device, prepares the ABS_MT_SLOT and
ABS_MT_TRACKING_ID events for use and sets up appropriate buffers.
Depending on the flags set, it also performs pointer emulation and
frame synchronization.</p>
<p>May be called repeatedly. Returns -EINVAL if attempting to
reinitialize with a different number of slots.</p>
<dl class="c function">
<dt id="c.input_mt_destroy_slots">
void <code class="sig-name descname">input_mt_destroy_slots</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_destroy_slots" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>frees the MT slots of the input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is only needed in error path as the input core will
automatically free the MT slots when the device is destroyed.</p>
<dl class="c function">
<dt id="c.input_mt_report_slot_state">
bool <code class="sig-name descname">input_mt_report_slot_state</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>tool_type</em>, bool <em>active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_slot_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report contact state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tool_type</span></code></dt><dd><p>the tool type to use in this slot</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">active</span></code></dt><dd><p>true if contact is active, false otherwise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports a contact via ABS_MT_TRACKING_ID, and optionally
ABS_MT_TOOL_TYPE. If active is true and the slot is currently
inactive, or if the tool type is changed, a new tracking id is
assigned to the slot. The tool type is only reported if the
corresponding absbit field is set.</p>
<p>Returns true if contact is active.</p>
<dl class="c function">
<dt id="c.input_mt_report_finger_count">
void <code class="sig-name descname">input_mt_report_finger_count</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_finger_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report contact count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of contacts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,
BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP.</p>
<p>The input core ensures only the KEY events already setup for
this device will produce output.</p>
<dl class="c function">
<dt id="c.input_mt_report_pointer_emulation">
void <code class="sig-name descname">input_mt_report_pointer_emulation</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, bool <em>use_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_report_pointer_emulation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>common pointer emulation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_count</span></code></dt><dd><p>report number of active contacts as finger count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Performs legacy pointer emulation via BTN_TOUCH, ABS_X, ABS_Y and
ABS_PRESSURE. Touchpad finger count is emulated if use_count is true.</p>
<p>The input core ensures only the KEY and ABS axes already setup for
this device will produce output.</p>
<dl class="c function">
<dt id="c.input_mt_drop_unused">
void <code class="sig-name descname">input_mt_drop_unused</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_drop_unused" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inactivate slots not seen in this frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lift all slots not seen since the last call to this function.</p>
<dl class="c function">
<dt id="c.input_mt_sync_frame">
void <code class="sig-name descname">input_mt_sync_frame</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_sync_frame" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>synchronize mt frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the frame and prepare the internal state for a new one.
Depending on the flags, marks unused slots as inactive and performs
pointer emulation.</p>
<dl class="c function">
<dt id="c.input_mt_assign_slots">
int <code class="sig-name descname">input_mt_assign_slots</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int *<em>slots</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.input_mt_pos" title="input_mt_pos">input_mt_pos</a> *<em>pos</em>, int <em>num_pos</em>, int <em>dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_assign_slots" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>perform a best-match assignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*slots</span></code></dt><dd><p>the slot assignment to be filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">input_mt_pos</span> <span class="pre">*pos</span></code></dt><dd><p>the position array to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_pos</span></code></dt><dd><p>number of positions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dmax</span></code></dt><dd><p>maximum ABS_MT_POSITION displacement (zero for infinite)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Performs a best match against the current contacts and returns
the slot assignment list. New contacts are assigned to unused
slots.</p>
<p>The assignments are balanced so that all coordinate displacements are
below the euclidian distance dmax. If no such assignment can be found,
some contacts are assigned to unused slots.</p>
<p>Returns zero on success, or negative error in case of failure.</p>
<dl class="c function">
<dt id="c.input_mt_get_slot_by_key">
int <code class="sig-name descname">input_mt_get_slot_by_key</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, int <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.input_mt_get_slot_by_key" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return slot matching key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>input device with allocated MT slots</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">key</span></code></dt><dd><p>the key of the sought slot</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the slot of the given key, if it exists, otherwise
set the key on the first unused slot and return.</p>
<p>If no available slot can be found, -1 is returned.
Note that for this function to work properly, <a class="reference internal" href="#c.input_mt_sync_frame" title="input_mt_sync_frame"><code class="xref c c-func docutils literal notranslate"><span class="pre">input_mt_sync_frame()</span></code></a> has
to be called at each frame.</p>
</div>
<div class="section" id="matrix-keyboards-keypads">
<h2>Matrix keyboards/keypads<a class="headerlink" href="#matrix-keyboards-keypads" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.matrix_keymap_data">
<em class="property">struct </em><code class="sig-name descname">matrix_keymap_data</code><a class="headerlink" href="#c.matrix_keymap_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>keymap for matrix keyboards</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct matrix_keymap_data {
  const uint32_t *keymap;
  unsigned int    keymap_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">keymap</span></code></dt><dd><p>pointer to array of uint32 values encoded with KEY() macro
representing keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keymap_size</span></code></dt><dd><p>number of entries (initialized) in this keymap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is supposed to be used by platform code to supply
keymaps to drivers that implement matrix-like keypads/keyboards.</p>
<dl class="c struct">
<dt id="c.matrix_keypad_platform_data">
<em class="property">struct </em><code class="sig-name descname">matrix_keypad_platform_data</code><a class="headerlink" href="#c.matrix_keypad_platform_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>platform-dependent keypad data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct matrix_keypad_platform_data {
  const struct matrix_keymap_data *keymap_data;
  const unsigned int *row_gpios;
  const unsigned int *col_gpios;
  unsigned int    num_row_gpios;
  unsigned int    num_col_gpios;
  unsigned int    col_scan_delay_us;
  unsigned int    debounce_ms;
  unsigned int    clustered_irq;
  unsigned int    clustered_irq_flags;
  bool active_low;
  bool wakeup;
  bool no_autorepeat;
  bool drive_inactive_cols;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">keymap_data</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.matrix_keymap_data" title="matrix_keymap_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">matrix_keymap_data</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">row_gpios</span></code></dt><dd><p>pointer to array of gpio numbers representing rows</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">col_gpios</span></code></dt><dd><p>pointer to array of gpio numbers reporesenting colums</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_row_gpios</span></code></dt><dd><p>actual number of row gpios used by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_col_gpios</span></code></dt><dd><p>actual number of col gpios used by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">col_scan_delay_us</span></code></dt><dd><p>delay, measured in microseconds, that is
needed before we can keypad after activating column gpio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debounce_ms</span></code></dt><dd><p>debounce interval in milliseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clustered_irq</span></code></dt><dd><p>may be specified if interrupts of all row/column GPIOs
are bundled to one single irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clustered_irq_flags</span></code></dt><dd><p>flags that are needed for the clustered irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_low</span></code></dt><dd><p>gpio polarity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeup</span></code></dt><dd><p>controls whether the device should be set up as wakeup
source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_autorepeat</span></code></dt><dd><p>disable key autorepeat</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drive_inactive_cols</span></code></dt><dd><p>drive inactive columns during scan, rather than
making them inputs.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents platform-specific data that use used by
matrix_keypad driver to perform proper initialization.</p>
</div>
<div class="section" id="sparse-keymap-support">
<h2>Sparse keymap support<a class="headerlink" href="#sparse-keymap-support" title="Permalink to this headline">¶</a></h2>
<dl class="c struct">
<dt id="c.key_entry">
<em class="property">struct </em><code class="sig-name descname">key_entry</code><a class="headerlink" href="#c.key_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>keymap entry for use in sparse keymap</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct key_entry {
  int type;
  u32 code;
  union {
    u16 keycode;
    struct {
      u8 code;
      u8 value;
    } sw;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the key entry (KE_KEY, KE_SW, KE_VSW, KE_END);
drivers are allowed to extend the list with their own
private definitions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt><dd><p>Device-specific data identifying the button/switch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycode</span></code></dt><dd><p>KEY_* code assigned to a key/button</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw</span></code></dt><dd><p>struct with code/value used by KE_SW and KE_VSW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw.code</span></code></dt><dd><p>SW_* code assigned to a switch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw.value</span></code></dt><dd><p>Value that should be sent in an input even when KE_SW
switch is toggled. KE_VSW switches ignore this field and
expect driver to supply value for the event.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines an entry in a sparse keymap used by some
input devices for which traditional table-based approach is not
suitable.</p>
<dl class="c function">
<dt id="c.sparse_keymap_entry_from_scancode">
<em class="property">struct</em> <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<code class="sig-name descname">sparse_keymap_entry_from_scancode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_entry_from_scancode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>perform sparse keymap lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Input device using sparse keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>Scan code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a> lookup in an
input device using sparse keymap.</p>
<dl class="c function">
<dt id="c.sparse_keymap_entry_from_keycode">
<em class="property">struct</em> <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<code class="sig-name descname">sparse_keymap_entry_from_keycode</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>keycode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_entry_from_keycode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>perform sparse keymap lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Input device using sparse keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keycode</span></code></dt><dd><p>Key code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a> lookup in an
input device using sparse keymap.</p>
<dl class="c function">
<dt id="c.sparse_keymap_setup">
int <code class="sig-name descname">sparse_keymap_setup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<em>keymap</em>, int (*<em>setup</em>)<span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a>*, <em class="property">struct</em> <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a>*<span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_setup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set up sparse keymap for an input device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Input device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*keymap</span></code></dt><dd><p>Keymap in form of array of <a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">key_entry</span></code></a> structures ending
with <code class="docutils literal notranslate"><span class="pre">KE_END</span></code> type entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*setup)(struct</span> <span class="pre">input_dev</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*)</span></code></dt><dd><p>Function that can be used to adjust keymap entries
depending on device’s needs, may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function calculates size and allocates copy of the original
keymap after which sets up input device event bits appropriately.
The allocated copy of the keymap is automatically freed when it
is no longer needed.</p>
<dl class="c function">
<dt id="c.sparse_keymap_report_entry">
void <code class="sig-name descname">sparse_keymap_report_entry</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#c.key_entry" title="key_entry">key_entry</a> *<em>ke</em>, unsigned int <em>value</em>, bool <em>autorelease</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_report_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report event corresponding to given key entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Input device for which event should be reported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">key_entry</span> <span class="pre">*ke</span></code></dt><dd><p>key entry describing event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>Value that should be reported (ignored by <code class="docutils literal notranslate"><span class="pre">KE_SW</span></code> entries)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">autorelease</span></code></dt><dd><p>Signals whether release event should be emitted for <code class="docutils literal notranslate"><span class="pre">KE_KEY</span></code>
entries right after reporting press event, ignored by all other
entries</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to report input event described by given
<a class="reference internal" href="#c.key_entry" title="key_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key_entry</span></code></a>.</p>
<dl class="c function">
<dt id="c.sparse_keymap_report_event">
bool <code class="sig-name descname">sparse_keymap_report_event</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#c.input_dev" title="input_dev">input_dev</a> *<em>dev</em>, unsigned int <em>code</em>, unsigned int <em>value</em>, bool <em>autorelease</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_keymap_report_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>report event corresponding to given scancode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">input_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Input device using sparse keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>Scan code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>Value that should be reported (ignored by <code class="docutils literal notranslate"><span class="pre">KE_SW</span></code> entries)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">autorelease</span></code></dt><dd><p>Signals whether release event should be emitted for <code class="docutils literal notranslate"><span class="pre">KE_KEY</span></code>
entries right after reporting press event, ignored by all other
entries</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to perform lookup in an input device using sparse
keymap and report corresponding event. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if lookup was
successful and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="usb/index.html" class="btn btn-neutral float-right" title="Linux USB API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="iio/hw-consumer.html" class="btn btn-neutral float-left" title="HW consumer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>