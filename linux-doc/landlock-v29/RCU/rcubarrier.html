

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>RCU and Unloadable Modules &mdash; The Linux Kernel 5.11.0+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()" href="rcu_dereference.html" />
    <link rel="prev" title="Lockdep-RCU Splat" href="lockdep-splat.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../core-api/index.html#concurrency-primitives">Concurrency primitives</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/irq/index.html">IRQs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/padata.html">The padata parallel execution mechanism</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">RCU concepts</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="arrayRCU.html">Using RCU to Protect Read-Mostly Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="checklist.html">Review Checklist for RCU Patches</a></li>
<li class="toctree-l4"><a class="reference internal" href="lockdep.html">RCU and lockdep checking</a></li>
<li class="toctree-l4"><a class="reference internal" href="lockdep-splat.html">Lockdep-RCU Splat</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">RCU and Unloadable Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcu_dereference.html">PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()</a></li>
<li class="toctree-l4"><a class="reference internal" href="whatisRCU.html">What is RCU?  –  “Read, Copy, Update”</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcu.html">RCU Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="rculist_nulls.html">Using RCU hlist_nulls to protect list and objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcuref.html">Reference-count design for elements of lists/arrays protected by RCU</a></li>
<li class="toctree-l4"><a class="reference internal" href="torture.html">RCU Torture Test Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="stallwarn.html">Using RCU’s CPU Stall Detector</a></li>
<li class="toctree-l4"><a class="reference internal" href="listRCU.html">Using RCU to Protect Read-Mostly Linked Lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="NMI-RCU.html">Using RCU to Protect Dynamic NMI Handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="UP.html">RCU on Uniprocessor Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Memory-Ordering/Tree-RCU-Memory-Ordering.html">A Tour Through TREE_RCU’s Grace-Period Memory Ordering</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Expedited-Grace-Periods/Expedited-Grace-Periods.html">A Tour Through TREE_RCU’s Expedited Grace Periods</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Requirements/Requirements.html">A Tour Through RCU’s Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Data-Structures/Data-Structures.html">A Tour Through TREE_RCU’s Data Structures [LWN.net]</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../core-api/index.html">Core API Documentation</a> &raquo;</li>
        
          <li><a href="index.html">RCU concepts</a> &raquo;</li>
        
      <li>RCU and Unloadable Modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/RCU/rcubarrier.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rcu-and-unloadable-modules">
<span id="rcu-barrier"></span><h1>RCU and Unloadable Modules<a class="headerlink" href="#rcu-and-unloadable-modules" title="Permalink to this headline">¶</a></h1>
<p>[Originally published in LWN Jan. 14, 2007: <a class="reference external" href="http://lwn.net/Articles/217484/">http://lwn.net/Articles/217484/</a>]</p>
<p>RCU (read-copy update) is a synchronization mechanism that can be thought
of as a replacement for read-writer locking (among other things), but with
very low-overhead readers that are immune to deadlock, priority inversion,
and unbounded latency. RCU read-side critical sections are delimited
by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, which, in non-CONFIG_PREEMPTION
kernels, generate no code whatsoever.</p>
<p>This means that RCU writers are unaware of the presence of concurrent
readers, so that RCU updates to shared data must be undertaken quite
carefully, leaving an old version of the data structure in place until all
pre-existing readers have finished. These old versions are needed because
such readers might hold a reference to them. RCU updates can therefore be
rather expensive, and RCU is thus best suited for read-mostly situations.</p>
<p>How can an RCU writer possibly determine when all readers are finished,
given that readers might well leave absolutely no trace of their
presence? There is a <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> primitive that blocks until all
pre-existing readers have completed. An updater wishing to delete an
element p from a linked list might do the following, while holding an
appropriate lock, of course:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list_del_rcu(p);
synchronize_rcu();
kfree(p);
</pre></div>
</div>
<p>But the above code cannot be used in IRQ context – the <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
primitive must be used instead. This primitive takes a pointer to an
rcu_head struct placed within the RCU-protected data structure and
another pointer to a function that may be invoked later to free that
structure. Code to delete an element p from the linked list from IRQ
context might then be as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list_del_rcu(p);
call_rcu(&amp;p-&gt;rcu, p_callback);
</pre></div>
</div>
<p>Since <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> never blocks, this code can safely be used from within
IRQ context. The function p_callback() might be defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void p_callback(struct rcu_head *rp)
{
        struct pstruct *p = container_of(rp, struct pstruct, rcu);

        kfree(p);
}
</pre></div>
</div>
<div class="section" id="unloading-modules-that-use-call-rcu">
<h2>Unloading Modules That Use call_rcu()<a class="headerlink" href="#unloading-modules-that-use-call-rcu" title="Permalink to this headline">¶</a></h2>
<p>But what if p_callback is defined in an unloadable module?</p>
<p>If we unload the module while some RCU callbacks are pending,
the CPUs executing these callbacks are going to be severely
disappointed when they are later invoked, as fancifully depicted at
<a class="reference external" href="http://lwn.net/images/ns/kernel/rcu-drop.jpg">http://lwn.net/images/ns/kernel/rcu-drop.jpg</a>.</p>
<p>We could try placing a <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> in the module-exit code path,
but this is not sufficient. Although <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> does wait for a
grace period to elapse, it does not wait for the callbacks to complete.</p>
<p>One might be tempted to try several back-to-back <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
calls, but this is still not guaranteed to work. If there is a very
heavy RCU-callback load, then some of the callbacks might be deferred
in order to allow other processing to proceed. Such deferral is required
in realtime kernels in order to avoid excessive scheduling latencies.</p>
</div>
<div class="section" id="id1">
<h2>rcu_barrier()<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>We instead need the <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> primitive.  Rather than waiting for
a grace period to elapse, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> waits for all outstanding RCU
callbacks to complete.  Please note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> does <strong>not</strong> imply
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, in particular, if there are no RCU callbacks queued
anywhere, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return immediately,
without waiting for a grace period to elapse.</p>
<p>Pseudo-code using <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Prevent any new RCU callbacks from being posted.</p></li>
<li><p>Execute <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>.</p></li>
<li><p>Allow the module to be unloaded.</p></li>
</ol>
</div></blockquote>
<p>There is also an <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a> function for SRCU, and you of course
must match the flavor of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> with that of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.  If your
module uses multiple flavors of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, then it must also use multiple
flavors of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> when unloading that module.  For example, if
it uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> on srcu_struct_1, and <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> on
srcu_struct_2, then the following three lines of code will be required
when unloading:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 rcu_barrier();
2 srcu_barrier(&amp;srcu_struct_1);
3 srcu_barrier(&amp;srcu_struct_2);
</pre></div>
</div>
<p>The rcutorture module makes use of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> in its exit function
as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  static void
2  rcu_torture_cleanup(void)
3  {
4    int i;
5
6    fullstop = 1;
7    if (shuffler_task != NULL) {
8     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_shuffle task&quot;);
9     kthread_stop(shuffler_task);
10   }
11   shuffler_task = NULL;
12
13   if (writer_task != NULL) {
14     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_writer task&quot;);
15     kthread_stop(writer_task);
16   }
17   writer_task = NULL;
18
19   if (reader_tasks != NULL) {
20     for (i = 0; i &lt; nrealreaders; i++) {
21       if (reader_tasks[i] != NULL) {
22         VERBOSE_PRINTK_STRING(
23           &quot;Stopping rcu_torture_reader task&quot;);
24         kthread_stop(reader_tasks[i]);
25       }
26       reader_tasks[i] = NULL;
27     }
28     kfree(reader_tasks);
29     reader_tasks = NULL;
30   }
31   rcu_torture_current = NULL;
32
33   if (fakewriter_tasks != NULL) {
34     for (i = 0; i &lt; nfakewriters; i++) {
35       if (fakewriter_tasks[i] != NULL) {
36         VERBOSE_PRINTK_STRING(
37           &quot;Stopping rcu_torture_fakewriter task&quot;);
38         kthread_stop(fakewriter_tasks[i]);
39       }
40       fakewriter_tasks[i] = NULL;
41     }
42     kfree(fakewriter_tasks);
43     fakewriter_tasks = NULL;
44   }
45
46   if (stats_task != NULL) {
47     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_stats task&quot;);
48     kthread_stop(stats_task);
49   }
50   stats_task = NULL;
51
52   /* Wait for all RCU callbacks to fire. */
53   rcu_barrier();
54
55   rcu_torture_stats_print(); /* -After- the stats thread is stopped! */
56
57   if (cur_ops-&gt;cleanup != NULL)
58     cur_ops-&gt;cleanup();
59   if (atomic_read(&amp;n_rcu_torture_error))
60     rcu_torture_print_module_parms(&quot;End of test: FAILURE&quot;);
61   else
62     rcu_torture_print_module_parms(&quot;End of test: SUCCESS&quot;);
63 }
</pre></div>
</div>
<p>Line 6 sets a global variable that prevents any RCU callbacks from
re-posting themselves. This will not be necessary in most cases, since
RCU callbacks rarely include calls to <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>. However, the rcutorture
module is an exception to this rule, and therefore needs to set this
global variable.</p>
<p>Lines 7-50 stop all the kernel tasks associated with the rcutorture
module. Therefore, once execution reaches line 53, no more rcutorture
RCU callbacks will be posted. The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> call on line 53 waits
for any pre-existing callbacks to complete.</p>
<p>Then lines 55-62 print status and do operation-specific cleanup, and
then return, permitting the module-unload operation to be completed.</p>
<dl class="simple" id="rcubarrier-quiz-1">
<dt>Quick Quiz #1:</dt><dd><p>Is there any other situation where <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> might
be required?</p>
</dd>
</dl>
<p><a class="reference internal" href="#answer-rcubarrier-quiz-1"><span class="std std-ref">Answer to Quick Quiz #1</span></a></p>
<p>Your module might have additional complications. For example, if your
module invokes <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> from timers, you will need to first cancel all
the timers, and only then invoke <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> to wait for any remaining
RCU callbacks to complete.</p>
<p>Of course, if you module uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, you will need to invoke
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> before unloading.  Similarly, if your module uses
<a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, you will need to invoke <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a> before unloading,
and on the same srcu_struct structure.  If your module uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
<strong>and</strong> <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, then you will need to invoke <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> <strong>and</strong>
<a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a>.</p>
</div>
<div class="section" id="implementing-rcu-barrier">
<h2>Implementing rcu_barrier()<a class="headerlink" href="#implementing-rcu-barrier" title="Permalink to this headline">¶</a></h2>
<p>Dipankar Sarma’s implementation of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> makes use of the fact
that RCU callbacks are never reordered once queued on one of the per-CPU
queues. His implementation queues an RCU callback on each of the per-CPU
callback queues, and then waits until they have all started executing, at
which point, all earlier RCU callbacks are guaranteed to have completed.</p>
<p>The original code for <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> was as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  void rcu_barrier(void)
2  {
3    BUG_ON(in_interrupt());
4    /* Take cpucontrol mutex to protect against CPU hotplug */
5    mutex_lock(&amp;rcu_barrier_mutex);
6    init_completion(&amp;rcu_barrier_completion);
7    atomic_set(&amp;rcu_barrier_cpu_count, 0);
8    on_each_cpu(rcu_barrier_func, NULL, 0, 1);
9    wait_for_completion(&amp;rcu_barrier_completion);
10   mutex_unlock(&amp;rcu_barrier_mutex);
11 }
</pre></div>
</div>
<p>Line 3 verifies that the caller is in process context, and lines 5 and 10
use rcu_barrier_mutex to ensure that only one <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is using the
global completion and counters at a time, which are initialized on lines
6 and 7. Line 8 causes each CPU to invoke rcu_barrier_func(), which is
shown below. Note that the final “1” in on_each_cpu()’s argument list
ensures that all the calls to rcu_barrier_func() will have completed
before on_each_cpu() returns. Line 9 then waits for the completion.</p>
<p>This code was rewritten in 2008 and several times thereafter, but this
still gives the general idea.</p>
<p>The rcu_barrier_func() runs on each CPU, where it invokes <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
to post an RCU callback, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  static void rcu_barrier_func(void *notused)
2  {
3    int cpu = smp_processor_id();
4    struct rcu_data *rdp = &amp;per_cpu(rcu_data, cpu);
5    struct rcu_head *head;
6
7    head = &amp;rdp-&gt;barrier;
8    atomic_inc(&amp;rcu_barrier_cpu_count);
9    call_rcu(head, rcu_barrier_callback);
10 }
</pre></div>
</div>
<p>Lines 3 and 4 locate RCU’s internal per-CPU rcu_data structure,
which contains the struct rcu_head that needed for the later call to
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>. Line 7 picks up a pointer to this struct rcu_head, and line
8 increments a global counter. This counter will later be decremented
by the callback. Line 9 then registers the rcu_barrier_callback() on
the current CPU’s queue.</p>
<p>The rcu_barrier_callback() function simply atomically decrements the
rcu_barrier_cpu_count variable and finalizes the completion when it
reaches zero, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 static void rcu_barrier_callback(struct rcu_head *notused)
2 {
3   if (atomic_dec_and_test(&amp;rcu_barrier_cpu_count))
4     complete(&amp;rcu_barrier_completion);
5 }
</pre></div>
</div>
<dl class="simple" id="rcubarrier-quiz-2">
<dt>Quick Quiz #2:</dt><dd><p>What happens if CPU 0’s rcu_barrier_func() executes
immediately (thus incrementing rcu_barrier_cpu_count to the
value one), but the other CPU’s rcu_barrier_func() invocations
are delayed for a full grace period? Couldn’t this result in
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> returning prematurely?</p>
</dd>
</dl>
<p><a class="reference internal" href="#answer-rcubarrier-quiz-2"><span class="std std-ref">Answer to Quick Quiz #2</span></a></p>
<p>The current <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> implementation is more complex, due to the need
to avoid disturbing idle CPUs (especially on battery-powered systems)
and the need to minimally disturb non-idle CPUs in real-time systems.
However, the code above illustrates the concepts.</p>
</div>
<div class="section" id="rcu-barrier-summary">
<h2>rcu_barrier() Summary<a class="headerlink" href="#rcu-barrier-summary" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> primitive has seen relatively little use, since most
code using RCU is in the core kernel rather than in modules. However, if
you are using RCU from an unloadable module, you need to use <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
so that your module may be safely unloaded.</p>
</div>
<div class="section" id="answers-to-quick-quizzes">
<h2>Answers to Quick Quizzes<a class="headerlink" href="#answers-to-quick-quizzes" title="Permalink to this headline">¶</a></h2>
<dl id="answer-rcubarrier-quiz-1">
<dt>Quick Quiz #1:</dt><dd><p>Is there any other situation where <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> might
be required?</p>
</dd>
<dt>Answer: Interestingly enough, rcu_barrier() was not originally</dt><dd><p>implemented for module unloading. Nikita Danilov was using
RCU in a filesystem, which resulted in a similar situation at
filesystem-unmount time. Dipankar Sarma coded up <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
in response, so that Nikita could invoke it during the
filesystem-unmount process.</p>
<p>Much later, yours truly hit the RCU module-unload problem when
implementing rcutorture, and found that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> solves
this problem as well.</p>
</dd>
</dl>
<p><a class="reference internal" href="#rcubarrier-quiz-1"><span class="std std-ref">Back to Quick Quiz #1</span></a></p>
<dl id="answer-rcubarrier-quiz-2">
<dt>Quick Quiz #2:</dt><dd><p>What happens if CPU 0’s rcu_barrier_func() executes
immediately (thus incrementing rcu_barrier_cpu_count to the
value one), but the other CPU’s rcu_barrier_func() invocations
are delayed for a full grace period? Couldn’t this result in
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> returning prematurely?</p>
</dd>
<dt>Answer: This cannot happen. The reason is that on_each_cpu() has its last</dt><dd><p>argument, the wait flag, set to “1”. This flag is passed through
to smp_call_function() and further to smp_call_function_on_cpu(),
causing this latter to spin until the cross-CPU invocation of
rcu_barrier_func() has completed. This by itself would prevent
a grace period from completing on non-CONFIG_PREEMPTION kernels,
since each CPU must undergo a context switch (or other quiescent
state) before the grace period can complete. However, this is
of no use in CONFIG_PREEMPTION kernels.</p>
<p>Therefore, on_each_cpu() disables preemption across its call
to smp_call_function() and also across the local call to
rcu_barrier_func(). This prevents the local CPU from context
switching, again preventing grace periods from completing. This
means that all CPUs have executed rcu_barrier_func() before
the first rcu_barrier_callback() can possibly execute, in turn
preventing rcu_barrier_cpu_count from prematurely reaching zero.</p>
<p>Currently, -rt implementations of RCU keep but a single global
queue for RCU callbacks, and thus do not suffer from this
problem. However, when the -rt RCU eventually does have per-CPU
callback queues, things will have to change. One simple change
is to add an <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> before line 8 of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
and an <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> after line 8 of this same function. If
you can think of a better change, please let me know!</p>
</dd>
</dl>
<p><a class="reference internal" href="#rcubarrier-quiz-2"><span class="std std-ref">Back to Quick Quiz #2</span></a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="rcu_dereference.html" class="btn btn-neutral float-right" title="PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="lockdep-splat.html" class="btn btn-neutral float-left" title="Lockdep-RCU Splat" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>