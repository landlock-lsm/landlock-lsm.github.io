

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Device Power Management Basics &mdash; The Linux Kernel 5.11.0+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Suspend/Hibernation Notifiers" href="notifiers.html" />
    <link rel="prev" title="CPU Idle Time Management" href="cpuidle.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">CPU and Device Power Management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cpuidle.html">CPU Idle Time Management</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Device Power Management Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#two-models-for-device-power-management">Two Models for Device Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfaces-for-entering-system-sleep-states">Interfaces for Entering System Sleep States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calling-drivers-to-enter-and-leave-system-sleep-states">Calling Drivers to Enter and Leave System Sleep States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-management-notifiers">Power Management Notifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-low-power-suspend-states">Device Low-Power (suspend) States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-power-management-domains">Device Power Management Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-power-management">Runtime Power Management</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="notifiers.html">Suspend/Hibernation Notifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">Device Power Management Data Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">CPU and Device Power Management</a> &raquo;</li>
        
      <li>Device Power Management Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/pm/devices.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-power-management-basics">
<span id="driverapi-pm-devices"></span><h1>Device Power Management Basics<a class="headerlink" href="#device-power-management-basics" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2010-2011 Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rjw&#37;&#52;&#48;sisk&#46;pl">rjw<span>&#64;</span>sisk<span>&#46;</span>pl</a>&gt;, Novell Inc.</p>
</dd>
<dt class="field-even">Copyright</dt>
<dd class="field-even"><p>© 2010 Alan Stern &lt;<a class="reference external" href="mailto:stern&#37;&#52;&#48;rowland&#46;harvard&#46;edu">stern<span>&#64;</span>rowland<span>&#46;</span>harvard<span>&#46;</span>edu</a>&gt;</p>
</dd>
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2016 Intel Corporation</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rafael&#46;j&#46;wysocki&#37;&#52;&#48;intel&#46;com">rafael<span>&#46;</span>j<span>&#46;</span>wysocki<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<p>Most of the code in Linux is device drivers, so most of the Linux power
management (PM) code is also driver-specific.  Most drivers will do very
little; others, especially for platforms with small batteries (like cell
phones), will do a lot.</p>
<p>This writeup gives an overview of how drivers interact with system-wide
power management goals, emphasizing the models and interfaces that are
shared by everything that hooks up to the driver model core.  Read it as
background for the domain-specific work you’d do with any specific driver.</p>
<div class="section" id="two-models-for-device-power-management">
<h2>Two Models for Device Power Management<a class="headerlink" href="#two-models-for-device-power-management" title="Permalink to this headline">¶</a></h2>
<p>Drivers will use one or both of these models to put devices into low-power
states:</p>
<blockquote>
<div><p>System Sleep model:</p>
<blockquote>
<div><p>Drivers can enter low-power states as part of entering system-wide
low-power states like “suspend” (also known as “suspend-to-RAM”), or
(mostly for systems with disks) “hibernation” (also known as
“suspend-to-disk”).</p>
<p>This is something that device, bus, and class drivers collaborate on
by implementing various role-specific suspend and resume methods to
cleanly power down hardware and software subsystems, then reactivate
them without loss of data.</p>
<p>Some drivers can manage hardware wakeup events, which make the system
leave the low-power state.  This feature may be enabled or disabled
using the relevant <code class="file docutils literal notranslate"><span class="pre">/sys/devices/.../power/wakeup</span></code> file (for
Ethernet drivers the ioctl interface used by ethtool may also be used
for this purpose); enabling it may cost some power usage, but let the
whole system enter low-power states more often.</p>
</div></blockquote>
<p>Runtime Power Management model:</p>
<blockquote>
<div><p>Devices may also be put into low-power states while the system is
running, independently of other power management activity in principle.
However, devices are not generally independent of each other (for
example, a parent device cannot be suspended unless all of its child
devices have been suspended).  Moreover, depending on the bus type the
device is on, it may be necessary to carry out some bus-specific
operations on the device for this purpose.  Devices put into low power
states at run time may require special handling during system-wide power
transitions (suspend or hibernation).</p>
<p>For these reasons not only the device driver itself, but also the
appropriate subsystem (bus type, device type or device class) driver and
the PM core are involved in runtime power management.  As in the system
sleep power management case, they need to collaborate by implementing
various role-specific suspend and resume methods, so that the hardware
is cleanly powered down and reactivated without data or service loss.</p>
</div></blockquote>
</div></blockquote>
<p>There’s not a lot to be said about those low-power states except that they are
very system-specific, and often device-specific.  Also, that if enough devices
have been put into low-power states (at runtime), the effect may be very similar
to entering some system-wide low-power state (system sleep) … and that
synergies exist, so that several drivers using runtime PM might put the system
into a state where even deeper power saving options are available.</p>
<p>Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
for wakeup events), no more data read or written, and requests from upstream
drivers are no longer accepted.  A given bus or platform may have different
requirements though.</p>
<p>Examples of hardware wakeup events include an alarm from a real time clock,
network wake-on-LAN packets, keyboard or mouse activity, and media insertion
or removal (for PCMCIA, MMC/SD, USB, and so on).</p>
</div>
<div class="section" id="interfaces-for-entering-system-sleep-states">
<h2>Interfaces for Entering System Sleep States<a class="headerlink" href="#interfaces-for-entering-system-sleep-states" title="Permalink to this headline">¶</a></h2>
<p>There are programming interfaces provided for subsystems (bus type, device type,
device class) and device drivers to allow them to participate in the power
management of devices they are concerned with.  These interfaces cover both
system sleep and runtime power management.</p>
<div class="section" id="device-power-management-operations">
<h3>Device Power Management Operations<a class="headerlink" href="#device-power-management-operations" title="Permalink to this headline">¶</a></h3>
<p>Device power management operations, at the subsystem level as well as at the
device driver level, are implemented by defining and populating objects of type
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> defined in <code class="file docutils literal notranslate"><span class="pre">include/linux/pm.h</span></code>.  The roles of the
methods included in it will be explained in what follows.  For now, it should be
sufficient to remember that the last three methods are specific to runtime power
management while the remaining ones are used during system-wide power
transitions.</p>
<p>There also is a deprecated “old” or “legacy” interface for power management
operations available at least for some subsystems.  This approach does not use
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> objects and it is suitable only for implementing system
sleep power management methods in a limited way.  Therefore it is not described
in this document, so please refer directly to the source code for more
information about it.</p>
</div>
<div class="section" id="subsystem-level-methods">
<h3>Subsystem-Level Methods<a class="headerlink" href="#subsystem-level-methods" title="Permalink to this headline">¶</a></h3>
<p>The core methods to suspend and resume devices reside in
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> pointed to by the <code class="xref c c-member docutils literal notranslate"><span class="pre">ops</span></code> member of
<a class="reference internal" href="types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a>, or by the <code class="xref c c-member docutils literal notranslate"><span class="pre">pm</span></code> member of struct bus_type,
struct device_type and struct class.  They are mostly of interest to the
people writing infrastructure for platforms and buses, like PCI or USB, or
device type and device class drivers.  They also are relevant to the writers of
device drivers whose subsystems (PM domains, device types, device classes and
bus types) don’t provide all power management methods.</p>
<p>Bus drivers implement these methods as appropriate for the hardware and the
drivers using it; PCI works differently from USB, and so on.  Not many people
write subsystem-level drivers; most driver code is a “device driver” that builds
on top of bus-specific framework code.</p>
<p>For more information on these driver calls, see the description later;
they are called in phases for every device, respecting the parent-child
sequencing in the driver model tree.</p>
</div>
<div class="section" id="sys-devices-power-wakeup-files">
<h3><code class="file docutils literal notranslate"><span class="pre">/sys/devices/.../power/wakeup</span></code> files<a class="headerlink" href="#sys-devices-power-wakeup-files" title="Permalink to this headline">¶</a></h3>
<p>All device objects in the driver model contain fields that control the handling
of system wakeup events (hardware signals that can force the system out of a
sleep state).  These fields are initialized by bus or device driver code using
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_capable()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_enable()</span></code>,
defined in <code class="file docutils literal notranslate"><span class="pre">include/linux/pm_wakeup.h</span></code>.</p>
<p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">power.can_wakeup</span></code> flag just records whether the device (and its
driver) can physically support wakeup events.  The
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_capable()</span></code> routine affects this flag.  The
<code class="xref c c-member docutils literal notranslate"><span class="pre">power.wakeup</span></code> field is a pointer to an object of type
struct wakeup_source used for controlling whether or not the device should use
its system wakeup mechanism and for notifying the PM core of system wakeup
events signaled by the device.  This object is only present for wakeup-capable
devices (i.e. devices whose <code class="xref c c-member docutils literal notranslate"><span class="pre">can_wakeup</span></code> flags are set) and is created
(or removed) by <code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_capable()</span></code>.</p>
<p>Whether or not a device is capable of issuing wakeup events is a hardware
matter, and the kernel is responsible for keeping track of it.  By contrast,
whether or not a wakeup-capable device should issue wakeup events is a policy
decision, and it is managed by user space through a sysfs attribute: the
<code class="file docutils literal notranslate"><span class="pre">power/wakeup</span></code> file.  User space can write the “enabled” or “disabled”
strings to it to indicate whether or not, respectively, the device is supposed
to signal system wakeup.  This file is only present if the
<code class="xref c c-member docutils literal notranslate"><span class="pre">power.wakeup</span></code> object exists for the given device and is created (or
removed) along with that object, by <code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_capable()</span></code>.
Reads from the file will return the corresponding string.</p>
<p>The initial value in the <code class="file docutils literal notranslate"><span class="pre">power/wakeup</span></code> file is “disabled” for the
majority of devices; the major exceptions are power buttons, keyboards, and
Ethernet adapters whose WoL (wake-on-LAN) feature has been set up with ethtool.
It should also default to “enabled” for devices that don’t generate wakeup
requests on their own but merely forward wakeup requests from one bus to another
(like PCI Express ports).</p>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">device_may_wakeup()</span></code> routine returns true only if the
<code class="xref c c-member docutils literal notranslate"><span class="pre">power.wakeup</span></code> object exists and the corresponding <code class="file docutils literal notranslate"><span class="pre">power/wakeup</span></code>
file contains the “enabled” string.  This information is used by subsystems,
like the PCI bus type code, to see whether or not to enable the devices’ wakeup
mechanisms.  If device wakeup mechanisms are enabled or disabled directly by
drivers, they also should use <code class="xref c c-func docutils literal notranslate"><span class="pre">device_may_wakeup()</span></code> to decide what to do
during a system sleep transition.  Device drivers, however, are not expected to
call <code class="xref c c-func docutils literal notranslate"><span class="pre">device_set_wakeup_enable()</span></code> directly in any case.</p>
<p>It ought to be noted that system wakeup is conceptually different from “remote
wakeup” used by runtime power management, although it may be supported by the
same physical mechanism.  Remote wakeup is a feature allowing devices in
low-power states to trigger specific interrupts to signal conditions in which
they should be put into the full-power state.  Those interrupts may or may not
be used to signal system wakeup events, depending on the hardware design.  On
some systems it is impossible to trigger them from system sleep states.  In any
case, remote wakeup should always be enabled for runtime power management for
all devices and drivers that support it.</p>
</div>
<div class="section" id="sys-devices-power-control-files">
<h3><code class="file docutils literal notranslate"><span class="pre">/sys/devices/.../power/control</span></code> files<a class="headerlink" href="#sys-devices-power-control-files" title="Permalink to this headline">¶</a></h3>
<p>Each device in the driver model has a flag to control whether it is subject to
runtime power management.  This flag, <code class="xref c c-member docutils literal notranslate"><span class="pre">runtime_auto</span></code>, is initialized
by the bus type (or generally subsystem) code using <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_allow()</span></code>
or <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_forbid()</span></code>; the default is to allow runtime power
management.</p>
<p>The setting can be adjusted by user space by writing either “on” or “auto” to
the device’s <code class="file docutils literal notranslate"><span class="pre">power/control</span></code> sysfs file.  Writing “auto” calls
<code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_allow()</span></code>, setting the flag and allowing the device to be
runtime power-managed by its driver.  Writing “on” calls
<code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_forbid()</span></code>, clearing the flag, returning the device to full
power if it was in a low-power state, and preventing the
device from being runtime power-managed.  User space can check the current value
of the <code class="xref c c-member docutils literal notranslate"><span class="pre">runtime_auto</span></code> flag by reading that file.</p>
<p>The device’s <code class="xref c c-member docutils literal notranslate"><span class="pre">runtime_auto</span></code> flag has no effect on the handling of
system-wide power transitions.  In particular, the device can (and in the
majority of cases should and will) be put into a low-power state during a
system-wide transition to a sleep state even though its <code class="xref c c-member docutils literal notranslate"><span class="pre">runtime_auto</span></code>
flag is clear.</p>
<p>For more information about the runtime power management framework, refer to
<code class="file docutils literal notranslate"><span class="pre">Documentation/power/runtime_pm.rst</span></code>.</p>
</div>
</div>
<div class="section" id="calling-drivers-to-enter-and-leave-system-sleep-states">
<h2>Calling Drivers to Enter and Leave System Sleep States<a class="headerlink" href="#calling-drivers-to-enter-and-leave-system-sleep-states" title="Permalink to this headline">¶</a></h2>
<p>When the system goes into a sleep state, each device’s driver is asked to
suspend the device by putting it into a state compatible with the target
system state.  That’s usually some version of “off”, but the details are
system-specific.  Also, wakeup-enabled devices will usually stay partly
functional in order to wake the system.</p>
<p>When the system leaves that low-power state, the device’s driver is asked to
resume it by returning it to full power.  The suspend and resume operations
always go together, and both are multi-phase operations.</p>
<p>For simple drivers, suspend might quiesce the device using class code
and then turn its hardware as “off” as possible during suspend_noirq.  The
matching resume calls would then completely reinitialize the hardware
before reactivating its class I/O queues.</p>
<p>More power-aware drivers might prepare the devices for triggering system wakeup
events.</p>
<div class="section" id="call-sequence-guarantees">
<h3>Call Sequence Guarantees<a class="headerlink" href="#call-sequence-guarantees" title="Permalink to this headline">¶</a></h3>
<p>To ensure that bridges and similar links needing to talk to a device are
available when the device is suspended or resumed, the device hierarchy is
walked in a bottom-up order to suspend devices.  A top-down order is
used to resume those devices.</p>
<p>The ordering of the device hierarchy is defined by the order in which devices
get registered:  a child can never be registered, probed or resumed before
its parent; and can’t be removed or suspended after that parent.</p>
<p>The policy is that the device hierarchy should match hardware bus topology.
[Or at least the control bus, for devices which use multiple busses.]
In particular, this means that a device registration may fail if the parent of
the device is suspending (i.e. has been chosen by the PM core as the next
device to suspend) or has already suspended, as well as after all of the other
devices have been suspended.  Device drivers must be prepared to cope with such
situations.</p>
</div>
<div class="section" id="system-power-management-phases">
<h3>System Power Management Phases<a class="headerlink" href="#system-power-management-phases" title="Permalink to this headline">¶</a></h3>
<p>Suspending or resuming the system is done in several phases.  Different phases
are used for suspend-to-idle, shallow (standby), and deep (“suspend-to-RAM”)
sleep states and the hibernation state (“suspend-to-disk”).  Each phase involves
executing callbacks for every device before the next phase begins.  Not all
buses or classes support all these callbacks and not all drivers use all the
callbacks.  The various phases always run after tasks have been frozen and
before they are unfrozen.  Furthermore, the <code class="docutils literal notranslate"><span class="pre">*_noirq</span></code> phases run at a time
when IRQ handlers have been disabled (except for those marked with the
IRQF_NO_SUSPEND flag).</p>
<p>All phases use PM domain, bus, type, class or driver callbacks (that is, methods
defined in <code class="docutils literal notranslate"><span class="pre">dev-&gt;pm_domain-&gt;ops</span></code>, <code class="docutils literal notranslate"><span class="pre">dev-&gt;bus-&gt;pm</span></code>, <code class="docutils literal notranslate"><span class="pre">dev-&gt;type-&gt;pm</span></code>,
<code class="docutils literal notranslate"><span class="pre">dev-&gt;class-&gt;pm</span></code> or <code class="docutils literal notranslate"><span class="pre">dev-&gt;driver-&gt;pm</span></code>).  These callbacks are regarded by the
PM core as mutually exclusive.  Moreover, PM domain callbacks always take
precedence over all of the other callbacks and, for example, type callbacks take
precedence over bus, class and driver callbacks.  To be precise, the following
rules are used to determine which callback to execute in the given phase:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">dev-&gt;pm_domain</span></code> is present, the PM core will choose the callback
provided by <code class="docutils literal notranslate"><span class="pre">dev-&gt;pm_domain-&gt;ops</span></code> for execution.</p></li>
<li><p>Otherwise, if both <code class="docutils literal notranslate"><span class="pre">dev-&gt;type</span></code> and <code class="docutils literal notranslate"><span class="pre">dev-&gt;type-&gt;pm</span></code> are present, the
callback provided by <code class="docutils literal notranslate"><span class="pre">dev-&gt;type-&gt;pm</span></code> will be chosen for execution.</p></li>
<li><p>Otherwise, if both <code class="docutils literal notranslate"><span class="pre">dev-&gt;class</span></code> and <code class="docutils literal notranslate"><span class="pre">dev-&gt;class-&gt;pm</span></code> are present,
the callback provided by <code class="docutils literal notranslate"><span class="pre">dev-&gt;class-&gt;pm</span></code> will be chosen for
execution.</p></li>
<li><p>Otherwise, if both <code class="docutils literal notranslate"><span class="pre">dev-&gt;bus</span></code> and <code class="docutils literal notranslate"><span class="pre">dev-&gt;bus-&gt;pm</span></code> are present, the
callback provided by <code class="docutils literal notranslate"><span class="pre">dev-&gt;bus-&gt;pm</span></code> will be chosen for execution.</p></li>
</ol>
</div></blockquote>
<p>This allows PM domains and device types to override callbacks provided by bus
types or device classes if necessary.</p>
<p>The PM domain, type, class and bus callbacks may in turn invoke device- or
driver-specific methods stored in <code class="docutils literal notranslate"><span class="pre">dev-&gt;driver-&gt;pm</span></code>, but they don’t have to do
that.</p>
<p>If the subsystem callback chosen for execution is not present, the PM core will
execute the corresponding method from the <code class="docutils literal notranslate"><span class="pre">dev-&gt;driver-&gt;pm</span></code> set instead if
there is one.</p>
</div>
<div class="section" id="entering-system-suspend">
<h3>Entering System Suspend<a class="headerlink" href="#entering-system-suspend" title="Permalink to this headline">¶</a></h3>
<p>When the system goes into the freeze, standby or memory sleep state,
the phases are: <code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">suspend</span></code>, <code class="docutils literal notranslate"><span class="pre">suspend_late</span></code>, <code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code>.</p>
<blockquote>
<div><ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">prepare</span></code> phase is meant to prevent races by preventing new
devices from being registered; the PM core would never know that all the
children of a device had been suspended if new children could be
registered at will.  [By contrast, from the PM core’s perspective,
devices may be unregistered at any time.]  Unlike the other
suspend-related phases, during the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> phase the device
hierarchy is traversed top-down.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback method returns, no new children may be
registered below the device.  The method may also prepare the device or
driver in some way for the upcoming system power transition, but it
should not put the device into a low-power state.  Moreover, if the
device supports runtime power management, the <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback
method must not update its state in case it is necessary to resume it
from runtime suspend later on.</p>
<p>For devices supporting runtime power management, the return value of the
prepare callback can be used to indicate to the PM core that it may
safely leave the device in runtime suspend (if runtime-suspended
already), provided that all of the device’s descendants are also left in
runtime suspend.  Namely, if the prepare callback returns a positive
number and that happens for all of the descendants of the device too,
and all of them (including the device itself) are runtime-suspended, the
PM core will skip the <code class="docutils literal notranslate"><span class="pre">suspend</span></code>, <code class="docutils literal notranslate"><span class="pre">suspend_late</span></code> and
<code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code> phases as well as all of the corresponding phases of
the subsequent device resume for all of these devices.  In that case,
the <code class="docutils literal notranslate"><span class="pre">-&gt;complete</span></code> callback will be the next one invoked after the
<code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback and is entirely responsible for putting the
device into a consistent state as appropriate.</p>
<p>Note that this direct-complete procedure applies even if the device is
disabled for runtime PM; only the runtime-PM status matters.  It follows
that if a device has system-sleep callbacks but does not support runtime
PM, then its prepare callback must never return a positive value.  This
is because all such devices are initially set to runtime-suspended with
runtime PM disabled.</p>
<p>This feature also can be controlled by device drivers by using the
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_NO_DIRECT_COMPLETE</span></code> and <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_PREPARE</span></code> driver
power management flags.  [Typically, they are set at the time the driver
is probed against the device in question by passing them to the
<code class="xref c c-func docutils literal notranslate"><span class="pre">dev_pm_set_driver_flags()</span></code> helper function.]  If the first of
these flags is set, the PM core will not apply the direct-complete
procedure described above to the given device and, consequenty, to any
of its ancestors.  The second flag, when set, informs the middle layer
code (bus types, device types, PM domains, classes) that it should take
the return value of the <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback provided by the driver
into account and it may only return a positive value from its own
<code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback if the driver’s one also has returned a positive
value.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> methods should quiesce the device to stop it from
performing I/O.  They also may save the device registers and put it into
the appropriate low-power state, depending on the bus type the device is
on, and they may enable wakeup events.</p>
<p>However, for devices supporting runtime power management, the
<code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> methods provided by subsystems (bus types and PM domains
in particular) must follow an additional rule regarding what can be done
to the devices before their drivers’ <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> methods are called.
Namely, they may resume the devices from runtime suspend by
calling <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_resume()</span></code> for them, if that is necessary, but
they must not update the state of the devices in any other way at that
time (in case the drivers need to resume the devices from runtime
suspend in their <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> methods).  In fact, the PM core prevents
subsystems or drivers from putting devices into runtime suspend at
these times by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_get_noresume()</span></code> before issuing
the <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback (and calling <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_put()</span></code> after
issuing the <code class="docutils literal notranslate"><span class="pre">-&gt;complete</span></code> callback).</p>
</li>
<li><p>For a number of devices it is convenient to split suspend into the
“quiesce device” and “save device state” phases, in which cases
<code class="docutils literal notranslate"><span class="pre">suspend_late</span></code> is meant to do the latter.  It is always executed after
runtime power management has been disabled for the device in question.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code> phase occurs after IRQ handlers have been disabled,
which means that the driver’s interrupt handler will not be called while
the callback method is running.  The <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_noirq</span></code> methods should
save the values of the device’s registers that weren’t saved previously
and finally put the device into the appropriate low-power state.</p>
<p>The majority of subsystems and device drivers need not implement this
callback.  However, bus types allowing devices to share interrupt
vectors, like PCI, generally need it; otherwise a driver might encounter
an error during the suspend phase by fielding a shared interrupt
generated by some other device after its own device had been set to low
power.</p>
</li>
</ol>
</div></blockquote>
<p>At the end of these phases, drivers should have stopped all I/O transactions
(DMA, IRQs), saved enough state that they can re-initialize or restore previous
state (as needed by the hardware), and placed the device into a low-power state.
On many platforms they will gate off one or more clock sources; sometimes they
will also switch off power supplies or reduce voltages.  [Drivers supporting
runtime PM may already have performed some or all of these steps.]</p>
<p>If <code class="xref c c-func docutils literal notranslate"><span class="pre">device_may_wakeup()</span></code> returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, the device should be
prepared for generating hardware wakeup signals to trigger a system wakeup event
when the system is in the sleep state.  For example, <code class="xref c c-func docutils literal notranslate"><span class="pre">enable_irq_wake()</span></code>
might identify GPIO signals hooked up to a switch or other external hardware,
and <a class="reference internal" href="../pci/pci.html#c.pci_enable_wake" title="pci_enable_wake"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_wake()</span></code></a> does something similar for the PCI PME signal.</p>
<p>If any of these callbacks returns an error, the system won’t enter the desired
low-power state.  Instead, the PM core will unwind its actions by resuming all
the devices that were suspended.</p>
</div>
<div class="section" id="leaving-system-suspend">
<h3>Leaving System Suspend<a class="headerlink" href="#leaving-system-suspend" title="Permalink to this headline">¶</a></h3>
<p>When resuming from freeze, standby or memory sleep, the phases are:
<code class="docutils literal notranslate"><span class="pre">resume_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">resume_early</span></code>, <code class="docutils literal notranslate"><span class="pre">resume</span></code>, <code class="docutils literal notranslate"><span class="pre">complete</span></code>.</p>
<blockquote>
<div><ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;resume_noirq</span></code> callback methods should perform any actions
needed before the driver’s interrupt handlers are invoked.  This
generally means undoing the actions of the <code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code> phase.  If
the bus type permits devices to share interrupt vectors, like PCI, the
method should bring the device and its driver into a state in which the
driver can recognize if the device is the source of incoming interrupts,
if any, and handle them correctly.</p>
<p>For example, the PCI bus type’s <code class="docutils literal notranslate"><span class="pre">-&gt;pm.resume_noirq()</span></code> puts the device
into the full-power state (D0 in the PCI terminology) and restores the
standard configuration registers of the device.  Then it calls the
device driver’s <code class="docutils literal notranslate"><span class="pre">-&gt;pm.resume_noirq()</span></code> method to perform device-specific
actions.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;resume_early</span></code> methods should prepare devices for the execution
of the resume methods.  This generally involves undoing the actions of
the preceding <code class="docutils literal notranslate"><span class="pre">suspend_late</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;resume</span></code> methods should bring the device back to its operating
state, so that it can perform normal I/O.  This generally involves
undoing the actions of the <code class="docutils literal notranslate"><span class="pre">suspend</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">complete</span></code> phase should undo the actions of the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> phase.
For this reason, unlike the other resume-related phases, during the
<code class="docutils literal notranslate"><span class="pre">complete</span></code> phase the device hierarchy is traversed bottom-up.</p>
<p>Note, however, that new children may be registered below the device as
soon as the <code class="docutils literal notranslate"><span class="pre">-&gt;resume</span></code> callbacks occur; it’s not necessary to wait
until the <code class="docutils literal notranslate"><span class="pre">complete</span></code> phase runs.</p>
<p>Moreover, if the preceding <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> callback returned a positive
number, the device may have been left in runtime suspend throughout the
whole system suspend and resume (its <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_late</span></code>,
<code class="docutils literal notranslate"><span class="pre">-&gt;suspend_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;resume_noirq</span></code>,
<code class="docutils literal notranslate"><span class="pre">-&gt;resume_early</span></code>, and <code class="docutils literal notranslate"><span class="pre">-&gt;resume</span></code> callbacks may have been
skipped).  In that case, the <code class="docutils literal notranslate"><span class="pre">-&gt;complete</span></code> callback is entirely
responsible for putting the device into a consistent state after system
suspend if necessary.  [For example, it may need to queue up a runtime
resume request for the device for this purpose.]  To check if that is
the case, the <code class="docutils literal notranslate"><span class="pre">-&gt;complete</span></code> callback can consult the device’s
<code class="docutils literal notranslate"><span class="pre">power.direct_complete</span></code> flag.  If that flag is set when the
<code class="docutils literal notranslate"><span class="pre">-&gt;complete</span></code> callback is being run then the direct-complete mechanism
was used, and special actions may be required to make the device work
correctly afterward.</p>
</li>
</ol>
</div></blockquote>
<p>At the end of these phases, drivers should be as functional as they were before
suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
gated on.</p>
<p>However, the details here may again be platform-specific.  For example,
some systems support multiple “run” states, and the mode in effect at
the end of resume might not be the one which preceded suspension.
That means availability of certain clocks or power supplies changed,
which could easily affect how a driver works.</p>
<p>Drivers need to be able to handle hardware which has been reset since all of the
suspend methods were called, for example by complete reinitialization.
This may be the hardest part, and the one most protected by NDA’d documents
and chip errata.  It’s simplest if the hardware state hasn’t changed since
the suspend was carried out, but that can only be guaranteed if the target
system sleep entered was suspend-to-idle.  For the other system sleep states
that may not be the case (and usually isn’t for ACPI-defined system sleep
states, like S3).</p>
<p>Drivers must also be prepared to notice that the device has been removed
while the system was powered down, whenever that’s physically possible.
PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
where common Linux platforms will see such removal.  Details of how drivers
will notice and handle such removals are currently bus-specific, and often
involve a separate thread.</p>
<p>These callbacks may return an error value, but the PM core will ignore such
errors since there’s nothing it can do about them other than printing them in
the system log.</p>
</div>
<div class="section" id="entering-hibernation">
<h3>Entering Hibernation<a class="headerlink" href="#entering-hibernation" title="Permalink to this headline">¶</a></h3>
<p>Hibernating the system is more complicated than putting it into sleep states,
because it involves creating and saving a system image.  Therefore there are
more phases for hibernation, with a different set of callbacks.  These phases
always run after tasks have been frozen and enough memory has been freed.</p>
<p>The general procedure for hibernation is to quiesce all devices (“freeze”),
create an image of the system memory while everything is stable, reactivate all
devices (“thaw”), write the image to permanent storage, and finally shut down
the system (“power off”).  The phases used to accomplish this are: <code class="docutils literal notranslate"><span class="pre">prepare</span></code>,
<code class="docutils literal notranslate"><span class="pre">freeze</span></code>, <code class="docutils literal notranslate"><span class="pre">freeze_late</span></code>, <code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">thaw_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">thaw_early</span></code>,
<code class="docutils literal notranslate"><span class="pre">thaw</span></code>, <code class="docutils literal notranslate"><span class="pre">complete</span></code>, <code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">poweroff</span></code>, <code class="docutils literal notranslate"><span class="pre">poweroff_late</span></code>,
<code class="docutils literal notranslate"><span class="pre">poweroff_noirq</span></code>.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">prepare</span></code> phase is discussed in the “Entering System Suspend”
section above.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;freeze</span></code> methods should quiesce the device so that it doesn’t
generate IRQs or DMA, and they may need to save the values of device
registers.  However the device does not have to be put in a low-power
state, and to save time it’s best not to do so.  Also, the device should
not be prepared to generate wakeup events.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">freeze_late</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">suspend_late</span></code> phase
described earlier, except that the device should not be put into a
low-power state and should not be allowed to generate wakeup events.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code> phase
discussed earlier, except again that the device should not be put into
a low-power state and should not be allowed to generate wakeup events.</p></li>
</ol>
</div></blockquote>
<p>At this point the system image is created.  All devices should be inactive and
the contents of memory should remain undisturbed while this happens, so that the
image forms an atomic snapshot of the system state.</p>
<blockquote>
<div><ol class="arabic simple" start="5">
<li><p>The <code class="docutils literal notranslate"><span class="pre">thaw_noirq</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume_noirq</span></code> phase
discussed earlier.  The main difference is that its methods can assume
the device is in the same state as at the end of the <code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code>
phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">thaw_early</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume_early</span></code> phase
described above.  Its methods should undo the actions of the preceding
<code class="docutils literal notranslate"><span class="pre">freeze_late</span></code>, if necessary.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">thaw</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume</span></code> phase discussed
earlier.  Its methods should bring the device back to an operating
state, so that it can be used for saving the image if necessary.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">complete</span></code> phase is discussed in the “Leaving System Suspend”
section above.</p></li>
</ol>
</div></blockquote>
<p>At this point the system image is saved, and the devices then need to be
prepared for the upcoming system shutdown.  This is much like suspending them
before putting the system into the suspend-to-idle, shallow or deep sleep state,
and the phases are similar.</p>
<blockquote>
<div><ol class="arabic simple" start="9">
<li><p>The <code class="docutils literal notranslate"><span class="pre">prepare</span></code> phase is discussed above.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">poweroff</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">suspend</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">poweroff_late</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">suspend_late</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">poweroff_noirq</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">suspend_noirq</span></code> phase.</p></li>
</ol>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">-&gt;poweroff</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;poweroff_late</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;poweroff_noirq</span></code> callbacks
should do essentially the same things as the <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_late</span></code>
and <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_noirq</span></code> callbacks, respectively.  A notable difference is
that they need not store the device register values, because the registers
should already have been stored during the <code class="docutils literal notranslate"><span class="pre">freeze</span></code>, <code class="docutils literal notranslate"><span class="pre">freeze_late</span></code> or
<code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code> phases.  Also, on many machines the firmware will power-down
the entire system, so it is not necessary for the callback to put the device in
a low-power state.</p>
</div>
<div class="section" id="leaving-hibernation">
<h3>Leaving Hibernation<a class="headerlink" href="#leaving-hibernation" title="Permalink to this headline">¶</a></h3>
<p>Resuming from hibernation is, again, more complicated than resuming from a sleep
state in which the contents of main memory are preserved, because it requires
a system image to be loaded into memory and the pre-hibernation memory contents
to be restored before control can be passed back to the image kernel.</p>
<p>Although in principle the image might be loaded into memory and the
pre-hibernation memory contents restored by the boot loader, in practice this
can’t be done because boot loaders aren’t smart enough and there is no
established protocol for passing the necessary information.  So instead, the
boot loader loads a fresh instance of the kernel, called “the restore kernel”,
into memory and passes control to it in the usual way.  Then the restore kernel
reads the system image, restores the pre-hibernation memory contents, and passes
control to the image kernel.  Thus two different kernel instances are involved
in resuming from hibernation.  In fact, the restore kernel may be completely
different from the image kernel: a different configuration and even a different
version.  This has important consequences for device drivers and their
subsystems.</p>
<p>To be able to load the system image into memory, the restore kernel needs to
include at least a subset of device drivers allowing it to access the storage
medium containing the image, although it doesn’t need to include all of the
drivers present in the image kernel.  After the image has been loaded, the
devices managed by the boot kernel need to be prepared for passing control back
to the image kernel.  This is very similar to the initial steps involved in
creating a system image, and it is accomplished in the same way, using
<code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">freeze</span></code>, and <code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code> phases.  However, the devices
affected by these phases are only those having drivers in the restore kernel;
other devices will still be in whatever state the boot loader left them.</p>
<p>Should the restoration of the pre-hibernation memory contents fail, the restore
kernel would go through the “thawing” procedure described above, using the
<code class="docutils literal notranslate"><span class="pre">thaw_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">thaw_early</span></code>, <code class="docutils literal notranslate"><span class="pre">thaw</span></code>, and <code class="docutils literal notranslate"><span class="pre">complete</span></code> phases, and then
continue running normally.  This happens only rarely.  Most often the
pre-hibernation memory contents are restored successfully and control is passed
to the image kernel, which then becomes responsible for bringing the system back
to the working state.</p>
<p>To achieve this, the image kernel must restore the devices’ pre-hibernation
functionality.  The operation is much like waking up from a sleep state (with
the memory contents preserved), although it involves different phases:
<code class="docutils literal notranslate"><span class="pre">restore_noirq</span></code>, <code class="docutils literal notranslate"><span class="pre">restore_early</span></code>, <code class="docutils literal notranslate"><span class="pre">restore</span></code>, <code class="docutils literal notranslate"><span class="pre">complete</span></code>.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">restore_noirq</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume_noirq</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">restore_early</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume_early</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">restore</span></code> phase is analogous to the <code class="docutils literal notranslate"><span class="pre">resume</span></code> phase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">complete</span></code> phase is discussed above.</p></li>
</ol>
</div></blockquote>
<p>The main difference from <code class="docutils literal notranslate"><span class="pre">resume[_early|_noirq]</span></code> is that
<code class="docutils literal notranslate"><span class="pre">restore[_early|_noirq]</span></code> must assume the device has been accessed and
reconfigured by the boot loader or the restore kernel.  Consequently, the state
of the device may be different from the state remembered from the <code class="docutils literal notranslate"><span class="pre">freeze</span></code>,
<code class="docutils literal notranslate"><span class="pre">freeze_late</span></code> and <code class="docutils literal notranslate"><span class="pre">freeze_noirq</span></code> phases.  The device may even need to be
reset and completely re-initialized.  In many cases this difference doesn’t
matter, so the <code class="docutils literal notranslate"><span class="pre">-&gt;resume[_early|_noirq]</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;restore[_early|_norq]</span></code>
method pointers can be set to the same routines.  Nevertheless, different
callback pointers are used in case there is a situation where it actually does
matter.</p>
</div>
</div>
<div class="section" id="power-management-notifiers">
<h2>Power Management Notifiers<a class="headerlink" href="#power-management-notifiers" title="Permalink to this headline">¶</a></h2>
<p>There are some operations that cannot be carried out by the power management
callbacks discussed above, because the callbacks occur too late or too early.
To handle these cases, subsystems and device drivers may register power
management notifiers that are called before tasks are frozen and after they have
been thawed.  Generally speaking, the PM notifiers are suitable for performing
actions that either require user space to be available, or at least won’t
interfere with user space.</p>
<p>For details refer to <a class="reference internal" href="notifiers.html"><span class="doc">Suspend/Hibernation Notifiers</span></a>.</p>
</div>
<div class="section" id="device-low-power-suspend-states">
<h2>Device Low-Power (suspend) States<a class="headerlink" href="#device-low-power-suspend-states" title="Permalink to this headline">¶</a></h2>
<p>Device low-power states aren’t standard.  One device might only handle
“on” and “off”, while another might support a dozen different versions of
“on” (how many engines are active?), plus a state that gets back to “on”
faster than from a full “off”.</p>
<p>Some buses define rules about what different suspend states mean.  PCI
gives one example: after the suspend sequence completes, a non-legacy
PCI device may not perform DMA or issue IRQs, and any wakeup events it
issues would be issued through the PME# bus signal.  Plus, there are
several PCI-standard device states, some of which are optional.</p>
<p>In contrast, integrated system-on-chip processors often use IRQs as the
wakeup event sources (so drivers would call <code class="xref c c-func docutils literal notranslate"><span class="pre">enable_irq_wake()</span></code>) and
might be able to treat DMA completion as a wakeup event (sometimes DMA can stay
active too, it’d only be the CPU and some peripherals that sleep).</p>
<p>Some details here may be platform-specific.  Systems may have devices that
can be fully active in certain sleep states, such as an LCD display that’s
refreshed using DMA while most of the system is sleeping lightly … and
its frame buffer might even be updated by a DSP or other non-Linux CPU while
the Linux control processor stays idle.</p>
<p>Moreover, the specific actions taken may depend on the target system state.
One target system state might allow a given device to be very operational;
another might require a hard shut down with re-initialization on resume.
And two different target systems might use the same device in different
ways; the aforementioned LCD might be active in one product’s “standby”,
but a different product using the same SOC might work differently.</p>
</div>
<div class="section" id="device-power-management-domains">
<h2>Device Power Management Domains<a class="headerlink" href="#device-power-management-domains" title="Permalink to this headline">¶</a></h2>
<p>Sometimes devices share reference clocks or other power resources.  In those
cases it generally is not possible to put devices into low-power states
individually.  Instead, a set of devices sharing a power resource can be put
into a low-power state together at the same time by turning off the shared
power resource.  Of course, they also need to be put into the full-power state
together, by turning the shared power resource on.  A set of devices with this
property is often referred to as a power domain. A power domain may also be
nested inside another power domain. The nested domain is referred to as the
sub-domain of the parent domain.</p>
<p>Support for power domains is provided through the <code class="xref c c-member docutils literal notranslate"><span class="pre">pm_domain</span></code> field of
<a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.  This field is a pointer to an object of type
<a class="reference internal" href="types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a>, defined in <code class="file docutils literal notranslate"><span class="pre">include/linux/pm.h</span></code>, providing a set
of power management callbacks analogous to the subsystem-level and device driver
callbacks that are executed for the given device during all power transitions,
instead of the respective subsystem-level callbacks.  Specifically, if a
device’s <code class="xref c c-member docutils literal notranslate"><span class="pre">pm_domain</span></code> pointer is not NULL, the <code class="docutils literal notranslate"><span class="pre">-&gt;suspend()</span></code> callback
from the object pointed to by it will be executed instead of its subsystem’s
(e.g. bus type’s) <code class="docutils literal notranslate"><span class="pre">-&gt;suspend()</span></code> callback and analogously for all of the
remaining callbacks.  In other words, power management domain callbacks, if
defined for the given device, always take precedence over the callbacks provided
by the device’s subsystem (e.g. bus type).</p>
<p>The support for device power management domains is only relevant to platforms
needing to use the same device driver power management callbacks in many
different power domain configurations and wanting to avoid incorporating the
support for power domains into subsystem-level callbacks, for example by
modifying the platform bus type.  Other platforms need not implement it or take
it into account in any way.</p>
<p>Devices may be defined as IRQ-safe which indicates to the PM core that their
runtime PM callbacks may be invoked with disabled interrupts (see
<code class="file docutils literal notranslate"><span class="pre">Documentation/power/runtime_pm.rst</span></code> for more information).  If an
IRQ-safe device belongs to a PM domain, the runtime PM of the domain will be
disallowed, unless the domain itself is defined as IRQ-safe. However, it
makes sense to define a PM domain as IRQ-safe only if all the devices in it
are IRQ-safe. Moreover, if an IRQ-safe domain has a parent domain, the runtime
PM of the parent is only allowed if the parent itself is IRQ-safe too with the
additional restriction that all child domains of an IRQ-safe parent must also
be IRQ-safe.</p>
</div>
<div class="section" id="runtime-power-management">
<h2>Runtime Power Management<a class="headerlink" href="#runtime-power-management" title="Permalink to this headline">¶</a></h2>
<p>Many devices are able to dynamically power down while the system is still
running. This feature is useful for devices that are not being used, and
can offer significant power savings on a running system.  These devices
often support a range of runtime power states, which might use names such
as “off”, “sleep”, “idle”, “active”, and so on.  Those states will in some
cases (like PCI) be partially constrained by the bus the device uses, and will
usually include hardware states that are also used in system sleep states.</p>
<p>A system-wide power transition can be started while some devices are in low
power states due to runtime power management.  The system sleep PM callbacks
should recognize such situations and react to them appropriately, but the
necessary actions are subsystem-specific.</p>
<p>In some cases the decision may be made at the subsystem level while in other
cases the device driver may be left to decide.  In some cases it may be
desirable to leave a suspended device in that state during a system-wide power
transition, but in other cases the device must be put back into the full-power
state temporarily, for example so that its system wakeup capability can be
disabled.  This all depends on the hardware and the design of the subsystem and
device driver in question.</p>
<p>If it is necessary to resume a device from runtime suspend during a system-wide
transition into a sleep state, that can be done by calling
<code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_resume()</span></code> from the <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> callback (or the <code class="docutils literal notranslate"><span class="pre">-&gt;freeze</span></code>
or <code class="docutils literal notranslate"><span class="pre">-&gt;poweroff</span></code> callback for transitions related to hibernation) of either the
device’s driver or its subsystem (for example, a bus type or a PM domain).
However, subsystems must not otherwise change the runtime status of devices
from their <code class="docutils literal notranslate"><span class="pre">-&gt;prepare</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> callbacks (or equivalent) <em>before</em>
invoking device drivers’ <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> callbacks (or equivalent).</p>
<div class="section" id="the-dpm-flag-smart-suspend-driver-flag">
<span id="smart-suspend-flag"></span><h3>The <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> Driver Flag<a class="headerlink" href="#the-dpm-flag-smart-suspend-driver-flag" title="Permalink to this headline">¶</a></h3>
<p>Some bus types and PM domains have a policy to resume all devices from runtime
suspend upfront in their <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> callbacks, but that may not be really
necessary if the device’s driver can cope with runtime-suspended devices.
The driver can indicate this by setting <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> in
<code class="xref c c-member docutils literal notranslate"><span class="pre">power.driver_flags</span></code> at probe time, with the assistance of the
<code class="xref c c-func docutils literal notranslate"><span class="pre">dev_pm_set_driver_flags()</span></code> helper routine.</p>
<p>Setting that flag causes the PM core and middle-layer code
(bus types, PM domains etc.) to skip the <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_late</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;suspend_noirq</span></code> callbacks provided by the driver if the device remains in
runtime suspend throughout those phases of the system-wide suspend (and
similarly for the “freeze” and “poweroff” parts of system hibernation).
[Otherwise the same driver
callback might be executed twice in a row for the same device, which would not
be valid in general.]  If the middle-layer system-wide PM callbacks are present
for the device then they are responsible for skipping these driver callbacks;
if not then the PM core skips them.  The subsystem callback routines can
determine whether they need to skip the driver callbacks by testing the return
value from the <code class="xref c c-func docutils literal notranslate"><span class="pre">dev_pm_skip_suspend()</span></code> helper function.</p>
<p>In addition, with <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> set, the driver’s <code class="docutils literal notranslate"><span class="pre">-&gt;thaw_noirq</span></code>
and <code class="docutils literal notranslate"><span class="pre">-&gt;thaw_early</span></code> callbacks are skipped in hibernation if the device remained
in runtime suspend throughout the preceding “freeze” transition.  Again, if the
middle-layer callbacks are present for the device, they are responsible for
doing this, otherwise the PM core takes care of it.</p>
</div>
<div class="section" id="the-dpm-flag-may-skip-resume-driver-flag">
<h3>The <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> Driver Flag<a class="headerlink" href="#the-dpm-flag-may-skip-resume-driver-flag" title="Permalink to this headline">¶</a></h3>
<p>During system-wide resume from a sleep state it’s easiest to put devices into
the full-power state, as explained in <code class="file docutils literal notranslate"><span class="pre">Documentation/power/runtime_pm.rst</span></code>.
[Refer to that document for more information regarding this particular issue as
well as for information on the device runtime power management framework in
general.]  However, it often is desirable to leave devices in suspend after
system transitions to the working state, especially if those devices had been in
runtime suspend before the preceding system-wide suspend (or analogous)
transition.</p>
<p>To that end, device drivers can use the <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> flag to
indicate to the PM core and middle-layer code that they allow their “noirq” and
“early” resume callbacks to be skipped if the device can be left in suspend
after system-wide PM transitions to the working state.  Whether or not that is
the case generally depends on the state of the device before the given system
suspend-resume cycle and on the type of the system transition under way.
In particular, the “thaw” and “restore” transitions related to hibernation are
not affected by <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> at all.  [All callbacks are
issued during the “restore” transition regardless of the flag settings,
and whether or not any driver callbacks
are skipped during the “thaw” transition depends whether or not the
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> flag is set (see <a class="reference internal" href="#smart-suspend-flag">above</a>).
In addition, a device is not allowed to remain in runtime suspend if any of its
children will be returned to full power.]</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> flag is taken into account in combination with
the <code class="xref c c-member docutils literal notranslate"><span class="pre">power.may_skip_resume</span></code> status bit set by the PM core during the
“suspend” phase of suspend-type transitions.  If the driver or the middle layer
has a reason to prevent the driver’s “noirq” and “early” resume callbacks from
being skipped during the subsequent system resume transition, it should
clear <code class="xref c c-member docutils literal notranslate"><span class="pre">power.may_skip_resume</span></code> in its <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_late</span></code>
or <code class="docutils literal notranslate"><span class="pre">-&gt;suspend_noirq</span></code> callback.  [Note that the drivers setting
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> need to clear <code class="xref c c-member docutils literal notranslate"><span class="pre">power.may_skip_resume</span></code> in
their <code class="docutils literal notranslate"><span class="pre">-&gt;suspend</span></code> callback in case the other two are skipped.]</p>
<p>Setting the <code class="xref c c-member docutils literal notranslate"><span class="pre">power.may_skip_resume</span></code> status bit along with the
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> flag is necessary, but generally not sufficient,
for the driver’s “noirq” and “early” resume callbacks to be skipped.  Whether or
not they should be skipped can be determined by evaluating the
<code class="xref c c-func docutils literal notranslate"><span class="pre">dev_pm_skip_resume()</span></code> helper function.</p>
<p>If that function returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, the driver’s “noirq” and “early” resume
callbacks should be skipped and the device’s runtime PM status will be set to
“suspended” by the PM core.  Otherwise, if the device was runtime-suspended
during the preceding system-wide suspend transition and its
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> is set, its runtime PM status will be set to
“active” by the PM core.  [Hence, the drivers that do not set
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> should not expect the runtime PM status of their
devices to be changed from “suspended” to “active” by the PM core during
system-wide resume-type transitions.]</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> flag is not set for a device, but
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> is set and the driver’s “late” and “noirq” suspend
callbacks are skipped, its system-wide “noirq” and “early” resume callbacks, if
present, are invoked as usual and the device’s runtime PM status is set to
“active” by the PM core before enabling runtime PM for it.  In that case, the
driver must be prepared to cope with the invocation of its system-wide resume
callbacks back-to-back with its <code class="docutils literal notranslate"><span class="pre">-&gt;runtime_suspend</span></code> one (without the
intervening <code class="docutils literal notranslate"><span class="pre">-&gt;runtime_resume</span></code> and system-wide suspend callbacks) and the
final state of the device must reflect the “active” runtime PM status in that
case.  [Note that this is not a problem at all if the driver’s
<code class="docutils literal notranslate"><span class="pre">-&gt;suspend_late</span></code> callback pointer points to the same function as its
<code class="docutils literal notranslate"><span class="pre">-&gt;runtime_suspend</span></code> one and its <code class="docutils literal notranslate"><span class="pre">-&gt;resume_early</span></code> callback pointer points to
the same function as the <code class="docutils literal notranslate"><span class="pre">-&gt;runtime_resume</span></code> one, while none of the other
system-wide suspend-resume callbacks of the driver are present, for example.]</p>
<p>Likewise, if <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> is set for a device, its driver’s
system-wide “noirq” and “early” resume callbacks may be skipped while its “late”
and “noirq” suspend callbacks may have been executed (in principle, regardless
of whether or not <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> is set).  In that case, the driver
needs to be able to cope with the invocation of its <code class="docutils literal notranslate"><span class="pre">-&gt;runtime_resume</span></code>
callback back-to-back with its “late” and “noirq” suspend ones.  [For instance,
that is not a concern if the driver sets both <code class="docutils literal notranslate"><span class="pre">DPM_FLAG_SMART_SUSPEND</span></code> and
<code class="docutils literal notranslate"><span class="pre">DPM_FLAG_MAY_SKIP_RESUME</span></code> and uses the same pair of suspend/resume callback
functions for runtime PM and system-wide suspend/resume.]</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="notifiers.html" class="btn btn-neutral float-right" title="Suspend/Hibernation Notifiers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="cpuidle.html" class="btn btn-neutral float-left" title="CPU Idle Time Management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>