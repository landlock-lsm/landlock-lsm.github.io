

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Summary of CDROM ioctl calls &mdash; The Linux Kernel 5.11.0+ documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Summary of HDIO_ ioctl calls" href="hdio.html" />
    <link rel="prev" title="Decoding an IOCTL Magic Number" href="ioctl-decoding.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux kernel user-space API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../no_new_privs.html">No New Privileges Flag</a></li>
<li class="toctree-l2"><a class="reference internal" href="../seccomp_filter.html">Seccomp BPF (SECure COMPuting with filters)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../landlock.html">Landlock: unprivileged access control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unshare.html">unshare system call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spec_ctrl.html">Speculation Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../accelerators/ocxl.html">OpenCAPI (Open Coherent Accelerator Processor Interface)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">IOCTLs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ioctl-number.html">Ioctl Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="ioctl-decoding.html">Decoding an IOCTL Magic Number</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Summary of CDROM ioctl calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="hdio.html">Summary of <cite>HDIO_</cite> ioctl calls</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../iommu.html">IOMMU Userspace API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysfs-platform_profile.html">Platform Profile Selection (e.g. /sys/firmware/acpi/platform_profile)</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">The Linux kernel user-space API guide</a> &raquo;</li>
        
          <li><a href="index.html">IOCTLs</a> &raquo;</li>
        
      <li>Summary of CDROM ioctl calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/userspace-api/ioctl/cdrom.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="summary-of-cdrom-ioctl-calls">
<h1>Summary of CDROM ioctl calls<a class="headerlink" href="#summary-of-cdrom-ioctl-calls" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Edward A. Falk &lt;<a class="reference external" href="mailto:efalk&#37;&#52;&#48;google&#46;com">efalk<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</p></li>
</ul>
<p>November, 2004</p>
<p>This document attempts to describe the ioctl(2) calls supported by
the CDROM layer.  These are by-and-large implemented (as of Linux 2.6)
in drivers/cdrom/cdrom.c and drivers/block/scsi_ioctl.c</p>
<p>ioctl values are listed in &lt;linux/cdrom.h&gt;.  As of this writing, they
are as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDROMPAUSE</p></td>
<td><p>Pause Audio Operation</p></td>
</tr>
<tr class="row-even"><td><p>CDROMRESUME</p></td>
<td><p>Resume paused Audio Operation</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMPLAYMSF</p></td>
<td><p>Play Audio MSF (struct cdrom_msf)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMPLAYTRKIND</p></td>
<td><p>Play Audio Track/index (struct cdrom_ti)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADTOCHDR</p></td>
<td><p>Read TOC header (struct cdrom_tochdr)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADTOCENTRY</p></td>
<td><p>Read TOC entry (struct cdrom_tocentry)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSTOP</p></td>
<td><p>Stop the cdrom drive</p></td>
</tr>
<tr class="row-even"><td><p>CDROMSTART</p></td>
<td><p>Start the cdrom drive</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMEJECT</p></td>
<td><p>Ejects the cdrom media</p></td>
</tr>
<tr class="row-even"><td><p>CDROMVOLCTRL</p></td>
<td><p>Control output volume (struct cdrom_volctrl)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSUBCHNL</p></td>
<td><p>Read subchannel data (struct cdrom_subchnl)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADMODE2</p></td>
<td><p>Read CDROM mode 2 data (2336 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADMODE1</p></td>
<td><p>Read CDROM mode 1 data (2048 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADAUDIO</p></td>
<td><p>(struct cdrom_read_audio)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMEJECT_SW</p></td>
<td><p>enable(1)/disable(0) auto-ejecting</p></td>
</tr>
<tr class="row-even"><td><p>CDROMMULTISESSION</p></td>
<td><p>Obtain the start-of-last-session
address of multi session disks
(struct cdrom_multisession)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_GET_MCN</p></td>
<td><p>Obtain the “Universal Product Code”
if available (struct cdrom_mcn)</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_GET_UPC</p></td>
<td><p>Deprecated, use CDROM_GET_MCN instead.</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMRESET</p></td>
<td><p>hard-reset the drive</p></td>
</tr>
<tr class="row-even"><td><p>CDROMVOLREAD</p></td>
<td><p>Get the drive’s volume setting
(struct cdrom_volctrl)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADRAW</p></td>
<td><p>read data in raw mode (2352 Bytes)
(struct cdrom_read)</p></td>
</tr>
<tr class="row-even"><td><p>CDROMREADCOOKED</p></td>
<td><p>read data in cooked mode</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSEEK</p></td>
<td><p>seek msf address</p></td>
</tr>
<tr class="row-even"><td><p>CDROMPLAYBLK</p></td>
<td><p>scsi-cd only, (struct cdrom_blk)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMREADALL</p></td>
<td><p>read all 2646 bytes</p></td>
</tr>
<tr class="row-even"><td><p>CDROMGETSPINDOWN</p></td>
<td><p>return 4-bit spindown value</p></td>
</tr>
<tr class="row-odd"><td><p>CDROMSETSPINDOWN</p></td>
<td><p>set 4-bit spindown value</p></td>
</tr>
<tr class="row-even"><td><p>CDROMCLOSETRAY</p></td>
<td><p>pendant of CDROMEJECT</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_SET_OPTIONS</p></td>
<td><p>Set behavior options</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_CLEAR_OPTIONS</p></td>
<td><p>Clear behavior options</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_SELECT_SPEED</p></td>
<td><p>Set the CD-ROM speed</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_SELECT_DISC</p></td>
<td><p>Select disc (for juke-boxes)</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_MEDIA_CHANGED</p></td>
<td><p>Check is media changed</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_DRIVE_STATUS</p></td>
<td><p>Get tray position, etc.</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_DISC_STATUS</p></td>
<td><p>Get disc type, etc.</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_CHANGER_NSLOTS</p></td>
<td><p>Get number of slots</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_LOCKDOOR</p></td>
<td><p>lock or unlock door</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_DEBUG</p></td>
<td><p>Turn debug messages on/off</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_GET_CAPABILITY</p></td>
<td><p>get capabilities</p></td>
</tr>
<tr class="row-even"><td><p>CDROMAUDIOBUFSIZ</p></td>
<td><p>set the audio buffer size</p></td>
</tr>
<tr class="row-odd"><td><p>DVD_READ_STRUCT</p></td>
<td><p>Read structure</p></td>
</tr>
<tr class="row-even"><td><p>DVD_WRITE_STRUCT</p></td>
<td><p>Write structure</p></td>
</tr>
<tr class="row-odd"><td><p>DVD_AUTH</p></td>
<td><p>Authentication</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_SEND_PACKET</p></td>
<td><p>send a packet to the drive</p></td>
</tr>
<tr class="row-odd"><td><p>CDROM_NEXT_WRITABLE</p></td>
<td><p>get next writable block</p></td>
</tr>
<tr class="row-even"><td><p>CDROM_LAST_WRITTEN</p></td>
<td><p>get last block written on disc</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The information that follows was determined from reading kernel source
code.  It is likely that some corrections will be made over time.</p>
<hr class="docutils" />
<p>General:</p>
<blockquote>
<div><p>Unless otherwise specified, all ioctl calls return 0 on success
and -1 with errno set to an appropriate value on error.  (Some
ioctls return non-negative data values.)</p>
<p>Unless otherwise specified, all ioctl calls return -1 and set
errno to EFAULT on a failed attempt to copy data to or from user
address space.</p>
<p>Individual drivers may return error codes not listed here.</p>
<p>Unless otherwise specified, all data structures and constants
are defined in &lt;linux/cdrom.h&gt;</p>
</div></blockquote>
<hr class="docutils" />
<dl>
<dt>CDROMPAUSE</dt><dd><p>Pause Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMPAUSE, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMRESUME</dt><dd><p>Resume paused Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESUME, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYMSF</dt><dd><p>Play Audio MSF</p>
<p>(struct cdrom_msf)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMPLAYMSF, &amp;msf);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_msf structure, describing a segment of music to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>MSF stands for minutes-seconds-frames</p></li>
<li><p>LBA stands for logical block address</p></li>
<li><p>Segment is described as start and end times, where each time
is described as minutes:seconds:frames.
A frame is 1/75 of a second.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYTRKIND</dt><dd><p>Play Audio Track/index</p>
<p>(struct cdrom_ti)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_ti ti;

ioctl(fd, CDROMPLAYTRKIND, &amp;ti);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_ti structure, describing a segment of music to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Segment is described as start and end times, where each time
is described as a track and an index.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCHDR</dt><dd><p>Read TOC header</p>
<p>(struct cdrom_tochdr)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cdrom_tochdr header;

ioctl(fd, CDROMREADTOCHDR, &amp;header);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_tochdr structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_tochdr structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCENTRY</dt><dd><p>Read TOC entry</p>
<p>(struct cdrom_tocentry)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_tocentry entry;

ioctl(fd, CDROMREADTOCENTRY, &amp;entry);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_tocentry structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_tocentry structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
<li><p>EINVAL      entry.cdte_format not CDROM_MSF or CDROM_LBA</p></li>
<li><p>EINVAL      requested track out of bounds</p></li>
<li><p>EIO         I/O error reading TOC</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>TOC stands for Table Of Contents</p></li>
<li><p>MSF stands for minutes-seconds-frames</p></li>
<li><p>LBA stands for logical block address</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTOP</dt><dd><p>Stop the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTOP, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive down.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTART</dt><dd><p>Start the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTART, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive up and/or close the tray.
Other devices ignore the ioctl completely.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT</dt><dd><ul class="simple">
<li><p>Ejects the cdrom media</p></li>
</ul>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMEJECT, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not capable of ejecting</p></li>
<li><p>EBUSY       other processes are accessing drive, or door is locked</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>See CDROM_LOCKDOOR, below.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMCLOSETRAY</dt><dd><p>pendant of CDROMEJECT</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMCLOSETRAY, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not capable of closing the tray</p></li>
<li><p>EBUSY       other processes are accessing drive, or door is locked</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>See CDROM_LOCKDOOR, below.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLCTRL</dt><dd><p>Control output volume (struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLCTRL, &amp;volume);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_volctrl structure containing volumes for up to 4
channels.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLREAD</dt><dd><p>Get the drive’s volume setting</p>
<p>(struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLREAD, &amp;volume);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The current volume settings.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSUBCHNL</dt><dd><p>Read subchannel data</p>
<p>(struct cdrom_subchnl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_subchnl q;

ioctl(fd, CDROMSUBCHNL, &amp;q);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_subchnl structure</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_subchnl structure</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      cd drive not audio-capable.</p></li>
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul class="simple">
<li><p>Format is converted to CDROM_MSF or CDROM_LBA
as per user request on return</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADRAW</dt><dd><p>read data in raw mode (2352 Bytes)</p>
<p>(struct cdrom_read)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union {

  struct cdrom_msf msf;               /* input */
  char buffer[CD_FRAMESIZE_RAW];      /* return */
} arg;
ioctl(fd, CDROMREADRAW, &amp;arg);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>cdrom_msf structure indicating an address to read.</p>
<p>Only the start values are significant.</p>
</dd>
<dt>outputs:</dt><dd><p>Data written to address provided by user.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      address less than 0, or msf less than 0:2:0</p></li>
<li><p>ENOMEM      out of memory</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>As of 2.6.8.1, comments in &lt;linux/cdrom.h&gt; indicate that this
ioctl accepts a cdrom_read structure, but actual source code
reads a cdrom_msf structure and writes a buffer of data to
the same address.</p></li>
<li><p>MSF values are converted to LBA values via this formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lba = (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADMODE1</dt><dd><p>Read CDROM mode 1 data (2048 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="simple">
<dt>notes:</dt><dd><p>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE (2048) bytes</p>
</dd>
</dl>
</dd>
<dt>CDROMREADMODE2</dt><dd><p>Read CDROM mode 2 data (2336 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="simple">
<dt>notes:</dt><dd><p>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE_RAW0 (2336) bytes</p>
</dd>
</dl>
</dd>
<dt>CDROMREADAUDIO</dt><dd><p>(struct cdrom_read_audio)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_read_audio ra;

ioctl(fd, CDROMREADAUDIO, &amp;ra);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>cdrom_read_audio structure containing read start
point and length</p>
</dd>
<dt>outputs:</dt><dd><p>audio data, returned to buffer indicated by ra</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
<li><p>EINVAL      nframes not in range [1 75]</p></li>
<li><p>ENXIO       drive has no queue (probably means invalid fd)</p></li>
<li><p>ENOMEM      out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT_SW</dt><dd><p>enable(1)/disable(0) auto-ejecting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, CDROMEJECT_SW, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Flag specifying auto-eject flag.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive is not capable of ejecting.</p></li>
<li><p>EBUSY       Door is locked</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMMULTISESSION</dt><dd><p>Obtain the start-of-last-session address of multi session disks</p>
<p>(struct cdrom_multisession)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_multisession ms_info;

ioctl(fd, CDROMMULTISESSION, &amp;ms_info);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>cdrom_multisession structure containing desired</p>
</div></blockquote>
<p>format.</p>
</dd>
<dt>outputs:</dt><dd><p>cdrom_multisession structure is filled with last_session
information.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      format not CDROM_MSF or CDROM_LBA</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_MCN</dt><dd><p>Obtain the “Universal Product Code”
if available</p>
<p>(struct cdrom_mcn)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_mcn mcn;

ioctl(fd, CDROM_GET_MCN, &amp;mcn);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>Universal Product Code</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive is not capable of reading MCN data.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The following function is implemented, although very few
audio discs give Universal Product Code information, which
should just be the Medium Catalog Number on the box.  Note,
that the way the code is written on the CD is /not/ uniform
across all discs!
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_UPC</dt><dd><p>CDROM_GET_MCN  (deprecated)</p>
<p>Not implemented, as of 2.6.8.1</p>
</dd>
<dt>CDROMRESET</dt><dd><p>hard-reset the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESET, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
<li><p>ENOSYS      Drive is not capable of resetting.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADCOOKED</dt><dd><p>read data in cooked mode</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 buffer[CD_FRAMESIZE]

ioctl(fd, CDROMREADCOOKED, buffer);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>2048 bytes of data, “cooked” mode.</p>
</dd>
<dt>notes:</dt><dd><p>Not implemented on all drives.</p>
</dd>
</dl>
</dd>
<dt>CDROMREADALL</dt><dd><p>read all 2646 bytes</p>
<p>Same as CDROMREADCOOKED, but reads 2646 bytes.</p>
</dd>
<dt>CDROMSEEK</dt><dd><p>seek msf address</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMSEEK, &amp;msf);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>MSF address to seek to.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROMPLAYBLK</dt><dd><p>scsi-cd only</p>
<p>(struct cdrom_blk)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_blk blk;

ioctl(fd, CDROMPLAYBLK, &amp;blk);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Region to play</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROMGETSPINDOWN</dt><dd><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown;

ioctl(fd, CDROMGETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The value of the current 4-bit spindown value.</p>
</dd>
</dl>
</dd>
<dt>CDROMSETSPINDOWN</dt><dd><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown

ioctl(fd, CDROMSETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>4-bit value used to control spindown (TODO: more detail here)</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROM_SET_OPTIONS</dt><dd><p>Set behavior options</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int options;

ioctl(fd, CDROM_SET_OPTIONS, options);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>New values for drive options.  The logical ‘or’ of:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDO_AUTO_CLOSE</p></td>
<td><p>close tray on first open(2)</p></td>
</tr>
<tr class="row-even"><td><p>CDO_AUTO_EJECT</p></td>
<td><p>open tray on last release</p></td>
</tr>
<tr class="row-odd"><td><p>CDO_USE_FFLAGS</p></td>
<td><p>use O_NONBLOCK information on open</p></td>
</tr>
<tr class="row-even"><td><p>CDO_LOCK</p></td>
<td><p>lock tray on open files</p></td>
</tr>
<tr class="row-odd"><td><p>CDO_CHECK_TYPE</p></td>
<td><p>check type on open for data</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><p>Returns the resulting options settings in the
ioctl return value.  Returns -1 on error.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      selected option(s) not supported by drive.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CLEAR_OPTIONS</dt><dd><p>Clear behavior options</p>
<p>Same as CDROM_SET_OPTIONS, except that selected options are
turned off.</p>
</dd>
<dt>CDROM_SELECT_SPEED</dt><dd><p>Set the CD-ROM speed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int speed;

ioctl(fd, CDROM_SELECT_SPEED, speed);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New drive speed.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      speed selection not supported by drive.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_SELECT_DISC</dt><dd><p>Select disc (for juke-boxes)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int disk;

ioctl(fd, CDROM_SELECT_DISC, disk);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Disk to load into drive.</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EINVAL      Disk number beyond capacity of drive</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_MEDIA_CHANGED</dt><dd><p>Check is media changed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_MEDIA_CHANGED, slot);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Slot number to be tested, always zero except for jukeboxes.</p>
<p>May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value is 0 or 1 depending on whether the media</p>
</div></blockquote>
<p>has been changed, or -1 on error.</p>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive can’t detect media change</p></li>
<li><p>EINVAL      Slot number beyond capacity of drive</p></li>
<li><p>ENOMEM      Out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DRIVE_STATUS</dt><dd><p>Get tray position, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_DRIVE_STATUS, slot);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Slot number to be tested, always zero except for jukeboxes.</p>
<p>May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value will be one of the following values</p>
</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>CDS_NO_INFO</p></td>
<td><p>Information not available.</p></td>
</tr>
<tr class="row-even"><td><p>CDS_NO_DISC</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CDS_TRAY_OPEN</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>CDS_DRIVE_NOT_READY</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CDS_DISC_OK</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>error</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>ENOSYS      Drive can’t detect drive status</p></li>
<li><p>EINVAL      Slot number beyond capacity of drive</p></li>
<li><p>ENOMEM      Out of memory</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DISC_STATUS</dt><dd><p>Get disc type, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_DISC_STATUS, 0);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>Ioctl return value will be one of the following values</p>
</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote>
<div><ul class="simple">
<li><p>CDS_NO_INFO</p></li>
<li><p>CDS_AUDIO</p></li>
<li><p>CDS_MIXED</p></li>
<li><p>CDS_XA_2_2</p></li>
<li><p>CDS_XA_2_1</p></li>
<li><p>CDS_DATA_1</p></li>
</ul>
</div></blockquote>
</dd>
<dt>error returns:</dt><dd><p>none at present</p>
</dd>
<dt>notes:</dt><dd><ul>
<li><p>Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ok, this is where problems start.  The current interface for
the CDROM_DISC_STATUS ioctl is flawed.  It makes the false
assumption that CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.
Unfortunately, while this is often the case, it is also
very common for CDs to have some tracks with data, and some
tracks with audio.      Just because I feel like it, I declare
the following to be the best way to cope.  If the CD has
ANY data tracks on it, it will be returned as a data CD.
If it has any XA tracks, I will return it as that.      Now I
could simplify this interface by combining these returns with
the above, but this more clearly demonstrates the problem
with the current interface.  Too bad this wasn&#39;t designed
to use bitmasks...             -Erik

Well, now we have the option CDS_MIXED: a mixed-type CD.
User level programmers might feel the ioctl is not very
useful.
                ---david
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CHANGER_NSLOTS</dt><dd><p>Get number of slots</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_CHANGER_NSLOTS, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value will be the number of slots in a
CD changer.  Typically 1 for non-multi-disk devices.</p>
</dd>
<dt>error returns:</dt><dd><p>none</p>
</dd>
</dl>
</dd>
<dt>CDROM_LOCKDOOR</dt><dd><p>lock or unlock door</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lock;

ioctl(fd, CDROM_LOCKDOOR, lock);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>Door lock flag, 1=lock, 0=unlock</p>
</dd>
<dt>outputs:</dt><dd><p>none</p>
</dd>
<dt>error returns:</dt><dd><ul>
<li><p>EDRIVE_CANT_DO_THIS</p>
<blockquote>
<div><p>Door lock function not supported.</p>
</div></blockquote>
</li>
<li><p>EBUSY</p>
<blockquote>
<div><p>Attempt to unlock when multiple users
have the drive open and not CAP_SYS_ADMIN</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt>notes:</dt><dd><p>As of 2.6.8.1, the lock flag is a global lock, meaning that
all CD drives will be locked or unlocked together.  This is
probably a bug.</p>
<p>The EDRIVE_CANT_DO_THIS value is defined in &lt;linux/cdrom.h&gt;
and is currently (2.6.8.1) the same as EOPNOTSUPP</p>
</dd>
</dl>
</dd>
<dt>CDROM_DEBUG</dt><dd><p>Turn debug messages on/off</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int debug;

ioctl(fd, CDROM_DEBUG, debug);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>Cdrom debug flag, 0=disable, 1=enable</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value will be the new debug flag.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>EACCES      Access denied:  requires CAP_SYS_ADMIN</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_CAPABILITY</dt><dd><p>get capabilities</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_GET_CAPABILITY, 0);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value is the current device capability
flags.  See CDC_CLOSE_TRAY, CDC_OPEN_TRAY, etc.</p>
</dd>
</dl>
</dd>
<dt>CDROMAUDIOBUFSIZ</dt><dd><p>set the audio buffer size</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int arg;

ioctl(fd, CDROMAUDIOBUFSIZ, val);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>New audio buffer size</p>
</dd>
<dt>outputs:</dt><dd><p>The ioctl return value is the new audio buffer size, or -1
on error.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOSYS      Not supported by this driver.</p></li>
</ul>
</dd>
<dt>notes:</dt><dd><p>Not supported by all drivers.</p>
</dd>
</dl>
</dd>
</dl>
<p>DVD_READ_STRUCT                 Read structure</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_struct s;

ioctl(fd, DVD_READ_STRUCT, &amp;s);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><blockquote>
<div><p>dvd_struct structure, containing:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>type</p></td>
<td><p>specifies the information desired, one of
DVD_STRUCT_PHYSICAL, DVD_STRUCT_COPYRIGHT,
DVD_STRUCT_DISCKEY, DVD_STRUCT_BCA,
DVD_STRUCT_MANUFACT</p></td>
</tr>
<tr class="row-even"><td><p>physical.layer_num</p></td>
<td><p>desired layer, indexed from 0</p></td>
</tr>
<tr class="row-odd"><td><p>copyright.layer_num</p></td>
<td><p>desired layer, indexed from 0</p></td>
</tr>
<tr class="row-even"><td><p>disckey.agid</p></td>
<td></td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>dvd_struct structure, containing:</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>physical</p></td>
<td><p>for type == DVD_STRUCT_PHYSICAL</p></td>
</tr>
<tr class="row-even"><td><p>copyright</p></td>
<td><p>for type == DVD_STRUCT_COPYRIGHT</p></td>
</tr>
<tr class="row-odd"><td><p>disckey.value</p></td>
<td><p>for type == DVD_STRUCT_DISCKEY</p></td>
</tr>
<tr class="row-even"><td><p>bca.{len,value}</p></td>
<td><p>for type == DVD_STRUCT_BCA</p></td>
</tr>
<tr class="row-odd"><td><p>manufact.{len,valu}</p></td>
<td><p>for type == DVD_STRUCT_MANUFACT</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt><dd><ul class="simple">
<li><p>EINVAL      physical.layer_num exceeds number of layers</p></li>
<li><p>EIO         Received invalid response from drive</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>DVD_WRITE_STRUCT                Write structure</p>
<blockquote>
<div><p>Not implemented, as of 2.6.8.1</p>
</div></blockquote>
<p>DVD_AUTH                        Authentication</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_authinfo ai;

ioctl(fd, DVD_AUTH, &amp;ai);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>dvd_authinfo structure.  See &lt;linux/cdrom.h&gt;</p>
</dd>
<dt>outputs:</dt><dd><p>dvd_authinfo structure.</p>
</dd>
<dt>error return:</dt><dd><ul class="simple">
<li><p>ENOTTY      ai.type not recognized.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>CDROM_SEND_PACKET</dt><dd><p>send a packet to the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_generic_command cgc;

ioctl(fd, CDROM_SEND_PACKET, &amp;cgc);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>cdrom_generic_command structure containing the packet to send.</p>
</dd>
<dt>outputs:</dt><dd><blockquote>
<div><p>none</p>
</div></blockquote>
<p>cdrom_generic_command structure containing results.</p>
</dd>
<dt>error return:</dt><dd><ul>
<li><p>EIO</p>
<blockquote>
<div><p>command failed.</p>
</div></blockquote>
</li>
<li><p>EPERM</p>
<blockquote>
<div><p>Operation not permitted, either because a
write command was attempted on a drive which
is opened read-only, or because the command
requires CAP_SYS_RAWIO</p>
</div></blockquote>
</li>
<li><p>EINVAL</p>
<blockquote>
<div><p>cgc.data_direction not set</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_NEXT_WRITABLE</dt><dd><p>get next writable block</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long next;

ioctl(fd, CDROM_NEXT_WRITABLE, &amp;next);
</pre></div>
</div>
<dl>
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The next writable block.</p>
</dd>
<dt>notes:</dt><dd><blockquote>
<div><p>If the device does not support this ioctl directly, the</p>
</div></blockquote>
<p>ioctl will return CDROM_LAST_WRITTEN + 7.</p>
</dd>
</dl>
</dd>
<dt>CDROM_LAST_WRITTEN</dt><dd><p>get last block written on disc</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long last;

ioctl(fd, CDROM_LAST_WRITTEN, &amp;last);
</pre></div>
</div>
<dl class="simple">
<dt>inputs:</dt><dd><p>none</p>
</dd>
<dt>outputs:</dt><dd><p>The last block written on disc</p>
</dd>
<dt>notes:</dt><dd><p>If the device does not support this ioctl directly, the
result is derived from the disc’s table of contents.  If the
table of contents can’t be read, this ioctl returns an
error.</p>
</dd>
</dl>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="hdio.html" class="btn btn-neutral float-right" title="Summary of HDIO_ ioctl calls" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="ioctl-decoding.html" class="btn btn-neutral float-left" title="Decoding an IOCTL Magic Number" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>