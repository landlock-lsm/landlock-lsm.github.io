

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The ALSA Driver API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Writing an ALSA Driver" href="writing-an-alsa-driver.html" />
    <link rel="prev" title="ALSA Kernel API Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.9.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Sound Subsystem Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">ALSA Kernel API Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The ALSA Driver API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#management-of-cards-and-devices">Management of Cards and Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pcm-api">PCM API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-mixer-api">Control/Mixer API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#midi-api">MIDI API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proc-info-api">Proc Info API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compress-offload">Compress Offload</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asoc">ASoC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#miscellaneous-functions">Miscellaneous Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="writing-an-alsa-driver.html">Writing an ALSA Driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../designs/index.html">Designs and Implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soc/index.html">ALSA SoC Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../alsa-configuration.html">Advanced Linux Sound Architecture - Driver Configuration guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hd-audio/index.html">HD-Audio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cards/index.html">Card-Specific Information</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Sound Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="index.html">ALSA Kernel API Documentation</a> &raquo;</li>
        
      <li>The ALSA Driver API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/sound/kernel-api/alsa-driver-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-alsa-driver-api">
<h1>The ALSA Driver API<a class="headerlink" href="#the-alsa-driver-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="management-of-cards-and-devices">
<h2>Management of Cards and Devices<a class="headerlink" href="#management-of-cards-and-devices" title="Permalink to this headline">¶</a></h2>
<div class="section" id="card-management">
<h3>Card Management<a class="headerlink" href="#card-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_device_initialize">
void <code class="descname">snd_device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize struct device for sound devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>card to assign, optional</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_new">
int <code class="descname">snd_card_new</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, int<em>&nbsp;idx</em>, const char *<em>&nbsp;xid</em>, struct module *<em>&nbsp;module</em>, int<em>&nbsp;extra_size</em>, struct snd_card **<em>&nbsp;card_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a soundcard structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>card index (address) [0 … (SNDRV_CARDS-1)]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">xid</span></code></dt>
<dd>card identification (ASCII string)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>top level module for locking</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extra_size</span></code></dt>
<dd>allocate this extra size after the main soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">**</span> <span class="pre">card_ret</span></code></dt>
<dd><p class="first">the pointer to store the created card instance</p>
<p>Creates and initializes a soundcard structure.</p>
<p class="last">The function allocates snd_card instance via kzalloc with the given
space for the driver to use freely.  The allocated struct is stored
in the given card_ret pointer.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_ref">
struct snd_card * <code class="descname">snd_card_ref</code><span class="sig-paren">(</span>int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the card object from the index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>the card index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a card object corresponding to the given index or NULL if not found.
Release the object via <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_card_disconnect">
int <code class="descname">snd_card_disconnect</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect all APIs from the file-operations (user space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd><p class="first">soundcard structure</p>
<p class="last">Disconnects all APIs from the file-operations (user space).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero, otherwise a negative error code.</p>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>The current implementation replaces all active file-&gt;f_op with special</dt>
<dd>dummy file operations (they do nothing except release).</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_disconnect_sync">
void <code class="descname">snd_card_disconnect_sync</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect card and wait until files get closed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>card object to disconnect</dd>
</dl>
<p><strong>Description</strong></p>
<p>This calls <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a> for disconnecting all belonging components
and waits until all pending files get closed.
It assures that all accesses from user-space finished so that the driver
can release its resources gracefully.</p>
<dl class="function">
<dt id="c.snd_card_free_when_closed">
int <code class="descname">snd_card_free_when_closed</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free_when_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect the card, free it later eventually</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>, this function doesn’t try to release the card
resource immediately, but tries to disconnect at first.  When the card
is still in use, the function returns before freeing the resources.
The card resources will be freed when the refcount gets to zero.</p>
<dl class="function">
<dt id="c.snd_card_free">
int <code class="descname">snd_card_free</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees given soundcard structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don’t have to release the devices
by yourself.</p>
<p>This function waits until the all resources are properly released.</p>
<p><strong>Return</strong></p>
<p>Zero. Frees all associated devices and frees the control
interface associated to given soundcard.</p>
<dl class="function">
<dt id="c.snd_card_set_id">
void <code class="descname">snd_card_set_id</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_set_id" title="Permalink to this definition">¶</a></dt>
<dd><p>set card identification name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">nid</span></code></dt>
<dd><p class="first">new identification string</p>
<p class="last">This function sets the card identification and checks for name
collisions.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_add_dev_attr">
int <code class="descname">snd_card_add_dev_attr</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const struct attribute_group *<em>&nbsp;group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_add_dev_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a new sysfs attribute group to card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>attribute group to append</dd>
</dl>
<dl class="function">
<dt id="c.snd_card_register">
int <code class="descname">snd_card_register</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the soundcard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd><p class="first">soundcard structure</p>
<p class="last">This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code if the registration failed.</p>
<dl class="function">
<dt id="c.snd_component_add">
int <code class="descname">snd_component_add</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_component_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd><p class="first">the component id string</p>
<p class="last">This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_file_add">
int <code class="descname">snd_card_file_add</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the file to the file list of the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><p class="first">file pointer</p>
<p class="last">This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero or a negative error code.</p>
<dl class="function">
<dt id="c.snd_card_file_remove">
int <code class="descname">snd_card_file_remove</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the file from the file list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><p class="first">file pointer</p>
<p class="last">This function removes the file formerly added to the card via
<a class="reference internal" href="#c.snd_card_file_add" title="snd_card_file_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_file_add()</span></code></a> function.
If all files are removed and <a class="reference internal" href="#c.snd_card_free_when_closed" title="snd_card_free_when_closed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_when_closed()</span></code></a> was
called beforehand, it processes the pending release of
resources.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero or a negative error code.</p>
<dl class="function">
<dt id="c.snd_power_wait">
int <code class="descname">snd_power_wait</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, unsigned int<em>&nbsp;power_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the power-state is changed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>soundcard structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">power_state</span></code></dt>
<dd><p class="first">expected power state</p>
<p class="last">Waits until the power-state is changed.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<div class="section" id="device-components">
<h3>Device Components<a class="headerlink" href="#device-components" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_device_new">
int <code class="descname">snd_device_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, enum snd_device_type<em>&nbsp;type</em>, void *<em>&nbsp;device_data</em>, const struct snd_device_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create an ALSA device component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_device_type</span> <span class="pre">type</span></code></dt>
<dd>the device type, SNDRV_DEV_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt>
<dd>the data pointer of this device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_device_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the operator table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.</p>
<p>The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_device_disconnect">
void <code class="descname">snd_device_disconnect</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, void *<em>&nbsp;device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt>
<dd>the data pointer to disconnect</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turns the device into the disconnection state, invoking
dev_disconnect callback, if the device was already registered.</p>
<p>Usually called from <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
<dl class="function">
<dt id="c.snd_device_free">
void <code class="descname">snd_device_free</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, void *<em>&nbsp;device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release the device from the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt>
<dd>the data pointer to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the device from the list on the card and invokes the
callbacks, dev_disconnect and dev_free, corresponding to the state.
Then release the device.</p>
<dl class="function">
<dt id="c.snd_device_register">
int <code class="descname">snd_device_register</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, void *<em>&nbsp;device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt>
<dd>the data pointer to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the device which was already created via
<a class="reference internal" href="#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a>.  Usually this is called from <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>,
but it can be called later if any new devices are created after
invocation of <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
<dl class="function">
<dt id="c.snd_device_get_state">
int <code class="descname">snd_device_get_state</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, void *<em>&nbsp;device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">device_data</span></code></dt>
<dd>the data pointer to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the current state of the given device object.  For the valid
device, either <strong>SNDRV_DEV_BUILD</strong>, <strong>SNDRV_DEV_REGISTERED</strong> or
<strong>SNDRV_DEV_DISCONNECTED</strong> is returned.
Or for a non-existing device, -1 is returned as an error.</p>
</div>
<div class="section" id="module-requests-and-device-file-entries">
<h3>Module requests and Device File Entries<a class="headerlink" href="#module-requests-and-device-file-entries" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_request_card">
void <code class="descname">snd_request_card</code><span class="sig-paren">(</span>int<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_request_card" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load the card module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">card</span></code></dt>
<dd>the card number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to load the module “snd-card-X” for the given card number
via request_module.  Returns immediately if already loaded.</p>
<dl class="function">
<dt id="c.snd_lookup_minor_data">
void * <code class="descname">snd_lookup_minor_data</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;minor</em>, int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_lookup_minor_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get user data of a registered device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minor</span></code></dt>
<dd>the minor number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>device type (SNDRV_DEVICE_TYPE_XXX)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a minor device with the specified type is registered, and returns
its user data pointer.</p>
<p>This function increments the reference counter of the card instance
if an associated instance with the given minor number and type is found.
The caller must call <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a> appropriately later.</p>
<p><strong>Return</strong></p>
<p>The user data pointer if the specified device is found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
otherwise.</p>
<dl class="function">
<dt id="c.snd_register_device">
int <code class="descname">snd_register_device</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, struct snd_card *<em>&nbsp;card</em>, int<em>&nbsp;dev</em>, const struct file_operations *<em>&nbsp;f_ops</em>, void *<em>&nbsp;private_data</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the ALSA device file for the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>the device type, SNDRV_DEVICE_TYPE_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt>
<dd>the device index</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">f_ops</span></code></dt>
<dd>the file operations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>user pointer for f_ops-&gt;open()</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>the device to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_unregister_device">
int <code class="descname">snd_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the device on the given card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters the device file already registered via
<a class="reference internal" href="#c.snd_register_device" title="snd_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_register_device()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<div class="section" id="memory-management-helpers">
<h3>Memory Management Helpers<a class="headerlink" href="#memory-management-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.copy_to_user_fromio">
int <code class="descname">copy_to_user_fromio</code><span class="sig-paren">(</span>void __user *<em>&nbsp;dst</em>, const volatile void __iomem *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_to_user_fromio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from mmio-space to user-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>the destination pointer on user-space</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>the source pointer on mmio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>the data size to copy in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from mmio-space to user-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
<dl class="function">
<dt id="c.copy_from_user_toio">
int <code class="descname">copy_from_user_toio</code><span class="sig-paren">(</span>volatile void __iomem *<em>&nbsp;dst</em>, const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_from_user_toio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from user-space to mmio-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>the destination pointer on mmio-space</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>the source pointer on user-space</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>the data size to copy in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from user-space to mmio-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
<dl class="function">
<dt id="c.snd_malloc_dev_iram">
void <code class="descname">snd_malloc_dev_iram</code><span class="sig-paren">(</span>struct snd_dma_buffer *<em>&nbsp;dmab</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_malloc_dev_iram" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory from on-chip internal ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt>
<dd>buffer allocation record to store the allocated data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to allocate from the iram</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function requires iram phandle provided via of_node</p>
<dl class="function">
<dt id="c.snd_free_dev_iram">
void <code class="descname">snd_free_dev_iram</code><span class="sig-paren">(</span>struct snd_dma_buffer *<em>&nbsp;dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_free_dev_iram" title="Permalink to this definition">¶</a></dt>
<dd><p>free allocated specific memory from on-chip internal ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt>
<dd>buffer allocation record to store the allocated data</dd>
</dl>
<dl class="function">
<dt id="c.snd_dma_alloc_pages">
int <code class="descname">snd_dma_alloc_pages</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, size_t<em>&nbsp;size</em>, struct snd_dma_buffer *<em>&nbsp;dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>the DMA buffer type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>the device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the buffer size to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt>
<dd>buffer allocation record to store the allocated data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
<dl class="function">
<dt id="c.snd_dma_alloc_pages_fallback">
int <code class="descname">snd_dma_alloc_pages_fallback</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, size_t<em>&nbsp;size</em>, struct snd_dma_buffer *<em>&nbsp;dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_pages_fallback" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type with fallback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>the DMA buffer type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>the device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the buffer size to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt>
<dd>buffer allocation record to store the allocated data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res_size argument.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
<dl class="function">
<dt id="c.snd_dma_free_pages">
void <code class="descname">snd_dma_free_pages</code><span class="sig-paren">(</span>struct snd_dma_buffer *<em>&nbsp;dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">dmab</span></code></dt>
<dd>the buffer allocation record to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the allocated buffer via <a class="reference internal" href="#c.snd_dma_alloc_pages" title="snd_dma_alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_dma_alloc_pages()</span></code></a>.</p>
</div>
</div>
<div class="section" id="pcm-api">
<h2>PCM API<a class="headerlink" href="#pcm-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pcm-core">
<h3>PCM Core<a class="headerlink" href="#pcm-core" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_format_name">
const char * <code class="descname">snd_pcm_format_name</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a name string for the given PCM format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>PCM format</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_new_stream">
int <code class="descname">snd_pcm_new_stream</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em>, int<em>&nbsp;stream</em>, int<em>&nbsp;substream_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the pcm instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>the stream direction, SNDRV_PCM_STREAM_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">substream_count</span></code></dt>
<dd>the number of substreams</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
<a class="reference internal" href="#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_new">
int <code class="descname">snd_pcm_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;id</em>, int<em>&nbsp;device</em>, int<em>&nbsp;playback_count</em>, int<em>&nbsp;capture_count</em>, struct snd_pcm **<em>&nbsp;rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the id string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>the device index (zero based)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt>
<dd>the number of substreams for playback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt>
<dd>the number of substreams for capture</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**</span> <span class="pre">rpcm</span></code></dt>
<dd>the pointer to store the new pcm instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new PCM instance.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_new_internal">
int <code class="descname">snd_pcm_new_internal</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;id</em>, int<em>&nbsp;device</em>, int<em>&nbsp;playback_count</em>, int<em>&nbsp;capture_count</em>, struct snd_pcm **<em>&nbsp;rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new internal PCM instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the id string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>the device index (zero based - shared with normal PCMs)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt>
<dd>the number of substreams for playback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt>
<dd>the number of substreams for capture</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**</span> <span class="pre">rpcm</span></code></dt>
<dd>the pointer to store the new pcm instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new internal PCM instance with no userspace device or procfs
entries. This is used by ASoC Back End PCMs in order to create a PCM that
will only be used internally by kernel drivers. i.e. it cannot be opened
by userspace. It provides existing ASoC components drivers with a substream
and access to any private data.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_notify">
int <code class="descname">snd_pcm_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_pcm_notify" title="snd_pcm_notify">snd_pcm_notify</a> *<em>&nbsp;notify</em>, int<em>&nbsp;nfree</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add/remove the notify list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt>
<dd>PCM notify list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nfree</span></code></dt>
<dd>0 = register, 1 = unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the given notifier to the global list so that the callback is
called for each registered PCM devices.  This exists only for PCM OSS
emulation, so far.</p>
<dl class="function">
<dt id="c.snd_pcm_set_ops">
void <code class="descname">snd_pcm_set_ops</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em>, int<em>&nbsp;direction</em>, const struct snd_pcm_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM operators</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the pcm instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">direction</span></code></dt>
<dd>stream direction, SNDRV_PCM_STREAM_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the operator table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the given PCM operators to the pcm instance.</p>
<dl class="function">
<dt id="c.snd_pcm_set_sync">
void <code class="descname">snd_pcm_set_sync</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM sync id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCM sync identifier for the card.</p>
<dl class="function">
<dt id="c.snd_interval_refine">
int <code class="descname">snd_interval_refine</code><span class="sig-paren">(</span>struct snd_interval *<em>&nbsp;i</em>, const struct snd_interval *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_refine" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value of configurator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt>
<dd>the interval value to refine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the interval value to refer to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_div">
void <code class="descname">snd_interval_div</code><span class="sig-paren">(</span>const struct snd_interval *<em>&nbsp;a</em>, const struct snd_interval *<em>&nbsp;b</em>, struct snd_interval *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_div" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value with division</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>dividend</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>divisor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>quotient</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a / b</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
<dl class="function">
<dt id="c.snd_interval_muldivk">
void <code class="descname">snd_interval_muldivk</code><span class="sig-paren">(</span>const struct snd_interval *<em>&nbsp;a</em>, const struct snd_interval *<em>&nbsp;b</em>, unsigned int<em>&nbsp;k</em>, struct snd_interval *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_muldivk" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>dividend 1</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>dividend 2</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">k</span></code></dt>
<dd>divisor (as integer)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>result</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a * b / k</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
<dl class="function">
<dt id="c.snd_interval_mulkdiv">
void <code class="descname">snd_interval_mulkdiv</code><span class="sig-paren">(</span>const struct snd_interval *<em>&nbsp;a</em>, unsigned int<em>&nbsp;k</em>, const struct snd_interval *<em>&nbsp;b</em>, struct snd_interval *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_mulkdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>dividend 1</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">k</span></code></dt>
<dd>dividend 2 (as integer)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>divisor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>result</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a * k / b</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
<dl class="function">
<dt id="c.snd_interval_ratnum">
int <code class="descname">snd_interval_ratnum</code><span class="sig-paren">(</span>struct snd_interval *<em>&nbsp;i</em>, unsigned int<em>&nbsp;rats_count</em>, const struct snd_ratnum *<em>&nbsp;rats</em>, unsigned int *<em>&nbsp;nump</em>, unsigned int *<em>&nbsp;denp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ratnum" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt>
<dd>interval to refine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rats_count</span></code></dt>
<dd>number of ratnum_t</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ratnum</span> <span class="pre">*</span> <span class="pre">rats</span></code></dt>
<dd>ratnum_t array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">nump</span></code></dt>
<dd>pointer to store the resultant numerator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">denp</span></code></dt>
<dd>pointer to store the resultant denominator</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_ratden">
int <code class="descname">snd_interval_ratden</code><span class="sig-paren">(</span>struct snd_interval *<em>&nbsp;i</em>, unsigned int<em>&nbsp;rats_count</em>, const struct snd_ratden *<em>&nbsp;rats</em>, unsigned int *<em>&nbsp;nump</em>, unsigned int *<em>&nbsp;denp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ratden" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt>
<dd>interval to refine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rats_count</span></code></dt>
<dd>number of struct ratden</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ratden</span> <span class="pre">*</span> <span class="pre">rats</span></code></dt>
<dd>struct ratden array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">nump</span></code></dt>
<dd>pointer to store the resultant numerator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">denp</span></code></dt>
<dd>pointer to store the resultant denominator</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_list">
int <code class="descname">snd_interval_list</code><span class="sig-paren">(</span>struct snd_interval *<em>&nbsp;i</em>, unsigned int<em>&nbsp;count</em>, const unsigned int *<em>&nbsp;list</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_list" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt>
<dd>the interval value to refine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of elements in the list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the value list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>the bit-mask to evaluate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_interval_ranges">
int <code class="descname">snd_interval_ranges</code><span class="sig-paren">(</span>struct snd_interval *<em>&nbsp;i</em>, unsigned int<em>&nbsp;count</em>, const struct snd_interval *<em>&nbsp;ranges</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list of ranges</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">i</span></code></dt>
<dd>the interval value to refine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of elements in the list of ranges</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*</span> <span class="pre">ranges</span></code></dt>
<dd>the ranges list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>the bit-mask to evaluate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list of ranges.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_add">
int <code class="descname">snd_pcm_hw_rule_add</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, int<em>&nbsp;var</em>, snd_pcm_hw_rule_func_t<em>&nbsp;func</em>, void *<em>&nbsp;private</em>, int<em>&nbsp;dep</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the hw-constraint rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>the pcm runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">var</span></code></dt>
<dd>the variable to evaluate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_rule_func_t</span> <span class="pre">func</span></code></dt>
<dd>the evaluation function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt>
<dd>the private data pointer passed to function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dep</span></code></dt>
<dd>the dependent variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_mask">
int <code class="descname">snd_pcm_hw_constraint_mask</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, u_int32_t<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the given bitmap mask constraint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_int32_t</span> <span class="pre">mask</span></code></dt>
<dd>the bitmap mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of the given bitmap mask to a 32-bit mask parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_mask64">
int <code class="descname">snd_pcm_hw_constraint_mask64</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, u_int64_t<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_mask64" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the given bitmap mask constraint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_int64_t</span> <span class="pre">mask</span></code></dt>
<dd>the 64bit bitmap mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of the given bitmap mask to a 64-bit mask parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_integer">
int <code class="descname">snd_pcm_hw_constraint_integer</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_hw_param_t<em>&nbsp;var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an integer constraint to an interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the integer constraint</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of integer to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_minmax">
int <code class="descname">snd_pcm_hw_constraint_minmax</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, unsigned int<em>&nbsp;min</em>, unsigned int<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a min/max range constraint to an interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>the minimal value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>the maximal value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the min/max range constraint to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_list">
int <code class="descname">snd_pcm_hw_constraint_list</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_list" title="snd_pcm_hw_constraint_list">snd_pcm_hw_constraint_list</a> *<em>&nbsp;l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_list" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a list of constraints to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the list constraint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_list</span> <span class="pre">*</span> <span class="pre">l</span></code></dt>
<dd>list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ranges">
int <code class="descname">snd_pcm_hw_constraint_ranges</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ranges" title="snd_pcm_hw_constraint_ranges">snd_pcm_hw_constraint_ranges</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>apply list of range constraints to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the list of range constraints</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ranges</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>ranges</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of range constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratnums">
int <code class="descname">snd_pcm_hw_constraint_ratnums</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratnums" title="snd_pcm_hw_constraint_ratnums">snd_pcm_hw_constraint_ratnums</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratnums" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratnums constraint to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the ratnums constraint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratnums</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>struct snd_ratnums constriants</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratdens">
int <code class="descname">snd_pcm_hw_constraint_ratdens</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratdens" title="snd_pcm_hw_constraint_ratdens">snd_pcm_hw_constraint_ratdens</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratdens" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratdens constraint to a parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the ratdens constraint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratdens</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>struct snd_ratdens constriants</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_msbits">
int <code class="descname">snd_pcm_hw_constraint_msbits</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, unsigned int<em>&nbsp;width</em>, unsigned int<em>&nbsp;msbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_msbits" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint msbits rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>sample bits width</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msbits</span></code></dt>
<dd>msbits width</dd>
</dl>
<p><strong>Description</strong></p>
<p>This constraint will set the number of most significant bits (msbits) if a
sample format with the specified width has been select. If width is set to 0
the msbits will be set for any sample format with a width larger than the
specified msbits.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_step">
int <code class="descname">snd_pcm_hw_constraint_step</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, unsigned long<em>&nbsp;step</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_step" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint step rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the step constraint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">step</span></code></dt>
<dd>step size</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_pow2">
int <code class="descname">snd_pcm_hw_constraint_pow2</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;cond</em>, snd_pcm_hw_param_t<em>&nbsp;var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_pow2" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint power-of-2 rule</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt>
<dd>condition bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>hw_params variable to apply the power-of-2 constraint</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_noresample">
int <code class="descname">snd_pcm_hw_rule_noresample</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, unsigned int<em>&nbsp;base_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_noresample" title="Permalink to this definition">¶</a></dt>
<dd><p>add a rule to allow disabling hw resampling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base_rate</span></code></dt>
<dd>the rate at which the hardware does not resample</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_value">
int <code class="descname">snd_pcm_hw_param_value</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;params</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, int *<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return <strong>params</strong> field <strong>var</strong> value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the hw_params instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>parameter to retrieve</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Return</strong></p>
<p>The value for field <strong>var</strong> if it’s fixed in configuration space
defined by <strong>params</strong>. -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_first">
int <code class="descname">snd_pcm_hw_param_first</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;pcm</em>, struct snd_pcm_hw_params *<em>&nbsp;params</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, int *<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_first" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return minimum value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>PCM instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the hw_params instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>parameter to retrieve</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &gt; minimum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The minimum, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_param_last">
int <code class="descname">snd_pcm_hw_param_last</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;pcm</em>, struct snd_pcm_hw_params *<em>&nbsp;params</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, int *<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_last" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return maximum value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>PCM instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the hw_params instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>parameter to retrieve</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &lt; maximum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The maximum, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_ioctl">
int <code class="descname">snd_pcm_lib_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned int<em>&nbsp;cmd</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>a generic PCM ioctl callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl command</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>ioctl argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_period_elapsed">
void <code class="descname">snd_pcm_period_elapsed</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_period_elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the pcm status for the next period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the interrupt handler when the
PCM has processed the period size.  It will update the current
pointer, wake up sleepers, etc.</p>
<p>Even if more than one periods have elapsed since the last call, you
have to call this only once.</p>
<dl class="function">
<dt id="c.snd_pcm_add_chmap_ctls">
int <code class="descname">snd_pcm_add_chmap_ctls</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em>, int<em>&nbsp;stream</em>, const struct snd_pcm_chmap_elem *<em>&nbsp;chmap</em>, int<em>&nbsp;max_channels</em>, unsigned long<em>&nbsp;private_value</em>, struct snd_pcm_chmap **<em>&nbsp;info_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_add_chmap_ctls" title="Permalink to this definition">¶</a></dt>
<dd><p>create channel-mapping control elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the assigned PCM instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>stream direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_chmap_elem</span> <span class="pre">*</span> <span class="pre">chmap</span></code></dt>
<dd>channel map elements (for query)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_channels</span></code></dt>
<dd>the max number of channels for the stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">private_value</span></code></dt>
<dd>the value passed to each kcontrol’s private_value field</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">**</span> <span class="pre">info_ret</span></code></dt>
<dd>store struct snd_pcm_chmap instance if non-NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create channel-mapping control elements assigned to the given PCM stream(s).</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error value.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock">
void <code class="descname">snd_pcm_stream_lock</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream’s spinlock or mutex depending on the nonatomic
flag of the given substream.  This also takes the global link rw lock
(or rw sem), too, for avoiding the race with linked streams.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock">
void <code class="descname">snd_pcm_stream_unlock</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unlocks the PCM stream that has been locked via <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irq">
void <code class="descname">snd_pcm_stream_lock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> and disables the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irq">
void <code class="descname">snd_pcm_stream_unlock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irq" title="snd_pcm_stream_lock_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irq()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irqrestore">
void <code class="descname">snd_pcm_stream_unlock_irqrestore</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irqrestore" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>irq flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irqsave" title="snd_pcm_stream_lock_irqsave"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irqsave()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_params_choose">
int <code class="descname">snd_pcm_hw_params_choose</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;pcm</em>, struct snd_pcm_hw_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_params_choose" title="Permalink to this definition">¶</a></dt>
<dd><p>choose a configuration defined by <strong>params</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>PCM instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the hw_params instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose one configuration from configuration space defined by <strong>params</strong>.
The configuration chosen is that obtained fixing in this order:
first access, first format, first subformat, min channels,
min rate, min period time, max buffer size, min tick time</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_start">
int <code class="descname">snd_pcm_start</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start all linked streams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the PCM substream instance</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.
The stream lock must be acquired before calling this function.</p>
<dl class="function">
<dt id="c.snd_pcm_stop">
int <code class="descname">snd_pcm_stop</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, snd_pcm_state_t<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>try to stop all running streams in the substream group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the PCM substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_state_t</span> <span class="pre">state</span></code></dt>
<dd>PCM state after stopping the stream</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state of each stream is then changed to the given state unconditionally.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_drain_done">
int <code class="descname">snd_pcm_drain_done</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_drain_done" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the DMA only when the given stream is playback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>After stopping, the state is changed to SETUP.
Unlike <a class="reference internal" href="#c.snd_pcm_stop" title="snd_pcm_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stop()</span></code></a>, this affects only the given stream.</p>
<p><strong>Return</strong></p>
<p>Zero if succesful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_stop_xrun">
int <code class="descname">snd_pcm_stop_xrun</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop_xrun" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the running streams as XRUN</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the PCM substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>This stops the given running substream (and all linked substreams) as XRUN.
Unlike <a class="reference internal" href="#c.snd_pcm_stop" title="snd_pcm_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stop()</span></code></a>, this function takes the substream lock by itself.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_suspend_all">
int <code class="descname">snd_pcm_suspend_all</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_suspend_all" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger SUSPEND to all substreams in the given pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the PCM instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, all streams are changed to SUSPENDED state.</p>
<p><strong>Return</strong></p>
<p>Zero if successful (or <strong>pcm</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>), or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_prepare">
int <code class="descname">snd_pcm_prepare</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare the PCM substream to be triggerable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the PCM substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file to refer f_flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_kernel_ioctl">
int <code class="descname">snd_pcm_kernel_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned int<em>&nbsp;cmd</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_kernel_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute PCM ioctl in the kernel-space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>IOCTL cmd</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>IOCTL argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function is provided primarily for OSS layer and USB gadget drivers,
and it allows only the limited set of ioctls (hw_params, sw_params,
prepare, start, drain, drop, forward).</p>
<dl class="function">
<dt id="c.snd_pcm_lib_default_mmap">
int <code class="descname">snd_pcm_lib_default_mmap</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct vm_area_struct *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_default_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>VMA</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default mmap handler for PCM data.  When mmap pcm_ops is NULL,
this function is invoked implicitly.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_mmap_iomem">
int <code class="descname">snd_pcm_lib_mmap_iomem</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct vm_area_struct *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_mmap_iomem" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function for I/O mem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>VMA</dd>
</dl>
<p><strong>Description</strong></p>
<p>When your hardware uses the iomapped pages as the hardware buffer and
wants to mmap it, pass this function as mmap pcm_ops.  Note that this
is supposed to work only on limited architectures.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_linked">
int <code class="descname">snd_pcm_stream_linked</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_linked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is linked with others</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>substream to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the given substream is being linked with others.</p>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irqsave">
<code class="descname">snd_pcm_stream_lock_irqsave</code><span class="sig-paren">(</span><em>substream</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>irq flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> but with the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_pcm_group_for_each_entry">
<code class="descname">snd_pcm_group_for_each_entry</code><span class="sig-paren">(</span><em>s</em>, <em>substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_group_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over the linked substreams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt>
<dd>the iterator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt>
<dd>the substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the all linked substreams to the given <strong>substream</strong>.
When <strong>substream</strong> isn’t linked with any others, this gives returns <strong>substream</strong>
itself once.</p>
<dl class="function">
<dt id="c.snd_pcm_running">
int <code class="descname">snd_pcm_running</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_running" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is in a running state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>substream to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the given substream is in the state RUNNING, or in the
state DRAINING for playback.</p>
<dl class="function">
<dt id="c.bytes_to_samples">
ssize_t <code class="descname">bytes_to_samples</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, ssize_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to samples</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt>
<dd>size in bytes</dd>
</dl>
<dl class="function">
<dt id="c.bytes_to_frames">
snd_pcm_sframes_t <code class="descname">bytes_to_frames</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, ssize_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to frames</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt>
<dd>size in bytes</dd>
</dl>
<dl class="function">
<dt id="c.samples_to_bytes">
ssize_t <code class="descname">samples_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, ssize_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.samples_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from samples to bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt>
<dd>size in samples</dd>
</dl>
<dl class="function">
<dt id="c.frames_to_bytes">
ssize_t <code class="descname">frames_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_sframes_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frames_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from frames to bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_sframes_t</span> <span class="pre">size</span></code></dt>
<dd>size in frames</dd>
</dl>
<dl class="function">
<dt id="c.frame_aligned">
int <code class="descname">frame_aligned</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, ssize_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frame_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the byte size is aligned to frames</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">bytes</span></code></dt>
<dd>size in bytes</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_buffer_bytes">
size_t <code class="descname">snd_pcm_lib_buffer_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size of the current PCM in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_period_bytes">
size_t <code class="descname">snd_pcm_lib_period_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_period_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size of the current PCM in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_playback_avail">
snd_pcm_uframes_t <code class="descname">snd_pcm_playback_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (writable) space for playback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<dl class="function">
<dt id="c.snd_pcm_capture_avail">
snd_pcm_uframes_t <code class="descname">snd_pcm_capture_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (readable) space for capture</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<dl class="function">
<dt id="c.snd_pcm_playback_hw_avail">
snd_pcm_sframes_t <code class="descname">snd_pcm_playback_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the queued space for playback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_capture_hw_avail">
snd_pcm_sframes_t <code class="descname">snd_pcm_capture_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the free space for capture</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_playback_ready">
int <code class="descname">snd_pcm_playback_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough free space is available on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_capture_ready">
int <code class="descname">snd_pcm_capture_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough capture data is available on the capture buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_playback_data">
int <code class="descname">snd_pcm_playback_data</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_data" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether any data exists on the playback buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether any data exists on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if any data exists, or zero if not. If stop_threshold
is bigger or equal to boundary, then this function returns always non-zero.</p>
<dl class="function">
<dt id="c.snd_pcm_playback_empty">
int <code class="descname">snd_pcm_playback_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the playback buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_capture_empty">
int <code class="descname">snd_pcm_capture_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the capture buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
<dl class="function">
<dt id="c.snd_pcm_trigger_done">
void <code class="descname">snd_pcm_trigger_done</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct snd_pcm_substream *<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_trigger_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the master substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd>the linked master substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>When multiple substreams of the same card are linked and the hardware
supports the single-shot operation, the driver calls this in the loop
in <a class="reference internal" href="#c.snd_pcm_group_for_each_entry" title="snd_pcm_group_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_group_for_each_entry()</span></code></a> for marking the substream as “done”.
Then most of trigger operations are performed only to the given master
substream.</p>
<p>The trigger_master mark is cleared at timestamp updates at the end
of trigger operations.</p>
<dl class="function">
<dt id="c.params_channels">
unsigned int <code class="descname">params_channels</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of channels from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.params_rate">
unsigned int <code class="descname">params_rate</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sample rate from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.params_period_size">
unsigned int <code class="descname">params_period_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_period_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size (in frames) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.params_periods">
unsigned int <code class="descname">params_periods</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of periods from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.params_buffer_size">
unsigned int <code class="descname">params_buffer_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in frames) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.params_buffer_bytes">
unsigned int <code class="descname">params_buffer_bytes</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in bytes) from the hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>hw params</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_single">
int <code class="descname">snd_pcm_hw_constraint_single</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, snd_pcm_hw_param_t<em>&nbsp;var</em>, unsigned int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrain parameter to a single value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt>
<dd>The hw_params variable to constrain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt>
<dd>The value to constrain to</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
<dl class="function">
<dt id="c.snd_pcm_format_cpu_endian">
int <code class="descname">snd_pcm_format_cpu_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_cpu_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is CPU-endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.</p>
<dl class="function">
<dt id="c.snd_pcm_set_runtime_buffer">
void <code class="descname">snd_pcm_set_runtime_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct snd_dma_buffer *<em>&nbsp;bufp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_runtime_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the PCM runtime buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream to set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">bufp</span></code></dt>
<dd>the buffer information, NULL to clear</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the buffer information to runtime-&gt;dma_buffer when <strong>bufp</strong> is non-NULL.
Otherwise it clears the current buffer information.</p>
<dl class="function">
<dt id="c.snd_pcm_gettime">
void <code class="descname">snd_pcm_gettime</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em>, struct timespec64 *<em>&nbsp;tv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_gettime" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the timespec64 depending on the timestamp mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>PCM runtime instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">tv</span></code></dt>
<dd>timespec64 to fill</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_buffer">
int <code class="descname">snd_pcm_lib_alloc_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtual DMA buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream to allocate the buffer to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested buffer size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the PCM substream buffer using <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, i.e., the memory is
contiguous in kernel virtual space, but not in physical memory.  Use this
if the buffer is accessed by kernel code but not by device DMA.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_32_buffer">
int <code class="descname">snd_pcm_lib_alloc_vmalloc_32_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_32_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate 32-bit-addressable buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream to allocate the buffer to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested buffer size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works like <a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a>, but uses
<a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc_32()</span></code></a>, i.e., the pages are allocated from 32-bit-addressable memory.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_addr">
dma_addr_t <code class="descname">snd_pcm_sgbuf_get_addr</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned int<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the DMA address at the corresponding offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt>
<dd>byte offset</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_ptr">
void * <code class="descname">snd_pcm_sgbuf_get_ptr</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned int<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the virtual address at the corresponding offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt>
<dd>byte offset</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_chunk_size">
unsigned int <code class="descname">snd_pcm_sgbuf_get_chunk_size</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned int<em>&nbsp;ofs</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max size that fits within the contig. page from the given size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt>
<dd>byte offset</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>byte size to examine</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_open">
void <code class="descname">snd_pcm_mmap_data_open</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_open" title="Permalink to this definition">¶</a></dt>
<dd><p>increase the mmap counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>VMA</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_close">
void <code class="descname">snd_pcm_mmap_data_close</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_close" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease the mmap counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">area</span></code></dt>
<dd>VMA</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
<dl class="function">
<dt id="c.snd_pcm_limit_isa_dma_size">
void <code class="descname">snd_pcm_limit_isa_dma_size</code><span class="sig-paren">(</span>int<em>&nbsp;dma</em>, size_t *<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_limit_isa_dma_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max size fitting with ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt>
<dd>DMA number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">max</span></code></dt>
<dd>pointer to store the max size</dd>
</dl>
<dl class="function">
<dt id="c.snd_pcm_stream_str">
const char * <code class="descname">snd_pcm_stream_str</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string naming the direction of a stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Return</strong></p>
<p>A string naming the direction of the stream.</p>
<dl class="function">
<dt id="c.snd_pcm_chmap_substream">
struct snd_pcm_substream * <code class="descname">snd_pcm_chmap_substream</code><span class="sig-paren">(</span>struct snd_pcm_chmap *<em>&nbsp;info</em>, unsigned int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_chmap_substream" title="Permalink to this definition">¶</a></dt>
<dd><p>get the PCM substream assigned to the given chmap info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>chmap information</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>the substream number index</dd>
</dl>
<dl class="function">
<dt id="c.pcm_format_to_bits">
u64 <code class="descname">pcm_format_to_bits</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;pcm_format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_format_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Strong-typed conversion of pcm_format to bitwise</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">pcm_format</span></code></dt>
<dd>PCM format</dd>
</dl>
<dl class="function">
<dt id="c.pcm_for_each_format">
<code class="descname">pcm_for_each_format</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_for_each_format" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to iterate for each format type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt>
<dd>the iterator variable in snd_pcm_format_t type</dd>
</dl>
</div>
<div class="section" id="pcm-format-helpers">
<h3>PCM Format Helpers<a class="headerlink" href="#pcm-format-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_format_signed">
int <code class="descname">snd_pcm_format_signed</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is signed linear</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is signed linear, 0 if unsigned
linear, and a negative error code for non-linear formats.</p>
<dl class="function">
<dt id="c.snd_pcm_format_unsigned">
int <code class="descname">snd_pcm_format_unsigned</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_unsigned" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is unsigned linear</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is unsigned linear, 0 if signed
linear, and a negative error code for non-linear formats.</p>
<dl class="function">
<dt id="c.snd_pcm_format_linear">
int <code class="descname">snd_pcm_format_linear</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is linear</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is linear, 0 if not.</p>
<dl class="function">
<dt id="c.snd_pcm_format_little_endian">
int <code class="descname">snd_pcm_format_little_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_little_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is little-endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is little-endian, 0 if
big-endian, or a negative error code if endian not specified.</p>
<dl class="function">
<dt id="c.snd_pcm_format_big_endian">
int <code class="descname">snd_pcm_format_big_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_big_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is big-endian</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is big-endian, 0 if
little-endian, or a negative error code if endian not specified.</p>
<dl class="function">
<dt id="c.snd_pcm_format_width">
int <code class="descname">snd_pcm_format_width</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_width" title="Permalink to this definition">¶</a></dt>
<dd><p>return the bit-width of the format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>The bit-width of the format, or a negative error code
if unknown format.</p>
<dl class="function">
<dt id="c.snd_pcm_format_physical_width">
int <code class="descname">snd_pcm_format_physical_width</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_physical_width" title="Permalink to this definition">¶</a></dt>
<dd><p>return the physical bit-width of the format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>The physical bit-width of the format, or a negative error code
if unknown format.</p>
<dl class="function">
<dt id="c.snd_pcm_format_size">
ssize_t <code class="descname">snd_pcm_format_size</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em>, size_t<em>&nbsp;samples</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_size" title="Permalink to this definition">¶</a></dt>
<dd><p>return the byte size of samples on the given format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">samples</span></code></dt>
<dd>sampling rate</dd>
</dl>
<p><strong>Return</strong></p>
<p>The byte size of the given samples for the format, or a
negative error code if unknown format.</p>
<dl class="function">
<dt id="c.snd_pcm_format_silence_64">
const unsigned char * <code class="descname">snd_pcm_format_silence_64</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_silence_64" title="Permalink to this definition">¶</a></dt>
<dd><p>return the silent data in 8 bytes array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the format to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>The format pattern to fill or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if error.</p>
<dl class="function">
<dt id="c.snd_pcm_format_set_silence">
int <code class="descname">snd_pcm_format_set_silence</code><span class="sig-paren">(</span>snd_pcm_format_t<em>&nbsp;format</em>, void *<em>&nbsp;data</em>, unsigned int<em>&nbsp;samples</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_set_silence" title="Permalink to this definition">¶</a></dt>
<dd><p>set the silence data on the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt>
<dd>the PCM format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>the buffer pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">samples</span></code></dt>
<dd>the number of samples to set silence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the silence data on the buffer for the given samples.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_hw_limit_rates">
int <code class="descname">snd_pcm_hw_limit_rates</code><span class="sig-paren">(</span>struct snd_pcm_hardware *<em>&nbsp;hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_limit_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>determine rate_min/rate_max fields</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*</span> <span class="pre">hw</span></code></dt>
<dd>the pcm hw instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determines the rate_min and rate_max fields from the rates bits of
the given hw.</p>
<p><strong>Return</strong></p>
<p>Zero if successful.</p>
<dl class="function">
<dt id="c.snd_pcm_rate_to_rate_bit">
unsigned int <code class="descname">snd_pcm_rate_to_rate_bit</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_to_rate_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>converts sample rate to SNDRV_PCM_RATE_xxx bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt>
<dd>the sample rate to convert</dd>
</dl>
<p><strong>Return</strong></p>
<p>The SNDRV_PCM_RATE_xxx flag that corresponds to the given rate, or
SNDRV_PCM_RATE_KNOT for an unknown rate.</p>
<dl class="function">
<dt id="c.snd_pcm_rate_bit_to_rate">
unsigned int <code class="descname">snd_pcm_rate_bit_to_rate</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rate_bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_bit_to_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>converts SNDRV_PCM_RATE_xxx bit to sample rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_bit</span></code></dt>
<dd>the rate bit to convert</dd>
</dl>
<p><strong>Return</strong></p>
<p>The sample rate that corresponds to the given SNDRV_PCM_RATE_xxx flag
or 0 for an unknown rate bit.</p>
<dl class="function">
<dt id="c.snd_pcm_rate_mask_intersect">
unsigned int <code class="descname">snd_pcm_rate_mask_intersect</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rates_a</em>, unsigned int<em>&nbsp;rates_b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_mask_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the intersection between two rate masks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rates_a</span></code></dt>
<dd>The first rate mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rates_b</span></code></dt>
<dd>The second rate mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the rates that are supported by both rate masks passed
to the function. It will take care of the special handling of
SNDRV_PCM_RATE_CONTINUOUS and SNDRV_PCM_RATE_KNOT.</p>
<p><strong>Return</strong></p>
<p>A rate mask containing the rates that are supported by both rates_a
and rates_b.</p>
<dl class="function">
<dt id="c.snd_pcm_rate_range_to_bits">
unsigned int <code class="descname">snd_pcm_rate_range_to_bits</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rate_min</em>, unsigned int<em>&nbsp;rate_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_range_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>converts rate range to SNDRV_PCM_RATE_xxx bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_min</span></code></dt>
<dd>the minimum sample rate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_max</span></code></dt>
<dd>the maximum sample rate</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has an implicit assumption: the rates in the given range have
only the pre-defined rates like 44100 or 16000.</p>
<p><strong>Return</strong></p>
<p>The SNDRV_PCM_RATE_xxx flag that corresponds to the given rate range,
or SNDRV_PCM_RATE_KNOT for an unknown range.</p>
</div>
<div class="section" id="pcm-memory-management">
<h3>PCM Memory Management<a class="headerlink" href="#pcm-memory-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_free">
void <code class="descname">snd_pcm_lib_preallocate_free</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release the preallocated buffer of the specified substream.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the pre-allocated buffer of the given substream.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_free_for_all">
void <code class="descname">snd_pcm_lib_preallocate_free_for_all</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_free_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>release all pre-allocated buffers on the pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the pcm instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all the pre-allocated buffers on the given pcm.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages">
void <code class="descname">snd_pcm_lib_preallocate_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, int<em>&nbsp;type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for the given DMA type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>DMA type (SNDRV_DMA_TYPE_*)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>DMA type dependent data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested pre-allocation size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>the max. allowed pre-allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages_for_all">
void <code class="descname">snd_pcm_lib_preallocate_pages_for_all</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em>, int<em>&nbsp;type</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for continuous memory type (all substreams)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the pcm instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>DMA type (SNDRV_DMA_TYPE_*)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>DMA type dependent data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested pre-allocation size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>the max. allowed pre-allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the
specified DMA type.</p>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer">
void <code class="descname">snd_pcm_set_managed_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, int<em>&nbsp;type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for a substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>DMA type (SNDRV_DMA_TYPE_*)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>DMA type dependent data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested pre-allocation size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>the max. allowed pre-allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type, and set the managed
buffer allocation mode to the given substream.
In this mode, PCM core will allocate a buffer automatically before PCM
hw_params ops call, and release the buffer after PCM hw_free ops call
as well, so that the driver doesn’t need to invoke the allocation and
the release explicitly in its callback.
When a buffer is actually allocated before the PCM hw_params call, it
turns on the runtime buffer_changed flag for drivers changing their h/w
parameters accordingly.</p>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer_all">
void <code class="descname">snd_pcm_set_managed_buffer_all</code><span class="sig-paren">(</span>struct snd_pcm *<em>&nbsp;pcm</em>, int<em>&nbsp;type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer_all" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for all substreams for all substreams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the pcm instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>DMA type (SNDRV_DMA_TYPE_*)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>DMA type dependent data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested pre-allocation size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>the max. allowed pre-allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the specified DMA
type and size, and set the managed_buffer_alloc flag to each substream.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_malloc_pages">
int <code class="descname">snd_pcm_lib_malloc_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_malloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the DMA buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream to allocate the DMA buffer to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the requested buffer size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the DMA buffer on the BUS type given earlier to
snd_pcm_lib_preallocate_xxx_pages().</p>
<p><strong>Return</strong></p>
<p>1 if the buffer is changed, 0 if not changed, or a negative
code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_free_pages">
int <code class="descname">snd_pcm_lib_free_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated DMA buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream to release the DMA buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the DMA buffer allocated via <a class="reference internal" href="#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_free_vmalloc_buffer">
int <code class="descname">snd_pcm_lib_free_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>free vmalloc buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_pcm_lib_get_vmalloc_page">
struct page * <code class="descname">snd_pcm_lib_get_vmalloc_page</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, unsigned long<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_get_vmalloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc buffer offset to page struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset</span></code></dt>
<dd>offset in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is to be used as the page callback in the PCM ops.</p>
<p><strong>Return</strong></p>
<p>The page struct, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<div class="section" id="pcm-dma-engine-api">
<h3>PCM DMA Engine API<a class="headerlink" href="#pcm-dma-engine-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_hwparams_to_dma_slave_config">
int <code class="descname">snd_hwparams_to_dma_slave_config</code><span class="sig-paren">(</span>const struct snd_pcm_substream *<em>&nbsp;substream</em>, const struct snd_pcm_hw_params *<em>&nbsp;params</em>, struct dma_slave_config *<em>&nbsp;slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_hwparams_to_dma_slave_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert hw_params to dma_slave_config</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>hw_params</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*</span> <span class="pre">slave_config</span></code></dt>
<dd>DMA slave config</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to initialize a dma_slave_config from a substream
and hw_params in a dmaengine based PCM driver implementation.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_set_config_from_dai_data">
void <code class="descname">snd_dmaengine_pcm_set_config_from_dai_data</code><span class="sig-paren">(</span>const struct snd_pcm_substream *<em>&nbsp;substream</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_dai_dma_data" title="snd_dmaengine_dai_dma_data">snd_dmaengine_dai_dma_data</a> *<em>&nbsp;dma_data</em>, struct dma_slave_config *<em>&nbsp;slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_set_config_from_dai_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a dma slave config using DAI DMA data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_dai_dma_data</span> <span class="pre">*</span> <span class="pre">dma_data</span></code></dt>
<dd>DAI DMA data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*</span> <span class="pre">slave_config</span></code></dt>
<dd>DMA slave configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the {dst,src}_addr, {dst,src}_maxburst, {dst,src}_addr_width and
slave_id fields of the DMA slave config from the same fields of the DAI DMA
data struct. The src and dst fields will be initialized depending on the
direction of the substream. If the substream is a playback stream the dst
fields will be initialized, if it is a capture stream the src fields will be
initialized. The {dst,src}_addr_width field will only be initialized if the
SND_DMAENGINE_PCM_DAI_FLAG_PACK flag is set or if the addr_width field of
the DAI DMA data struct is not equal to DMA_SLAVE_BUSWIDTH_UNDEFINED. If
both conditions are met the latter takes priority.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_trigger">
int <code class="descname">snd_dmaengine_pcm_trigger</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, int<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM trigger implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>Trigger command</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, a negative error code otherwise.</p>
<p>This function can be used as the PCM trigger callback for dmaengine based PCM
driver implementations.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_pointer_no_residue">
snd_pcm_uframes_t <code class="descname">snd_dmaengine_pcm_pointer_no_residue</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_pointer_no_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM pointer implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated and should not be used by new drivers, as its
results may be unreliable.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_pointer">
snd_pcm_uframes_t <code class="descname">snd_dmaengine_pcm_pointer</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM pointer implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the PCM pointer callback for dmaengine based PCM
driver implementations.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_request_channel">
struct dma_chan * <code class="descname">snd_dmaengine_pcm_request_channel</code><span class="sig-paren">(</span>dma_filter_fn<em>&nbsp;filter_fn</em>, void *<em>&nbsp;filter_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_request_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Request channel for the dmaengine PCM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dma_filter_fn</span> <span class="pre">filter_fn</span></code></dt>
<dd>Filter function used to request the DMA channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">filter_data</span></code></dt>
<dd>Data passed to the DMA filter function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL or the requested DMA channel.</p>
<p>This function request a DMA channel for usage with dmaengine PCM.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_open">
int <code class="descname">snd_dmaengine_pcm_open</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct dma_chan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a dmaengine based PCM substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_chan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>DMA channel to use for data transfers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, a negative error code otherwise.</p>
<p>The function should usually be called from the pcm open callback. Note that
this function will use private_data field of the substream’s runtime. So it
is not available to your pcm driver implementation.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_open_request_chan">
int <code class="descname">snd_dmaengine_pcm_open_request_chan</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, dma_filter_fn<em>&nbsp;filter_fn</em>, void *<em>&nbsp;filter_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_open_request_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a dmaengine based PCM substream and request channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_filter_fn</span> <span class="pre">filter_fn</span></code></dt>
<dd>Filter function used to request the DMA channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">filter_data</span></code></dt>
<dd>Data passed to the DMA filter function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, a negative error code otherwise.</p>
<p>This function will request a DMA channel using the passed filter function and
data. The function should usually be called from the pcm open callback. Note
that this function will use private_data field of the substream’s runtime. So
it is not available to your pcm driver implementation.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_close">
int <code class="descname">snd_dmaengine_pcm_close</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a dmaengine based PCM substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_close_release_chan">
int <code class="descname">snd_dmaengine_pcm_close_release_chan</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_close_release_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a dmaengine based PCM substream and release channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the DMA channel associated with the PCM substream.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_refine_runtime_hwparams">
int <code class="descname">snd_dmaengine_pcm_refine_runtime_hwparams</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct <a class="reference internal" href="#c.snd_dmaengine_dai_dma_data" title="snd_dmaengine_dai_dma_data">snd_dmaengine_dai_dma_data</a> *<em>&nbsp;dma_data</em>, struct snd_pcm_hardware *<em>&nbsp;hw</em>, struct dma_chan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_refine_runtime_hwparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine runtime hw params</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dmaengine_dai_dma_data</span> <span class="pre">*</span> <span class="pre">dma_data</span></code></dt>
<dd>DAI DMA data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*</span> <span class="pre">hw</span></code></dt>
<dd>PCM hw params</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_chan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>DMA channel to use for data transfers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, a negative error code otherwise.</p>
<p>This function will query DMA capability, then refine the pcm hardware
parameters.</p>
<dl class="function">
<dt id="c.snd_pcm_substream_to_dma_direction">
enum dma_transfer_direction <code class="descname">snd_pcm_substream_to_dma_direction</code><span class="sig-paren">(</span>const struct snd_pcm_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_substream_to_dma_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dma_transfer_direction for a PCM substream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
</dl>
<dl class="type">
<dt id="c.snd_dmaengine_dai_dma_data">
struct <code class="descname">snd_dmaengine_dai_dma_data</code><a class="headerlink" href="#c.snd_dmaengine_dai_dma_data" title="Permalink to this definition">¶</a></dt>
<dd><p>DAI DMA configuration data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_dmaengine_dai_dma_data {
  dma_addr_t addr;
  enum dma_slave_buswidth addr_width;
  u32 maxburst;
  unsigned int slave_id;
  void *filter_data;
  const char *chan_name;
  unsigned int fifo_size;
  unsigned int flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>Address of the DAI data source or destination register.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_width</span></code></dt>
<dd>Width of the DAI data source or destination register.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxburst</span></code></dt>
<dd>Maximum number of words(note: words, as in units of the
src_addr_width member, not bytes) that can be send to or received from the
DAI in one burst.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave_id</span></code></dt>
<dd>Slave requester id for the DMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filter_data</span></code></dt>
<dd>Custom DMA channel filter data, this will usually be used when
requesting the DMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chan_name</span></code></dt>
<dd>Custom channel name to use when requesting DMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fifo_size</span></code></dt>
<dd>FIFO size of the DAI controller in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>PCM_DAI flags, only SND_DMAENGINE_PCM_DAI_FLAG_PACK for now</dd>
</dl>
<dl class="type">
<dt id="c.snd_dmaengine_pcm_config">
struct <code class="descname">snd_dmaengine_pcm_config</code><a class="headerlink" href="#c.snd_dmaengine_pcm_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration data for dmaengine based PCM</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_dmaengine_pcm_config {
  int (*prepare_slave_config)(struct snd_pcm_substream *substream,struct snd_pcm_hw_params *params, struct dma_slave_config *slave_config);
  struct dma_chan *(*compat_request_channel)(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_substream *substream);
  int (*process)(struct snd_pcm_substream *substream,int channel, unsigned long hwoff, void *buf, unsigned long bytes);
  dma_filter_fn compat_filter_fn;
  struct device *dma_dev;
  const char *chan_names[SNDRV_PCM_STREAM_LAST + 1];
  const struct snd_pcm_hardware *pcm_hardware;
  unsigned int prealloc_buffer_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">prepare_slave_config</span></code></dt>
<dd>Callback used to fill in the DMA slave_config for a
PCM substream. Will be called from the PCM drivers hwparams callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_request_channel</span></code></dt>
<dd>Callback to request a DMA channel for platforms
which do not use devicetree.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">process</span></code></dt>
<dd>Callback used to apply processing on samples transferred from/to
user space.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_filter_fn</span></code></dt>
<dd>Will be used as the filter function when requesting a
channel for platforms which do not use devicetree. The filter parameter
will be the DAI’s DMA data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_dev</span></code></dt>
<dd>If set, request DMA channel on this device rather than the DAI
device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chan_names</span></code></dt>
<dd>If set, these custom DMA channel names will be requested at
registration time.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_hardware</span></code></dt>
<dd>snd_pcm_hardware struct to be used for the PCM.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prealloc_buffer_size</span></code></dt>
<dd>Size of the preallocated audio buffer.</dd>
</dl>
<p><strong>Note</strong></p>
<p>If both compat_request_channel and compat_filter_fn are set
compat_request_channel will be used to request the channel and
compat_filter_fn will be ignored. Otherwise the channel will be requested
using dma_request_channel with compat_filter_fn as the filter function.</p>
</div>
</div>
<div class="section" id="control-mixer-api">
<h2>Control/Mixer API<a class="headerlink" href="#control-mixer-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-control-interface">
<h3>General Control Interface<a class="headerlink" href="#general-control-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ctl_notify">
void <code class="descname">snd_ctl_notify</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, unsigned int<em>&nbsp;mask</em>, struct snd_ctl_elem_id *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Send notification to user-space for a control change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card to send notification</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>the event mask, SNDRV_CTL_EVENT_*</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the ctl element id to send notification</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds an event record with the given id and mask, appends
to the list and wakes up the user-space for notification.  This can be
called in the atomic context.</p>
<dl class="function">
<dt id="c.snd_ctl_new">
int <code class="descname">snd_ctl_new</code><span class="sig-paren">(</span>struct snd_kcontrol **<em>&nbsp;kctl</em>, unsigned int<em>&nbsp;count</em>, unsigned int<em>&nbsp;access</em>, struct snd_ctl_file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new control instance with some elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">**</span> <span class="pre">kctl</span></code></dt>
<dd>the pointer to store new control instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of elements in this control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">access</span></code></dt>
<dd>the default access flags for elements in this control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>given when locking these elements</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a memory object for a new control instance. The instance has
elements as many as the given number (<strong>count</strong>). Each element has given
access permissions (<strong>access</strong>). Each element is locked when <strong>file</strong> is given.</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure</p>
<dl class="function">
<dt id="c.snd_ctl_new1">
struct snd_kcontrol * <code class="descname">snd_ctl_new1</code><span class="sig-paren">(</span>const struct snd_kcontrol_new *<em>&nbsp;ncontrol</em>, void *<em>&nbsp;private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_new1" title="Permalink to this definition">¶</a></dt>
<dd><p>create a control instance from the template</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">ncontrol</span></code></dt>
<dd>the initialization record</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>the private data to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a new struct snd_kcontrol instance and initialize from the given
template.  When the access field of ncontrol is 0, it’s assumed as
READWRITE access. When the count field is 0, it’s assumes as one.</p>
<p><strong>Return</strong></p>
<p>The pointer of the newly generated instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_free_one">
void <code class="descname">snd_ctl_free_one</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_free_one" title="Permalink to this definition">¶</a></dt>
<dd><p>release the control instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the control instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the control instance created via <a class="reference internal" href="#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a>
or <a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a>.
Don’t call this after the control was added to the card.</p>
<dl class="function">
<dt id="c.snd_ctl_add">
int <code class="descname">snd_ctl_add</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the control instance to the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the control instance to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the control instance created via <a class="reference internal" href="#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a> or
<a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> to the given card. Assigns also an unique
numid used for fast search.</p>
<p>It frees automatically the control which cannot be added.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_replace">
int <code class="descname">snd_ctl_replace</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_kcontrol *<em>&nbsp;kcontrol</em>, bool<em>&nbsp;add_on_replace</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the control instance of the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the control instance to replace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">add_on_replace</span></code></dt>
<dd>add the control if not already added</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the given control.  If the given control does not exist
and the add_on_replace flag is set, the control is added.  If the
control exists, it is destroyed first.</p>
<p>It frees automatically the control which cannot be added or replaced.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_remove">
int <code class="descname">snd_ctl_remove</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control from the card and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the control instance to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the control from the card and then releases the instance.
You don’t need to call <a class="reference internal" href="#c.snd_ctl_free_one" title="snd_ctl_free_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_free_one()</span></code></a>. You must be in
the write lock - down_write(<code class="xref c c-type docutils literal notranslate"><span class="pre">card-&gt;controls_rwsem</span></code>).</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_remove_id">
int <code class="descname">snd_ctl_remove_id</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_ctl_elem_id *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove_id" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control of the given id and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the control id to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, removes it from the
card list and releases it.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_remove_user_ctl">
int <code class="descname">snd_ctl_remove_user_ctl</code><span class="sig-paren">(</span>struct snd_ctl_file *<em>&nbsp;file</em>, struct snd_ctl_elem_id *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove_user_ctl" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and release the unlocked user control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>active control handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the control id to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, removes it from the
card list and releases it.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_activate_id">
int <code class="descname">snd_ctl_activate_id</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_ctl_elem_id *<em>&nbsp;id</em>, int<em>&nbsp;active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_activate_id" title="Permalink to this definition">¶</a></dt>
<dd><p>activate/inactivate the control of the given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the control id to activate/inactivate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">active</span></code></dt>
<dd>non-zero to activate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, and activate or
inactivate the control together with notification, if changed.
The given ID data is filled with full information.</p>
<p><strong>Return</strong></p>
<p>0 if unchanged, 1 if changed, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_rename_id">
int <code class="descname">snd_ctl_rename_id</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_ctl_elem_id *<em>&nbsp;src_id</em>, struct snd_ctl_elem_id *<em>&nbsp;dst_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_rename_id" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the id of a control on the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">src_id</span></code></dt>
<dd>the old id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">dst_id</span></code></dt>
<dd>the new id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control with the old id from the card, and replaces the
id with the new one.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ctl_find_numid">
struct snd_kcontrol * <code class="descname">snd_ctl_find_numid</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, unsigned int<em>&nbsp;numid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_numid" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given number-id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">numid</span></code></dt>
<dd>the number-id to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given number-id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
<dl class="function">
<dt id="c.snd_ctl_find_id">
struct snd_kcontrol * <code class="descname">snd_ctl_find_id</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, struct snd_ctl_elem_id *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the id to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl">
int <code class="descname">snd_ctl_register_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em>&nbsp;fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt>
<dd>ioctl callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>called from each device manager like pcm.c, hwdep.c, etc.</p>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl_compat">
int <code class="descname">snd_ctl_register_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em>&nbsp;fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific 32bit compat control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt>
<dd>ioctl callback function</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl">
int <code class="descname">snd_ctl_unregister_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em>&nbsp;fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt>
<dd>ioctl callback function to unregister</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl_compat">
int <code class="descname">snd_ctl_unregister_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em>&nbsp;fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific compat 32bit control-ioctls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt>
<dd>ioctl callback function to unregister</dd>
</dl>
<dl class="function">
<dt id="c.snd_ctl_boolean_mono_info">
int <code class="descname">snd_ctl_boolean_mono_info</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_mono_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with a mono channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the kcontrol instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>info to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with a single mono channel.</p>
<dl class="function">
<dt id="c.snd_ctl_boolean_stereo_info">
int <code class="descname">snd_ctl_boolean_stereo_info</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_stereo_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with stereo two channels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>the kcontrol instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>info to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with stereo two channels.</p>
<dl class="function">
<dt id="c.snd_ctl_enum_info">
int <code class="descname">snd_ctl_enum_info</code><span class="sig-paren">(</span>struct snd_ctl_elem_info *<em>&nbsp;info</em>, unsigned int<em>&nbsp;channels</em>, unsigned int<em>&nbsp;items</em>, const char *const<em>&nbsp;names</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_enum_info" title="Permalink to this definition">¶</a></dt>
<dd><p>fills the info structure for an enumerated control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>the structure to be filled</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">channels</span></code></dt>
<dd>the number of the control’s channels; often one</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">items</span></code></dt>
<dd>the number of control values; also the size of <strong>names</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">names</span></code></dt>
<dd>an array containing the names of all control values</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets all required fields in <strong>info</strong> to their appropriate values.
If the control’s accessibility is not the default (readable and writable),
the caller has to fill <strong>info-&gt;access</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
</div>
<div class="section" id="ac97-codec-api">
<h3>AC97 Codec API<a class="headerlink" href="#ac97-codec-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ac97_write">
void <code class="descname">snd_ac97_write</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, unsigned short<em>&nbsp;reg</em>, unsigned short<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a value on the given register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt>
<dd>the register to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt>
<dd>the value to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a value on the given register.  This will invoke the write
callback directly after the register check.
This function doesn’t change the register cache unlike
#snd_ca97_write_cache(), so use this only when you don’t want to
reflect the change to the suspend/resume state.</p>
<dl class="function">
<dt id="c.snd_ac97_read">
unsigned short <code class="descname">snd_ac97_read</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, unsigned short<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a value from the given register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt>
<dd>the register to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a value from the given register.  This will invoke the read
callback directly after the register check.</p>
<p><strong>Return</strong></p>
<p>The read value.</p>
<dl class="function">
<dt id="c.snd_ac97_write_cache">
void <code class="descname">snd_ac97_write_cache</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, unsigned short<em>&nbsp;reg</em>, unsigned short<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>write a value on the given register and update the cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt>
<dd>the register to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt>
<dd>the value to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a value on the given register and updates the register
cache.  The cached values are used for the cached-read and the
suspend/resume.</p>
<dl class="function">
<dt id="c.snd_ac97_update">
int <code class="descname">snd_ac97_update</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, unsigned short<em>&nbsp;reg</em>, unsigned short<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the value on the given register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt>
<dd>the register to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt>
<dd>the value to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compares the value with the register cache and updates the value
only when the value is changed.</p>
<p><strong>Return</strong></p>
<p>1 if the value is changed, 0 if no change, or a negative
code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_update_bits">
int <code class="descname">snd_ac97_update_bits</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, unsigned short<em>&nbsp;reg</em>, unsigned short<em>&nbsp;mask</em>, unsigned short<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>update the bits on the given register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt>
<dd>the register to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mask</span></code></dt>
<dd>the bit-mask to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt>
<dd>the value to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the masked-bits on the given register only when the value
is changed.</p>
<p><strong>Return</strong></p>
<p>1 if the bits are changed, 0 if no change, or a negative
code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_get_short_name">
const char * <code class="descname">snd_ac97_get_short_name</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_get_short_name" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve codec name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the codec instance</dd>
</dl>
<p><strong>Return</strong></p>
<p>The short identifying name of the codec.</p>
<dl class="function">
<dt id="c.snd_ac97_bus">
int <code class="descname">snd_ac97_bus</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, int<em>&nbsp;num</em>, const struct snd_ac97_bus_ops *<em>&nbsp;ops</em>, void *<em>&nbsp;private_data</em>, struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a> **<em>&nbsp;rbus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>create an AC97 bus component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>the bus number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ac97_bus_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the bus callbacks table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>private data pointer for the new instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">**</span> <span class="pre">rbus</span></code></dt>
<dd>the pointer to store the new AC97 bus instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an AC97 bus component.  An struct snd_ac97_bus instance is newly
allocated and initialized.</p>
<p>The ops table must include valid callbacks (at least read and
write).  The other callbacks, wait and reset, are not mandatory.</p>
<p>The clock is set to 48000.  If another clock is needed, set
<code class="docutils literal notranslate"><span class="pre">(*rbus)-&gt;clock</span></code> manually.</p>
<p>The AC97 bus instance is registered as a low-level device, so you don’t
have to release it manually.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_mixer">
int <code class="descname">snd_ac97_mixer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a> *<em>&nbsp;bus</em>, struct snd_ac97_template *<em>&nbsp;template</em>, struct snd_ac97 **<em>&nbsp;rac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>create an Codec97 component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the AC97 bus which codec is attached to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_template</span> <span class="pre">*</span> <span class="pre">template</span></code></dt>
<dd>the template of ac97, including index, callbacks and
the private data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">**</span> <span class="pre">rac97</span></code></dt>
<dd>the pointer to store the new ac97 instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an Codec97 component.  An struct snd_ac97 instance is newly
allocated and initialized from the template.  The codec
is then initialized by the standard procedure.</p>
<p>The template must include the codec number (num) and address (addr),
and the private data (private_data).</p>
<p>The ac97 instance is registered as a low-level device, so you don’t
have to release it manually.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_update_power">
int <code class="descname">snd_ac97_update_power</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, int<em>&nbsp;reg</em>, int<em>&nbsp;powerup</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update_power" title="Permalink to this definition">¶</a></dt>
<dd><p>update the powerdown register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the codec instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>the rate register, e.g. AC97_PCM_FRONT_DAC_RATE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">powerup</span></code></dt>
<dd>non-zero when power up the part</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the AC97 powerdown register bits of the given part.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
<dl class="function">
<dt id="c.snd_ac97_suspend">
void <code class="descname">snd_ac97_suspend</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>General suspend function for AC97 codec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Suspends the codec, power down the chip.</p>
<dl class="function">
<dt id="c.snd_ac97_resume">
void <code class="descname">snd_ac97_resume</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>General resume function for AC97 codec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do the standard resume procedure, power up and restoring the
old register values.</p>
<dl class="function">
<dt id="c.snd_ac97_tune_hardware">
int <code class="descname">snd_ac97_tune_hardware</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, const struct ac97_quirk *<em>&nbsp;quirk</em>, const char *<em>&nbsp;override</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_tune_hardware" title="Permalink to this definition">¶</a></dt>
<dd><p>tune up the hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ac97_quirk</span> <span class="pre">*</span> <span class="pre">quirk</span></code></dt>
<dd>quirk list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">override</span></code></dt>
<dd>explicit quirk value (overrides the list if non-NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do some workaround for each pci device, such as renaming of the
headphone (true line-out) control as “Master”.
The quirk-list must be terminated with a zero-filled entry.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_set_rate">
int <code class="descname">snd_ac97_set_rate</code><span class="sig-paren">(</span>struct snd_ac97 *<em>&nbsp;ac97</em>, int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>change the rate of the given input/output.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*</span> <span class="pre">ac97</span></code></dt>
<dd>the ac97 instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>the register to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt>
<dd>the sample rate to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changes the rate of the given input/output on the codec.
If the codec doesn’t support VAR, the rate must be 48000 (except
for SPDIF).</p>
<p>The valid registers are AC97_PMC_MIC_ADC_RATE,
AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.
AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted
if the codec supports them.
AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
status bits.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_pcm_assign">
int <code class="descname">snd_ac97_pcm_assign</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a> *<em>&nbsp;bus</em>, unsigned short<em>&nbsp;pcms_count</em>, const struct ac97_pcm *<em>&nbsp;pcms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>assign AC97 slots to given PCM streams</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the ac97 bus instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">pcms_count</span></code></dt>
<dd>count of PCMs to be assigned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*</span> <span class="pre">pcms</span></code></dt>
<dd>PCMs to be assigned</dd>
</dl>
<p><strong>Description</strong></p>
<p>It assigns available AC97 slots for given PCMs. If none or only
some slots are available, pcm-&gt;xxx.slots and pcm-&gt;xxx.rslots[] members
are reduced and might be zero.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_pcm_open">
int <code class="descname">snd_ac97_pcm_open</code><span class="sig-paren">(</span>struct ac97_pcm *<em>&nbsp;pcm</em>, unsigned int<em>&nbsp;rate</em>, enum ac97_pcm_cfg<em>&nbsp;cfg</em>, unsigned short<em>&nbsp;slots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_open" title="Permalink to this definition">¶</a></dt>
<dd><p>opens the given AC97 pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the ac97 pcm instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt>
<dd>rate in Hz, if codec does not support VRA, this value must be 48000Hz</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ac97_pcm_cfg</span> <span class="pre">cfg</span></code></dt>
<dd>output stream characteristics</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">slots</span></code></dt>
<dd>a subset of allocated slots (snd_ac97_pcm_assign) for this pcm</dd>
</dl>
<p><strong>Description</strong></p>
<p>It locks the specified slots and sets the given rate to AC97 registers.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_ac97_pcm_close">
int <code class="descname">snd_ac97_pcm_close</code><span class="sig-paren">(</span>struct ac97_pcm *<em>&nbsp;pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_close" title="Permalink to this definition">¶</a></dt>
<dd><p>closes the given AC97 pcm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*</span> <span class="pre">pcm</span></code></dt>
<dd>the ac97 pcm instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>It frees the locked AC97 slots.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
<dl class="function">
<dt id="c.snd_ac97_pcm_double_rate_rules">
int <code class="descname">snd_ac97_pcm_double_rate_rules</code><span class="sig-paren">(</span>struct snd_pcm_runtime *<em>&nbsp;runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_double_rate_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>set double rate constraints</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*</span> <span class="pre">runtime</span></code></dt>
<dd>the runtime of the ac97 front playback pcm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the hardware constraint rules to prevent using double rates and
more than two channels at the same time.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<div class="section" id="virtual-master-control-api">
<h3>Virtual Master Control API<a class="headerlink" href="#virtual-master-control-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ctl_make_virtual_master">
struct snd_kcontrol * <code class="descname">snd_ctl_make_virtual_master</code><span class="sig-paren">(</span>char *<em>&nbsp;name</em>, const unsigned int *<em>&nbsp;tlv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_make_virtual_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a virtual master control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name string of the control element to create</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">tlv</span></code></dt>
<dd>optional TLV int array for dB information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a virtual master control with the given name string.</p>
<p>After creating a vmaster element, you can add the follower controls
via <a class="reference internal" href="#c.snd_ctl_add_follower" title="snd_ctl_add_follower"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower()</span></code></a> or <a class="reference internal" href="#c.snd_ctl_add_follower_uncached" title="snd_ctl_add_follower_uncached"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower_uncached()</span></code></a>.</p>
<p>The optional argument <strong>tlv</strong> can be used to specify the TLV information
for dB scale of the master control.  It should be a single element
with #SNDRV_CTL_TLVT_DB_SCALE, #SNDRV_CTL_TLV_DB_MINMAX or
#SNDRV_CTL_TLVT_DB_MINMAX_MUTE type, and should be the max 0dB.</p>
<p><strong>Return</strong></p>
<p>The created control element, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for errors (ENOMEM).</p>
<dl class="function">
<dt id="c.snd_ctl_add_vmaster_hook">
int <code class="descname">snd_ctl_add_vmaster_hook</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, void (<em>*hook</em>)(void *private_data, int), void *<em>&nbsp;private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_vmaster_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hook to a vmaster control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>vmaster kctl element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*private_data,</span> <span class="pre">int)</span> <span class="pre">hook</span></code></dt>
<dd>the hook function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>the private_data pointer to be saved</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the given hook to the vmaster control element so that it’s called
at each time when the value is changed.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
<dl class="function">
<dt id="c.snd_ctl_sync_vmaster">
void <code class="descname">snd_ctl_sync_vmaster</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, bool<em>&nbsp;hook_only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_sync_vmaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Sync the vmaster followers and hook</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>vmaster kctl element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hook_only</span></code></dt>
<dd>sync only the hook</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forcibly call the put callback of each follower and call the hook function
to synchronize with the current value of the given vmaster element.
NOP when NULL is passed to <strong>kcontrol</strong>.</p>
<dl class="function">
<dt id="c.snd_ctl_apply_vmaster_followers">
int <code class="descname">snd_ctl_apply_vmaster_followers</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kctl</em>, int (<em>*func</em>)(struct snd_kcontrol *vfollower, struct snd_kcontrol *follower, void *arg), void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_apply_vmaster_followers" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply function to each vmaster follower</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kctl</span></code></dt>
<dd>vmaster kctl element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*vfollower,</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*follower,</span> <span class="pre">void</span> <span class="pre">*arg)</span> <span class="pre">func</span></code></dt>
<dd>function to apply</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>optional function argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the function <strong>func</strong> to each follower kctl of the given vmaster kctl.
Returns 0 if successful, or a negative error code.</p>
<dl class="function">
<dt id="c.snd_ctl_add_follower">
int <code class="descname">snd_ctl_add_follower</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;master</em>, struct snd_kcontrol *<em>&nbsp;follower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_follower" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a virtual follower control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd>vmaster element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">follower</span></code></dt>
<dd>follower element to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a virtual follower control to the given master element created via
snd_ctl_create_virtual_master() beforehand.</p>
<p>All followers must be the same type (returning the same information
via info callback).  The function doesn’t check it, so it’s your
responsibility.</p>
<p>Also, some additional limitations:
at most two channels,
logarithmic volume control (dB level) thus no linear volume,
master can only attenuate the volume without gain</p>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
<dl class="function">
<dt id="c.snd_ctl_add_follower_uncached">
int <code class="descname">snd_ctl_add_follower_uncached</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;master</em>, struct snd_kcontrol *<em>&nbsp;follower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_follower_uncached" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a virtual follower control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd>vmaster element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">follower</span></code></dt>
<dd>follower element to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a virtual follower control to the given master.
Unlike <a class="reference internal" href="#c.snd_ctl_add_follower" title="snd_ctl_add_follower"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower()</span></code></a>, the element added via this function
is supposed to have volatile values, and get callback is called
at each time queried from the master.</p>
<p>When the control peeks the hardware values directly and the value
can be changed by other means than the put callback of the element,
this function should be used to keep the value always up-to-date.</p>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
</div>
</div>
<div class="section" id="midi-api">
<h2>MIDI API<a class="headerlink" href="#midi-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="raw-midi-api">
<h3>Raw MIDI API<a class="headerlink" href="#raw-midi-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_rawmidi_receive">
int <code class="descname">snd_rawmidi_receive</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, const unsigned char *<em>&nbsp;buffer</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_receive" title="Permalink to this definition">¶</a></dt>
<dd><p>receive the input data from the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the buffer pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the data size to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the data from the internal buffer.</p>
<p><strong>Return</strong></p>
<p>The size of read data, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_empty">
int <code class="descname">snd_rawmidi_transmit_empty</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the output buffer is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the internal output buffer is empty, 0 if not.</p>
<dl class="function">
<dt id="c.__snd_rawmidi_transmit_peek">
int <code class="descname">__snd_rawmidi_transmit_peek</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, unsigned char *<em>&nbsp;buffer</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__snd_rawmidi_transmit_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the internal buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the buffer pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>data size to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.snd_rawmidi_transmit_peek" title="snd_rawmidi_transmit_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_peek()</span></code></a> without spinlock.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_peek">
int <code class="descname">snd_rawmidi_transmit_peek</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, unsigned char *<em>&nbsp;buffer</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the internal buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the buffer pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>data size to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the internal output buffer to the given buffer.</p>
<p>Call this in the interrupt handler when the midi output is ready,
and call <a class="reference internal" href="#c.snd_rawmidi_transmit_ack" title="snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_ack()</span></code></a> after the transmission is
finished.</p>
<p><strong>Return</strong></p>
<p>The size of copied data, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.__snd_rawmidi_transmit_ack">
int <code class="descname">__snd_rawmidi_transmit_ack</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__snd_rawmidi_transmit_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>acknowledge the transmission</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the transferred count</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.__snd_rawmidi_transmit_ack" title="__snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">__snd_rawmidi_transmit_ack()</span></code></a> without spinlock.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_ack">
int <code class="descname">snd_rawmidi_transmit_ack</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>acknowledge the transmission</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the transferred count</dd>
</dl>
<p><strong>Description</strong></p>
<p>Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.</p>
<p><strong>Return</strong></p>
<p>The advanced size if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_transmit">
int <code class="descname">snd_rawmidi_transmit</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em>, unsigned char *<em>&nbsp;buffer</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit" title="Permalink to this definition">¶</a></dt>
<dd><p>copy from the buffer to the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the rawmidi substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the buffer pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the data size to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the buffer to the device and advances the pointer.</p>
<p><strong>Return</strong></p>
<p>The copied size if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_proceed">
int <code class="descname">snd_rawmidi_proceed</code><span class="sig-paren">(</span>struct snd_rawmidi_substream *<em>&nbsp;substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_proceed" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard the all pending bytes and proceed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>rawmidi substream</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of discarded bytes</p>
<dl class="function">
<dt id="c.snd_rawmidi_new">
int <code class="descname">snd_rawmidi_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, char *<em>&nbsp;id</em>, int<em>&nbsp;device</em>, int<em>&nbsp;output_count</em>, int<em>&nbsp;input_count</em>, struct snd_rawmidi **<em>&nbsp;rrawmidi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a rawmidi instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the id string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>the device index</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">output_count</span></code></dt>
<dd>the number of output streams</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">input_count</span></code></dt>
<dd>the number of input streams</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">**</span> <span class="pre">rrawmidi</span></code></dt>
<dd>the pointer to store the new rawmidi instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rawmidi instance.
Use <a class="reference internal" href="#c.snd_rawmidi_set_ops" title="snd_rawmidi_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_set_ops()</span></code></a> to set the operators to the new instance.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_rawmidi_set_ops">
void <code class="descname">snd_rawmidi_set_ops</code><span class="sig-paren">(</span>struct snd_rawmidi *<em>&nbsp;rmidi</em>, int<em>&nbsp;stream</em>, const struct snd_rawmidi_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the rawmidi operators</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">*</span> <span class="pre">rmidi</span></code></dt>
<dd>the rawmidi instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>the stream direction, SNDRV_RAWMIDI_STREAM_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_rawmidi_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the operator table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the rawmidi operators for the given stream direction.</p>
</div>
<div class="section" id="mpu401-uart-api">
<h3>MPU401-UART API<a class="headerlink" href="#mpu401-uart-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_mpu401_uart_interrupt">
irqreturn_t <code class="descname">snd_mpu401_uart_interrupt</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>generic MPU401-UART interrupt handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>the irq number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>mpu401 instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the interrupt for MPU401-UART i/o.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IRQ_HANDLED</span></code> if the interrupt was handled. <code class="docutils literal notranslate"><span class="pre">IRQ_NONE</span></code> otherwise.</p>
<dl class="function">
<dt id="c.snd_mpu401_uart_interrupt_tx">
irqreturn_t <code class="descname">snd_mpu401_uart_interrupt_tx</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_interrupt_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>generic MPU401-UART transmit irq handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>the irq number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>mpu401 instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the interrupt for MPU401-UART output.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IRQ_HANDLED</span></code> if the interrupt was handled. <code class="docutils literal notranslate"><span class="pre">IRQ_NONE</span></code> otherwise.</p>
<dl class="function">
<dt id="c.snd_mpu401_uart_new">
int <code class="descname">snd_mpu401_uart_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, int<em>&nbsp;device</em>, unsigned short<em>&nbsp;hardware</em>, unsigned long<em>&nbsp;port</em>, unsigned int<em>&nbsp;info_flags</em>, int<em>&nbsp;irq</em>, struct snd_rawmidi **<em>&nbsp;rrawmidi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create an MPU401-UART instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>the device index, zero-based</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">hardware</span></code></dt>
<dd>the hardware type, MPU401_HW_XXXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">port</span></code></dt>
<dd>the base address of MPU401 port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">info_flags</span></code></dt>
<dd>bitflags MPU401_INFO_XXX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>the ISA irq number, -1 if not to be allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">**</span> <span class="pre">rrawmidi</span></code></dt>
<dd>the pointer to store the new rawmidi instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new MPU-401 instance.</p>
<p>Note that the rawmidi instance is returned on the rrawmidi argument,
not the mpu401 instance itself.  To access to the mpu401 instance,
cast from rawmidi-&gt;private_data (with struct snd_mpu401 magic-cast).</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
</div>
<div class="section" id="proc-info-api">
<h2>Proc Info API<a class="headerlink" href="#proc-info-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proc-info-interface">
<h3>Proc Info Interface<a class="headerlink" href="#proc-info-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_info_get_line">
int <code class="descname">snd_info_get_line</code><span class="sig-paren">(</span>struct snd_info_buffer *<em>&nbsp;buffer</em>, char *<em>&nbsp;line</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>read one line from the procfs buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the procfs buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">line</span></code></dt>
<dd>the buffer to store</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the max. buffer size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads one line from the buffer and stores the string.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or 1 if error or EOF.</p>
<dl class="function">
<dt id="c.snd_info_get_str">
const char * <code class="descname">snd_info_get_str</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_str" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string token</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>the buffer to store the string token</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>the original string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the max. length of token - 1</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the original string and copy a token to the given
string buffer.</p>
<p><strong>Return</strong></p>
<p>The updated pointer of the original string so that
it can be used for the next call.</p>
<dl class="function">
<dt id="c.snd_info_create_module_entry">
struct snd_info_entry * <code class="descname">snd_info_create_module_entry</code><span class="sig-paren">(</span>struct module *<em>&nbsp;module</em>, const char *<em>&nbsp;name</em>, struct snd_info_entry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_module_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>the module pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the file name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent directory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given module.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_info_create_card_entry">
struct snd_info_entry * <code class="descname">snd_info_create_card_entry</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;name</em>, struct snd_info_entry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_card_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the file name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent directory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given card.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.snd_info_free_entry">
void <code class="descname">snd_info_free_entry</code><span class="sig-paren">(</span>struct snd_info_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_free_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>release the info entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the info entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the info entry.</p>
<dl class="function">
<dt id="c.snd_info_register">
int <code class="descname">snd_info_register</code><span class="sig-paren">(</span>struct snd_info_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the info entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the info entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the proc info entry.
The all children entries are registered recursively.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_card_rw_proc_new">
int <code class="descname">snd_card_rw_proc_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;name</em>, void *<em>&nbsp;private_data</em>, void (<em>*read</em>)(struct snd_info_entry *, struct snd_info_buffer *), void (*<a class="reference internal" href="../../userspace-api/media/dvb/video-fwrite.html#c.write" title="write">write</a>) (struct snd_info_entry *entry, struct snd_info_buffer *buffer)<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_rw_proc_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read/write text proc file entry for the card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the file name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>the arbitrary private data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*)</span> <span class="pre">read</span></code></dt>
<dd>the read callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*entry,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*buffer)</span> <span class="pre">write</span></code></dt>
<dd>the write callback, NULL for read-only</dd>
</dl>
<p><strong>Description</strong></p>
<p>This proc file entry will be registered via <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> call, and
it will be removed automatically at the card removal, too.</p>
</div>
</div>
<div class="section" id="compress-offload">
<h2>Compress Offload<a class="headerlink" href="#compress-offload" title="Permalink to this headline">¶</a></h2>
<div class="section" id="compress-offload-api">
<h3>Compress Offload API<a class="headerlink" href="#compress-offload-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_compress_register">
int <code class="descname">snd_compress_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_compr" title="snd_compr">snd_compr</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compress_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register compressed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>compressed device to register</dd>
</dl>
<dl class="type">
<dt id="c.snd_compressed_buffer">
struct <code class="descname">snd_compressed_buffer</code><a class="headerlink" href="#c.snd_compressed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compressed_buffer {
  __u32 fragment_size;
  __u32 fragments;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fragment_size</span></code></dt>
<dd>size of buffer fragment in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragments</span></code></dt>
<dd>number of such fragments</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_params">
struct <code class="descname">snd_compr_params</code><a class="headerlink" href="#c.snd_compr_params" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed stream params</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_params {
  struct snd_compressed_buffer buffer;
  struct snd_codec codec;
  __u8 no_wake_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt>
<dd>buffer description</dd>
<dt><code class="docutils literal notranslate"><span class="pre">codec</span></code></dt>
<dd>codec parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_wake_mode</span></code></dt>
<dd>dont wake on fragment elapsed</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_tstamp">
struct <code class="descname">snd_compr_tstamp</code><a class="headerlink" href="#c.snd_compr_tstamp" title="Permalink to this definition">¶</a></dt>
<dd><p>timestamp descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_tstamp {
  __u32 byte_offset;
  __u32 copied_total;
  __u32 pcm_frames;
  __u32 pcm_io_frames;
  __u32 sampling_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">byte_offset</span></code></dt>
<dd>Byte offset in ring buffer to DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied_total</span></code></dt>
<dd>Total number of bytes copied from/to ring buffer to/by DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_frames</span></code></dt>
<dd>Frames decoded or encoded by DSP. This field will evolve by
large steps and should only be used to monitor encoding/decoding
progress. It shall not be used for timing estimates.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_io_frames</span></code></dt>
<dd>Frames rendered or received by DSP into a mixer or an audio
output/input. This field should be used for A/V sync or time estimates.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code></dt>
<dd>sampling rate of audio</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_avail">
struct <code class="descname">snd_compr_avail</code><a class="headerlink" href="#c.snd_compr_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>avail descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_avail {
  __u64 avail;
  struct snd_compr_tstamp tstamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">avail</span></code></dt>
<dd>Number of bytes available in ring buffer for writing/reading</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstamp</span></code></dt>
<dd>timestamp information</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_caps">
struct <code class="descname">snd_compr_caps</code><a class="headerlink" href="#c.snd_compr_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>caps descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_caps {
  __u32 num_codecs;
  __u32 direction;
  __u32 min_fragment_size;
  __u32 max_fragment_size;
  __u32 min_fragments;
  __u32 max_fragments;
  __u32 codecs[MAX_NUM_CODECS];
  __u32 reserved[11];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">num_codecs</span></code></dt>
<dd>number of codecs supported</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt>
<dd>direction supported. Of type snd_compr_direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_fragment_size</span></code></dt>
<dd>minimum fragment supported by DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fragment_size</span></code></dt>
<dd>maximum fragment supported by DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_fragments</span></code></dt>
<dd>min fragments supported by DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fragments</span></code></dt>
<dd>max fragments supported by DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">codecs</span></code></dt>
<dd>pointer to array of codecs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt>
<dd>reserved field</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_codec_caps">
struct <code class="descname">snd_compr_codec_caps</code><a class="headerlink" href="#c.snd_compr_codec_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>query capability of codec</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_codec_caps {
  __u32 codec;
  __u32 num_descriptors;
  struct snd_codec_desc descriptor[MAX_NUM_CODEC_DESCRIPTORS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">codec</span></code></dt>
<dd>codec for which capability is queried</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_descriptors</span></code></dt>
<dd>number of codec descriptors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptor</span></code></dt>
<dd>array of codec capability descriptor</dd>
</dl>
<dl class="type">
<dt id="c.sndrv_compress_encoder">
enum <code class="descname">sndrv_compress_encoder</code><a class="headerlink" href="#c.sndrv_compress_encoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SNDRV_COMPRESS_ENCODER_PADDING</span></code></dt>
<dd>no of samples appended by the encoder at the
end of the track</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SNDRV_COMPRESS_ENCODER_DELAY</span></code></dt>
<dd>no of samples inserted by the encoder at the
beginning of the track</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_metadata">
struct <code class="descname">snd_compr_metadata</code><a class="headerlink" href="#c.snd_compr_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed stream metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_metadata {
  __u32 key;
  __u32 value[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt>
<dd>key id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt>
<dd>key value</dd>
</dl>
<dl class="function">
<dt id="c.SNDRV_COMPRESS_IOCTL_VERSION">
<code class="descname">SNDRV_COMPRESS_IOCTL_VERSION</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.SNDRV_COMPRESS_IOCTL_VERSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>SNDRV_COMPRESS_GET_CAPS: Query capability of DSP
SNDRV_COMPRESS_GET_CODEC_CAPS: Query capability of a codec
SNDRV_COMPRESS_SET_PARAMS: Set codec and stream parameters</p>
<p><strong>Note</strong></p>
<p>only codec params can be changed runtime and stream params cant be
SNDRV_COMPRESS_GET_PARAMS: Query codec params
SNDRV_COMPRESS_TSTAMP: get the current timestamp value
SNDRV_COMPRESS_AVAIL: get the current buffer avail value.
This also queries the tstamp properties
SNDRV_COMPRESS_PAUSE: Pause the running stream
SNDRV_COMPRESS_RESUME: resume a paused stream
SNDRV_COMPRESS_START: Start a stream
SNDRV_COMPRESS_STOP: stop a running stream, discarding ring buffer content
and the buffers currently with DSP
SNDRV_COMPRESS_DRAIN: Play till end of buffers and stop after that
SNDRV_COMPRESS_IOCTL_VERSION: Query the API version</p>
<dl class="type">
<dt id="c.snd_enc_vorbis">
struct <code class="descname">snd_enc_vorbis</code><a class="headerlink" href="#c.snd_enc_vorbis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_vorbis {
  __s32 quality;
  __u32 managed;
  __u32 max_bit_rate;
  __u32 min_bit_rate;
  __u32 downmix;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">quality</span></code></dt>
<dd>Sets encoding quality to n, between -1 (low) and 10 (high).
In the default mode of operation, the quality level is 3.
Normal quality range is 0 - 10.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">managed</span></code></dt>
<dd>Boolean. Set  bitrate  management  mode. This turns off the
normal VBR encoding, but allows hard or soft bitrate constraints to be
enforced by the encoder. This mode can be slower, and may also be
lower quality. It is primarily useful for streaming.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_bit_rate</span></code></dt>
<dd>Enabled only if managed is TRUE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_bit_rate</span></code></dt>
<dd>Enabled only if managed is TRUE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">downmix</span></code></dt>
<dd>Boolean. Downmix input from stereo to mono (has no effect on
non-stereo streams). Useful for lower-bitrate encoding.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These options were extracted from the OpenMAX IL spec and Gstreamer vorbisenc
properties</p>
<p>For best quality users should specify VBR mode and set quality levels.</p>
<dl class="type">
<dt id="c.snd_enc_real">
struct <code class="descname">snd_enc_real</code><a class="headerlink" href="#c.snd_enc_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_real {
  __u32 quant_bits;
  __u32 start_region;
  __u32 num_regions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">quant_bits</span></code></dt>
<dd>number of coupling quantization bits in the stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_region</span></code></dt>
<dd>coupling start region in the stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt>
<dd>number of regions value</dd>
</dl>
<p><strong>Description</strong></p>
<p>These options were extracted from the OpenMAX IL spec</p>
<dl class="type">
<dt id="c.snd_enc_flac">
struct <code class="descname">snd_enc_flac</code><a class="headerlink" href="#c.snd_enc_flac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_flac {
  __u32 num;
  __u32 gain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt>
<dd>serial number, valid only for OGG formats
needs to be set by application</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gain</span></code></dt>
<dd>Add replay gain tags</dd>
</dl>
<p><strong>Description</strong></p>
<p>These options were extracted from the FLAC online documentation
at <a class="reference external" href="http://flac.sourceforge.net/documentation_tools_flac.html">http://flac.sourceforge.net/documentation_tools_flac.html</a></p>
<p>To make the API simpler, it is assumed that the user will select quality
profiles. Additional options that affect encoding quality and speed can
be added at a later stage if needed.</p>
<p>By default the Subset format is used by encoders.</p>
<p>TAGS such as pictures, etc, cannot be handled by an offloaded encoder and are
not supported in this API.</p>
<dl class="type">
<dt id="c.snd_compr_runtime">
struct <code class="descname">snd_compr_runtime</code><a class="headerlink" href="#c.snd_compr_runtime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_runtime {
  snd_pcm_state_t state;
  struct snd_compr_ops *ops;
  void *buffer;
  u64 buffer_size;
  u32 fragment_size;
  u32 fragments;
  u64 total_bytes_available;
  u64 total_bytes_transferred;
  wait_queue_head_t sleep;
  void *private_data;
  unsigned char *dma_area;
  dma_addr_t dma_addr;
  size_t dma_bytes;
  struct snd_dma_buffer *dma_buffer_p;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>stream state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>pointer to DSP callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt>
<dd>pointer to kernel buffer, valid only when not in mmap mode or
DSP doesn’t implement copy</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code></dt>
<dd>size of the above buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragment_size</span></code></dt>
<dd>size of buffer fragment in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragments</span></code></dt>
<dd>number of such fragments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_bytes_available</span></code></dt>
<dd>cumulative number of bytes made available in
the ring buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_bytes_transferred</span></code></dt>
<dd>cumulative bytes transferred by offload DSP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep</span></code></dt>
<dd>poll sleep</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt>
<dd>driver private data pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_area</span></code></dt>
<dd>virtual buffer address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt>
<dd>physical buffer address (not accessible from main CPU)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code></dt>
<dd>size of DMA area</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_buffer_p</span></code></dt>
<dd>runtime dma buffer pointer</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_stream">
struct <code class="descname">snd_compr_stream</code><a class="headerlink" href="#c.snd_compr_stream" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_stream {
  const char *name;
  struct snd_compr_ops *ops;
  struct snd_compr_runtime *runtime;
  struct snd_compr *device;
  struct delayed_work error_work;
  enum snd_compr_direction direction;
  bool metadata_set;
  bool next_track;
  bool partial_drain;
  void *private_data;
  struct snd_dma_buffer dma_buffer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>pointer to DSP callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">runtime</span></code></dt>
<dd>pointer to runtime structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt>
<dd>device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_work</span></code></dt>
<dd>delayed work used when closing the stream due to an error</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt>
<dd>stream direction, playback/recording</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata_set</span></code></dt>
<dd>metadata set flag, true when set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_track</span></code></dt>
<dd>has userspace signal next track transition, true when set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">partial_drain</span></code></dt>
<dd>undergoing partial_drain for stream, true when set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt>
<dd>pointer to DSP private data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_buffer</span></code></dt>
<dd>allocated buffer if any</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr_ops">
struct <code class="descname">snd_compr_ops</code><a class="headerlink" href="#c.snd_compr_ops" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_ops {
  int (*open)(struct snd_compr_stream *stream);
  int (*free)(struct snd_compr_stream *stream);
  int (*set_params)(struct snd_compr_stream *stream, struct snd_compr_params *params);
  int (*get_params)(struct snd_compr_stream *stream, struct snd_codec *params);
  int (*set_metadata)(struct snd_compr_stream *stream, struct snd_compr_metadata *metadata);
  int (*get_metadata)(struct snd_compr_stream *stream, struct snd_compr_metadata *metadata);
  int (*trigger)(struct snd_compr_stream *stream, int cmd);
  int (*pointer)(struct snd_compr_stream *stream, struct snd_compr_tstamp *tstamp);
  int (*copy)(struct snd_compr_stream *stream, char __user *buf, size_t count);
  int (*mmap)(struct snd_compr_stream *stream, struct vm_area_struct *vma);
  int (*ack)(struct snd_compr_stream *stream, size_t bytes);
  int (*get_caps) (struct snd_compr_stream *stream, struct snd_compr_caps *caps);
  int (*get_codec_caps) (struct snd_compr_stream *stream, struct snd_compr_codec_caps *codec);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt>
<dd>Open the compressed stream
This callback is mandatory and shall keep dsp ready to receive the stream
parameter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt>
<dd>Close the compressed stream, mandatory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_params</span></code></dt>
<dd>Sets the compressed stream parameters, mandatory
This can be called in during stream creation only to set codec params
and the stream properties</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_params</span></code></dt>
<dd>retrieve the codec parameters, mandatory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_metadata</span></code></dt>
<dd>Set the metadata values for a stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_metadata</span></code></dt>
<dd>retrieves the requested metadata values from stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trigger</span></code></dt>
<dd>Trigger operations like start, pause, resume, drain, stop.
This callback is mandatory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pointer</span></code></dt>
<dd>Retrieve current h/w pointer information. Mandatory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copy</span></code></dt>
<dd>Copy the compressed data to/from userspace, Optional
Can’t be implemented if DSP supports mmap</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt>
<dd>DSP mmap method to mmap DSP memory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack</span></code></dt>
<dd>Ack for DSP when data is written to audio buffer, Optional
Not valid if copy is implemented</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_caps</span></code></dt>
<dd>Retrieve DSP capabilities, mandatory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_codec_caps</span></code></dt>
<dd>Retrieve capabilities for a specific codec, mandatory</dd>
</dl>
<dl class="type">
<dt id="c.snd_compr">
struct <code class="descname">snd_compr</code><a class="headerlink" href="#c.snd_compr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr {
  const char *name;
  struct device dev;
  struct snd_compr_ops *ops;
  void *private_data;
  struct snd_card *card;
  unsigned int direction;
  struct mutex lock;
  int device;
#ifdef CONFIG_SND_VERBOSE_PROCFS;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>DSP device name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>associated device instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>pointer to DSP callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt>
<dd>pointer to DSP pvt data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">card</span></code></dt>
<dd>sound card pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt>
<dd>Playback or capture direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>device lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt>
<dd>device id</dd>
</dl>
<dl class="function">
<dt id="c.snd_compr_set_runtime_buffer">
void <code class="descname">snd_compr_set_runtime_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_compr_stream" title="snd_compr_stream">snd_compr_stream</a> *<em>&nbsp;stream</em>, struct snd_dma_buffer *<em>&nbsp;bufp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compr_set_runtime_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Compress runtime buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr_stream</span> <span class="pre">*</span> <span class="pre">stream</span></code></dt>
<dd>compress stream to set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*</span> <span class="pre">bufp</span></code></dt>
<dd>the buffer information, NULL to clear</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the buffer information to runtime buffer when <strong>bufp</strong> is non-NULL.
Otherwise it clears the current buffer information.</p>
</div>
</div>
<div class="section" id="asoc">
<h2>ASoC<a class="headerlink" href="#asoc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="asoc-core-api">
<h3>ASoC Core API<a class="headerlink" href="#asoc-core-api" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.snd_soc_jack_pin">
struct <code class="descname">snd_soc_jack_pin</code><a class="headerlink" href="#c.snd_soc_jack_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a pin to update based on jack detection</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_soc_jack_pin {
  struct list_head list;
  const char *pin;
  int mask;
  bool invert;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>internal list entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pin</span></code></dt>
<dd>name of the pin to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt>
<dd>bits to check for in reported jack status</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invert</span></code></dt>
<dd>if non-zero then pin is enabled when status is not reported</dd>
</dl>
<dl class="type">
<dt id="c.snd_soc_jack_zone">
struct <code class="descname">snd_soc_jack_zone</code><a class="headerlink" href="#c.snd_soc_jack_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes voltage zones of jack detection</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_soc_jack_zone {
  unsigned int min_mv;
  unsigned int max_mv;
  unsigned int jack_type;
  unsigned int debounce_time;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">min_mv</span></code></dt>
<dd>start voltage in mv</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_mv</span></code></dt>
<dd>end voltage in mv</dd>
<dt><code class="docutils literal notranslate"><span class="pre">jack_type</span></code></dt>
<dd>type of jack that is expected for this voltage</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debounce_time</span></code></dt>
<dd>debounce_time for jack, codec driver should wait for this
duration before reading the adc for voltages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>internal list entry</dd>
</dl>
<dl class="type">
<dt id="c.snd_soc_jack_gpio">
struct <code class="descname">snd_soc_jack_gpio</code><a class="headerlink" href="#c.snd_soc_jack_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a gpio pin for jack detection</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_soc_jack_gpio {
  unsigned int gpio;
  unsigned int idx;
  struct device *gpiod_dev;
  const char *name;
  int report;
  int invert;
  int debounce_time;
  bool wake;
  int (*jack_status_check)(void *data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">gpio</span></code></dt>
<dd>legacy gpio number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idx</span></code></dt>
<dd>gpio descriptor index within the function of the GPIO
consumer device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpiod_dev</span></code></dt>
<dd>GPIO consumer device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>gpio name. Also as connection ID for the GPIO consumer
device function name lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">report</span></code></dt>
<dd>value to report when jack detected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invert</span></code></dt>
<dd>report presence in low state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debounce_time</span></code></dt>
<dd>debounce time in ms</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wake</span></code></dt>
<dd>enable as wake source</dd>
<dt><code class="docutils literal notranslate"><span class="pre">jack_status_check</span></code></dt>
<dd>callback function which overrides the detection
to provide more complex checks (eg, reading an
ADC).</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_kcontrol_component">
struct snd_soc_component * <code class="descname">snd_soc_kcontrol_component</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_kcontrol_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the component that registered the control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>The control for which to get the component</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function will work correctly if the control has been registered
for a component. With snd_soc_add_codec_controls() or via table based
setup for either a CODEC or component driver. Otherwise the behavior is
undefined.</p>
<dl class="function">
<dt id="c.snd_soc_find_dai">
struct snd_soc_dai * <code class="descname">snd_soc_find_dai</code><span class="sig-paren">(</span>const struct snd_soc_dai_link_component *<em>&nbsp;dlc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_find_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a registered DAI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dai_link_component</span> <span class="pre">*</span> <span class="pre">dlc</span></code></dt>
<dd>name of the DAI or the DAI driver and optional component info to match</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will search all registered components and their DAIs to
find the DAI of the same name. The component’s of_node and name
should also match if being specified.</p>
<p><strong>Return</strong></p>
<p>pointer of DAI, or NULL if not found.</p>
<dl class="function">
<dt id="c.snd_soc_remove_pcm_runtime">
void <code class="descname">snd_soc_remove_pcm_runtime</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em>, struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_remove_pcm_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a pcm_runtime from card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>The ASoC card to which the pcm_runtime has</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>The pcm_runtime to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a pcm_runtime from the ASoC card.</p>
<dl class="function">
<dt id="c.snd_soc_add_pcm_runtime">
int <code class="descname">snd_soc_add_pcm_runtime</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em>, struct snd_soc_dai_link *<em>&nbsp;dai_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_pcm_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a pcm_runtime dynamically via dai_link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>The ASoC card to which the pcm_runtime is added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_link</span> <span class="pre">*</span> <span class="pre">dai_link</span></code></dt>
<dd>The DAI link to find pcm_runtime</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds a pcm_runtime ASoC card by using dai_link.</p>
<p><strong>Note</strong></p>
<p>Topology can use this API to add pcm_runtime when probing the
topology component. And machine drivers can still define static
DAI links in dai_link array.</p>
<dl class="function">
<dt id="c.snd_soc_runtime_set_dai_fmt">
int <code class="descname">snd_soc_runtime_set_dai_fmt</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em>, unsigned int<em>&nbsp;dai_fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_set_dai_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Change DAI link format for a ASoC runtime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>The runtime for which the DAI link format should be changed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dai_fmt</span></code></dt>
<dd>The new DAI link format</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the DAI link format for all DAIs connected to the DAI
link for the specified runtime.</p>
<p>Returns 0 on success, otherwise a negative error code.</p>
<p><strong>Note</strong></p>
<p>For setups with a static format set the dai_fmt field in the
corresponding snd_dai_link struct instead of using this function.</p>
<dl class="function">
<dt id="c.snd_soc_set_dmi_name">
int <code class="descname">snd_soc_set_dmi_name</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em>, const char *<em>&nbsp;flavour</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_set_dmi_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Register DMI names to card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>The card to register DMI names</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">flavour</span></code></dt>
<dd>The flavour “differentiator” for the card amongst its peers.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An Intel machine driver may be used by many different devices but are
difficult for userspace to differentiate, since machine drivers ususally
use their own name as the card short name and leave the card long name
blank. To differentiate such devices and fix bugs due to lack of
device-specific configurations, this function allows DMI info to be used
as the sound card long name, in the format of
“vendor-product-version-board”
(Character ‘-‘ is used to separate different DMI fields here).
This will help the user space to load the device-specific Use Case Manager
(UCM) configurations for the card.</p>
<p>Possible card long names may be:
DellInc.-XPS139343-01-0310JH
ASUSTeKCOMPUTERINC.-T100TA-1.0-T100TA
Circuitco-MinnowboardMaxD0PLATFORM-D0-MinnowBoardMAX</p>
<p>This function also supports flavoring the card longname to provide
the extra differentiation, like “vendor-product-version-board-flavor”.</p>
<p>We only keep number and alphabet characters and a few separator characters
in the card long name since UCM in the user space uses the card long names
as card configuration directory names and AudoConf cannot support special
charactors like SPACE.</p>
<p>Returns 0 on success, otherwise a negative error code.</p>
<dl class="function">
<dt id="c.snd_soc_cnew">
struct snd_kcontrol * <code class="descname">snd_soc_cnew</code><span class="sig-paren">(</span>const struct snd_kcontrol_new *<em>&nbsp;_template</em>, void *<em>&nbsp;data</em>, const char *<em>&nbsp;long_name</em>, const char *<em>&nbsp;prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_cnew" title="Permalink to this definition">¶</a></dt>
<dd><p>create new control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">_template</span></code></dt>
<dd>control template</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>control private data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">long_name</span></code></dt>
<dd>control long name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt>
<dd>control name prefix</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new mixer control from a template control.</p>
<p>Returns 0 for success, else error.</p>
<dl class="function">
<dt id="c.snd_soc_add_component_controls">
int <code class="descname">snd_soc_add_component_controls</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, const struct snd_kcontrol_new *<em>&nbsp;controls</em>, unsigned int<em>&nbsp;num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_component_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an array of controls to a component.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component to add controls to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">controls</span></code></dt>
<dd>Array of controls to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_controls</span></code></dt>
<dd>Number of elements in the array</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, else error.</p>
<dl class="function">
<dt id="c.snd_soc_add_card_controls">
int <code class="descname">snd_soc_add_card_controls</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;soc_card</em>, const struct snd_kcontrol_new *<em>&nbsp;controls</em>, int<em>&nbsp;num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_card_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>add an array of controls to a SoC card. Convenience function to add a list of controls.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">soc_card</span></code></dt>
<dd>SoC card to add controls to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">controls</span></code></dt>
<dd>array of controls to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_controls</span></code></dt>
<dd>number of elements in the array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
<dl class="function">
<dt id="c.snd_soc_add_dai_controls">
int <code class="descname">snd_soc_add_dai_controls</code><span class="sig-paren">(</span>struct snd_soc_dai *<em>&nbsp;dai</em>, const struct snd_kcontrol_new *<em>&nbsp;controls</em>, int<em>&nbsp;num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_dai_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>add an array of controls to a DAI. Convienience function to add a list of controls.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai</span> <span class="pre">*</span> <span class="pre">dai</span></code></dt>
<dd>DAI to add controls to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*</span> <span class="pre">controls</span></code></dt>
<dd>array of controls to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_controls</span></code></dt>
<dd>number of elements in the array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
<dl class="function">
<dt id="c.snd_soc_register_card">
int <code class="descname">snd_soc_register_card</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_card" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a card with the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>Card to register</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_unregister_card">
int <code class="descname">snd_soc_unregister_card</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_card" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a card with the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>Card to unregister</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_register_dai">
struct snd_soc_dai * <code class="descname">snd_soc_register_dai</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, struct snd_soc_dai_driver *<em>&nbsp;dai_drv</em>, bool<em>&nbsp;legacy_dai_naming</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a DAI dynamically &amp; create its widgets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component the DAIs are registered for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*</span> <span class="pre">dai_drv</span></code></dt>
<dd>DAI driver to use for the DAI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">legacy_dai_naming</span></code></dt>
<dd>if <code class="docutils literal notranslate"><span class="pre">true</span></code>, use legacy single-name format;
if <code class="docutils literal notranslate"><span class="pre">false</span></code>, use multiple-name format;</dd>
</dl>
<p><strong>Description</strong></p>
<p>Topology can use this API to register DAIs when probing a component.
These DAIs’s widgets will be freed in the card cleanup and the DAIs
will be freed in the component cleanup.</p>
<dl class="function">
<dt id="c.snd_soc_unregister_dais">
void <code class="descname">snd_soc_unregister_dais</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_dais" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister DAIs from the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component for which the DAIs should be unregistered</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_register_dais">
int <code class="descname">snd_soc_register_dais</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, struct snd_soc_dai_driver *<em>&nbsp;dai_drv</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_dais" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a DAI with the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component the DAIs are registered for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*</span> <span class="pre">dai_drv</span></code></dt>
<dd>DAI driver to use for the DAIs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Number of DAIs</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_unregister_component_by_driver">
void <code class="descname">snd_soc_unregister_component_by_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct snd_soc_component_driver *<em>&nbsp;component_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_component_by_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister component using a given driver from the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to unregister</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_component_driver</span> <span class="pre">*</span> <span class="pre">component_driver</span></code></dt>
<dd>The component driver to unregister</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_unregister_component">
void <code class="descname">snd_soc_unregister_component</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister all related component from the ASoC core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to unregister</dd>
</dl>
<dl class="function">
<dt id="c.devm_snd_soc_register_dai">
struct snd_soc_dai * <code class="descname">devm_snd_soc_register_dai</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct snd_soc_component *<em>&nbsp;component</em>, struct snd_soc_dai_driver *<em>&nbsp;dai_drv</em>, bool<em>&nbsp;legacy_dai_naming</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>resource-managed dai registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device used to manage component</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component the DAIs are registered for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*</span> <span class="pre">dai_drv</span></code></dt>
<dd>DAI driver to use for the DAI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">legacy_dai_naming</span></code></dt>
<dd>if <code class="docutils literal notranslate"><span class="pre">true</span></code>, use legacy single-name format;
if <code class="docutils literal notranslate"><span class="pre">false</span></code>, use multiple-name format;</dd>
</dl>
<dl class="function">
<dt id="c.devm_snd_soc_register_component">
int <code class="descname">devm_snd_soc_register_component</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct snd_soc_component_driver *<em>&nbsp;cmpnt_drv</em>, struct snd_soc_dai_driver *<em>&nbsp;dai_drv</em>, int<em>&nbsp;num_dai</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_component" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed component registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device used to manage component</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_component_driver</span> <span class="pre">*</span> <span class="pre">cmpnt_drv</span></code></dt>
<dd>Component driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*</span> <span class="pre">dai_drv</span></code></dt>
<dd>DAI driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_dai</span></code></dt>
<dd>Number of DAIs to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a component with automatic unregistration when the device is
unregistered.</p>
<dl class="function">
<dt id="c.devm_snd_soc_register_card">
int <code class="descname">devm_snd_soc_register_card</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct snd_soc_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_card" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed card registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device used to manage card</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>Card to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a card with automatic unregistration when the device is
unregistered.</p>
<dl class="function">
<dt id="c.devm_snd_dmaengine_pcm_register">
int <code class="descname">devm_snd_dmaengine_pcm_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_pcm_config" title="snd_dmaengine_pcm_config">snd_dmaengine_pcm_config</a> *<em>&nbsp;config</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_dmaengine_pcm_register" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed dmaengine PCM registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The parent device for the PCM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_pcm_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>Platform specific PCM configuration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Platform specific quirks</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a dmaengine based PCM device with automatic unregistration when the
device is unregistered.</p>
<dl class="function">
<dt id="c.snd_soc_component_set_sysclk">
int <code class="descname">snd_soc_component_set_sysclk</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, int<em>&nbsp;clk_id</em>, int<em>&nbsp;source</em>, unsigned int<em>&nbsp;freq</em>, int<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_set_sysclk" title="Permalink to this definition">¶</a></dt>
<dd><p>configure COMPONENT system or master clock.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>COMPONENT</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">clk_id</span></code></dt>
<dd>DAI specific clock ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">source</span></code></dt>
<dd>Source for the clock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">freq</span></code></dt>
<dd>new clock frequency in Hz</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dir</span></code></dt>
<dd>new clock direction - input/output.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configures the CODEC master (MCLK) or system (SYSCLK) clocking.</p>
<dl class="function">
<dt id="c.snd_soc_component_set_jack">
int <code class="descname">snd_soc_component_set_jack</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, struct snd_soc_jack *<em>&nbsp;jack</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_set_jack" title="Permalink to this definition">¶</a></dt>
<dd><p>configure component jack.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>COMPONENTs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>structure to use for the jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>can be used if codec driver need extra data for configuring jack</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configures and enables jack detection function.</p>
<dl class="function">
<dt id="c.snd_soc_component_init_regmap">
void <code class="descname">snd_soc_component_init_regmap</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, struct regmap *<em>&nbsp;regmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_init_regmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize regmap instance for the component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component for which to initialize the regmap instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regmap</span> <span class="pre">*</span> <span class="pre">regmap</span></code></dt>
<dd>The regmap instance that should be used by the component</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows deferred assignment of the regmap instance that is
associated with the component. Only use this if the regmap instance is not
yet ready when the component is registered. The function must also be called
before the first IO attempt of the component.</p>
<dl class="function">
<dt id="c.snd_soc_component_exit_regmap">
void <code class="descname">snd_soc_component_exit_regmap</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_exit_regmap" title="Permalink to this definition">¶</a></dt>
<dd><p>De-initialize regmap instance for the component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>The component for which to de-initialize the regmap instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls regmap_exit() on the regmap instance associated to the component and
removes the regmap instance from the component.</p>
<p>This function should only be used if <a class="reference internal" href="#c.snd_soc_component_init_regmap" title="snd_soc_component_init_regmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_init_regmap()</span></code></a> was used
to initialize the regmap instance.</p>
<dl class="function">
<dt id="c.snd_soc_component_read">
unsigned int <code class="descname">snd_soc_component_read</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read register value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to read</dd>
</dl>
<p><strong>Return</strong></p>
<p>read value</p>
<dl class="function">
<dt id="c.snd_soc_component_write">
int <code class="descname">snd_soc_component_write</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write register value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component to write to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt>
<dd>Value to write to the register</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise.</p>
<dl class="function">
<dt id="c.snd_soc_component_update_bits">
int <code class="descname">snd_soc_component_update_bits</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;mask</em>, unsigned int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_update_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform read/modify/write cycle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Mask that specifies which bits to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt>
<dd>New value for the bits specified by mask</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.</p>
<dl class="function">
<dt id="c.snd_soc_component_update_bits_async">
int <code class="descname">snd_soc_component_update_bits_async</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;mask</em>, unsigned int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_update_bits_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform asynchronous read/modify/write cycle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Mask that specifies which bits to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt>
<dd>New value for the bits specified by mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.snd_soc_component_update_bits" title="snd_soc_component_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_update_bits()</span></code></a>, but the update
operation is scheduled asynchronously. This means it may not be completed
when the function returns. To make sure that all scheduled updates have been
completed <a class="reference internal" href="#c.snd_soc_component_async_complete" title="snd_soc_component_async_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_async_complete()</span></code></a> must be called.</p>
<p><strong>Return</strong></p>
<p>1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.</p>
<dl class="function">
<dt id="c.snd_soc_component_async_complete">
void <code class="descname">snd_soc_component_async_complete</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_async_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure asynchronous I/O has completed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>Component for which to wait</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function blocks until all asynchronous I/O which has previously been
scheduled using <a class="reference internal" href="#c.snd_soc_component_update_bits_async" title="snd_soc_component_update_bits_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_update_bits_async()</span></code></a> has completed.</p>
<dl class="function">
<dt id="c.snd_soc_component_test_bits">
int <code class="descname">snd_soc_component_test_bits</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;mask</em>, unsigned int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_test_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Test register for change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>component</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to test</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Mask that specifies which bits to test</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>Value to test against</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tests a register with a new value and checks if the new value is
different from the old value.</p>
<p><strong>Return</strong></p>
<p>1 for change, otherwise 0.</p>
<dl class="function">
<dt id="c.snd_soc_runtime_action">
void <code class="descname">snd_soc_runtime_action</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em>, int<em>&nbsp;stream</em>, int<em>&nbsp;action</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment/Decrement active count for PCM runtime components</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>ASoC PCM runtime that is activated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>Direction of the PCM stream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">action</span></code></dt>
<dd>Activate stream if 1. Deactivate if -1.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments/Decrements the active count for all the DAIs and components
attached to a PCM runtime.
Should typically be called when a stream is opened.</p>
<p>Must be called with the rtd-&gt;card-&gt;pcm_mutex being held</p>
<dl class="function">
<dt id="c.snd_soc_runtime_ignore_pmdown_time">
bool <code class="descname">snd_soc_runtime_ignore_pmdown_time</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_ignore_pmdown_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether to ignore the power down delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>The ASoC PCM runtime that should be checked.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks whether the power down delay should be ignored for a
specific PCM runtime. Returns true if the delay is 0, if it the DAI link has
been configured to ignore the delay, or if none of the components benefits
from having the delay.</p>
<dl class="function">
<dt id="c.snd_soc_set_runtime_hwparams">
int <code class="descname">snd_soc_set_runtime_hwparams</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, const struct snd_pcm_hardware *<em>&nbsp;hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_set_runtime_hwparams" title="Permalink to this definition">¶</a></dt>
<dd><p>set the runtime hardware parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>the pcm substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*</span> <span class="pre">hw</span></code></dt>
<dd>the hardware parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the substream runtime hardware parameters.</p>
<dl class="function">
<dt id="c.snd_soc_runtime_calc_hw">
int <code class="descname">snd_soc_runtime_calc_hw</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em>, struct snd_pcm_hardware *<em>&nbsp;hw</em>, int<em>&nbsp;stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_calc_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hw limits for a PCM stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>ASoC PCM runtime</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*</span> <span class="pre">hw</span></code></dt>
<dd>PCM hardware parameters (output)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>Direction of the PCM stream</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates the subset of stream parameters supported by all DAIs
associated with the PCM stream.</p>
<dl class="function">
<dt id="c.snd_soc_info_enum_double">
int <code class="descname">snd_soc_info_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer info callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a double enumerated
mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_enum_double">
int <code class="descname">snd_soc_get_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a double enumerated mixer.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_enum_double">
int <code class="descname">snd_soc_put_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer put callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a double enumerated mixer.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_read_signed">
int <code class="descname">snd_soc_read_signed</code><span class="sig-paren">(</span>struct snd_soc_component *<em>&nbsp;component</em>, unsigned int<em>&nbsp;reg</em>, unsigned int<em>&nbsp;mask</em>, unsigned int<em>&nbsp;shift</em>, unsigned int<em>&nbsp;sign_bit</em>, int *<em>&nbsp;signed_val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_read_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a codec register and interpret as signed value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*</span> <span class="pre">component</span></code></dt>
<dd>component</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>Register to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Mask to use after shifting the register value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt>
<dd>Right shift of register value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sign_bit</span></code></dt>
<dd>Bit that describes if a number is negative or not.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">signed_val</span></code></dt>
<dd>Pointer to where the read value should be stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions reads a codec register. The register value is shifted right
by ‘shift’ bits and masked with the given ‘mask’. Afterwards it translates
the given registervalue into a signed integer if sign_bit is non-zero.</p>
<p>Returns 0 on sucess, otherwise an error value</p>
<dl class="function">
<dt id="c.snd_soc_info_volsw">
int <code class="descname">snd_soc_info_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer info callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_info_volsw_sx">
int <code class="descname">snd_soc_info_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixer info callback for SX TLV controls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers of the SX TLV type. SX TLV controls
have a range that represents both positive and negative values either side
of zero but without a sign bit.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_volsw">
int <code class="descname">snd_soc_get_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_volsw">
int <code class="descname">snd_soc_put_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer put callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_volsw_sx">
int <code class="descname">snd_soc_get_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_volsw_sx">
int <code class="descname">snd_soc_put_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>double mixer set callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a double mixer control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_info_volsw_range">
int <code class="descname">snd_soc_info_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer info callback with range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information, within a range, about a single
mixer control.</p>
<p>returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_volsw_range">
int <code class="descname">snd_soc_put_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer put value callback with range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value, within a range, for a single mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_volsw_range">
int <code class="descname">snd_soc_get_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback with range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value, within a range, of a single mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_limit_volume">
int <code class="descname">snd_soc_limit_volume</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_limit_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Set new limit to an existing volume control.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>where to look for the control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Name of the control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>new maximum limit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
<dl class="function">
<dt id="c.snd_soc_info_xr_sx">
int <code class="descname">snd_soc_info_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register info callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mreg control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information of a control that can
span multiple codec registers which together
forms a single signed value in a MSB/LSB manner.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_xr_sx">
int <code class="descname">snd_soc_get_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mreg control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_xr_sx">
int <code class="descname">snd_soc_put_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mreg control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_get_strobe">
int <code class="descname">snd_soc_get_strobe</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_strobe" title="Permalink to this definition">¶</a></dt>
<dd><p>strobe get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback get the value of a strobe mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_put_strobe">
int <code class="descname">snd_soc_put_strobe</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_strobe" title="Permalink to this definition">¶</a></dt>
<dd><p>strobe put callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback strobe a register bit to high then low (or the inverse)
in one pass of a single mixer enum control.</p>
<p>Returns 1 for success.</p>
<dl class="function">
<dt id="c.snd_soc_new_compress">
int <code class="descname">snd_soc_new_compress</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_new_compress" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new compress.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>The runtime for which we will create compress</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>the device index number (zero based - shared with normal PCMs)</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, else error.</p>
</div>
<div class="section" id="asoc-dapm-api">
<h3>ASoC DAPM API<a class="headerlink" href="#asoc-dapm-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_soc_dapm_kcontrol_widget">
struct snd_soc_dapm_widget * <code class="descname">snd_soc_dapm_kcontrol_widget</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_kcontrol_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the widget associated to a kcontrol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>The kcontrol</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_dapm_kcontrol_dapm">
struct snd_soc_dapm_context * <code class="descname">snd_soc_dapm_kcontrol_dapm</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_kcontrol_dapm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dapm context associated to a kcontrol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>The kcontrol</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function must only be used on kcontrols that are known to have
been registered for a CODEC. Otherwise the behaviour is undefined.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_force_bias_level">
int <code class="descname">snd_soc_dapm_force_bias_level</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, enum snd_soc_bias_level<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_bias_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the DAPM bias level</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>The DAPM context for which to set the level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_soc_bias_level</span> <span class="pre">level</span></code></dt>
<dd>The level to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces the DAPM bias level to a specific state. It will call the bias level
callback of DAPM context with the specified level. This will even happen if
the context is already at the same level. Furthermore it will not go through
the normal bias level sequencing, meaning any intermediate states between the
current and the target state will not be entered.</p>
<p>Note that the change in bias level is only temporary and the next time
<a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> is called the state will be set to the level as
determined by the DAPM core. The function is mainly intended to be used to
used during probe or resume from suspend to power up the device so
initialization can be done, before the DAPM core takes over.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_set_bias_level">
int <code class="descname">snd_soc_dapm_set_bias_level</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, enum snd_soc_bias_level<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_set_bias_level" title="Permalink to this definition">¶</a></dt>
<dd><p>set the bias level for the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_soc_bias_level</span> <span class="pre">level</span></code></dt>
<dd>level to configure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the bias (power) levels for the SoC audio device.</p>
<p>Returns 0 for success else error.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_dai_get_connected_widgets">
int <code class="descname">snd_soc_dapm_dai_get_connected_widgets</code><span class="sig-paren">(</span>struct snd_soc_dai *<em>&nbsp;dai</em>, int<em>&nbsp;stream</em>, struct snd_soc_dapm_widget_list **<em>&nbsp;list</em>, bool (<em>*custom_stop_condition</em>)(struct snd_soc_dapm_widget *, enum snd_soc_dapm_direction)<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_dai_get_connected_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>query audio path and it’s widgets.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai</span> <span class="pre">*</span> <span class="pre">dai</span></code></dt>
<dd>the soc DAI.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>stream direction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget_list</span> <span class="pre">**</span> <span class="pre">list</span></code></dt>
<dd>list of active widgets for this stream.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*)(struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*,</span> <span class="pre">enum</span> <span class="pre">snd_soc_dapm_direction)</span> <span class="pre">custom_stop_condition</span></code></dt>
<dd>(optional) a function meant to stop the widget graph
walk based on custom logic.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queries DAPM graph as to whether a valid audio stream path exists for
the initial stream specified by name. This takes into account
current mixer and mux kcontrol settings. Creates list of valid widgets.</p>
<p>Optionally, can be supplied with a function acting as a stopping condition.
This function takes the dapm widget currently being examined and the walk
direction as an arguments, it should return true if the walk should be
stopped and false otherwise.</p>
<p>Returns the number of valid paths or negative error.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_sync_unlocked">
int <code class="descname">snd_soc_dapm_sync_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_sync_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>scan and power dapm paths</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks all dapm audio paths and powers widgets according to their
stream or path usage.</p>
<p>Requires external locking.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_sync">
int <code class="descname">snd_soc_dapm_sync</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>scan and power dapm paths</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks all dapm audio paths and powers widgets according to their
stream or path usage.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_add_routes">
int <code class="descname">snd_soc_dapm_add_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const struct snd_soc_dapm_route *<em>&nbsp;route</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_add_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Add routes between DAPM widgets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*</span> <span class="pre">route</span></code></dt>
<dd>audio routes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of routes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connects 2 dapm widgets together via a named audio path. The sink is
the widget receiving the audio signal, whilst the source is the sender
of the audio signal.</p>
<p>Returns 0 for success else error. On error all resources can be freed
with a call to snd_soc_card_free().</p>
<dl class="function">
<dt id="c.snd_soc_dapm_del_routes">
int <code class="descname">snd_soc_dapm_del_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const struct snd_soc_dapm_route *<em>&nbsp;route</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_del_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove routes between DAPM widgets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*</span> <span class="pre">route</span></code></dt>
<dd>audio routes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of routes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes routes from the DAPM context.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_weak_routes">
int <code class="descname">snd_soc_dapm_weak_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const struct snd_soc_dapm_route *<em>&nbsp;route</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_weak_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark routes between DAPM widgets as weak</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*</span> <span class="pre">route</span></code></dt>
<dd>audio routes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of routes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark existing routes matching those specified in the passed array
as being weak, meaning that they are ignored for the purpose of
power decisions.  The main intended use case is for sidetone paths
which couple audio between other independent paths if they are both
active in order to make the combination work better at the user
level but which aren’t intended to be “used”.</p>
<p>Note that CODEC drivers should not use this as sidetone type paths
can frequently also be used as bypass paths.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_new_widgets">
int <code class="descname">snd_soc_dapm_new_widgets</code><span class="sig-paren">(</span>struct snd_soc_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>add new dapm widgets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>card to be checked for new dapm widgets</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the codec for any new dapm widgets and creates them if found.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_get_volsw">
int <code class="descname">snd_soc_dapm_get_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm mixer get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a dapm mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_put_volsw">
int <code class="descname">snd_soc_dapm_put_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm mixer set callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a dapm mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_get_enum_double">
int <code class="descname">snd_soc_dapm_get_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm enumerated double mixer get callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a dapm enumerated double mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_put_enum_double">
int <code class="descname">snd_soc_dapm_put_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm enumerated double mixer set callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a dapm enumerated double mixer control.</p>
<p>Returns 0 for success.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_info_pin_switch">
int <code class="descname">snd_soc_dapm_info_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_info *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_info_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Info for a pin switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>control element information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a pin switch control.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_get_pin_switch">
int <code class="descname">snd_soc_dapm_get_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information for a pin switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>Value</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_dapm_put_pin_switch">
int <code class="descname">snd_soc_dapm_put_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol *<em>&nbsp;kcontrol</em>, struct snd_ctl_elem_value *<em>&nbsp;ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set information for a pin switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*</span> <span class="pre">kcontrol</span></code></dt>
<dd>mixer control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*</span> <span class="pre">ucontrol</span></code></dt>
<dd>Value</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_dapm_new_control">
struct snd_soc_dapm_widget * <code class="descname">snd_soc_dapm_new_control</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const struct snd_soc_dapm_widget *<em>&nbsp;widget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_control" title="Permalink to this definition">¶</a></dt>
<dd><p>create new dapm control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*</span> <span class="pre">widget</span></code></dt>
<dd>widget template</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates new DAPM control based upon a template.</p>
<p>Returns a widget pointer on success or an error pointer on failure</p>
<dl class="function">
<dt id="c.snd_soc_dapm_new_controls">
int <code class="descname">snd_soc_dapm_new_controls</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const struct snd_soc_dapm_widget *<em>&nbsp;widget</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>create new dapm controls</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*</span> <span class="pre">widget</span></code></dt>
<dd>widget array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of widgets</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates new DAPM controls based upon the templates.</p>
<p>Returns 0 for success else error.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_stream_event">
void <code class="descname">snd_soc_dapm_stream_event</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime *<em>&nbsp;rtd</em>, int<em>&nbsp;stream</em>, int<em>&nbsp;event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_stream_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send a stream event to the dapm core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*</span> <span class="pre">rtd</span></code></dt>
<dd>PCM runtime data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt>
<dd>stream name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">event</span></code></dt>
<dd>stream event</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sends a stream event to the dapm core. The core then makes any
necessary widget power changes.</p>
<p>Returns 0 for success else error.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_enable_pin_unlocked">
int <code class="descname">snd_soc_dapm_enable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_enable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>enable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_enable_pin">
int <code class="descname">snd_soc_dapm_enable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_enable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>enable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_force_enable_pin_unlocked">
int <code class="descname">snd_soc_dapm_force_enable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_enable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>force a pin to be enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_force_enable_pin">
int <code class="descname">snd_soc_dapm_force_enable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_enable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>force a pin to be enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_disable_pin_unlocked">
int <code class="descname">snd_soc_dapm_disable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_disable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>disable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables input/output pin and its parents or children widgets.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_disable_pin">
int <code class="descname">snd_soc_dapm_disable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_disable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>disable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables input/output pin and its parents or children widgets.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_nc_pin_unlocked">
int <code class="descname">snd_soc_dapm_nc_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_nc_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>permanently disable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
<a class="reference internal" href="#c.snd_soc_dapm_disable_pin" title="snd_soc_dapm_disable_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_disable_pin()</span></code></a> but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_nc_pin">
int <code class="descname">snd_soc_dapm_nc_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_nc_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>permanently disable pin.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>pin name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
<a class="reference internal" href="#c.snd_soc_dapm_disable_pin" title="snd_soc_dapm_disable_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_disable_pin()</span></code></a> but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_get_pin_status">
int <code class="descname">snd_soc_dapm_get_pin_status</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_pin_status" title="Permalink to this definition">¶</a></dt>
<dd><p>get audio pin status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>audio signal pin endpoint (or start point)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get audio pin status - connected or disconnected.</p>
<p>Returns 1 for connected otherwise 0.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_ignore_suspend">
int <code class="descname">snd_soc_dapm_ignore_suspend</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em>, const char *<em>&nbsp;pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_ignore_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>ignore suspend status for DAPM endpoint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin</span></code></dt>
<dd>audio signal pin endpoint (or start point)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark the given endpoint or pin as ignoring suspend.  When the
system is disabled a path between two endpoints flagged as ignoring
suspend will not be disabled.  The path must already be enabled via
normal means at suspend time, it will not be turned on if it was not
already enabled.</p>
<dl class="function">
<dt id="c.snd_soc_dapm_free">
void <code class="descname">snd_soc_dapm_free</code><span class="sig-paren">(</span>struct snd_soc_dapm_context *<em>&nbsp;dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free dapm resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*</span> <span class="pre">dapm</span></code></dt>
<dd>DAPM context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all dapm widgets and resources.</p>
</div>
<div class="section" id="asoc-dma-engine-api">
<h3>ASoC DMA Engine API<a class="headerlink" href="#asoc-dma-engine-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_prepare_slave_config">
int <code class="descname">snd_dmaengine_pcm_prepare_slave_config</code><span class="sig-paren">(</span>struct snd_pcm_substream *<em>&nbsp;substream</em>, struct snd_pcm_hw_params *<em>&nbsp;params</em>, struct dma_slave_config *<em>&nbsp;slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_prepare_slave_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic prepare_slave_config callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*</span> <span class="pre">substream</span></code></dt>
<dd>PCM substream</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>hw_params</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*</span> <span class="pre">slave_config</span></code></dt>
<dd>DMA slave config to prepare</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as a generic prepare_slave_config callback for
platforms which make use of the snd_dmaengine_dai_dma_data struct for their
DAI DMA data. Internally the function will first call
snd_hwparams_to_dma_slave_config to fill in the slave config based on the
hw_params, followed by snd_dmaengine_set_config_from_dai_data to fill in the
remaining fields based on the DAI DMA data.</p>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_register">
int <code class="descname">snd_dmaengine_pcm_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_pcm_config" title="snd_dmaengine_pcm_config">snd_dmaengine_pcm_config</a> *<em>&nbsp;config</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a dmaengine based PCM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The parent device for the PCM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_pcm_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>Platform specific PCM configuration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Platform specific quirks</dd>
</dl>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_unregister">
void <code class="descname">snd_dmaengine_pcm_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a dmaengine based PCM device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Parent device the PCM was register with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dmaengine based PCM device previously registered with
snd_dmaengine_pcm_register.</p>
</div>
</div>
<div class="section" id="miscellaneous-functions">
<h2>Miscellaneous Functions<a class="headerlink" href="#miscellaneous-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hardware-dependent-devices-api">
<h3>Hardware-Dependent Devices API<a class="headerlink" href="#hardware-dependent-devices-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_hwdep_new">
int <code class="descname">snd_hwdep_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, char *<em>&nbsp;id</em>, int<em>&nbsp;device</em>, struct snd_hwdep **<em>&nbsp;rhwdep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_hwdep_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new hwdep instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>the id string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>the device index (zero-based)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_hwdep</span> <span class="pre">**</span> <span class="pre">rhwdep</span></code></dt>
<dd>the pointer to store the new hwdep instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-&gt;ops) must be set on the returned instance
after this call manually by the caller.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<div class="section" id="jack-abstraction-layer-api">
<h3>Jack Abstraction Layer API<a class="headerlink" href="#jack-abstraction-layer-api" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.snd_jack_types">
enum <code class="descname">snd_jack_types</code><a class="headerlink" href="#c.snd_jack_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Jack types which can be reported</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_HEADPHONE</span></code></dt>
<dd>Headphone</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_MICROPHONE</span></code></dt>
<dd>Microphone</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_HEADSET</span></code></dt>
<dd>Headset</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_LINEOUT</span></code></dt>
<dd>Line out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_MECHANICAL</span></code></dt>
<dd>Mechanical switch</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_VIDEOOUT</span></code></dt>
<dd>Video out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_AVOUT</span></code></dt>
<dd>AV (Audio Video) out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_LINEIN</span></code></dt>
<dd>Line in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_0</span></code></dt>
<dd>Button 0</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_1</span></code></dt>
<dd>Button 1</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_2</span></code></dt>
<dd>Button 2</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_3</span></code></dt>
<dd>Button 3</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_4</span></code></dt>
<dd>Button 4</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_5</span></code></dt>
<dd>Button 5</dd>
</dl>
<p><strong>Description</strong></p>
<p>These values are used as a bitmask.</p>
<p>Note that this must be kept in sync with the lookup table in
sound/core/jack.c.</p>
<dl class="function">
<dt id="c.snd_jack_add_new_kctl">
int <code class="descname">snd_jack_add_new_kctl</code><span class="sig-paren">(</span>struct snd_jack *<em>&nbsp;jack</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_add_new_kctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new snd_jack_kctl and add it to jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>the jack instance which the kctl will attaching to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name for the snd_kcontrol object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>a bitmask of enum snd_jack_type values that can be detected
by this snd_jack_kctl object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new snd_kcontrol object and adds it to the jack kctl_list.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_jack_new">
int <code class="descname">snd_jack_new</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em>, const char *<em>&nbsp;id</em>, int<em>&nbsp;type</em>, struct snd_jack **<em>&nbsp;jjack</em>, bool<em>&nbsp;initial_kctl</em>, bool<em>&nbsp;phantom_jack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>an identifying string for this jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>a bitmask of enum snd_jack_type values that can be detected by
this jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">**</span> <span class="pre">jjack</span></code></dt>
<dd>Used to provide the allocated jack object to the caller.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">initial_kctl</span></code></dt>
<dd>if true, create a kcontrol and add it to the jack list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">phantom_jack</span></code></dt>
<dd>Don’t create a input device for phantom jacks.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new jack object.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.
On success <strong>jjack</strong> will be initialised.</p>
<dl class="function">
<dt id="c.snd_jack_set_parent">
void <code class="descname">snd_jack_set_parent</code><span class="sig-paren">(</span>struct snd_jack *<em>&nbsp;jack</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parent device for a jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>The jack to configure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>The device to set as parent for the jack.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the parent for the jack devices in the device tree.  This
function is only valid prior to registration of the jack.  If no
parent is configured then the parent device will be the sound card.</p>
<dl class="function">
<dt id="c.snd_jack_set_key">
int <code class="descname">snd_jack_set_key</code><span class="sig-paren">(</span>struct snd_jack *<em>&nbsp;jack</em>, enum <a class="reference internal" href="#c.snd_jack_types" title="snd_jack_types">snd_jack_types</a><em>&nbsp;type</em>, int<em>&nbsp;keytype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_set_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key mapping on a jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>The jack to configure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_jack_types</span> <span class="pre">type</span></code></dt>
<dd>Jack report type for this key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">keytype</span></code></dt>
<dd>Input layer key type to be reported</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map a SND_JACK_BTN_* button type to an input layer key, allowing
reporting of keys on accessories via the jack abstraction.  If no
mapping is provided but keys are enabled in the jack type then
BTN_n numeric buttons will be reported.</p>
<p>If jacks are not reporting via the input API this call will have no
effect.</p>
<p>Note that this is intended to be use by simple devices with small
numbers of keys that can be reported.  It is also possible to
access the input device directly - devices with complex input
capabilities on accessories should consider doing this rather than
using this abstraction.</p>
<p>This function may only be called prior to registration of the jack.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
<dl class="function">
<dt id="c.snd_jack_report">
void <code class="descname">snd_jack_report</code><span class="sig-paren">(</span>struct snd_jack *<em>&nbsp;jack</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the current status of a jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>The jack to report status for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>The current status of the jack</dd>
</dl>
<dl class="function">
<dt id="c.snd_soc_jack_report">
void <code class="descname">snd_soc_jack_report</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;status</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the current status for a jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>the jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>a bitmask of enum snd_jack_type values that are currently detected.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>a bitmask of enum snd_jack_type values that being reported.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If configured using <a class="reference internal" href="#c.snd_soc_jack_add_pins" title="snd_soc_jack_add_pins"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_jack_add_pins()</span></code></a> then the associated
DAPM pins will be enabled or disabled as appropriate and DAPM
synchronised.</p>
<p><strong>Note</strong></p>
<p>This function uses mutexes and should be called from a
context which can sleep (such as a workqueue).</p>
<dl class="function">
<dt id="c.snd_soc_jack_add_zones">
int <code class="descname">snd_soc_jack_add_zones</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;count</em>, struct <a class="reference internal" href="#c.snd_soc_jack_zone" title="snd_soc_jack_zone">snd_soc_jack_zone</a> *<em>&nbsp;zones</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_zones" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate voltage zones with jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>Number of zones</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_zone</span> <span class="pre">*</span> <span class="pre">zones</span></code></dt>
<dd>Array of zones</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function has been called the zones specified in the
array will be associated with the jack.</p>
<dl class="function">
<dt id="c.snd_soc_jack_get_type">
int <code class="descname">snd_soc_jack_get_type</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;micbias_voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the mic bias value, this function returns the type of jack from the zones declared in the jack type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">micbias_voltage</span></code></dt>
<dd>mic bias voltage at adc channel when jack is plugged in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the mic bias value passed, this function helps identify
the type of jack from the already declared jack zones</p>
<dl class="function">
<dt id="c.snd_soc_jack_add_pins">
int <code class="descname">snd_soc_jack_add_pins</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;count</em>, struct <a class="reference internal" href="#c.snd_soc_jack_pin" title="snd_soc_jack_pin">snd_soc_jack_pin</a> *<em>&nbsp;pins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate DAPM pins with an ASoC jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>Number of pins</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_pin</span> <span class="pre">*</span> <span class="pre">pins</span></code></dt>
<dd>Array of pins</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function has been called the DAPM pins specified in the
pins array will have their status updated to reflect the current
state of the jack whenever the jack status is updated.</p>
<dl class="function">
<dt id="c.snd_soc_jack_notifier_register">
void <code class="descname">snd_soc_jack_notifier_register</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a notifier for jack status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>Notifier block to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register for notification of the current status of the jack.  Note
that it is not possible to report additional jack events in the
callback from the notifier, this is intended to support
applications such as enabling electrical detection only when a
mechanical detection event has occurred.</p>
<dl class="function">
<dt id="c.snd_soc_jack_notifier_unregister">
void <code class="descname">snd_soc_jack_notifier_unregister</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a notifier for jack status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>Notifier block to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop notifying for status changes.</p>
<dl class="function">
<dt id="c.snd_soc_jack_add_gpios">
int <code class="descname">snd_soc_jack_add_gpios</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;count</em>, struct <a class="reference internal" href="#c.snd_soc_jack_gpio" title="snd_soc_jack_gpio">snd_soc_jack_gpio</a> *<em>&nbsp;gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_gpios" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate GPIO pins with an ASoC jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pins</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*</span> <span class="pre">gpios</span></code></dt>
<dd>array of gpio pins</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will request gpio, set data direction and request irq
for each gpio in the array.</p>
<dl class="function">
<dt id="c.snd_soc_jack_add_gpiods">
int <code class="descname">snd_soc_jack_add_gpiods</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;gpiod_dev</em>, struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;count</em>, struct <a class="reference internal" href="#c.snd_soc_jack_gpio" title="snd_soc_jack_gpio">snd_soc_jack_gpio</a> *<em>&nbsp;gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_gpiods" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate GPIO descriptor pins with an ASoC jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">gpiod_dev</span></code></dt>
<dd>GPIO consumer device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pins</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*</span> <span class="pre">gpios</span></code></dt>
<dd>array of gpio pins</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will request gpio, set data direction and request irq
for each gpio in the array.</p>
<dl class="function">
<dt id="c.snd_soc_jack_free_gpios">
void <code class="descname">snd_soc_jack_free_gpios</code><span class="sig-paren">(</span>struct snd_soc_jack *<em>&nbsp;jack</em>, int<em>&nbsp;count</em>, struct <a class="reference internal" href="#c.snd_soc_jack_gpio" title="snd_soc_jack_gpio">snd_soc_jack_gpio</a> *<em>&nbsp;gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_free_gpios" title="Permalink to this definition">¶</a></dt>
<dd><p>Release GPIO pins’ resources of an ASoC jack</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*</span> <span class="pre">jack</span></code></dt>
<dd>ASoC jack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pins</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*</span> <span class="pre">gpios</span></code></dt>
<dd>array of gpio pins</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release gpio and irq resources for gpio pins associated with an ASoC jack.</p>
</div>
<div class="section" id="isa-dma-helpers">
<h3>ISA DMA Helpers<a class="headerlink" href="#isa-dma-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_dma_program">
void <code class="descname">snd_dma_program</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;dma</em>, unsigned long<em>&nbsp;addr</em>, unsigned int<em>&nbsp;size</em>, unsigned short<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_program" title="Permalink to this definition">¶</a></dt>
<dd><p>program an ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt>
<dd>the dma number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>the physical address of the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the DMA transfer size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mode</span></code></dt>
<dd>the DMA transfer mode, DMA_MODE_XXX</dd>
</dl>
<p><strong>Description</strong></p>
<p>Programs an ISA DMA transfer for the given buffer.</p>
<dl class="function">
<dt id="c.snd_dma_disable">
void <code class="descname">snd_dma_disable</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the ISA DMA transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt>
<dd>the dma number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the ISA DMA transfer.</p>
<dl class="function">
<dt id="c.snd_dma_pointer">
unsigned int <code class="descname">snd_dma_pointer</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;dma</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current pointer to DMA transfer buffer in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt>
<dd>the dma number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the dma transfer size</dd>
</dl>
<p><strong>Return</strong></p>
<p>The current pointer in DMA transfer buffer in bytes.</p>
</div>
<div class="section" id="other-helper-macros">
<h3>Other Helper Macros<a class="headerlink" href="#other-helper-macros" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_card_unref">
void <code class="descname">snd_card_unref</code><span class="sig-paren">(</span>struct snd_card *<em>&nbsp;card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Unreference the card object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*</span> <span class="pre">card</span></code></dt>
<dd>the card object to unreference</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function for the card object that was obtained via <a class="reference internal" href="#c.snd_card_ref" title="snd_card_ref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_ref()</span></code></a>
or <a class="reference internal" href="#c.snd_lookup_minor_data" title="snd_lookup_minor_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_lookup_minor_data()</span></code></a>.</p>
<dl class="function">
<dt id="c.snd_printk">
<code class="descname">snd_printk</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printk" title="Permalink to this definition">¶</a></dt>
<dd><p>printk wrapper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> but prints the file and the line of the caller
when configured with CONFIG_SND_VERBOSE_PRINTK.</p>
<dl class="function">
<dt id="c.snd_printd">
<code class="descname">snd_printd</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG is not set.</p>
<dl class="function">
<dt id="c.snd_BUG">
<code class="descname">snd_BUG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG" title="Permalink to this definition">¶</a></dt>
<dd><p>give a BUG warning message and stack trace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Calls WARN() if CONFIG_SND_DEBUG is set.
Ignored when CONFIG_SND_DEBUG is not set.</p>
<dl class="function">
<dt id="c.snd_printd_ratelimit">
<code class="descname">snd_printd_ratelimit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd_ratelimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.snd_BUG_ON">
<code class="descname">snd_BUG_ON</code><span class="sig-paren">(</span><em>cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG_ON" title="Permalink to this definition">¶</a></dt>
<dd><p>debugging check macro</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt>
<dd>condition to evaluate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Has the same behavior as WARN_ON when CONFIG_SND_DEBUG is set,
otherwise just evaluates the conditional and returns the value.</p>
<dl class="function">
<dt id="c.snd_printdd">
<code class="descname">snd_printdd</code><span class="sig-paren">(</span><em>format</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printdd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="writing-an-alsa-driver.html" class="btn btn-neutral float-right" title="Writing an ALSA Driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="ALSA Kernel API Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>