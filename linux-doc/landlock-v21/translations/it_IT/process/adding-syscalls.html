

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Aggiungere una nuova chiamata di sistema &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="I numeri magici di Linux" href="magic-number.html" />
    <link rel="prev" title="Applicare patch al kernel Linux" href="applying-patches.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.9.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">中文翻译</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Traduzione italiana</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#avvertenze">Avvertenze</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#la-documentazione-del-kernel-linux">La documentazione del kernel Linux</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-sulla-licenza-dei-sorgenti">Documentazione sulla licenza dei sorgenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-utenti">Documentazione per gli utenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-sviluppatori-di-applicazioni">Documentazione per gli sviluppatori di applicazioni</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html#introduzione-allo-sviluppo-del-kernel">Introduzione allo sviluppo del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-della-api-del-kernel">Documentazione della API del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-specifica-per-architettura">Documentazione specifica per architettura</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">한국어 번역</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">Japanese translations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Translations</a> &raquo;</li>
        
          <li><a href="../index.html">Traduzione italiana</a> &raquo;</li>
        
          <li><a href="index.html">Lavorare con la comunità di sviluppo del kernel</a> &raquo;</li>
        
      <li>Aggiungere una nuova chiamata di sistema</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/translations/it_IT/process/adding-syscalls.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Original:</th><td class="field-body"><a class="reference internal" href="../../../process/adding-syscalls.html#addsyscalls"><span class="std std-ref">Documentation/process/adding-syscalls.rst</span></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Translator:</th><td class="field-body">Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="aggiungere-una-nuova-chiamata-di-sistema">
<span id="it-addsyscalls"></span><h1>Aggiungere una nuova chiamata di sistema<a class="headerlink" href="#aggiungere-una-nuova-chiamata-di-sistema" title="Permalink to this headline">¶</a></h1>
<p>Questo documento descrive quello che è necessario sapere per aggiungere
nuove chiamate di sistema al kernel Linux; questo è da considerarsi come
un’aggiunta ai soliti consigli su come proporre nuove modifiche
<a class="reference internal" href="submitting-patches.html#it-submittingpatches"><span class="std std-ref">Documentation/translations/it_IT/process/submitting-patches.rst</span></a>.</p>
<div class="section" id="alternative-alle-chiamate-di-sistema">
<h2>Alternative alle chiamate di sistema<a class="headerlink" href="#alternative-alle-chiamate-di-sistema" title="Permalink to this headline">¶</a></h2>
<p>La prima considerazione da fare quando si aggiunge una nuova chiamata di
sistema è quella di valutare le alternative.  Nonostante le chiamate di sistema
siano il punto di interazione fra spazio utente e kernel più tradizionale ed
ovvio, esistono altre possibilità - scegliete quella che meglio si adatta alle
vostra interfaccia.</p>
<blockquote>
<div><ul>
<li><p class="first">Se le operazioni coinvolte possono rassomigliare a quelle di un filesystem,
allora potrebbe avere molto più senso la creazione di un nuovo filesystem o
dispositivo.  Inoltre, questo rende più facile incapsulare la nuova
funzionalità in un modulo kernel piuttosto che essere sviluppata nel cuore
del kernel.</p>
<blockquote>
<div><ul class="simple">
<li>Se la nuova funzionalità prevede operazioni dove il kernel notifica
lo spazio utente su un avvenimento, allora restituire un descrittore
di file all’oggetto corrispondente permette allo spazio utente di
utilizzare <code class="docutils literal notranslate"><span class="pre">poll</span></code>/<code class="docutils literal notranslate"><span class="pre">select</span></code>/<code class="docutils literal notranslate"><span class="pre">epoll</span></code> per ricevere quelle notifiche.</li>
<li>Tuttavia, le operazioni che non si sposano bene con operazioni tipo
<em class="manpage">read(2)</em>/<em class="manpage">write(2)</em> dovrebbero essere implementate
come chiamate <em class="manpage">ioctl(2)</em>, il che potrebbe portare ad un’API in
un qualche modo opaca.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Se dovete esporre solo delle informazioni sul sistema, un nuovo nodo in
sysfs (vedere <code class="docutils literal notranslate"><span class="pre">Documentation/filesystems/sysfs.rst</span></code>) o
in procfs potrebbe essere sufficiente.  Tuttavia, l’accesso a questi
meccanismi richiede che il filesystem sia montato, il che potrebbe non
essere sempre vero (per esempio, in ambienti come namespace/sandbox/chroot).
Evitate d’aggiungere nuove API in debugfs perché questo non viene
considerata un’interfaccia di ‘produzione’ verso lo spazio utente.</p>
</li>
<li><p class="first">Se l’operazione è specifica ad un particolare file o descrittore, allora
potrebbe essere appropriata l’aggiunta di un comando <em class="manpage">fcntl(2)</em>.
Tuttavia, <em class="manpage">fcntl(2)</em> è una chiamata di sistema multiplatrice che
nasconde una notevole complessità, quindi è ottima solo quando la nuova
funzione assomiglia a quelle già esistenti in <em class="manpage">fcntl(2)</em>, oppure
la nuova funzionalità è veramente semplice (per esempio, leggere/scrivere
un semplice flag associato ad un descrittore di file).</p>
</li>
<li><p class="first">Se l’operazione è specifica ad un particolare processo, allora
potrebbe essere appropriata l’aggiunta di un comando <em class="manpage">prctl(2)</em>.
Come per <em class="manpage">fcntl(2)</em>, questa chiamata di sistema è un complesso
multiplatore quindi è meglio usarlo per cose molto simili a quelle esistenti
nel comando <code class="docutils literal notranslate"><span class="pre">prctl</span></code> oppure per leggere/scrivere un semplice flag relativo
al processo.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="progettare-l-api-pianificare-le-estensioni">
<h2>Progettare l’API: pianificare le estensioni<a class="headerlink" href="#progettare-l-api-pianificare-le-estensioni" title="Permalink to this headline">¶</a></h2>
<p>Una nuova chiamata di sistema diventerà parte dell’API del kernel, e
dev’essere supportata per un periodo indefinito.  Per questo, è davvero
un’ottima idea quella di discutere apertamente l’interfaccia sulla lista
di discussione del kernel, ed è altrettanto importante pianificarne eventuali
estensioni future.</p>
<p>(Nella tabella delle chiamate di sistema sono disseminati esempi dove questo
non fu fatto, assieme ai corrispondenti aggiornamenti -
<code class="docutils literal notranslate"><span class="pre">eventfd</span></code>/<code class="docutils literal notranslate"><span class="pre">eventfd2</span></code>, <code class="docutils literal notranslate"><span class="pre">dup2</span></code>/<code class="docutils literal notranslate"><span class="pre">dup3</span></code>, <code class="docutils literal notranslate"><span class="pre">inotify_init</span></code>/<code class="docutils literal notranslate"><span class="pre">inotify_init1</span></code>,
<code class="docutils literal notranslate"><span class="pre">pipe</span></code>/<code class="docutils literal notranslate"><span class="pre">pipe2</span></code>, <code class="docutils literal notranslate"><span class="pre">renameat</span></code>/<code class="docutils literal notranslate"><span class="pre">renameat2</span></code> –quindi imparate dalla storia
del kernel e pianificate le estensioni fin dall’inizio)</p>
<p>Per semplici chiamate di sistema che accettano solo un paio di argomenti,
il modo migliore di permettere l’estensibilità è quello di includere un
argomento <em>flags</em> alla chiamata di sistema.  Per assicurarsi che i programmi
dello spazio utente possano usare in sicurezza <em>flags</em> con diverse versioni
del kernel, verificate se <em>flags</em> contiene un qualsiasi valore sconosciuto,
in qual caso rifiutate la chiamata di sistema (con <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (flags &amp; ~(THING_FLAG1 | THING_FLAG2 | THING_FLAG3))
    return -EINVAL;
</pre></div>
</div>
<p>(Se <em>flags</em> non viene ancora utilizzato, verificate che l’argomento sia zero)</p>
<p>Per chiamate di sistema più sofisticate che coinvolgono un numero più grande di
argomenti, il modo migliore è quello di incapsularne la maggior parte in una
struttura dati che verrà passata per puntatore.  Questa struttura potrà
funzionare con future estensioni includendo un campo <em>size</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xyzzy_params {
    u32 size; /* userspace sets p-&gt;size = sizeof(struct xyzzy_params) */
    u32 param_1;
    u64 param_2;
    u64 param_3;
};
</pre></div>
</div>
<p>Fintanto che un qualsiasi campo nuovo, diciamo <code class="docutils literal notranslate"><span class="pre">param_4</span></code>, è progettato per
offrire il comportamento precedente quando vale zero, allora questo permetterà
di gestire un conflitto di versione in entrambe le direzioni:</p>
<blockquote>
<div><ul class="simple">
<li>un vecchio kernel può gestire l’accesso di una versione moderna di un
programma in spazio utente verificando che la memoria oltre la dimensione
della struttura dati attesa sia zero (in pratica verificare che
<code class="docutils literal notranslate"><span class="pre">param_4</span> <span class="pre">==</span> <span class="pre">0</span></code>).</li>
<li>un nuovo kernel può gestire l’accesso di una versione vecchia di un
programma in spazio utente estendendo la struttura dati con zeri (in pratica
<code class="docutils literal notranslate"><span class="pre">param_4</span> <span class="pre">=</span> <span class="pre">0</span></code>).</li>
</ul>
</div></blockquote>
<p>Vedere <em class="manpage">perf_event_open(2)</em> e la funzione <code class="docutils literal notranslate"><span class="pre">perf_copy_attr()</span></code> (in
<code class="docutils literal notranslate"><span class="pre">kernel/events/core.c</span></code>) per un esempio pratico di questo approccio.</p>
</div>
<div class="section" id="progettare-l-api-altre-considerazioni">
<h2>Progettare l’API: altre considerazioni<a class="headerlink" href="#progettare-l-api-altre-considerazioni" title="Permalink to this headline">¶</a></h2>
<p>Se la vostra nuova chiamata di sistema permette allo spazio utente di fare
riferimento ad un oggetto del kernel, allora questa dovrebbe usare un
descrittore di file per accesso all’oggetto - non inventatevi nuovi tipi di
accesso da spazio utente quando il kernel ha già dei meccanismi e una semantica
ben definita per utilizzare i descrittori di file.</p>
<p>Se la vostra nuova chiamata di sistema <em class="manpage">xyzzy(2)</em> ritorna un nuovo
descrittore di file, allora l’argomento <em>flags</em> dovrebbe includere un valore
equivalente a <code class="docutils literal notranslate"><span class="pre">O_CLOEXEC</span></code> per i nuovi descrittori.  Questo rende possibile,
nello spazio utente, la chiusura della finestra temporale fra le chiamate a
<code class="docutils literal notranslate"><span class="pre">xyzzy()</span></code> e <code class="docutils literal notranslate"><span class="pre">fcntl(fd,</span> <span class="pre">F_SETFD,</span> <span class="pre">FD_CLOEXEC)</span></code>, dove un inaspettato
<code class="docutils literal notranslate"><span class="pre">fork()</span></code> o <code class="docutils literal notranslate"><span class="pre">execve()</span></code> potrebbe trasferire il descrittore al programma
eseguito (Comunque, resistete alla tentazione di riutilizzare il valore di
<code class="docutils literal notranslate"><span class="pre">O_CLOEXEC</span></code> dato che è specifico dell’architettura e fa parte di una
enumerazione di flag <code class="docutils literal notranslate"><span class="pre">O_*</span></code> che è abbastanza ricca).</p>
<p>Se la vostra nuova chiamata di sistema ritorna un nuovo descrittore di file,
dovreste considerare che significato avrà l’uso delle chiamate di sistema
della famiglia di <em class="manpage">poll(2)</em>. Rendere un descrittore di file pronto
per la lettura o la scrittura è il tipico modo del kernel per notificare lo
spazio utente circa un evento associato all’oggetto del kernel.</p>
<p>Se la vostra nuova chiamata di sistema <em class="manpage">xyzzy(2)</em> ha un argomento
che è il percorso ad un file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sys_xyzzy(const char __user *path, ..., unsigned int flags);
</pre></div>
</div>
<p>dovreste anche considerare se non sia più appropriata una versione
<em class="manpage">xyzzyat(2)</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sys_xyzzyat(int dfd, const char __user *path, ..., unsigned int flags);
</pre></div>
</div>
<p>Questo permette più flessibilità su come lo spazio utente specificherà il file
in questione; in particolare, permette allo spazio utente di richiedere la
funzionalità su un descrittore di file già aperto utilizzando il <em>flag</em>
<code class="docutils literal notranslate"><span class="pre">AT_EMPTY_PATH</span></code>, in pratica otterremmo gratuitamente l’operazione
<em class="manpage">fxyzzy(3)</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- xyzzyat(AT_FDCWD, path, ..., 0) is equivalent to xyzzy(path,...)
- xyzzyat(fd, &quot;&quot;, ..., AT_EMPTY_PATH) is equivalent to fxyzzy(fd, ...)
</pre></div>
</div>
<p>(Per maggiori dettagli sulla logica delle chiamate *at(), leggete la pagina
man <em class="manpage">openat(2)</em>; per un esempio di AT_EMPTY_PATH, leggere la pagina
man <em class="manpage">fstatat(2)</em>).</p>
<p>Se la vostra nuova chiamata di sistema <em class="manpage">xyzzy(2)</em> prevede un parametro
per descrivere uno scostamento all’interno di un file, usate <code class="docutils literal notranslate"><span class="pre">loff_t</span></code> come
tipo cosicché scostamenti a 64-bit potranno essere supportati anche su
architetture a 32-bit.</p>
<p>Se la vostra nuova chiamata di sistema <em class="manpage">xyzzy(2)</em> prevede l’uso di
funzioni riservate, allora dev’essere gestita da un opportuno bit di privilegio
(verificato con una chiamata a <code class="docutils literal notranslate"><span class="pre">capable()</span></code>), come descritto nella pagina man
<em class="manpage">capabilities(7)</em>.  Scegliete un bit di privilegio già esistente per
gestire la funzionalità associata, ma evitate la combinazione di diverse
funzionalità vagamente collegate dietro lo stesso bit, in quanto va contro il
principio di <em>capabilities</em> di separare i poteri di root.  In particolare,
evitate di aggiungere nuovi usi al fin-troppo-generico privilegio
<code class="docutils literal notranslate"><span class="pre">CAP_SYS_ADMIN</span></code>.</p>
<p>Se la vostra nuova chiamata di sistema <em class="manpage">xyzzy(2)</em> manipola altri
processi oltre a quello chiamato, allora dovrebbe essere limitata (usando
la chiamata <code class="docutils literal notranslate"><span class="pre">ptrace_may_access()</span></code>) di modo che solo un processo chiamante
con gli stessi permessi del processo in oggetto, o con i necessari privilegi,
possa manipolarlo.</p>
<p>Infine, state attenti che in alcune architetture non-x86 la vita delle chiamate
di sistema con argomenti a 64-bit viene semplificata se questi argomenti
ricadono in posizioni dispari (pratica, i parametri 1, 3, 5); questo permette
l’uso di coppie contigue di registri a 32-bit.  (Questo non conta se gli
argomenti sono parte di una struttura dati che viene passata per puntatore).</p>
</div>
<div class="section" id="proporre-l-api">
<h2>Proporre l’API<a class="headerlink" href="#proporre-l-api" title="Permalink to this headline">¶</a></h2>
<p>Al fine di rendere le nuove chiamate di sistema di facile revisione, è meglio
che dividiate le modifiche i pezzi separati.  Questi dovrebbero includere
almeno le seguenti voci in <em>commit</em> distinti (ognuno dei quali sarà descritto
più avanti):</p>
<blockquote>
<div><ul class="simple">
<li>l’essenza dell’implementazione della chiamata di sistema, con i prototipi,
i numeri generici, le modifiche al Kconfig e l’implementazione <em>stub</em> di
ripiego.</li>
<li>preparare la nuova chiamata di sistema per un’architettura specifica,
solitamente x86 (ovvero tutti: x86_64, x86_32 e x32).</li>
<li>un programma di auto-verifica da mettere in <code class="docutils literal notranslate"><span class="pre">tools/testing/selftests/</span></code>
che mostri l’uso della chiamata di sistema.</li>
<li>una bozza di pagina man per la nuova chiamata di sistema. Può essere
scritta nell’email di presentazione, oppure come modifica vera e propria
al repositorio delle pagine man.</li>
</ul>
</div></blockquote>
<p>Le proposte di nuove chiamate di sistema, come ogni altro modifica all’API del
kernel, deve essere sottomessa alla lista di discussione
<a class="reference external" href="mailto:linux-api&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-api<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>.</p>
</div>
<div class="section" id="implementazione-di-chiamate-di-sistema-generiche">
<h2>Implementazione di chiamate di sistema generiche<a class="headerlink" href="#implementazione-di-chiamate-di-sistema-generiche" title="Permalink to this headline">¶</a></h2>
<p>Il principale punto d’accesso alla vostra nuova chiamata di sistema
<em class="manpage">xyzzy(2)</em> verrà chiamato <code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code>; ma, piuttosto che in modo
esplicito, lo aggiungerete tramite la macro <code class="docutils literal notranslate"><span class="pre">SYSCALL_DEFINEn</span></code>. La ‘n’
indica il numero di argomenti della chiamata di sistema; la macro ha come
argomento il nome della chiamata di sistema, seguito dalle coppie (tipo, nome)
per definire i suoi parametri.  L’uso di questa macro permette di avere
i metadati della nuova chiamata di sistema disponibili anche per altri
strumenti.</p>
<p>Il nuovo punto d’accesso necessita anche del suo prototipo di funzione in
<code class="docutils literal notranslate"><span class="pre">include/linux/syscalls.h</span></code>, marcato come asmlinkage di modo da abbinargli
il modo in cui quelle chiamate di sistema verranno invocate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long sys_xyzzy(...);
</pre></div>
</div>
<p>Alcune architetture (per esempio x86) hanno le loro specifiche tabelle di
chiamate di sistema (syscall), ma molte altre architetture condividono una
tabella comune di syscall. Aggiungete alla lista generica la vostra nuova
chiamata di sistema aggiungendo un nuovo elemento alla lista in
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define __NR_xyzzy 292
__SYSCALL(__NR_xyzzy, sys_xyzzy)
</pre></div>
</div>
<p>Aggiornate anche il contatore __NR_syscalls di modo che sia coerente con
l’aggiunta della nuove chiamate di sistema; va notato che se più di una nuova
chiamata di sistema viene aggiunga nella stessa finestra di sviluppo, il numero
della vostra nuova syscall potrebbe essere aggiustato al fine di risolvere i
conflitti.</p>
<p>Il file <code class="docutils literal notranslate"><span class="pre">kernel/sys_ni.c</span></code> fornisce le implementazioni <em>stub</em> di ripiego che
ritornano <code class="docutils literal notranslate"><span class="pre">-ENOSYS</span></code>.  Aggiungete la vostra nuova chiamata di sistema anche
qui:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COND_SYSCALL(xyzzy);
</pre></div>
</div>
<p>La vostra nuova funzionalità del kernel, e la chiamata di sistema che la
controlla, dovrebbero essere opzionali. Quindi, aggiungete un’opzione
<code class="docutils literal notranslate"><span class="pre">CONFIG</span></code> (solitamente in <code class="docutils literal notranslate"><span class="pre">init/Kconfig</span></code>).  Come al solito per le nuove
opzioni <code class="docutils literal notranslate"><span class="pre">CONFIG</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li>Includete una descrizione della nuova funzionalità e della chiamata di
sistema che la controlla.</li>
<li>Rendete l’opzione dipendente da EXPERT se dev’essere nascosta agli utenti
normali.</li>
<li>Nel Makefile, rendere tutti i nuovi file sorgenti, che implementano la
nuova funzionalità, dipendenti dall’opzione CONFIG (per esempio
<code class="docutils literal notranslate"><span class="pre">obj-$(CONFIG_XYZZY_SYSCALL)</span> <span class="pre">+=</span> <span class="pre">xyzzy.o</span></code>).</li>
<li>Controllate due volte che sia possibile generare il kernel con la nuova
opzione CONFIG disabilitata.</li>
</ul>
</div></blockquote>
<p>Per riassumere, vi serve un <em>commit</em> che includa:</p>
<blockquote>
<div><ul class="simple">
<li>un’opzione <code class="docutils literal notranslate"><span class="pre">CONFIG``per</span> <span class="pre">la</span> <span class="pre">nuova</span> <span class="pre">funzione,</span> <span class="pre">normalmente</span> <span class="pre">in</span> <span class="pre">``init/Kconfig</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SYSCALL_DEFINEn(xyzzy,</span> <span class="pre">...)</span></code> per il punto d’accesso</li>
<li>il corrispondente prototipo in <code class="docutils literal notranslate"><span class="pre">include/linux/syscalls.h</span></code></li>
<li>un elemento nella tabella generica in <code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code></li>
<li><em>stub</em> di ripiego in <code class="docutils literal notranslate"><span class="pre">kernel/sys_ni.c</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implementazione-delle-chiamate-di-sistema-x86">
<h2>Implementazione delle chiamate di sistema x86<a class="headerlink" href="#implementazione-delle-chiamate-di-sistema-x86" title="Permalink to this headline">¶</a></h2>
<p>Per collegare la vostra nuova chiamate di sistema alle piattaforme x86,
dovete aggiornate la tabella principale di syscall.  Assumendo che la vostra
nuova chiamata di sistema non sia particolarmente speciale (vedere sotto),
dovete aggiungere un elemento <em>common</em> (per x86_64 e x32) in
arch/x86/entry/syscalls/syscall_64.tbl:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   common   xyzzy     sys_xyzzy
</pre></div>
</div>
<p>e un elemento per <em>i386</em> <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380   i386     xyzzy     sys_xyzzy
</pre></div>
</div>
<p>Ancora una volta, questi numeri potrebbero essere cambiati se generano
conflitti durante la finestra di integrazione.</p>
</div>
<div class="section" id="chiamate-di-sistema-compatibili-generico">
<h2>Chiamate di sistema compatibili (generico)<a class="headerlink" href="#chiamate-di-sistema-compatibili-generico" title="Permalink to this headline">¶</a></h2>
<p>Per molte chiamate di sistema, la stessa implementazione a 64-bit può essere
invocata anche quando il programma in spazio utente è a 32-bit; anche se la
chiamata di sistema include esplicitamente un puntatore, questo viene gestito
in modo trasparente.</p>
<p>Tuttavia, ci sono un paio di situazione dove diventa necessario avere un
livello di gestione della compatibilità per risolvere le differenze di
dimensioni fra 32-bit e 64-bit.</p>
<p>Il primo caso è quando un kernel a 64-bit supporta anche programmi in spazio
utente a 32-bit, perciò dovrà ispezionare aree della memoria (<code class="docutils literal notranslate"><span class="pre">__user</span></code>) che
potrebbero contenere valori a 32-bit o a 64-bit.  In particolar modo, questo
è necessario quando un argomento di una chiamata di sistema è:</p>
<blockquote>
<div><ul class="simple">
<li>un puntatore ad un puntatore</li>
<li>un puntatore ad una struttura dati contenente a sua volta un puntatore
( ad esempio <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iovec</span> <span class="pre">__user</span> <span class="pre">*</span></code>)</li>
<li>un puntatore ad un tipo intero di dimensione variabile (<code class="docutils literal notranslate"><span class="pre">time_t</span></code>,
<code class="docutils literal notranslate"><span class="pre">off_t</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, …)</li>
<li>un puntatore ad una struttura dati contenente un tipo intero di dimensione
variabile.</li>
</ul>
</div></blockquote>
<p>Il secondo caso che richiede un livello di gestione della compatibilità è
quando uno degli argomenti di una chiamata a sistema è esplicitamente un tipo
a 64-bit anche su architetture a 32-bit, per esempio <code class="docutils literal notranslate"><span class="pre">loff_t</span></code> o <code class="docutils literal notranslate"><span class="pre">__u64</span></code>.
In questo caso, un valore che arriva ad un kernel a 64-bit da un’applicazione
a 32-bit verrà diviso in due valori a 32-bit che dovranno essere riassemblati
in questo livello di compatibilità.</p>
<p>(Da notare che non serve questo livello di compatibilità per argomenti che
sono puntatori ad un tipo esplicitamente a 64-bit; per esempio, in
<em class="manpage">splice(2)</em> l’argomento di tipo <code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">__user</span> <span class="pre">*</span></code> non necessita
di una chiamata di sistema <code class="docutils literal notranslate"><span class="pre">compat_</span></code>)</p>
<p>La versione compatibile della nostra chiamata di sistema si chiamerà
<code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code>, e viene aggiunta utilizzando la macro
<code class="docutils literal notranslate"><span class="pre">COMPAT_SYSCALL_DEFINEn()</span></code> (simile a SYSCALL_DEFINEn).  Questa versione
dell’implementazione è parte del kernel a 64-bit ma accetta parametri a 32-bit
che trasformerà secondo le necessità (tipicamente, la versione
<code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code> converte questi valori nello loro corrispondente a 64-bit e
può chiamare la versione <code class="docutils literal notranslate"><span class="pre">sys_</span></code> oppure invocare una funzione che implementa
le parti comuni).</p>
<p>Il punto d’accesso <em>compat</em> deve avere il corrispondente prototipo di funzione
in <code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code>, marcato come asmlinkage di modo da abbinargli
il modo in cui quelle chiamate di sistema verranno invocate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long compat_sys_xyzzy(...);
</pre></div>
</div>
<p>Se la chiamata di sistema prevede una struttura dati organizzata in modo
diverso per sistemi a 32-bit e per quelli a 64-bit, diciamo
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xyzzy_args</span></code>, allora il file d’intestazione
<code class="docutils literal notranslate"><span class="pre">then</span> <span class="pre">the</span> <span class="pre">include/linux/compat.h</span></code> deve includere la sua versione
<em>compatibile</em> (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_xyzzy_args</span></code>); ogni variabile con
dimensione variabile deve avere il proprio tipo <code class="docutils literal notranslate"><span class="pre">compat_</span></code> corrispondente
a quello in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xyzzy_args</span></code>.  La funzione <code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code>
può usare la struttura <code class="docutils literal notranslate"><span class="pre">compat_</span></code> per analizzare gli argomenti ricevuti
da una chiamata a 32-bit.</p>
<p>Per esempio, se avete i seguenti campi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xyzzy_args {
    const char __user *ptr;
    __kernel_long_t varying_val;
    u64 fixed_val;
    /* ... */
};
</pre></div>
</div>
<p>nella struttura <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xyzzy_args</span></code>, allora la struttura
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_xyzzy_args</span></code> dovrebbe avere:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct compat_xyzzy_args {
    compat_uptr_t ptr;
    compat_long_t varying_val;
    u64 fixed_val;
    /* ... */
};
</pre></div>
</div>
<p>La lista generica delle chiamate di sistema ha bisogno di essere
aggiustata al fine di permettere l’uso della versione <em>compatibile</em>;
la voce in <code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code> dovrebbero usare
<code class="docutils literal notranslate"><span class="pre">__SC_COMP</span></code> piuttosto di <code class="docutils literal notranslate"><span class="pre">__SYSCALL</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define __NR_xyzzy 292
__SC_COMP(__NR_xyzzy, sys_xyzzy, compat_sys_xyzzy)
</pre></div>
</div>
<p>Riassumendo, vi serve:</p>
<blockquote>
<div><ul class="simple">
<li>un <code class="docutils literal notranslate"><span class="pre">COMPAT_SYSCALL_DEFINEn(xyzzy,</span> <span class="pre">...)</span></code> per il punto d’accesso
<em>compatibile</em></li>
<li>un prototipo in <code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code></li>
<li>(se necessario) una struttura di compatibilità a 32-bit in
<code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code></li>
<li>una voce <code class="docutils literal notranslate"><span class="pre">__SC_COMP</span></code>, e non <code class="docutils literal notranslate"><span class="pre">__SYSCALL</span></code>, in
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="compatibilita-delle-chiamate-di-sistema-x86">
<h2>Compatibilità delle chiamate di sistema (x86)<a class="headerlink" href="#compatibilita-delle-chiamate-di-sistema-x86" title="Permalink to this headline">¶</a></h2>
<p>Per collegare una chiamata di sistema, su un’architettura x86, con la sua
versione <em>compatibile</em>, è necessario aggiustare la voce nella tabella
delle syscall.</p>
<p>Per prima cosa, la voce in <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code> prende
un argomento aggiuntivo per indicare che un programma in spazio utente
a 32-bit, eseguito su un kernel a 64-bit, dovrebbe accedere tramite il punto
d’accesso compatibile:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380   i386     xyzzy     sys_xyzzy    __ia32_compat_sys_xyzzy
</pre></div>
</div>
<p>Secondo, dovete capire cosa dovrebbe succedere alla nuova chiamata di sistema
per la versione dell’ABI x32.  Qui C’è una scelta da fare: gli argomenti
possono corrisponde alla versione a 64-bit o a quella a 32-bit.</p>
<p>Se c’è un puntatore ad un puntatore, la decisione è semplice: x32 è ILP32,
quindi gli argomenti dovrebbero corrispondere a quelli a 32-bit, e la voce in
<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_64.tbl</span></code> sarà divisa cosicché i programmi
x32 eseguano la chiamata <em>compatibile</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   64       xyzzy     sys_xyzzy
...
555   x32      xyzzy     __x32_compat_sys_xyzzy
</pre></div>
</div>
<p>Se non ci sono puntatori, allora è preferibile riutilizzare la chiamata di
sistema a 64-bit per l’ABI x32 (e di conseguenza la voce in
arch/x86/entry/syscalls/syscall_64.tbl rimane immutata).</p>
<p>In ambo i casi, dovreste verificare che i tipi usati dagli argomenti
abbiano un’esatta corrispondenza da x32 (-mx32) al loro equivalente a
32-bit (-m32) o 64-bit (-m64).</p>
</div>
<div class="section" id="chiamate-di-sistema-che-ritornano-altrove">
<h2>Chiamate di sistema che ritornano altrove<a class="headerlink" href="#chiamate-di-sistema-che-ritornano-altrove" title="Permalink to this headline">¶</a></h2>
<p>Nella maggior parte delle chiamate di sistema, al termine della loro
esecuzione, i programmi in spazio utente riprendono esattamente dal punto
in cui si erano interrotti – quindi dall’istruzione successiva, con lo
stesso <em>stack</em> e con la maggior parte del registri com’erano stati
lasciati prima della chiamata di sistema, e anche con la stessa memoria
virtuale.</p>
<p>Tuttavia, alcune chiamata di sistema fanno le cose in modo differente.
Potrebbero ritornare ad un punto diverso (<code class="docutils literal notranslate"><span class="pre">rt_sigreturn</span></code>) o cambiare
la memoria in spazio utente (<code class="docutils literal notranslate"><span class="pre">fork</span></code>/<code class="docutils literal notranslate"><span class="pre">vfork</span></code>/<code class="docutils literal notranslate"><span class="pre">clone</span></code>) o perfino
l’architettura del programma (<code class="docutils literal notranslate"><span class="pre">execve</span></code>/<code class="docutils literal notranslate"><span class="pre">execveat</span></code>).</p>
<p>Per permettere tutto ciò, l’implementazione nel kernel di questo tipo di
chiamate di sistema potrebbero dover salvare e ripristinare registri
aggiuntivi nello <em>stack</em> del kernel, permettendo così un controllo completo
su dove e come l’esecuzione dovrà continuare dopo l’esecuzione della
chiamata di sistema.</p>
<p>Queste saranno specifiche per ogni architettura, ma tipicamente si definiscono
dei punti d’accesso in <em>assembly</em> per salvare/ripristinare i registri
aggiuntivi e quindi chiamare il vero punto d’accesso per la chiamata di
sistema.</p>
<p>Per l’architettura x86_64, questo è implementato come un punto d’accesso
<code class="docutils literal notranslate"><span class="pre">stub_xyzzy</span></code> in <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64.S</span></code>, e la voce nella tabella
di syscall (<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_64.tbl</span></code>) verrà corretta di
conseguenza:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   common   xyzzy     stub_xyzzy
</pre></div>
</div>
<p>L’equivalente per programmi a 32-bit eseguiti su un kernel a 64-bit viene
normalmente chiamato <code class="docutils literal notranslate"><span class="pre">stub32_xyzzy</span></code> e implementato in
<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64_compat.S</span></code> con la corrispondente voce nella tabella
di syscall <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code> corretta nel
seguente modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380   i386     xyzzy     sys_xyzzy    stub32_xyzzy
</pre></div>
</div>
<p>Se una chiamata di sistema necessita di un livello di compatibilità (come
nella sezione precedente), allora la versione <code class="docutils literal notranslate"><span class="pre">stub32_</span></code> deve invocare
la versione <code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code> piuttosto che quella nativa a 64-bit.  In aggiunta,
se l’implementazione dell’ABI x32 è diversa da quella x86_64, allora la sua
voce nella tabella di syscall dovrà chiamare uno <em>stub</em> che invoca la versione
<code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code>,</p>
<p>Per completezza, sarebbe carino impostare una mappatura cosicché
<em>user-mode</em> Linux (UML) continui a funzionare – la sua tabella di syscall
farà riferimento a stub_xyzzy, ma UML non include l’implementazione
in <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64.S</span></code> (perché UML simula i registri eccetera).
Correggerlo è semplice, basta aggiungere una #define in
<code class="docutils literal notranslate"><span class="pre">arch/x86/um/sys_call_table_64.c</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define stub_xyzzy sys_xyzzy
</pre></div>
</div>
</div>
<div class="section" id="altri-dettagli">
<h2>Altri dettagli<a class="headerlink" href="#altri-dettagli" title="Permalink to this headline">¶</a></h2>
<p>La maggior parte dei kernel tratta le chiamate di sistema allo stesso modo,
ma possono esserci rare eccezioni per le quali potrebbe essere necessario
l’aggiornamento della vostra chiamata di sistema.</p>
<p>Il sotto-sistema di controllo (<em>audit subsystem</em>) è uno di questi casi
speciali; esso include (per architettura) funzioni che classificano alcuni
tipi di chiamate di sistema – in particolare apertura dei file
(<code class="docutils literal notranslate"><span class="pre">open</span></code>/<code class="docutils literal notranslate"><span class="pre">openat</span></code>), esecuzione dei programmi (<code class="docutils literal notranslate"><span class="pre">execve</span></code>/<code class="docutils literal notranslate"><span class="pre">exeveat</span></code>)
oppure multiplatori di socket (<code class="docutils literal notranslate"><span class="pre">socketcall</span></code>). Se la vostra nuova chiamata
di sistema è simile ad una di queste, allora il sistema di controllo dovrebbe
essere aggiornato.</p>
<p>Più in generale, se esiste una chiamata di sistema che è simile alla vostra,
vale la pena fare una ricerca con <code class="docutils literal notranslate"><span class="pre">grep</span></code> su tutto il kernel per la chiamata
di sistema esistente per verificare che non ci siano altri casi speciali.</p>
</div>
<div class="section" id="verifica">
<h2>Verifica<a class="headerlink" href="#verifica" title="Permalink to this headline">¶</a></h2>
<p>Una nuova chiamata di sistema dev’essere, ovviamente, provata; è utile fornire
ai revisori un programma in spazio utente che mostri l’uso della chiamata di
sistema.  Un buon modo per combinare queste cose è quello di aggiungere un
semplice programma di auto-verifica in una nuova cartella in
<code class="docutils literal notranslate"><span class="pre">tools/testing/selftests/</span></code>.</p>
<p>Per una nuova chiamata di sistema, ovviamente, non ci sarà alcuna funzione
in libc e quindi il programma di verifica dovrà invocarla usando <code class="docutils literal notranslate"><span class="pre">syscall()</span></code>;
inoltre, se la nuova chiamata di sistema prevede un nuova struttura dati
visibile in spazio utente, il file d’intestazione necessario dev’essere
installato al fine di compilare il programma.</p>
<p>Assicuratevi che il programma di auto-verifica possa essere eseguito
correttamente su tutte le architetture supportate.  Per esempio, verificate che
funzioni quando viene compilato per x86_64 (-m64), x86_32 (-m32) e x32 (-mx32).</p>
<p>Al fine di una più meticolosa ed estesa verifica della nuova funzionalità,
dovreste considerare l’aggiunta di nuove verifica al progetto ‘Linux Test’,
oppure al progetto xfstests per cambiamenti relativi al filesystem.</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://linux-test-project.github.io/">https://linux-test-project.github.io/</a></li>
<li>git://git.kernel.org/pub/scm/fs/xfs/xfstests-dev.git</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="pagine-man">
<h2>Pagine man<a class="headerlink" href="#pagine-man" title="Permalink to this headline">¶</a></h2>
<p>Tutte le nuove chiamate di sistema dovrebbero avere una pagina man completa,
idealmente usando i marcatori groff, ma anche il puro testo può andare.  Se
state usando groff, è utile che includiate nella email di presentazione una
versione già convertita in formato ASCII: semplificherà la vita dei revisori.</p>
<p>Le pagine man dovrebbero essere in copia-conoscenza verso
<a class="reference external" href="mailto:linux-man&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-man<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>
Per maggiori dettagli, leggere
<a class="reference external" href="https://www.kernel.org/doc/man-pages/patches.html">https://www.kernel.org/doc/man-pages/patches.html</a></p>
</div>
<div class="section" id="non-invocate-chiamate-di-sistema-dal-kernel">
<h2>Non invocate chiamate di sistema dal kernel<a class="headerlink" href="#non-invocate-chiamate-di-sistema-dal-kernel" title="Permalink to this headline">¶</a></h2>
<p>Le chiamate di sistema sono, come già detto prima, punti di interazione fra
lo spazio utente e il kernel.  Perciò, le chiamate di sistema come
<code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code> o <code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code> dovrebbero essere chiamate solo dallo
spazio utente attraverso la tabella syscall, ma non da nessun altro punto nel
kernel.  Se la nuova funzionalità è utile all’interno del kernel, per esempio
dev’essere condivisa fra una vecchia e una nuova chiamata di sistema o
dev’essere utilizzata da una chiamata di sistema e la sua variante compatibile,
allora dev’essere implementata come una funzione di supporto
(<em>helper function</em>) (per esempio <code class="docutils literal notranslate"><span class="pre">kern_xyzzy()</span></code>).  Questa funzione potrà
essere chiamata dallo <em>stub</em> (<code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code>), dalla variante compatibile
(<code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code>), e/o da altri parti del kernel.</p>
<p>Sui sistemi x86 a 64-bit, a partire dalla versione v4.17 è un requisito
fondamentale quello di non invocare chiamate di sistema all’interno del kernel.
Esso usa una diversa convenzione per l’invocazione di chiamate di sistema dove
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_regs</span></code> viene decodificata al volo in una funzione che racchiude
la chiamata di sistema la quale verrà eseguita successivamente.
Questo significa che verranno passati solo i parametri che sono davvero
necessari ad una specifica chiamata di sistema, invece che riempire ogni volta
6 registri del processore con contenuti presi dallo spazio utente (potrebbe
causare seri problemi nella sequenza di chiamate).</p>
<p>Inoltre, le regole su come i dati possano essere usati potrebbero differire
fra il kernel e l’utente.  Questo è un altro motivo per cui invocare
<code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code> è generalmente una brutta idea.</p>
<p>Eccezioni a questa regola vengono accettate solo per funzioni d’architetture
che surclassano quelle generiche, per funzioni d’architettura di compatibilità,
o per altro codice in arch/</p>
</div>
<div class="section" id="riferimenti-e-fonti">
<h2>Riferimenti e fonti<a class="headerlink" href="#riferimenti-e-fonti" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">Articolo di Michael Kerris su LWN sull’uso dell’argomento flags nelle
chiamate di sistema: <a class="reference external" href="https://lwn.net/Articles/585415/">https://lwn.net/Articles/585415/</a></p>
</li>
<li><p class="first">Articolo di Michael Kerris su LWN su come gestire flag sconosciuti in
una chiamata di sistema: <a class="reference external" href="https://lwn.net/Articles/588444/">https://lwn.net/Articles/588444/</a></p>
</li>
<li><p class="first">Articolo di Jake Edge su LWN che descrive i limiti degli argomenti a 64-bit
delle chiamate di sistema: <a class="reference external" href="https://lwn.net/Articles/311630/">https://lwn.net/Articles/311630/</a></p>
</li>
<li><p class="first">Una coppia di articoli di David Drysdale che descrivono i dettagli del
percorso implementativo di una chiamata di sistema per la versione v3.14:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/604287/">https://lwn.net/Articles/604287/</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/604515/">https://lwn.net/Articles/604515/</a></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Requisiti specifici alle architetture sono discussi nella pagina man
<em class="manpage">syscall(2)</em> :
<a class="reference external" href="http://man7.org/linux/man-pages/man2/syscall.2.html#NOTES">http://man7.org/linux/man-pages/man2/syscall.2.html#NOTES</a></p>
</li>
<li><p class="first">Collezione di email di Linux Torvalds sui problemi relativi a <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code>:
<a class="reference external" href="http://yarchive.net/comp/linux/ioctl.html">http://yarchive.net/comp/linux/ioctl.html</a></p>
</li>
<li><p class="first">“Come non inventare interfacce del kernel”, Arnd Bergmann,
<a class="reference external" href="http://www.ukuug.org/events/linux2007/2007/papers/Bergmann.pdf">http://www.ukuug.org/events/linux2007/2007/papers/Bergmann.pdf</a></p>
</li>
<li><p class="first">Articolo di Michael Kerris su LWN sull’evitare nuovi usi di CAP_SYS_ADMIN:
<a class="reference external" href="https://lwn.net/Articles/486306/">https://lwn.net/Articles/486306/</a></p>
</li>
<li><p class="first">Raccomandazioni da Andrew Morton circa il fatto che tutte le informazioni
su una nuova chiamata di sistema dovrebbero essere contenute nello stesso
filone di discussione di email: <a class="reference external" href="https://lkml.org/lkml/2014/7/24/641">https://lkml.org/lkml/2014/7/24/641</a></p>
</li>
<li><p class="first">Raccomandazioni da Michael Kerrisk circa il fatto che le nuove chiamate di
sistema dovrebbero avere una pagina man: <a class="reference external" href="https://lkml.org/lkml/2014/6/13/309">https://lkml.org/lkml/2014/6/13/309</a></p>
</li>
<li><p class="first">Consigli da Thomas Gleixner sul fatto che il collegamento all’architettura
x86 dovrebbe avvenire in un <em>commit</em> differente:
<a class="reference external" href="https://lkml.org/lkml/2014/11/19/254">https://lkml.org/lkml/2014/11/19/254</a></p>
</li>
<li><p class="first">Consigli da Greg Kroah-Hartman circa la bontà d’avere una pagina man e un
programma di auto-verifica per le nuove chiamate di sistema:
<a class="reference external" href="https://lkml.org/lkml/2014/3/19/710">https://lkml.org/lkml/2014/3/19/710</a></p>
</li>
<li><p class="first">Discussione di Michael Kerrisk sulle nuove chiamate di sistema contro
le estensioni <em class="manpage">prctl(2)</em>: <a class="reference external" href="https://lkml.org/lkml/2014/6/3/411">https://lkml.org/lkml/2014/6/3/411</a></p>
</li>
<li><p class="first">Consigli da Ingo Molnar che le chiamate di sistema con più argomenti
dovrebbero incapsularli in una struttura che includa un argomento
<em>size</em> per garantire l’estensibilità futura:
<a class="reference external" href="https://lkml.org/lkml/2015/7/30/117">https://lkml.org/lkml/2015/7/30/117</a></p>
</li>
<li><p class="first">Un certo numero di casi strani emersi dall’uso (riuso) dei flag O_*:</p>
<blockquote>
<div><ul class="simple">
<li>commit 75069f2b5bfb (“vfs: renumber FMODE_NONOTIFY and add to uniqueness
check”)</li>
<li>commit 12ed2e36c98a (“fanotify: FMODE_NONOTIFY and __O_SYNC in sparc
conflict”)</li>
<li>commit bb458c644a59 (“Safer ABI for O_TMPFILE”)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Discussion from Matthew Wilcox about restrictions on 64-bit arguments:
<a class="reference external" href="https://lkml.org/lkml/2008/12/12/187">https://lkml.org/lkml/2008/12/12/187</a></p>
</li>
<li><p class="first">Raccomandazioni da Greg Kroah-Hartman sul fatto che i flag sconosciuti dovrebbero
essere controllati: <a class="reference external" href="https://lkml.org/lkml/2014/7/17/577">https://lkml.org/lkml/2014/7/17/577</a></p>
</li>
<li><p class="first">Raccomandazioni da Linus Torvalds che le chiamate di sistema x32 dovrebbero
favorire la compatibilità con le versioni a 64-bit piuttosto che quelle a 32-bit:
<a class="reference external" href="https://lkml.org/lkml/2011/8/31/244">https://lkml.org/lkml/2011/8/31/244</a></p>
</li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="magic-number.html" class="btn btn-neutral float-right" title="I numeri magici di Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="applying-patches.html" class="btn btn-neutral float-left" title="Applicare patch al kernel Linux" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>