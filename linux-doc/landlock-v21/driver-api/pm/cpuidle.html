

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>CPU Idle Time Management &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Device Power Management Basics" href="devices.html" />
    <link rel="prev" title="CPU and Device Power Management" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.9.0-rc8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">CPU and Device Power Management</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">CPU Idle Time Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cpu-idle-time-management-subsystem">CPU Idle Time Management Subsystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-idle-time-governors">CPU Idle Time Governors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-idle-time-management-drivers">CPU Idle Time Management Drivers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="devices.html">Device Power Management Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="notifiers.html">Suspend/Hibernation Notifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">Device Power Management Data Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">CPU and Device Power Management</a> &raquo;</li>
        
      <li>CPU Idle Time Management</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/pm/cpuidle.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cpu-idle-time-management">
<h1>CPU Idle Time Management<a class="headerlink" href="#cpu-idle-time-management" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Copyright:</th><td class="field-body">© 2019 Intel Corporation</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rafael&#46;j&#46;wysocki&#37;&#52;&#48;intel&#46;com">rafael<span>&#46;</span>j<span>&#46;</span>wysocki<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="cpu-idle-time-management-subsystem">
<h2>CPU Idle Time Management Subsystem<a class="headerlink" href="#cpu-idle-time-management-subsystem" title="Permalink to this headline">¶</a></h2>
<p>Every time one of the logical CPUs in the system (the entities that appear to
fetch and execute instructions: hardware threads, if present, or processor
cores) is idle after an interrupt or equivalent wakeup event, which means that
there are no tasks to run on it except for the special “idle” task associated
with it, there is an opportunity to save energy for the processor that it
belongs to.  That can be done by making the idle logical CPU stop fetching
instructions from memory and putting some of the processor’s functional units
depended on by it into an idle state in which they will draw less power.</p>
<p>However, there may be multiple different idle states that can be used in such a
situation in principle, so it may be necessary to find the most suitable one
(from the kernel perspective) and ask the processor to use (or “enter”) that
particular idle state.  That is the role of the CPU idle time management
subsystem in the kernel, called <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>.</p>
<p>The design of <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> is modular and based on the code duplication avoidance
principle, so the generic code that in principle need not depend on the hardware
or platform design details in it is separate from the code that interacts with
the hardware.  It generally is divided into three categories of functional
units: <em>governors</em> responsible for selecting idle states to ask the processor
to enter, <em>drivers</em> that pass the governors’ decisions on to the hardware and
the <em>core</em> providing a common framework for them.</p>
</div>
<div class="section" id="cpu-idle-time-governors">
<h2>CPU Idle Time Governors<a class="headerlink" href="#cpu-idle-time-governors" title="Permalink to this headline">¶</a></h2>
<p>A CPU idle time (<code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>) governor is a bundle of policy code invoked when
one of the logical CPUs in the system turns out to be idle.  Its role is to
select an idle state to ask the processor to enter in order to save some energy.</p>
<p><code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> governors are generic and each of them can be used on any hardware
platform that the Linux kernel can run on.  For this reason, data structures
operated on by them cannot depend on any hardware architecture or platform
design details as well.</p>
<p>The governor itself is represented by a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_governor</span></code> object
containing four callback pointers, <code class="xref c c-member docutils literal notranslate"><span class="pre">enable</span></code>, <code class="xref c c-member docutils literal notranslate"><span class="pre">disable</span></code>,
<code class="xref c c-member docutils literal notranslate"><span class="pre">select</span></code>, <code class="xref c c-member docutils literal notranslate"><span class="pre">reflect</span></code>, a <code class="xref c c-member docutils literal notranslate"><span class="pre">rating</span></code> field described
below, and a name (string) used for identifying it.</p>
<p>For the governor to be available at all, that object needs to be registered
with the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> core by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register_governor()</span></code> with
a pointer to it passed as the argument.  If successful, that causes the core to
add the governor to the global list of available governors and, if it is the
only one in the list (that is, the list was empty before) or the value of its
<code class="xref c c-member docutils literal notranslate"><span class="pre">rating</span></code> field is greater than the value of that field for the
governor currently in use, or the name of the new governor was passed to the
kernel as the value of the <code class="docutils literal notranslate"><span class="pre">cpuidle.governor=</span></code> command line parameter, the new
governor will be used from that point on (there can be only one <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
governor in use at a time).  Also, user space can choose the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
governor to use at run time via <code class="docutils literal notranslate"><span class="pre">sysfs</span></code>.</p>
<p>Once registered, <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> governors cannot be unregistered, so it is not
practical to put them into loadable kernel modules.</p>
<p>The interface between <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> governors and the core consists of four
callbacks:</p>
<dl class="docutils">
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">enable</span></code></dt>
<dd><div class="first highlight-none notranslate"><div class="highlight"><pre><span></span>int (*enable) (struct cpuidle_driver *drv, struct cpuidle_device *dev);
</pre></div>
</div>
<p>The role of this callback is to prepare the governor for handling the
(logical) CPU represented by the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> object pointed
to by the <code class="docutils literal notranslate"><span class="pre">dev</span></code> argument.  The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object pointed
to by the <code class="docutils literal notranslate"><span class="pre">drv</span></code> argument represents the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver to be used
with that CPU (among other things, it should contain the list of
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> objects representing idle states that the
processor holding the given CPU can be asked to enter).</p>
<p class="last">It may fail, in which case it is expected to return a negative error
code, and that causes the kernel to run the architecture-specific
default code for idle CPUs on the CPU in question instead of <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
until the <code class="docutils literal notranslate"><span class="pre">-&gt;enable()</span></code> governor callback is invoked for that CPU
again.</p>
</dd>
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">disable</span></code></dt>
<dd><div class="first highlight-none notranslate"><div class="highlight"><pre><span></span>void (*disable) (struct cpuidle_driver *drv, struct cpuidle_device *dev);
</pre></div>
</div>
<p>Called to make the governor stop handling the (logical) CPU represented
by the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> object pointed to by the <code class="docutils literal notranslate"><span class="pre">dev</span></code>
argument.</p>
<p class="last">It is expected to reverse any changes made by the <code class="docutils literal notranslate"><span class="pre">-&gt;enable()</span></code>
callback when it was last invoked for the target CPU, free all memory
allocated by that callback and so on.</p>
</dd>
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">select</span></code></dt>
<dd><div class="first highlight-none notranslate"><div class="highlight"><pre><span></span>int (*select) (struct cpuidle_driver *drv, struct cpuidle_device *dev,
               bool *stop_tick);
</pre></div>
</div>
<p>Called to select an idle state for the processor holding the (logical)
CPU represented by the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> object pointed to by the
<code class="docutils literal notranslate"><span class="pre">dev</span></code> argument.</p>
<p>The list of idle states to take into consideration is represented by the
<code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> objects held by the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object pointed to by the <code class="docutils literal notranslate"><span class="pre">drv</span></code> argument (which
represents the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver to be used with the CPU at hand).  The
value returned by this callback is interpreted as an index into that
array (unless it is a negative error code).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stop_tick</span></code> argument is used to indicate whether or not to stop
the scheduler tick before asking the processor to enter the selected
idle state.  When the <code class="docutils literal notranslate"><span class="pre">bool</span></code> variable pointed to by it (which is set
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before invoking this callback) is cleared to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the
processor will be asked to enter the selected idle state without
stopping the scheduler tick on the given CPU (if the tick has been
stopped on that CPU already, however, it will not be restarted before
asking the processor to enter the idle state).</p>
<p class="last">This callback is mandatory (i.e. the <code class="xref c c-member docutils literal notranslate"><span class="pre">select</span></code> callback pointer
in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_governor</span></code> must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for the registration
of the governor to succeed).</p>
</dd>
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">reflect</span></code></dt>
<dd><div class="first highlight-none notranslate"><div class="highlight"><pre><span></span>void (*reflect) (struct cpuidle_device *dev, int index);
</pre></div>
</div>
<p class="last">Called to allow the governor to evaluate the accuracy of the idle state
selection made by the <code class="docutils literal notranslate"><span class="pre">-&gt;select()</span></code> callback (when it was invoked last
time) and possibly use the result of that to improve the accuracy of
idle state selections in the future.</p>
</dd>
</dl>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> governors are required to take power management
quality of service (PM QoS) constraints on the processor wakeup latency into
account when selecting idle states.  In order to obtain the current effective
PM QoS wakeup latency constraint for a given CPU, a <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> governor is
expected to pass the number of the CPU to
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_governor_latency_req()</span></code>.  Then, the governor’s <code class="docutils literal notranslate"><span class="pre">-&gt;select()</span></code>
callback must not return the index of an indle state whose
<code class="xref c c-member docutils literal notranslate"><span class="pre">exit_latency</span></code> value is greater than the number returned by that
function.</p>
</div>
<div class="section" id="cpu-idle-time-management-drivers">
<h2>CPU Idle Time Management Drivers<a class="headerlink" href="#cpu-idle-time-management-drivers" title="Permalink to this headline">¶</a></h2>
<p>CPU idle time management (<code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>) drivers provide an interface between the
other parts of <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> and the hardware.</p>
<p>First of all, a <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver has to populate the <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array
of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> objects included in the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object
representing it.  Going forward this array will represent the list of available
idle states that the processor hardware can be asked to enter shared by all of
the logical CPUs handled by the given driver.</p>
<p>The entries in the <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array are expected to be sorted by the
value of the <code class="xref c c-member docutils literal notranslate"><span class="pre">target_residency</span></code> field in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> in
the ascending order (that is, index 0 should correspond to the idle state with
the minimum value of <code class="xref c c-member docutils literal notranslate"><span class="pre">target_residency</span></code>).  [Since the
<code class="xref c c-member docutils literal notranslate"><span class="pre">target_residency</span></code> value is expected to reflect the “depth” of the
idle state represented by the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> object holding it, this
sorting order should be the same as the ascending sorting order by the idle
state “depth”.]</p>
<p>Three fields in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> are used by the existing <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
governors for computations related to idle state selection:</p>
<dl class="docutils">
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">target_residency</span></code></dt>
<dd>Minimum time to spend in this idle state including the time needed to
enter it (which may be substantial) to save more energy than could
be saved by staying in a shallower idle state for the same amount of
time, in microseconds.</dd>
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">exit_latency</span></code></dt>
<dd>Maximum time it will take a CPU asking the processor to enter this idle
state to start executing the first instruction after a wakeup from it,
in microseconds.</dd>
<dt><code class="xref c c-member docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Flags representing idle state properties.  Currently, governors only use
the <code class="docutils literal notranslate"><span class="pre">CPUIDLE_FLAG_POLLING</span></code> flag which is set if the given object
does not represent a real idle state, but an interface to a software
“loop” that can be used in order to avoid asking the processor to enter
any idle state at all.  [There are other flags used by the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
core in special situations.]</dd>
</dl>
<p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">enter</span></code> callback pointer in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code>, which must not
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, points to the routine to execute in order to ask the processor to
enter this particular idle state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*enter) (struct cpuidle_device *dev, struct cpuidle_driver *drv,
               int index);
</pre></div>
</div>
<p>The first two arguments of it point to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> object
representing the logical CPU running this callback and the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object representing the driver itself, respectively,
and the last one is an index of the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> entry in the driver’s
<code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array representing the idle state to ask the processor to
enter.</p>
<p>The analogous <code class="docutils literal notranslate"><span class="pre">-&gt;enter_s2idle()</span></code> callback in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_state</span></code> is used
only for implementing the suspend-to-idle system-wide power management feature.
The difference between in and <code class="docutils literal notranslate"><span class="pre">-&gt;enter()</span></code> is that it must not re-enable
interrupts at any point (even temporarily) or attempt to change the states of
clock event devices, which the <code class="docutils literal notranslate"><span class="pre">-&gt;enter()</span></code> callback may do sometimes.</p>
<p>Once the <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array has been populated, the number of valid
entries in it has to be stored in the <code class="xref c c-member docutils literal notranslate"><span class="pre">state_count</span></code> field of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object representing the driver.  Moreover, if any
entries in the <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array represent “coupled” idle states (that
is, idle states that can only be asked for if multiple related logical CPUs are
idle), the <code class="xref c c-member docutils literal notranslate"><span class="pre">safe_state_index</span></code> field in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> needs
to be the index of an idle state that is not “coupled” (that is, one that can be
asked for if only one logical CPU is idle).</p>
<p>In addition to that, if the given <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver is only going to handle a
subset of logical CPUs in the system, the <code class="xref c c-member docutils literal notranslate"><span class="pre">cpumask</span></code> field in its
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object must point to the set (mask) of CPUs that will be
handled by it.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver can only be used after it has been registered.  If there
are no “coupled” idle state entries in the driver’s <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array,
that can be accomplished by passing the driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_driver</span></code> object
to <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register_driver()</span></code>.  Otherwise, <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register()</span></code>
should be used for this purpose.</p>
<p>However, it also is necessary to register <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects for
all of the logical CPUs to be handled by the given <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver with the
help of <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register_device()</span></code> after the driver has been registered
and <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register_driver()</span></code>, unlike <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register()</span></code>,
does not do that automatically.  For this reason, the drivers that use
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register_driver()</span></code> to register themselves must also take care
of registering the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects as needed, so it is generally
recommended to use <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_register()</span></code> for <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver
registration in all cases.</p>
<p>The registration of a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> object causes the <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code>
<code class="docutils literal notranslate"><span class="pre">sysfs</span></code> interface to be created and the governor’s <code class="docutils literal notranslate"><span class="pre">-&gt;enable()</span></code> callback to
be invoked for the logical CPU represented by it, so it must take place after
registering the driver that will handle the CPU in question.</p>
<p><code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> drivers and <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects can be unregistered
when they are not necessary any more which allows some resources associated with
them to be released.  Due to dependencies between them, all of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects representing CPUs handled by the given
<code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver must be unregistered, with the help of
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_unregister_device()</span></code>, before calling
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_unregister_driver()</span></code> to unregister the driver.  Alternatively,
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_unregister()</span></code> can be called to unregister a <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver
along with all of the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects representing CPUs handled
by it.</p>
<p><code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> drivers can respond to runtime system configuration changes that
lead to modifications of the list of available processor idle states (which can
happen, for example, when the system’s power source is switched from AC to
battery or the other way around).  Upon a notification of such a change,
a <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> driver is expected to call <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_pause_and_lock()</span></code> to
turn <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> off temporarily and then <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_disable_device()</span></code> for
all of the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects representing CPUs affected by that
change.  Next, it can update its <code class="xref c c-member docutils literal notranslate"><span class="pre">states</span></code> array in accordance with
the new configuration of the system, call <code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_enable_device()</span></code> for
all of the relevant <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpuidle_device</span></code> objects and invoke
<code class="xref c c-func docutils literal notranslate"><span class="pre">cpuidle_resume_and_unlock()</span></code> to allow <code class="docutils literal notranslate"><span class="pre">CPUIdle</span></code> to be used again.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="devices.html" class="btn btn-neutral float-right" title="Device Power Management Basics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="CPU and Device Power Management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>