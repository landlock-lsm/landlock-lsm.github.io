

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Documentation for Kdump - The kexec-based Crash Dumping Solution &mdash; The Linux Kernel 5.2.0+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Documentation for Kdump - The kexec-based Crash Dumping Solution</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/kdump/kdump.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="documentation-for-kdump-the-kexec-based-crash-dumping-solution">
<h1>Documentation for Kdump - The kexec-based Crash Dumping Solution<a class="headerlink" href="#documentation-for-kdump-the-kexec-based-crash-dumping-solution" title="Permalink to this headline">¶</a></h1>
<p>This document includes overview, setup and installation, and analysis
information.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Kdump uses kexec to quickly boot to a dump-capture kernel whenever a
dump of the system kernel’s memory needs to be taken (for example, when
the system panics). The system kernel’s memory image is preserved across
the reboot and is accessible to the dump-capture kernel.</p>
<p>You can use common commands, such as cp and scp, to copy the
memory image to a dump file on the local disk, or across the network to
a remote system.</p>
<p>Kdump and kexec are currently supported on the x86, x86_64, ppc64, ia64,
s390x, arm and arm64 architectures.</p>
<p>When the system kernel boots, it reserves a small section of memory for
the dump-capture kernel. This ensures that ongoing Direct Memory Access
(DMA) from the system kernel does not corrupt the dump-capture kernel.
The kexec -p command loads the dump-capture kernel into this reserved
memory.</p>
<p>On x86 machines, the first 640 KB of physical memory is needed to boot,
regardless of where the kernel loads. Therefore, kexec backs up this
region just before rebooting into the dump-capture kernel.</p>
<p>Similarly on PPC64 machines first 32KB of physical memory is needed for
booting regardless of where the kernel is loaded and to support 64K page
size kexec backs up the first 64KB memory.</p>
<p>For s390x, when kdump is triggered, the crashkernel region is exchanged
with the region [0, crashkernel region size] and then the kdump kernel
runs in [0, crashkernel region size]. Therefore no relocatable kernel is
needed for s390x.</p>
<p>All of the necessary information about the system kernel’s core image is
encoded in the ELF format, and stored in a reserved area of memory
before a crash. The physical address of the start of the ELF header is
passed to the dump-capture kernel through the elfcorehdr= boot
parameter. Optionally the size of the ELF header can also be passed
when using the elfcorehdr=[size[KMG]&#64;]offset[KMG] syntax.</p>
<p>With the dump-capture kernel, you can access the memory image through
/proc/vmcore. This exports the dump as an ELF-format file that you can
write out using file copy commands such as cp or scp. Further, you can
use analysis tools such as the GNU Debugger (GDB) and the Crash tool to
debug the dump file. This method ensures that the dump pages are correctly
ordered.</p>
</div>
<div class="section" id="setup-and-installation">
<h2>Setup and Installation<a class="headerlink" href="#setup-and-installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="install-kexec-tools">
<h3>Install kexec-tools<a class="headerlink" href="#install-kexec-tools" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Login as the root user.</li>
<li>Download the kexec-tools user-space package from the following URL:</li>
</ol>
<p><a class="reference external" href="http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz">http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz</a></p>
<p>This is a symlink to the latest version.</p>
<p>The latest kexec-tools git tree is available at:</p>
<ul class="simple">
<li>git://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git</li>
<li><a class="reference external" href="http://www.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git">http://www.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git</a></li>
</ul>
<p>There is also a gitweb interface available at
<a class="reference external" href="http://www.kernel.org/git/?p=utils/kernel/kexec/kexec-tools.git">http://www.kernel.org/git/?p=utils/kernel/kexec/kexec-tools.git</a></p>
<p>More information about kexec-tools can be found at
<a class="reference external" href="http://horms.net/projects/kexec/">http://horms.net/projects/kexec/</a></p>
<ol class="arabic" start="3">
<li><p class="first">Unpack the tarball with the tar command, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tar xvpzf kexec-tools.tar.gz
</pre></div>
</div>
</li>
<li><p class="first">Change to the kexec-tools directory, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cd kexec-tools-VERSION
</pre></div>
</div>
</li>
<li><p class="first">Configure the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./configure
</pre></div>
</div>
</li>
<li><p class="first">Compile the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make
</pre></div>
</div>
</li>
<li><p class="first">Install the package, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>make install
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="build-the-system-and-dump-capture-kernels">
<h3>Build the system and dump-capture kernels<a class="headerlink" href="#build-the-system-and-dump-capture-kernels" title="Permalink to this headline">¶</a></h3>
<p>There are two possible methods of using Kdump.</p>
<ol class="arabic simple">
<li>Build a separate custom dump-capture kernel for capturing the
kernel core dump.</li>
<li>Or use the system kernel binary itself as dump-capture kernel and there is
no need to build a separate dump-capture kernel. This is possible
only with the architectures which support a relocatable kernel. As
of today, i386, x86_64, ppc64, ia64, arm and arm64 architectures support
relocatable kernel.</li>
</ol>
<p>Building a relocatable kernel is advantageous from the point of view that
one does not have to build a second kernel for capturing the dump. But
at the same time one might want to build a custom dump capture kernel
suitable to his needs.</p>
<p>Following are the configuration setting required for system and
dump-capture kernels for enabling kdump support.</p>
</div>
<div class="section" id="system-kernel-config-options">
<h3>System kernel config options<a class="headerlink" href="#system-kernel-config-options" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Enable “kexec system call” in “Processor type and features.”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KEXEC=y
</pre></div>
</div>
</li>
<li><p class="first">Enable “sysfs file system support” in “Filesystem” -&gt; “Pseudo
filesystems.” This is usually enabled by default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_SYSFS=y
</pre></div>
</div>
<p>Note that “sysfs file system support” might not appear in the “Pseudo
filesystems” menu if “Configure standard kernel features (for small
systems)” is not enabled in “General Setup.” In this case, check the
.config file itself to ensure that sysfs is turned on, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>grep &#39;CONFIG_SYSFS&#39; .config
</pre></div>
</div>
</li>
<li><p class="first">Enable “Compile the kernel with debug info” in “Kernel hacking.”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_DEBUG_INFO=Y
</pre></div>
</div>
<p>This causes the kernel to be built with debug symbols. The dump
analysis tools require a vmlinux with debug symbols in order to read
and analyze a dump file.</p>
</li>
</ol>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-independent">
<h3>Dump-capture kernel config options (Arch Independent)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-independent" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Enable “kernel crash dumps” support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_CRASH_DUMP=y
</pre></div>
</div>
</li>
<li><p class="first">Enable “/proc/vmcore support” under “Filesystems” -&gt; “Pseudo filesystems”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_PROC_VMCORE=y
</pre></div>
</div>
<p>(CONFIG_PROC_VMCORE is set by default when CONFIG_CRASH_DUMP is selected.)</p>
</li>
</ol>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-dependent-i386-and-x86-64">
<h3>Dump-capture kernel config options (Arch Dependent, i386 and x86_64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-i386-and-x86-64" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">On i386, enable high memory support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_HIGHMEM64G=y
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_HIGHMEM4G
</pre></div>
</div>
</li>
<li><p class="first">On i386 and x86_64, disable symmetric multi-processing support
under “Processor type and features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_SMP=n
</pre></div>
</div>
<p>(If CONFIG_SMP=y, then specify maxcpus=1 on the kernel command line
when loading the dump-capture kernel, see section “Load the Dump-capture
Kernel”.)</p>
</li>
<li><p class="first">If one wants to build and use a relocatable kernel,
Enable “Build a relocatable kernel” support under “Processor type and
features”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_RELOCATABLE=y
</pre></div>
</div>
</li>
<li><p class="first">Use a suitable value for “Physical address where the kernel is
loaded” (under “Processor type and features”). This only appears when
“kernel crash dumps” is enabled. A suitable value depends upon
whether kernel is relocatable or not.</p>
<p>If you are using a relocatable kernel use CONFIG_PHYSICAL_START=0x100000
This will compile the kernel for physical address 1MB, but given the fact
kernel is relocatable, it can be run from any physical address hence
kexec boot loader will load it in memory region reserved for dump-capture
kernel.</p>
<p>Otherwise it should be the start of memory region reserved for
second kernel using boot parameter “crashkernel=Y&#64;X”. Here X is
start of memory region reserved for dump-capture kernel.
Generally X is 16MB (0x1000000). So you can set
CONFIG_PHYSICAL_START=0x1000000</p>
</li>
<li><p class="first">Make and install the kernel and its modules. DO NOT add this kernel
to the boot loader configuration files.</p>
</li>
</ol>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-dependent-ppc64">
<h3>Dump-capture kernel config options (Arch Dependent, ppc64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-ppc64" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Enable “Build a kdump crash kernel” support under “Kernel” options:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_CRASH_DUMP=y
</pre></div>
</div>
</li>
<li><p class="first">Enable “Build a relocatable kernel” support:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_RELOCATABLE=y
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div>Make and install the kernel and its modules.</div></blockquote>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-dependent-ia64">
<h3>Dump-capture kernel config options (Arch Dependent, ia64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-ia64" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">No specific options are required to create a dump-capture kernel
for ia64, other than those specified in the arch independent section
above. This means that it is possible to use the system kernel
as a dump-capture kernel if desired.</p>
<p>The crashkernel region can be automatically placed by the system
kernel at run time. This is done by specifying the base address as 0,
or omitting it all together:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M@0
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=256M
</pre></div>
</div>
<p>If the start address is specified, note that the start address of the
kernel will be aligned to 64Mb, so if the start address is not then
any space below the alignment point will be wasted.</p>
</li>
</ul>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-dependent-arm">
<h3>Dump-capture kernel config options (Arch Dependent, arm)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-arm" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">To use a relocatable kernel,
Enable “AUTO_ZRELADDR” support under “Boot” options:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AUTO_ZRELADDR=y
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="dump-capture-kernel-config-options-arch-dependent-arm64">
<h3>Dump-capture kernel config options (Arch Dependent, arm64)<a class="headerlink" href="#dump-capture-kernel-config-options-arch-dependent-arm64" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Please note that kvm of the dump-capture kernel will not be enabled
on non-VHE systems even if it is configured. This is because the CPU
will not be reset to EL2 on panic.</li>
</ul>
</div>
</div>
<div class="section" id="extended-crashkernel-syntax">
<h2>Extended crashkernel syntax<a class="headerlink" href="#extended-crashkernel-syntax" title="Permalink to this headline">¶</a></h2>
<p>While the “crashkernel=size[&#64;offset]” syntax is sufficient for most
configurations, sometimes it’s handy to have the reserved memory dependent
on the value of System RAM – that’s mostly for distributors that pre-setup
the kernel command line to avoid a unbootable system after some memory has
been removed from the machine.</p>
<p>The syntax is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=&lt;range1&gt;:&lt;size1&gt;[,&lt;range2&gt;:&lt;size2&gt;,...][@offset]
range=start-[end]
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>crashkernel=512M-2G:64M,2G-:128M
</pre></div>
</div>
<p>This would mean:</p>
<blockquote>
<div><ol class="arabic simple">
<li>if the RAM is smaller than 512M, then don’t reserve anything
(this is the “rescue” case)</li>
<li>if the RAM size is between 512M and 2G (exclusive), then reserve 64M</li>
<li>if the RAM size is larger than 2G, then reserve 128M</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="boot-into-system-kernel">
<h2>Boot into System Kernel<a class="headerlink" href="#boot-into-system-kernel" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Update the boot loader (such as grub, yaboot, or lilo) configuration
files as necessary.</p>
</li>
<li><p class="first">Boot the system kernel with the boot parameter “crashkernel=Y&#64;X”,
where Y specifies how much memory to reserve for the dump-capture kernel
and X specifies the beginning of this reserved memory. For example,
“<a class="reference external" href="mailto:crashkernel=64M&#37;&#52;&#48;16M">crashkernel=64M<span>&#64;</span>16M</a>” tells the system kernel to reserve 64 MB of memory
starting at physical address 0x01000000 (16MB) for the dump-capture kernel.</p>
<p>On x86 and x86_64, use “<a class="reference external" href="mailto:crashkernel=64M&#37;&#52;&#48;16M">crashkernel=64M<span>&#64;</span>16M</a>”.</p>
<p>On ppc64, use “<a class="reference external" href="mailto:crashkernel=128M&#37;&#52;&#48;32M">crashkernel=128M<span>&#64;</span>32M</a>”.</p>
<p>On ia64, <a class="reference external" href="mailto:256M&#37;&#52;&#48;256M">256M<span>&#64;</span>256M</a> is a generous value that typically works.
The region may be automatically placed on ia64, see the
dump-capture kernel config option notes above.
If use sparse memory, the size should be rounded to GRANULE boundaries.</p>
<p>On s390x, typically use “crashkernel=xxM”. The value of xx is dependent
on the memory consumption of the kdump system. In general this is not
dependent on the memory size of the production system.</p>
<p>On arm, the use of “crashkernel=Y&#64;X” is no longer necessary; the
kernel will automatically locate the crash kernel image within the
first 512MB of RAM if X is not given.</p>
<p>On arm64, use “crashkernel=Y[&#64;X]”.  Note that the start address of
the kernel, X if explicitly specified, must be aligned to 2MiB (0x200000).</p>
</li>
</ol>
</div>
<div class="section" id="load-the-dump-capture-kernel">
<h2>Load the Dump-capture Kernel<a class="headerlink" href="#load-the-dump-capture-kernel" title="Permalink to this headline">¶</a></h2>
<p>After booting to the system kernel, dump-capture kernel needs to be
loaded.</p>
<p>Based on the architecture and type of image (relocatable or not), one
can choose to load the uncompressed vmlinux or compressed bzImage/vmlinuz
of dump-capture kernel. Following is the summary.</p>
<p>For i386 and x86_64:</p>
<blockquote>
<div><ul class="simple">
<li>Use vmlinux if kernel is not relocatable.</li>
<li>Use bzImage/vmlinuz if kernel is relocatable.</li>
</ul>
</div></blockquote>
<p>For ppc64:</p>
<blockquote>
<div><ul class="simple">
<li>Use vmlinux</li>
</ul>
</div></blockquote>
<p>For ia64:</p>
<blockquote>
<div><ul class="simple">
<li>Use vmlinux or vmlinuz.gz</li>
</ul>
</div></blockquote>
<p>For s390x:</p>
<blockquote>
<div><ul class="simple">
<li>Use image or bzImage</li>
</ul>
</div></blockquote>
<p>For arm:</p>
<blockquote>
<div><ul class="simple">
<li>Use zImage</li>
</ul>
</div></blockquote>
<p>For arm64:</p>
<blockquote>
<div><ul class="simple">
<li>Use vmlinux or Image</li>
</ul>
</div></blockquote>
<p>If you are using an uncompressed vmlinux image then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-vmlinux-image&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; --args-linux \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using a compressed bzImage/vmlinuz, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-bzImage&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using a compressed zImage, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec --type zImage -p &lt;dump-capture-kernel-bzImage&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--dtb=&lt;dtb-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>If you are using an uncompressed Image, then use following command
to load dump-capture kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kexec -p &lt;dump-capture-kernel-Image&gt; \
--initrd=&lt;initrd-for-dump-capture-kernel&gt; \
--append=&quot;root=&lt;root-dev&gt; &lt;arch-specific-options&gt;&quot;
</pre></div>
</div>
<p>Please note, that –args-linux does not need to be specified for ia64.
It is planned to make this a no-op on that architecture, but for now
it should be omitted</p>
<p>Following are the arch specific command line options to be used while
loading dump-capture kernel.</p>
<p>For i386, x86_64 and ia64:</p>
<blockquote>
<div>“1 irqpoll maxcpus=1 reset_devices”</div></blockquote>
<p>For ppc64:</p>
<blockquote>
<div>“1 maxcpus=1 noirqdistrib reset_devices”</div></blockquote>
<p>For s390x:</p>
<blockquote>
<div>“1 maxcpus=1 cgroup_disable=memory”</div></blockquote>
<p>For arm:</p>
<blockquote>
<div>“1 maxcpus=1 reset_devices”</div></blockquote>
<p>For arm64:</p>
<blockquote>
<div>“1 maxcpus=1 reset_devices”</div></blockquote>
<p>Notes on loading the dump-capture kernel:</p>
<ul>
<li><p class="first">By default, the ELF headers are stored in ELF64 format to support
systems with more than 4GB memory. On i386, kexec automatically checks if
the physical RAM size exceeds the 4 GB limit and if not, uses ELF32.
So, on non-PAE systems, ELF32 is always used.</p>
<p>The –elf32-core-headers option can be used to force the generation of ELF32
headers. This is necessary because GDB currently cannot open vmcore files
with ELF64 headers on 32-bit systems.</p>
</li>
<li><p class="first">The “irqpoll” boot parameter reduces driver initialization failures
due to shared interrupts in the dump-capture kernel.</p>
</li>
<li><p class="first">You must specify &lt;root-dev&gt; in the format corresponding to the root
device name in the output of mount command.</p>
</li>
<li><p class="first">Boot parameter “1” boots the dump-capture kernel into single-user
mode without networking. If you want networking, use “3”.</p>
</li>
<li><p class="first">We generally don’t have to bring up a SMP kernel just to capture the
dump. Hence generally it is useful either to build a UP dump-capture
kernel or specify maxcpus=1 option while loading dump-capture kernel.
Note, though maxcpus always works, you had better replace it with
nr_cpus to save memory if supported by the current ARCH, such as x86.</p>
</li>
<li><p class="first">You should enable multi-cpu support in dump-capture kernel if you intend
to use multi-thread programs with it, such as parallel dump feature of
makedumpfile. Otherwise, the multi-thread program may have a great
performance degradation. To enable multi-cpu support, you should bring up an
SMP dump-capture kernel and specify maxcpus/nr_cpus, disable_cpu_apicid=[X]
options while loading it.</p>
</li>
<li><p class="first">For s390x there are two kdump modes: If a ELF header is specified with
the elfcorehdr= kernel parameter, it is used by the kdump kernel as it
is done on all other architectures. If no elfcorehdr= kernel parameter is
specified, the s390x kdump kernel dynamically creates the header. The
second mode has the advantage that for CPU and memory hotplug, kdump has
not to be reloaded with kexec_load().</p>
</li>
<li><p class="first">For s390x systems with many attached devices the “cio_ignore” kernel
parameter should be used for the kdump kernel in order to prevent allocation
of kernel memory for devices that are not relevant for kdump. The same
applies to systems that use SCSI/FCP devices. In that case the
“allow_lun_scan” zfcp module parameter should be set to zero before
setting FCP devices online.</p>
</li>
</ul>
</div>
<div class="section" id="kernel-panic">
<h2>Kernel Panic<a class="headerlink" href="#kernel-panic" title="Permalink to this headline">¶</a></h2>
<p>After successfully loading the dump-capture kernel as previously
described, the system will reboot into the dump-capture kernel if a
system crash is triggered.  Trigger points are located in <a class="reference internal" href="../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a>,
die(), die_nmi() and in the sysrq handler (ALT-SysRq-c).</p>
<p>The following conditions will execute a crash trigger point:</p>
<p>If a hard lockup is detected and “NMI watchdog” is configured, the system
will boot into the dump-capture kernel ( die_nmi() ).</p>
<p>If die() is called, and it happens to be a thread with pid 0 or 1, or die()
is called inside interrupt context or die() is called and panic_on_oops is set,
the system will boot into the dump-capture kernel.</p>
<p>On powerpc systems when a soft-reset is generated, die() is called by all cpus
and the system will boot into the dump-capture kernel.</p>
<p>For testing purposes, you can trigger a crash by using “ALT-SysRq-c”,
“echo c &gt; /proc/sysrq-trigger” or write a module to force the panic.</p>
</div>
<div class="section" id="write-out-the-dump-file">
<h2>Write Out the Dump File<a class="headerlink" href="#write-out-the-dump-file" title="Permalink to this headline">¶</a></h2>
<p>After the dump-capture kernel is booted, write out the dump file with
the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cp /proc/vmcore &lt;dump-file&gt;
</pre></div>
</div>
</div>
<div class="section" id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Before analyzing the dump image, you should reboot into a stable kernel.</p>
<p>You can do limited analysis using GDB on the dump file copied out of
/proc/vmcore. Use the debug vmlinux built with -g and run the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gdb vmlinux &lt;dump-file&gt;
</pre></div>
</div>
<p>Stack trace for the task on processor 0, register display, and memory
display work fine.</p>
<p>Note: GDB cannot analyze core files generated in ELF64 format for x86.
On systems with a maximum of 4GB of memory, you can generate
ELF32-format headers using the –elf32-core-headers kernel option on the
dump kernel.</p>
<p>You can also use the Crash utility to analyze dump files in Kdump
format. Crash is available on Dave Anderson’s site at the following URL:</p>
<blockquote>
<div><a class="reference external" href="http://people.redhat.com/~anderson/">http://people.redhat.com/~anderson/</a></div></blockquote>
</div>
<div class="section" id="trigger-kdump-on-warn">
<h2>Trigger Kdump on WARN()<a class="headerlink" href="#trigger-kdump-on-warn" title="Permalink to this headline">¶</a></h2>
<p>The kernel parameter, panic_on_warn, calls <a class="reference internal" href="../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a> in all WARN() paths.  This
will cause a kdump to occur at the <a class="reference internal" href="../driver-api/basics.html#c.panic" title="panic"><code class="xref c c-func docutils literal notranslate"><span class="pre">panic()</span></code></a> call.  In cases where a user wants
to specify this during runtime, /proc/sys/kernel/panic_on_warn can be set to 1
to achieve the same behaviour.</p>
</div>
<div class="section" id="contact">
<h2>Contact<a class="headerlink" href="#contact" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Vivek Goyal (<a class="reference external" href="mailto:vgoyal&#37;&#52;&#48;redhat&#46;com">vgoyal<span>&#64;</span>redhat<span>&#46;</span>com</a>)</li>
<li>Maneesh Soni (<a class="reference external" href="mailto:maneesh&#37;&#52;&#48;in&#46;ibm&#46;com">maneesh<span>&#64;</span>in<span>&#46;</span>ibm<span>&#46;</span>com</a>)</li>
</ul>
</div>
<div class="section" id="gdb-macros">
<h2>GDB macros<a class="headerlink" href="#gdb-macros" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
#
# This file contains a few gdb macros (user defined commands) to extract
# useful information from kernel crashdump (kdump) like stack traces of
# all the processes or a particular process and trapinfo.
#
# These macros can be used by copying this file in .gdbinit (put in home
# directory or current directory) or by invoking gdb command with
# --command=&lt;command-file-name&gt; option
#
# Credits:
# Alexander Nyberg &lt;alexn&#64;telia.com&gt;
# V Srivatsa &lt;vatsa&#64;in.ibm.com&gt;
# Maneesh Soni &lt;maneesh&#64;in.ibm.com&gt;
#

define bttnobp
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $stacksize = sizeof(union thread_union)
        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t
                printf &quot;\npid %d; comm %s:\n&quot;, $next_t.pid, $next_t.comm
                printf &quot;===================\n&quot;
                set var $stackp = $next_t.thread.sp
                set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + $stacksize

                while ($stackp &lt; $stack_top)
                        if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)
                                info symbol *($stackp)
                        end
                        set $stackp += 4
                end
                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        printf &quot;\npid %d; comm %s:\n&quot;, $next_t.pid, $next_t.comm
                        printf &quot;===================\n&quot;
                        set var $stackp = $next_t.thread.sp
                        set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + stacksize

                        while ($stackp &lt; $stack_top)
                                if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)
                                        info symbol *($stackp)
                                end
                                set $stackp += 4
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end
end
document bttnobp
        dump all thread stack traces on a kernel compiled with !CONFIG_FRAME_POINTER
end

define btthreadstack
        set var $pid_task = $arg0

        printf &quot;\npid %d; comm %s:\n&quot;, $pid_task.pid, $pid_task.comm
        printf &quot;task struct: &quot;
        print $pid_task
        printf &quot;===================\n&quot;
        set var $stackp = $pid_task.thread.sp
        set var $stacksize = sizeof(union thread_union)
        set var $stack_top = ($stackp &amp; ~($stacksize - 1)) + $stacksize
        set var $stack_bot = ($stackp &amp; ~($stacksize - 1))

        set $stackp = *((unsigned long *) $stackp)
        while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))
                set var $addr = *(((unsigned long *) $stackp) + 1)
                info symbol $addr
                set $stackp = *((unsigned long *) $stackp)
        end
end
document btthreadstack
         dump a thread stack using the given task structure pointer
end


define btt
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t
                btthreadstack $next_t

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        btthreadstack $next_th
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end
end
document btt
        dump all thread stack traces on a kernel compiled with CONFIG_FRAME_POINTER
end

define btpid
        set var $pid = $arg0
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $pid_task = 0

        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t

                if ($next_t.pid == $pid)
                        set $pid_task = $next_t
                end

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        if ($next_th.pid == $pid)
                                set $pid_task = $next_th
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end

        btthreadstack $pid_task
end
document btpid
        backtrace of pid
end


define trapinfo
        set var $pid = $arg0
        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)
        set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)
        set $init_t=&amp;init_task
        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)
        set var $pid_task = 0

        while ($next_t != $init_t)
                set $next_t=(struct task_struct *)$next_t

                if ($next_t.pid == $pid)
                        set $pid_task = $next_t
                end

                set $next_th=(((char *)$next_t-&gt;thread_group.next) - $pid_off)
                while ($next_th != $next_t)
                        set $next_th=(struct task_struct *)$next_th
                        if ($next_th.pid == $pid)
                                set $pid_task = $next_th
                        end
                        set $next_th=(((char *)$next_th-&gt;thread_group.next) - $pid_off)
                end
                set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off
        end

        printf &quot;Trapno %ld, cr2 0x%lx, error_code %ld\n&quot;, $pid_task.thread.trap_no, \
                                $pid_task.thread.cr2, $pid_task.thread.error_code

end
document trapinfo
        Run info threads and lookup pid of thread #1
        'trapinfo &lt;pid&gt;' will tell you by which trap &amp; possibly
        address the kernel panicked.
end

define dump_log_idx
        set $idx = $arg0
        if ($argc &gt; 1)
                set $prev_flags = $arg1
        else
                set $prev_flags = 0
        end
        set $msg = ((struct printk_log *) (log_buf + $idx))
        set $prefix = 1
        set $newline = 1
        set $log = log_buf + $idx + sizeof(*$msg)

        # prev &amp; LOG_CONT &amp;&amp; !(msg-&gt;flags &amp; LOG_PREIX)
        if (($prev_flags &amp; 8) &amp;&amp; !($msg-&gt;flags &amp; 4))
                set $prefix = 0
        end

        # msg-&gt;flags &amp; LOG_CONT
        if ($msg-&gt;flags &amp; 8)
                # (prev &amp; LOG_CONT &amp;&amp; !(prev &amp; LOG_NEWLINE))
                if (($prev_flags &amp; 8) &amp;&amp; !($prev_flags &amp; 2))
                        set $prefix = 0
                end
                # (!(msg-&gt;flags &amp; LOG_NEWLINE))
                if (!($msg-&gt;flags &amp; 2))
                        set $newline = 0
                end
        end

        if ($prefix)
                printf &quot;[%5lu.%06lu] &quot;, $msg-&gt;ts_nsec / 1000000000, $msg-&gt;ts_nsec % 1000000000
        end
        if ($msg-&gt;text_len != 0)
                eval &quot;printf \&quot;%%%d.%ds\&quot;, $log&quot;, $msg-&gt;text_len, $msg-&gt;text_len
        end
        if ($newline)
                printf &quot;\n&quot;
        end
        if ($msg-&gt;dict_len &gt; 0)
                set $dict = $log + $msg-&gt;text_len
                set $idx = 0
                set $line = 1
                while ($idx &lt; $msg-&gt;dict_len)
                        if ($line)
                                printf &quot; &quot;
                                set $line = 0
                        end
                        set $c = $dict[$idx]
                        if ($c == '\0')
                                printf &quot;\n&quot;
                                set $line = 1
                        else
                                if ($c &lt; ' ' || $c &gt;= 127 || $c == '\\')
                                        printf &quot;\\x%02x&quot;, $c
                                else
                                        printf &quot;%c&quot;, $c
                                end
                        end
                        set $idx = $idx + 1
                end
                printf &quot;\n&quot;
        end
end
document dump_log_idx
        Dump a single log given its index in the log buffer.  The first
        parameter is the index into log_buf, the second is optional and
        specified the previous log buffer's flags, used for properly
        formatting continued lines.
end

define dmesg
        set $i = log_first_idx
        set $end_idx = log_first_idx
        set $prev_flags = 0

        while (1)
                set $msg = ((struct printk_log *) (log_buf + $i))
                if ($msg-&gt;len == 0)
                        set $i = 0
                else
                        dump_log_idx $i $prev_flags
                        set $i = $i + $msg-&gt;len
                        set $prev_flags = $msg-&gt;flags
                end
                if ($i == $end_idx)
                        loop_break
                end
        end
end
document dmesg
        print the kernel ring buffer
end

</pre>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>