

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>L’inaffidabile guida all’hacking del kernel Linux &mdash; The Linux Kernel 5.2.0+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="L’inaffidabile guida alla sincronizzazione" href="locking.html" />
    <link rel="prev" title="Guida all’hacking del kernel" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../x86/index.html">x86-specific Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">中文翻译</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Traduzione italiana</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#avvertenze">Avvertenze</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#la-documentazione-del-kernel-linux">La documentazione del kernel Linux</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-sulla-licenza-dei-sorgenti">Documentazione sulla licenza dei sorgenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-utenti">Documentazione per gli utenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-sviluppatori-di-applicazioni">Documentazione per gli sviluppatori di applicazioni</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html#introduzione-allo-sviluppo-del-kernel">Introduzione allo sviluppo del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-della-api-del-kernel">Documentazione della API del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-specifica-per-architettura">Documentazione specifica per architettura</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">Korean translations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">Japanese translations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Translations</a> &raquo;</li>
        
          <li><a href="../index.html">Traduzione italiana</a> &raquo;</li>
        
          <li><a href="index.html">Guida all’hacking del kernel</a> &raquo;</li>
        
      <li>L’inaffidabile guida all’hacking del kernel Linux</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/translations/it_IT/kernel-hacking/hacking.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Per leggere la documentazione originale in inglese:
<a class="reference internal" href="../../../kernel-hacking/hacking.html#kernel-hacking-hack"><span class="std std-ref">Documentation/kernel-hacking/hacking.rst</span></a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Original:</th><td class="field-body"><a class="reference internal" href="../../../kernel-hacking/hacking.html#kernel-hacking-hack"><span class="std std-ref">Documentation/kernel-hacking/hacking.rst</span></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Translator:</th><td class="field-body">Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="l-inaffidabile-guida-all-hacking-del-kernel-linux">
<span id="it-kernel-hacking-hack"></span><h1>L’inaffidabile guida all’hacking del kernel Linux<a class="headerlink" href="#l-inaffidabile-guida-all-hacking-del-kernel-linux" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Rusty Russell</td>
</tr>
</tbody>
</table>
<div class="section" id="introduzione">
<h2>Introduzione<a class="headerlink" href="#introduzione" title="Permalink to this headline">¶</a></h2>
<p>Benvenuto, gentile lettore, alla notevole ed inaffidabile guida all’hacking
del kernel Linux ad opera di Rusty. Questo documento descrive le procedure
più usate ed i concetti necessari per scrivere codice per il kernel: lo scopo
è di fornire ai programmatori C più esperti un manuale di base per sviluppo.
Eviterò dettagli implementativi: per questo abbiamo il codice,
ed ignorerò intere parti di alcune procedure.</p>
<p>Prima di leggere questa guida, sappiate che non ho mai voluto scriverla,
essendo esageratamente sotto qualificato, ma ho sempre voluto leggere
qualcosa di simile, e quindi questa era l’unica via. Spero che possa
crescere e diventare un compendio di buone pratiche, punti di partenza
e generiche informazioni.</p>
</div>
<div class="section" id="gli-attori">
<h2>Gli attori<a class="headerlink" href="#gli-attori" title="Permalink to this headline">¶</a></h2>
<p>In qualsiasi momento ognuna delle CPU di un sistema può essere:</p>
<ul class="simple">
<li>non associata ad alcun processo, servendo un’interruzione hardware;</li>
<li>non associata ad alcun processo, servendo un softirq o tasklet;</li>
<li>in esecuzione nello spazio kernel, associata ad un processo
(contesto utente);</li>
<li>in esecuzione di un processo nello spazio utente;</li>
</ul>
<p>Esiste un ordine fra questi casi. Gli ultimi due possono avvicendarsi (preempt)
l’un l’altro, ma a parte questo esiste una gerarchia rigida: ognuno di questi
può avvicendarsi solo ad uno di quelli sottostanti. Per esempio, mentre un
softirq è in esecuzione su d’una CPU, nessun altro softirq può avvicendarsi
nell’esecuzione, ma un’interruzione hardware può. Ciò nonostante, le altre CPU
del sistema operano indipendentemente.</p>
<p>Più avanti vedremo alcuni modi in cui dal contesto utente è possibile bloccare
le interruzioni, così da impedirne davvero il diritto di prelazione.</p>
<div class="section" id="contesto-utente">
<h3>Contesto utente<a class="headerlink" href="#contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Ci si trova nel contesto utente quando si arriva da una chiamata di sistema
od altre eccezioni: come nello spazio utente, altre procedure più importanti,
o le interruzioni, possono far valere il proprio diritto di prelazione sul
vostro processo. Potete sospendere l’esecuzione chiamando <code class="xref c c-func docutils literal notranslate"><span class="pre">schedule()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Si è sempre in contesto utente quando un modulo viene caricato o rimosso,
e durante le operazioni nello strato dei dispositivi a blocchi
(<em>block layer</em>).</p>
</div>
<p>Nel contesto utente, il puntatore <code class="docutils literal notranslate"><span class="pre">current</span></code> (il quale indica il processo al
momento in esecuzione) è valido, e <code class="xref c c-func docutils literal notranslate"><span class="pre">in_interrupt()</span></code>
(<code class="docutils literal notranslate"><span class="pre">include/linux/preempt.h</span></code>) è falsa.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Attenzione che se avete la prelazione o i softirq disabilitati (vedere
di seguito), <code class="xref c c-func docutils literal notranslate"><span class="pre">in_interrupt()</span></code> ritornerà un falso positivo.</p>
</div>
</div>
<div class="section" id="interruzioni-hardware-hard-irqs">
<h3>Interruzioni hardware (Hard IRQs)<a class="headerlink" href="#interruzioni-hardware-hard-irqs" title="Permalink to this headline">¶</a></h3>
<p>Temporizzatori, schede di rete e tastiere sono esempi di vero hardware
che possono produrre interruzioni in un qualsiasi momento. Il kernel esegue
i gestori d’interruzione che prestano un servizio all’hardware. Il kernel
garantisce che questi gestori non vengano mai interrotti: se una stessa
interruzione arriva, questa verrà accodata (o scartata).
Dato che durante la loro esecuzione le interruzioni vengono disabilitate,
i gestori d’interruzioni devono essere veloci: spesso si limitano
esclusivamente a notificare la presa in carico dell’interruzione,
programmare una ‘interruzione software’ per l’esecuzione e quindi terminare.</p>
<p>Potete dire d’essere in una interruzione hardware perché <code class="xref c c-func docutils literal notranslate"><span class="pre">in_irq()</span></code>
ritorna vero.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Attenzione, questa ritornerà un falso positivo se le interruzioni
sono disabilitate (vedere di seguito).</p>
</div>
</div>
<div class="section" id="contesto-d-interruzione-software-softirq-e-tasklet">
<h3>Contesto d’interruzione software: softirq e tasklet<a class="headerlink" href="#contesto-d-interruzione-software-softirq-e-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Quando una chiamata di sistema sta per tornare allo spazio utente,
oppure un gestore d’interruzioni termina, qualsiasi ‘interruzione software’
marcata come pendente (solitamente da un’interruzione hardware) viene
eseguita (<code class="docutils literal notranslate"><span class="pre">kernel/softirq.c</span></code>).</p>
<p>La maggior parte del lavoro utile alla gestione di un’interruzione avviene qui.
All’inizio della transizione ai sistemi multiprocessore, c’erano solo i
cosiddetti ‘bottom half’ (BH), i quali non traevano alcun vantaggio da questi
sistemi. Non appena abbandonammo i computer raffazzonati con fiammiferi e
cicche, abbandonammo anche questa limitazione e migrammo alle interruzioni
software ‘softirqs’.</p>
<p>Il file <code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code> elenca i differenti tipi di ‘softirq’.
Un tipo di softirq molto importante è il timer (<code class="docutils literal notranslate"><span class="pre">include/linux/timer.h</span></code>):
potete programmarlo per far si che esegua funzioni dopo un determinato
periodo di tempo.</p>
<p>Dato che i softirq possono essere eseguiti simultaneamente su più di un
processore, spesso diventa estenuante l’averci a che fare. Per questa ragione,
i tasklet (<code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code>) vengo usati più di frequente:
possono essere registrati dinamicamente (il che significa che potete averne
quanti ne volete), e garantiscono che un qualsiasi tasklet verrà eseguito
solo su un processore alla volta, sebbene diversi tasklet possono essere
eseguiti simultaneamente.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Il nome ‘tasklet’ è ingannevole: non hanno niente a che fare
con i ‘processi’ (‘tasks’), e probabilmente hanno più a che vedere
con qualche pessima vodka che Alexey Kuznetsov si fece a quel tempo.</p>
</div>
<p>Potete determinate se siete in un softirq (o tasklet) utilizzando la
macro <code class="xref c c-func docutils literal notranslate"><span class="pre">in_softirq()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/preempt.h</span></code>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">State attenti che questa macro ritornerà un falso positivo
se <a class="reference internal" href="#it-local-bh-disable"><span class="std std-ref">botton half lock</span></a> è bloccato.</p>
</div>
</div>
</div>
<div class="section" id="alcune-regole-basilari">
<h2>Alcune regole basilari<a class="headerlink" href="#alcune-regole-basilari" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Nessuna protezione della memoria</dt>
<dd>Se corrompete la memoria, che sia in contesto utente o d’interruzione,
la macchina si pianterà. Siete sicuri che quello che volete fare
non possa essere fatto nello spazio utente?</dd>
<dt>Nessun numero in virgola mobile o MMX</dt>
<dd>Il contesto della FPU non è salvato; anche se siete in contesto utente
lo stato dell’FPU probabilmente non corrisponde a quello del processo
corrente: vi incasinerete con lo stato di qualche altro processo. Se
volete davvero usare la virgola mobile, allora dovrete salvare e recuperare
lo stato dell’FPU (ed evitare cambi di contesto). Generalmente è una
cattiva idea; usate l’aritmetica a virgola fissa.</dd>
<dt>Un limite rigido dello stack</dt>
<dd>A seconda della configurazione del kernel lo stack è fra 3K e 6K per la
maggior parte delle architetture a 32-bit; è di 14K per la maggior
parte di quelle a 64-bit; e spesso è condiviso con le interruzioni,
per cui non si può usare.
Evitare profonde ricorsioni ad enormi array locali nello stack
(allocateli dinamicamente).</dd>
<dt>Il kernel Linux è portabile</dt>
<dd>Quindi mantenetelo tale. Il vostro codice dovrebbe essere a 64-bit ed
indipendente dall’ordine dei byte (endianess) di un processore. Inoltre,
dovreste minimizzare il codice specifico per un processore; per esempio
il codice assembly dovrebbe essere incapsulato in modo pulito e minimizzato
per facilitarne la migrazione. Generalmente questo codice dovrebbe essere
limitato alla parte di kernel specifica per un’architettura.</dd>
</dl>
</div>
<div class="section" id="ioctl-non-scrivere-nuove-chiamate-di-sistema">
<h2>ioctl: non scrivere nuove chiamate di sistema<a class="headerlink" href="#ioctl-non-scrivere-nuove-chiamate-di-sistema" title="Permalink to this headline">¶</a></h2>
<p>Una chiamata di sistema, generalmente, è scritta così:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long sys_mycall(int arg)
{
        return 0;
}
</pre></div>
</div>
<p>Primo, nella maggior parte dei casi non volete creare nuove chiamate di
sistema.
Create un dispositivo a caratteri ed implementate l’appropriata chiamata ioctl.
Questo meccanismo è molto più flessibile delle chiamate di sistema: esso non
dev’essere dichiarato in tutte le architetture nei file
<code class="docutils literal notranslate"><span class="pre">include/asm/unistd.h</span></code> e <code class="docutils literal notranslate"><span class="pre">arch/kernel/entry.S</span></code>; inoltre, è improbabile
che questo venga accettato da Linus.</p>
<p>Se tutto quello che il vostro codice fa è leggere o scrivere alcuni parametri,
considerate l’implementazione di un’interfaccia <code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs()</span></code>.</p>
<p>All’interno di una ioctl vi trovate nel contesto utente di un processo. Quando
avviene un errore dovete ritornare un valore negativo di errno (consultate
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/errno-base.h</span></code>,
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/errno.h</span></code> e <code class="docutils literal notranslate"><span class="pre">include/linux/errno.h</span></code>), altrimenti
ritornate 0.</p>
<p>Dopo aver dormito dovreste verificare se ci sono stati dei segnali: il modo
Unix/Linux di gestire un segnale è di uscire temporaneamente dalla chiamata
di sistema con l’errore <code class="docutils literal notranslate"><span class="pre">-ERESTARTSYS</span></code>. La chiamata di sistema ritornerà
al contesto utente, eseguirà il gestore del segnale e poi la vostra chiamata
di sistema riprenderà (a meno che l’utente non l’abbia disabilitata). Quindi,
dovreste essere pronti per continuare l’esecuzione, per esempio nel mezzo
della manipolazione di una struttura dati.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (signal_pending(current))
        return -ERESTARTSYS;
</pre></div>
</div>
<p>Se dovete eseguire dei calcoli molto lunghi: pensate allo spazio utente.
Se <strong>davvero</strong> volete farlo nel kernel ricordatevi di verificare periodicamente
se dovete <em>lasciare</em> il processore (ricordatevi che, per ogni processore, c’è
un sistema multi-processo senza diritto di prelazione).
Esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cond_resched(); /* Will sleep */
</pre></div>
</div>
<p>Una breve nota sulla progettazione delle interfacce: il motto dei sistemi
UNIX è “fornite meccanismi e non politiche”</p>
</div>
<div class="section" id="la-ricetta-per-uno-stallo">
<h2>La ricetta per uno stallo<a class="headerlink" href="#la-ricetta-per-uno-stallo" title="Permalink to this headline">¶</a></h2>
<p>Non è permesso invocare una procedura che potrebbe dormire, fanno eccezione
i seguenti casi:</p>
<ul class="simple">
<li>Siete in un contesto utente.</li>
<li>Non trattenete alcun spinlock.</li>
<li>Avete abilitato le interruzioni (in realtà, Andy Kleen dice che
lo schedulatore le abiliterà per voi, ma probabilmente questo non è quello
che volete).</li>
</ul>
<p>Da tener presente che alcune funzioni potrebbero dormire implicitamente:
le più comuni sono quelle per l’accesso allo spazio utente (*_user) e
quelle per l’allocazione della memoria senza l’opzione <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></p>
<p>Dovreste sempre compilare il kernel con l’opzione <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_ATOMIC_SLEEP</span></code>
attiva, questa vi avviserà se infrangete una di queste regole.
Se <strong>infrangete</strong> le regole, allora potreste bloccare il vostro scatolotto.</p>
<p>Veramente.</p>
</div>
<div class="section" id="alcune-delle-procedure-piu-comuni">
<h2>Alcune delle procedure più comuni<a class="headerlink" href="#alcune-delle-procedure-piu-comuni" title="Permalink to this headline">¶</a></h2>
<div class="section" id="printk">
<h3><a class="reference internal" href="../../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a><a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/printk.h</span></code></p>
<p><a class="reference internal" href="../../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> fornisce messaggi alla console, dmesg, e al demone syslog.
Essa è utile per il debugging o per la notifica di errori; può essere
utilizzata anche all’interno del contesto d’interruzione, ma usatela con
cautela: una macchina che ha la propria console inondata da messaggi diventa
inutilizzabile. La funzione utilizza un formato stringa quasi compatibile con
la printf ANSI C, e la concatenazione di una stringa C come primo argomento
per indicare la “priorità”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printk(KERN_INFO &quot;i = %u\n&quot;, i);
</pre></div>
</div>
<p>Consultate <code class="docutils literal notranslate"><span class="pre">include/linux/kern_levels.h</span></code> per gli altri valori <code class="docutils literal notranslate"><span class="pre">KERN_</span></code>;
questi sono interpretati da syslog come livelli. Un caso speciale:
per stampare un indirizzo IP usate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__be32 ipaddress;
printk(KERN_INFO &quot;my ip: %pI4\n&quot;, &amp;ipaddress);
</pre></div>
</div>
<p><a class="reference internal" href="../../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> utilizza un buffer interno di 1K e non s’accorge di
eventuali sforamenti. Accertatevi che vi basti.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saprete di essere un vero hacker del kernel quando inizierete a digitare
nei vostri programmi utenti le printf come se fossero printk :)</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Un’altra nota a parte: la versione originale di Unix 6 aveva un commento
sopra alla funzione printf: “Printf non dovrebbe essere usata per il
chiacchiericcio”. Dovreste seguire questo consiglio.</p>
</div>
</div>
<div class="section" id="copy-to-user-copy-from-user-get-user-put-user">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> / <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> / <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a> / <a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a><a class="headerlink" href="#copy-to-user-copy-from-user-get-user-put-user" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/uaccess.h</span></code> / <code class="docutils literal notranslate"><span class="pre">asm/uaccess.h</span></code></p>
<p><strong>[DORMONO]</strong></p>
<p><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a> e <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a> sono usate per ricevere ed
impostare singoli valori (come int, char, o long) da e verso lo spazio utente.
Un puntatore nello spazio utente non dovrebbe mai essere dereferenziato: i dati
dovrebbero essere copiati usando suddette procedure. Entrambe ritornano
<code class="docutils literal notranslate"><span class="pre">-EFAULT</span></code> oppure 0.</p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> sono più generiche:
esse copiano una quantità arbitraria di dati da e verso lo spazio utente.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Al contrario di:c:func:<cite><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a></cite> e <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a>, queste
funzioni ritornano la quantità di dati copiati (0 è comunque un successo).</p>
</div>
<p>[Sì, questa stupida interfaccia mi imbarazza. La battaglia torna in auge anno
dopo anno. –RR]</p>
<p>Le funzioni potrebbero dormire implicitamente. Queste non dovrebbero mai essere
invocate fuori dal contesto utente (non ha senso), con le interruzioni
disabilitate, o con uno spinlock trattenuto.</p>
</div>
<div class="section" id="kmalloc-kfree">
<h3><a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>/<a class="reference internal" href="../../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a><a class="headerlink" href="#kmalloc-kfree" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/slab.h</span></code></p>
<p><strong>[POTREBBERO DORMIRE: LEGGI SOTTO]</strong></p>
<p>Queste procedure sono utilizzate per la richiesta dinamica di un puntatore ad
un pezzo di memoria allineato, esattamente come malloc e free nello spazio
utente, ma <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> ha un argomento aggiuntivo per indicare alcune
opzioni. Le opzioni più importanti sono:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code></dt>
<dd>Potrebbe dormire per librarare della memoria. L’opzione fornisce il modo
più affidabile per allocare memoria, ma il suo uso è strettamente limitato
allo spazio utente.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></dt>
<dd>Non dorme. Meno affidabile di <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, ma può essere usata in un
contesto d’interruzione. Dovreste avere <strong>davvero</strong> una buona strategia
per la gestione degli errori in caso di mancanza di memoria.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code></dt>
<dd>Alloca memoria per il DMA sul bus ISA nello spazio d’indirizzamento
inferiore ai 16MB. Se non sapete cos’è allora non vi serve.
Molto inaffidabile.</dd>
</dl>
<p>Se vedete un messaggio d’avviso per una funzione dormiente che viene chiamata
da un contesto errato, allora probabilmente avete usato una funzione
d’allocazione dormiente da un contesto d’interruzione senza <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.
Dovreste correggerlo. Sbrigatevi, non cincischiate.</p>
<p>Se allocate almeno <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE``(``asm/page.h</span></code> o <code class="docutils literal notranslate"><span class="pre">asm/page_types.h</span></code>) byte,
considerate l’uso di <code class="xref c c-func docutils literal notranslate"><span class="pre">__get_free_pages()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/gfp.h</span></code>).
Accetta un argomento che definisce l’ordine (0 per per la dimensione di una
pagine, 1 per una doppia pagina, 2 per quattro pagine, eccetra) e le stesse
opzioni d’allocazione viste precedentemente.</p>
<p>Se state allocando un numero di byte notevolemnte superiore ad una pagina
potete usare <a class="reference internal" href="../../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>. Essa allocherà memoria virtuale all’interno
dello spazio kernel. Questo è un blocco di memoria fisica non contiguo, ma
la MMU vi darà l’impressione che lo sia (quindi, sarà contiguo solo dal punto
di vista dei processori, non dal punto di vista dei driver dei dispositivi
esterni).
Se per qualche strana ragione avete davvero bisogno di una grossa quantità di
memoria fisica contigua, avete un problema: Linux non ha un buon supporto per
questo caso d’uso perché, dopo un po’ di tempo, la frammentazione della memoria
rende l’operazione difficile. Il modo migliore per allocare un simile blocco
all’inizio dell’avvio del sistema è attraverso la procedura
<code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_bootmem()</span></code>.</p>
<p>Prima di inventare la vostra cache per gli oggetti più usati, considerate
l’uso di una cache slab disponibile in <code class="docutils literal notranslate"><span class="pre">include/linux/slab.h</span></code>.</p>
</div>
<div class="section" id="current">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">current()</span></code><a class="headerlink" href="#current" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/asm/current.h</span></code></p>
<p>Questa variabile globale (in realtà una macro) contiene un puntatore alla
struttura del processo corrente, quindi è valido solo dal contesto utente.
Per esempio, quando un processo esegue una chiamata di sistema, questo
punterà alla struttura dati del processo chiamate.
Nel contesto d’interruzione in suo valore <strong>non è NULL</strong>.</p>
</div>
<div class="section" id="mdelay-udelay">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code><a class="headerlink" href="#mdelay-udelay" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/asm/delay.h</span></code> / <code class="docutils literal notranslate"><span class="pre">include/linux/delay.h</span></code></p>
<p>Le funzioni <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">ndelay()</span></code> possono essere utilizzate
per brevi pause. Non usate grandi valori perché rischiate d’avere un
overflow - in questo contesto la funzione <code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code> è utile,
oppure considerate <a class="reference internal" href="../../../driver-api/basics.html#c.msleep" title="msleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">msleep()</span></code></a>.</p>
</div>
<div class="section" id="cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">be32_to_cpu()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_le32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">le32_to_cpu()</span></code><a class="headerlink" href="#cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/asm/byteorder.h</span></code></p>
<p>La famiglia di funzioni <code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32()</span></code> (dove “32” può essere
sostituito da 64 o 16, e “be” con “le”) forniscono un modo generico
per fare conversioni sull’ordine dei byte (endianess): esse ritornano
il valore convertito. Tutte le varianti supportano anche il processo inverso:
<code class="xref c c-func docutils literal notranslate"><span class="pre">be32_to_cpu()</span></code>, eccetera.</p>
<p>Queste funzioni hanno principalmente due varianti: la variante per
puntatori, come <code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32p(),</span> <span class="pre">che</span> <span class="pre">prende</span> <span class="pre">un</span> <span class="pre">puntatore</span>
<span class="pre">ad</span> <span class="pre">un</span> <span class="pre">tipo,</span> <span class="pre">e</span> <span class="pre">ritorna</span> <span class="pre">il</span> <span class="pre">valore</span> <span class="pre">convertito.</span> <span class="pre">L'altra</span> <span class="pre">variante</span> <span class="pre">per</span>
<span class="pre">la</span> <span class="pre">famiglia</span> <span class="pre">di</span> <span class="pre">conversioni</span> <span class="pre">&quot;in-situ&quot;,</span> <span class="pre">come</span> <span class="pre">:c:func:`cpu_to_be32s()</span></code>,
che convertono il valore puntato da un puntatore, e ritornano void.</p>
</div>
<div class="section" id="local-irq-save-local-irq-restore">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_save()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_restore()</span></code><a class="headerlink" href="#local-irq-save-local-irq-restore" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/irqflags.h</span></code></p>
<p>Queste funzioni abilitano e disabilitano le interruzioni hardware
sul processore locale. Entrambe sono rientranti; esse salvano lo stato
precedente nel proprio argomento <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code>. Se sapete
che le interruzioni sono abilite, potete semplicemente utilizzare
<code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_disable()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_enable()</span></code>.</p>
</div>
<div class="section" id="local-bh-disable-local-bh-enable">
<span id="it-local-bh-disable"></span><h3><code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_disable()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_enable()</span></code><a class="headerlink" href="#local-bh-disable-local-bh-enable" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/bottom_half.h</span></code></p>
<p>Queste funzioni abilitano e disabilitano le interruzioni software
sul processore locale. Entrambe sono rientranti; se le interruzioni
software erano già state disabilitate in precedenza, rimarranno
disabilitate anche dopo aver invocato questa coppia di funzioni.
Lo scopo è di prevenire l’esecuzione di softirq e tasklet sul processore
attuale.</p>
</div>
<div class="section" id="smp-processor-id">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">smp_processor_id()</span></code><a class="headerlink" href="#smp-processor-id" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/smp.h</span></code></p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">get_cpu()</span></code> nega il diritto di prelazione (quindi non potete essere
spostati su un altro processore all’improvviso) e ritorna il numero
del processore attuale, fra 0 e <code class="docutils literal notranslate"><span class="pre">NR_CPUS</span></code>. Da notare che non è detto
che la numerazione dei processori sia continua. Quando avete terminato,
ritornate allo stato precedente con <code class="xref c c-func docutils literal notranslate"><span class="pre">put_cpu()</span></code>.</p>
<p>Se sapete che non dovete essere interrotti da altri processi (per esempio,
se siete in un contesto d’interruzione, o il diritto di prelazione
è disabilitato) potete utilizzare smp_processor_id().</p>
</div>
<div class="section" id="init-exit-initdata">
<h3><code class="docutils literal notranslate"><span class="pre">__init</span></code>/<code class="docutils literal notranslate"><span class="pre">__exit</span></code>/<code class="docutils literal notranslate"><span class="pre">__initdata</span></code><a class="headerlink" href="#init-exit-initdata" title="Permalink to this headline">¶</a></h3>
<p>Definite in  <code class="docutils literal notranslate"><span class="pre">include/linux/init.h</span></code></p>
<p>Dopo l’avvio, il kernel libera una sezione speciale; le funzioni marcate
con <code class="docutils literal notranslate"><span class="pre">__init</span></code> e le strutture dati marcate con <code class="docutils literal notranslate"><span class="pre">__initdata</span></code> vengono
eliminate dopo il completamento dell’avvio: in modo simile i moduli eliminano
questa memoria dopo l’inizializzazione. <code class="docutils literal notranslate"><span class="pre">__exit</span></code> viene utilizzato per
dichiarare che una funzione verrà utilizzata solo in fase di rimozione:
la detta funzione verrà eliminata quando il file che la contiene non è
compilato come modulo. Guardate l’header file per informazioni. Da notare che
non ha senso avere una funzione marcata come <code class="docutils literal notranslate"><span class="pre">__init</span></code> e al tempo stesso
esportata ai moduli utilizzando <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code> o
<code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> - non funzionerà.</p>
</div>
<div class="section" id="initcall-module-init">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">__initcall()</span></code>/<a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a><a class="headerlink" href="#initcall-module-init" title="Permalink to this headline">¶</a></h3>
<p>Definite in  <code class="docutils literal notranslate"><span class="pre">include/linux/init.h</span></code> / <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Molte parti del kernel funzionano bene come moduli (componenti del kernel
caricabili dinamicamente). L’utilizzo delle macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a>
e <a class="reference internal" href="../../../driver-api/basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> semplifica la scrittura di codice che può funzionare
sia come modulo, sia come parte del kernel, senza l’ausilio di #ifdef.</p>
<p>La macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> definisce quale funzione dev’essere
chiamata quando il modulo viene inserito (se il file è stato compilato come
tale), o in fase di avvio : se il file non è stato compilato come modulo la
macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> diventa equivalente a <code class="xref c c-func docutils literal notranslate"><span class="pre">__initcall()</span></code>,
la quale, tramite qualche magia del linker, s’assicura che la funzione venga
chiamata durante l’avvio.</p>
<p>La funzione può ritornare un numero d’errore negativo per scatenare un
fallimento del caricamento (sfortunatamente, questo non ha effetto se il
modulo è compilato come parte integrante del kernel). Questa funzione è chiamata
in contesto utente con le interruzioni abilitate, quindi potrebbe dormire.</p>
</div>
<div class="section" id="module-exit">
<h3><a class="reference internal" href="../../../driver-api/basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a><a class="headerlink" href="#module-exit" title="Permalink to this headline">¶</a></h3>
<p>Definita in  <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Questa macro definisce la funzione che dev’essere chiamata al momento della
rimozione (o mai, nel caso in cui il file sia parte integrante del kernel).
Essa verrà chiamata solo quando il contatore d’uso del modulo raggiunge lo
zero. Questa funzione può anche dormire, ma non può fallire: tutto dev’essere
ripulito prima che la funzione ritorni.</p>
<p>Da notare che questa macro è opzionale: se non presente, il modulo non sarà
removibile (a meno che non usiate ‘rmmod -f’ ).</p>
</div>
<div class="section" id="try-module-get-module-put">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code><a class="headerlink" href="#try-module-get-module-put" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Queste funzioni maneggiano il contatore d’uso del modulo per proteggerlo dalla
rimozione (in aggiunta, un modulo non può essere rimosso se un altro modulo
utilizzo uno dei sui simboli esportati: vedere di seguito). Prima di eseguire
codice del modulo, dovreste chiamare <code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code> su quel modulo:
se fallisce significa che il modulo è stato rimosso e dovete agire come se
non fosse presente. Altrimenti, potete accedere al modulo in sicurezza, e
chiamare <code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code> quando avete finito.</p>
<p>La maggior parte delle strutture registrabili hanno un campo owner
(proprietario), come nella struttura
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code>.
Impostate questo campo al valore della macro <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code>.</p>
</div>
</div>
<div class="section" id="code-d-attesa-include-linux-wait-h">
<h2>Code d’attesa <code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code><a class="headerlink" href="#code-d-attesa-include-linux-wait-h" title="Permalink to this headline">¶</a></h2>
<p><strong>[DORMONO]</strong></p>
<p>Una coda d’attesa è usata per aspettare che qualcuno vi attivi quando una
certa condizione s’avvera. Per evitare corse critiche, devono essere usate
con cautela. Dichiarate una <code class="xref c c-type docutils literal notranslate"><span class="pre">wait_queue_head_t</span></code>, e poi i processi
che vogliono attendere il verificarsi di quella condizione dichiareranno
una <code class="xref c c-type docutils literal notranslate"><span class="pre">wait_queue_entry_t</span></code> facendo riferimento a loro stessi, poi
metteranno questa in coda.</p>
<div class="section" id="dichiarazione">
<h3>Dichiarazione<a class="headerlink" href="#dichiarazione" title="Permalink to this headline">¶</a></h3>
<p>Potere dichiarare una <code class="docutils literal notranslate"><span class="pre">wait_queue_head_t</span></code> utilizzando la macro
<code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_WAIT_QUEUE_HEAD()</span></code> oppure utilizzando la procedura
<code class="xref c c-func docutils literal notranslate"><span class="pre">init_waitqueue_head()</span></code> nel vostro codice d’inizializzazione.</p>
</div>
<div class="section" id="accodamento">
<h3>Accodamento<a class="headerlink" href="#accodamento" title="Permalink to this headline">¶</a></h3>
<p>Mettersi in una coda d’attesa è piuttosto complesso, perché dovete
mettervi in coda prima di verificare la condizione. Esiste una macro
a questo scopo: <a class="reference internal" href="../../../driver-api/basics.html#c.wait_event_interruptible" title="wait_event_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event_interruptible()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code>).
Il primo argomento è la testa della coda d’attesa, e il secondo è
un’espressione che dev’essere valutata; la macro ritorna 0 quando questa
espressione è vera, altrimenti <code class="docutils literal notranslate"><span class="pre">-ERESTARTSYS</span></code> se è stato ricevuto un segnale.
La versione <a class="reference internal" href="../../../driver-api/basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> ignora i segnali.</p>
</div>
<div class="section" id="svegliare-una-procedura-in-coda">
<h3>Svegliare una procedura in coda<a class="headerlink" href="#svegliare-una-procedura-in-coda" title="Permalink to this headline">¶</a></h3>
<p>Chiamate <code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code>); questa attiverà tutti
i processi in coda. Ad eccezione se uno di questi è impostato come
<code class="docutils literal notranslate"><span class="pre">TASK_EXCLUSIVE</span></code>, in questo caso i rimanenti non verranno svegliati.
Nello stesso header file esistono altre varianti di questa funzione.</p>
</div>
</div>
<div class="section" id="operazioni-atomiche">
<h2>Operazioni atomiche<a class="headerlink" href="#operazioni-atomiche" title="Permalink to this headline">¶</a></h2>
<p>Certe operazioni sono garantite come atomiche su tutte le piattaforme.
Il primo gruppo di operazioni utilizza <code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code>
(<code class="docutils literal notranslate"><span class="pre">include/asm/atomic.h</span></code>); questo contiene un intero con segno (minimo 32bit),
e dovete utilizzare queste funzione per modificare o leggere variabili di tipo
<code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code>. <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_read()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_set()</span></code> leggono ed
impostano il contatore, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec()</span></code>, e
<code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code> (ritorna vero se raggiunge zero dopo essere
stata decrementata).</p>
<p>Sì. Ritorna vero (ovvero != 0) se la variabile atomica è zero.</p>
<p>Da notare che queste funzioni sono più lente rispetto alla normale aritmetica,
e quindi non dovrebbero essere usate a sproposito.</p>
<p>Il secondo gruppo di operazioni atomiche sono definite in
<code class="docutils literal notranslate"><span class="pre">include/linux/bitops.h</span></code> ed agiscono sui bit d’una variabile di tipo
<code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>. Queste operazioni prendono come argomento un puntatore
alla variabile, e un numero di bit dove 0 è quello meno significativo.
<a class="reference internal" href="../../../core-api/kernel-api.html#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_bit()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">clear_bit()</span></code></a> e <a class="reference internal" href="../../../core-api/kernel-api.html#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">change_bit()</span></code></a>
impostano, cancellano, ed invertono il bit indicato.
<a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_set_bit" title="test_and_set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_set_bit()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_clear_bit" title="test_and_clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_clear_bit()</span></code></a> e
<a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_change_bit" title="test_and_change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_change_bit()</span></code></a> fanno la stessa cosa, ad eccezione che
ritornano vero se il bit era impostato; queste sono particolarmente
utili quando si vuole impostare atomicamente dei flag.</p>
<p>Con queste operazioni è possibile utilizzare indici di bit che eccedono
il valore <code class="docutils literal notranslate"><span class="pre">BITS_PER_LONG</span></code>. Il comportamento è strano sulle piattaforme
big-endian quindi è meglio evitarlo.</p>
</div>
<div class="section" id="simboli">
<h2>Simboli<a class="headerlink" href="#simboli" title="Permalink to this headline">¶</a></h2>
<p>All’interno del kernel, si seguono le normali regole del linker (ovvero,
a meno che un simbolo non venga dichiarato con visibilita limitata ad un
file con la parola chiave <code class="docutils literal notranslate"><span class="pre">static</span></code>, esso può essere utilizzato in qualsiasi
parte del kernel). Nonostante ciò, per i moduli, esiste una tabella dei
simboli esportati che limita i punti di accesso al kernel. Anche i moduli
possono esportare simboli.</p>
<div class="section" id="export-symbol">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code><a class="headerlink" href="#export-symbol" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Questo è il classico metodo per esportare un simbolo: i moduli caricati
dinamicamente potranno utilizzare normalmente il simbolo.</p>
</div>
<div class="section" id="export-symbol-gpl">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code><a class="headerlink" href="#export-symbol-gpl" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Essa è simile a <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code> ad eccezione del fatto che i
simboli esportati con <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> possono essere
utilizzati solo dai moduli che hanno dichiarato una licenza compatibile
con la GPL attraverso <code class="xref c c-func docutils literal notranslate"><span class="pre">MODULE_LICENSE()</span></code>. Questo implica che la
funzione esportata è considerata interna, e non una vera e propria interfaccia.
Alcuni manutentori e sviluppatori potrebbero comunque richiedere
<code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> quando si aggiungono nuove funzionalità o
interfacce.</p>
</div>
</div>
<div class="section" id="procedure-e-convenzioni">
<h2>Procedure e convenzioni<a class="headerlink" href="#procedure-e-convenzioni" title="Permalink to this headline">¶</a></h2>
<div class="section" id="liste-doppiamente-concatenate-include-linux-list-h">
<h3>Liste doppiamente concatenate <code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code><a class="headerlink" href="#liste-doppiamente-concatenate-include-linux-list-h" title="Permalink to this headline">¶</a></h3>
<p>Un tempo negli header del kernel c’erano tre gruppi di funzioni per
le liste concatenate, ma questa è stata la vincente. Se non avete particolari
necessità per una semplice lista concatenata, allora questa è una buona scelta.</p>
<p>In particolare, <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a> è utile.</p>
</div>
<div class="section" id="convenzione-dei-valori-di-ritorno">
<h3>Convenzione dei valori di ritorno<a class="headerlink" href="#convenzione-dei-valori-di-ritorno" title="Permalink to this headline">¶</a></h3>
<p>Per codice chiamato in contesto utente, è molto comune sfidare le convenzioni
C e ritornare 0 in caso di successo, ed un codice di errore negativo
(eg. <code class="docutils literal notranslate"><span class="pre">-EFAULT</span></code>) nei casi fallimentari. Questo potrebbe essere controintuitivo
a prima vista, ma è abbastanza diffuso nel kernel.</p>
<p>Utilizzate <code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/err.h</span></code>) per codificare
un numero d’errore negativo in un puntatore, e <code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code> e
<code class="xref c c-func docutils literal notranslate"><span class="pre">PTR_ERR()</span></code> per recuperarlo di nuovo: così si evita d’avere un
puntatore dedicato per il numero d’errore. Da brividi, ma in senso positivo.</p>
</div>
<div class="section" id="rompere-la-compilazione">
<h3>Rompere la compilazione<a class="headerlink" href="#rompere-la-compilazione" title="Permalink to this headline">¶</a></h3>
<p>Linus e gli altri sviluppatori a volte cambiano i nomi delle funzioni e
delle strutture nei kernel in sviluppo; questo non è solo per tenere
tutti sulle spine: questo riflette cambiamenti fondamentati (eg. la funzione
non può più essere chiamata con le funzioni attive, o fa controlli aggiuntivi,
o non fa più controlli che venivano fatti in precedenza). Solitamente a questo
s’accompagna un’adeguata e completa nota sulla lista di discussone
linux-kernel; cercate negli archivi.
Solitamente eseguire una semplice sostituzione su tutto un file rendere
le cose <strong>peggiori</strong>.</p>
</div>
<div class="section" id="inizializzazione-dei-campi-d-una-struttura">
<h3>Inizializzazione dei campi d’una struttura<a class="headerlink" href="#inizializzazione-dei-campi-d-una-struttura" title="Permalink to this headline">¶</a></h3>
<p>Il metodo preferito per l’inizializzazione delle strutture è quello
di utilizzare gli inizializzatori designati, come definiti nello
standard ISO C99, eg:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct block_device_operations opt_fops = {
        .open               = opt_open,
        .release            = opt_release,
        .ioctl              = opt_ioctl,
        .check_media_change = opt_media_change,
};
</pre></div>
</div>
<p>Questo rende più facile la ricerca con grep, e rende più chiaro quale campo
viene impostato. Dovreste fare così perché si mostra meglio.</p>
</div>
<div class="section" id="estensioni-gnu">
<h3>Estensioni GNU<a class="headerlink" href="#estensioni-gnu" title="Permalink to this headline">¶</a></h3>
<p>Le estensioni GNU sono esplicitamente permesse nel kernel Linux. Da notare
che alcune delle più complesse non sono ben supportate, per via dello scarso
sviluppo, ma le seguenti sono da considerarsi la norma (per maggiori dettagli,
leggete la sezione “C Extensions” nella pagina info di GCC - Sì, davvero
la pagina info, la pagina man è solo un breve riassunto delle cose nella
pagina info).</p>
<ul class="simple">
<li>Funzioni inline</li>
<li>Istruzioni in espressioni (ie. il costrutto ({ and }) ).</li>
<li>Dichiarate attributi di una funzione / variabile / tipo
(__attribute__)</li>
<li>typeof</li>
<li>Array con lunghezza zero</li>
<li>Macro varargs</li>
<li>Aritmentica sui puntatori void</li>
<li>Inizializzatori non costanti</li>
<li>Istruzioni assembler (non al di fuori di ‘arch/’ e ‘include/asm/’)</li>
<li>Nomi delle funzioni come stringhe (__func__).</li>
<li>__builtin_constant_p()</li>
</ul>
<p>Siate sospettosi quando utilizzate long long nel kernel, il codice generato
da gcc è orribile ed anche peggio: le divisioni e le moltiplicazioni non
funzionano sulle piattaforme i386 perché le rispettive funzioni di runtime
di GCC non sono incluse nell’ambiente del kernel.</p>
</div>
<div class="section" id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>Solitamente utilizzare il C++ nel kernel è una cattiva idea perché
il kernel non fornisce il necessario ambiente di runtime e gli header file
non sono stati verificati. Rimane comunque possibile, ma non consigliato.
Se davvero volete usarlo, almeno evitate le eccezioni.</p>
</div>
<div class="section" id="numif">
<h3>NUMif<a class="headerlink" href="#numif" title="Permalink to this headline">¶</a></h3>
<p>Viene generalmente considerato più pulito l’uso delle macro negli header file
(o all’inizio dei file .c) per astrarre funzioni piuttosto che utlizzare
l’istruzione di pre-processore `#if’ all’interno del codice sorgente.</p>
</div>
</div>
<div class="section" id="mettere-le-vostre-cose-nel-kernel">
<h2>Mettere le vostre cose nel kernel<a class="headerlink" href="#mettere-le-vostre-cose-nel-kernel" title="Permalink to this headline">¶</a></h2>
<p>Al fine d’avere le vostre cose in ordine per l’inclusione ufficiale, o
anche per avere patch pulite, c’è del lavoro amministrativo da fare:</p>
<ul>
<li><p class="first">Trovare di chi è lo stagno in cui state pisciando. Guardare in cima
ai file sorgenti, all’interno del file <code class="docutils literal notranslate"><span class="pre">MAINTAINERS</span></code>, ed alla fine
di tutti nel file <code class="docutils literal notranslate"><span class="pre">CREDITS</span></code>. Dovreste coordinarvi con queste persone
per evitare di duplicare gli sforzi, o provare qualcosa che è già stato
rigettato.</p>
<p>Assicuratevi di mettere il vostro nome ed indirizzo email in cima a
tutti i file che create o che mangeggiate significativamente. Questo è
il primo posto dove le persone guarderanno quando troveranno un baco,
o quando <strong>loro</strong> vorranno fare una modifica.</p>
</li>
<li><p class="first">Solitamente vorrete un’opzione di configurazione per la vostra modifica
al kernel. Modificate <code class="docutils literal notranslate"><span class="pre">Kconfig</span></code> nella cartella giusta. Il linguaggio
Config è facile con copia ed incolla, e c’è una completa documentazione
nel file <code class="docutils literal notranslate"><span class="pre">Documentation/kbuild/kconfig-language.rst</span></code>.</p>
<p>Nella descrizione della vostra opzione, assicuratevi di parlare sia agli
utenti esperti sia agli utente che non sanno nulla del vostro lavoro.
Menzionate qui le incompatibilità ed i problemi. Chiaramente la
descrizione deve terminare con “if in doubt, say N” (se siete in dubbio,
dite N) (oppure, occasionalmente, `Y’); questo è per le persone che non
hanno idea di che cosa voi stiate parlando.</p>
</li>
<li><p class="first">Modificate il file <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>: le variabili CONFIG sono esportate qui,
quindi potete solitamente aggiungere una riga come la seguete
“obj-$(CONFIG_xxx) += xxx.o”. La sintassi è documentata nel file
<code class="docutils literal notranslate"><span class="pre">Documentation/kbuild/makefiles.rst</span></code>.</p>
</li>
<li><p class="first">Aggiungete voi stessi in <code class="docutils literal notranslate"><span class="pre">CREDITS</span></code> se avete fatto qualcosa di notevole,
solitamente qualcosa che supera il singolo file (comunque il vostro nome
dovrebbe essere all’inizio dei file sorgenti). <code class="docutils literal notranslate"><span class="pre">MAINTAINERS</span></code> significa
che volete essere consultati quando vengono fatte delle modifiche ad un
sottosistema, e quando ci sono dei bachi; questo implica molto di più
di un semplice impegno su una parte del codice.</p>
</li>
<li><p class="first">Infine, non dimenticatevi di leggere
<code class="docutils literal notranslate"><span class="pre">Documentation/process/submitting-patches.rst</span></code> e possibilmente anche
<code class="docutils literal notranslate"><span class="pre">Documentation/process/submitting-drivers.rst</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="trucchetti-del-kernel">
<h2>Trucchetti del kernel<a class="headerlink" href="#trucchetti-del-kernel" title="Permalink to this headline">¶</a></h2>
<p>Dopo una rapida occhiata al codice, questi sono i preferiti. Sentitevi liberi
di aggiungerne altri.</p>
<p><code class="docutils literal notranslate"><span class="pre">arch/x86/include/asm/delay.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define ndelay(n) (__builtin_constant_p(n) ? \
        ((n) &gt; 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
        __ndelay(n))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">include/linux/fs.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a dentry
 * pointer with the same return value.
 *
 * This should be a per-architecture thing, to allow different
 * error and pointer decisions.
 */
 #define ERR_PTR(err)    ((void *)((long)(err)))
 #define PTR_ERR(ptr)    ((long)(ptr))
 #define IS_ERR(ptr)     ((unsigned long)(ptr) &gt; (unsigned long)(-1000))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/x86/include/asm/uaccess_32.h:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define copy_to_user(to,from,n)                         \
        (__builtin_constant_p(n) ?                      \
         __constant_copy_to_user((to),(from),(n)) :     \
         __generic_copy_to_user((to),(from),(n)))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/sparc/kernel/head.S:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Sun people can&#39;t spell worth damn. &quot;compatability&quot; indeed.
 * At least we *know* we can&#39;t spell, and use a spell-checker.
 */

/* Uh, actually Linus it is I who cannot spell. Too much murky
 * Sparc assembly will do this to ya.
 */
C_LABEL(cputypvar):
        .asciz &quot;compatibility&quot;

/* Tested on SS-5, SS-10. Probably someone at Sun applied a spell-checker. */
        .align 4
C_LABEL(cputypvar_sun4m):
        .asciz &quot;compatible&quot;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/sparc/lib/checksum.S:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Sun, you just can&#39;t beat me, you just can&#39;t.  Stop trying,
 * give up.  I&#39;m serious, I am going to kick the living shit
 * out of you, game over, lights out.
 */
</pre></div>
</div>
</div>
<div class="section" id="ringraziamenti">
<h2>Ringraziamenti<a class="headerlink" href="#ringraziamenti" title="Permalink to this headline">¶</a></h2>
<p>Ringrazio Andi Kleen per le sue idee, le risposte alle mie domande,
le correzioni dei miei errori, l’aggiunta di contenuti, eccetera.
Philipp Rumpf per l’ortografia e per aver reso più chiaro il testo, e
per alcuni eccellenti punti tutt’altro che ovvi. Werner Almesberger
per avermi fornito un ottimo riassunto di <a class="reference internal" href="../../../core-api/kernel-api.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>,
e Jes Sorensen e Andrea Arcangeli per le precisazioni. Michael Elizabeth
Chastain per aver verificato ed aggiunto la sezione configurazione.
Telsa Gwynne per avermi insegnato DocBook.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="locking.html" class="btn btn-neutral float-right" title="L’inaffidabile guida alla sincronizzazione" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Guida all’hacking del kernel" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>