

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device drivers infrastructure &mdash; The Linux Kernel 5.6.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Early Userspace" href="early-userspace/index.html" />
    <link rel="prev" title="Driver Basics" href="basics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Device drivers infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-basic-device-driver-model-structures">The Basic Device Driver-Model Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-base">Device Drivers Base</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-dma-management">Device Drivers DMA Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-pnp-support">Device drivers PnP support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#userspace-io-devices">Userspace IO devices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Device drivers infrastructure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/infrastructure.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-drivers-infrastructure">
<h1>Device drivers infrastructure<a class="headerlink" href="#device-drivers-infrastructure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-basic-device-driver-model-structures">
<h2>The Basic Device Driver-Model Structures<a class="headerlink" href="#the-basic-device-driver-model-structures" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.subsys_interface">
struct <code class="descname">subsys_interface</code><a class="headerlink" href="#c.subsys_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>interfaces to device functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct subsys_interface {
  const char *name;
  struct bus_type *subsys;
  struct list_head node;
  int (*add_dev)(struct device *dev, struct subsys_interface *sif);
  void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>name of the device function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subsys</span></code></dt>
<dd>subsytem of the devices to attach to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt>
<dd>the list of functions registered at the subsystem</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_dev</span></code></dt>
<dd>device hookup to device function handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove_dev</span></code></dt>
<dd>device hookup to device function handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple interfaces attached to a subsystem. Multiple interfaces can
attach to a subsystem and its devices. Unlike drivers, they do not
exclusively claim or control devices. Interfaces usually represent
a specific functionality of a subsystem/class of devices.</p>
<dl class="function">
<dt id="c.devm_alloc_percpu">
<code class="descname">devm_alloc_percpu</code><span class="sig-paren">(</span><em>dev</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_alloc_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>Device to allocate per-cpu memory for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>Type to allocate per-cpu memory for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="type">
<dt id="c.device_connection">
struct <code class="descname">device_connection</code><a class="headerlink" href="#c.device_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Device Connection Descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_connection {
  struct fwnode_handle    *fwnode;
  const char              *endpoint[2];
  const char              *id;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt>
<dd>The device node of the connected device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endpoint</span></code></dt>
<dd>The names of the two devices connected together</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>Unique identifier for the connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>List head, private, for internal use only</dd>
</dl>
<p><strong>NOTE</strong></p>
<p><strong>fwnode</strong> is not used together with <strong>endpoint</strong>. <strong>fwnode</strong> is used when
platform firmware defines the connection. When the connection is registered
with <a class="reference internal" href="device_connection.html#c.device_connection_add" title="device_connection_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_connection_add()</span></code></a> <strong>endpoint</strong> is used instead.</p>
<dl class="function">
<dt id="c.device_connections_add">
void <code class="descname">device_connections_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_connection" title="device_connection">device_connection</a> *<em>&nbsp;cons</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_connections_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multiple device connections at once</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_connection</span> <span class="pre">*</span> <span class="pre">cons</span></code></dt>
<dd>Zero terminated array of device connection descriptors</dd>
</dl>
<dl class="function">
<dt id="c.device_connections_remove">
void <code class="descname">device_connections_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_connection" title="device_connection">device_connection</a> *<em>&nbsp;cons</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_connections_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove multiple device connections at once</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_connection</span> <span class="pre">*</span> <span class="pre">cons</span></code></dt>
<dd>Zero terminated array of device connection descriptors</dd>
</dl>
<dl class="type">
<dt id="c.device_link_state">
enum <code class="descname">device_link_state</code><a class="headerlink" href="#c.device_link_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Device link states.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_NONE</span></code></dt>
<dd>The presence of the drivers is not being tracked.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code></dt>
<dd>None of the supplier/consumer drivers is present.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code></dt>
<dd>The supplier driver is present, but the consumer is not.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code></dt>
<dd>The consumer is probing (supplier driver present).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_ACTIVE</span></code></dt>
<dd>Both the supplier and consumer drivers are present.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code></dt>
<dd>The supplier driver is unbinding.</dd>
</dl>
<dl class="type">
<dt id="c.device_link">
struct <code class="descname">device_link</code><a class="headerlink" href="#c.device_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Device link representation.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_link {
  struct device *supplier;
  struct list_head s_node;
  struct device *consumer;
  struct list_head c_node;
  enum device_link_state status;
  u32 flags;
  refcount_t rpm_active;
  struct kref kref;
#ifdef CONFIG_SRCU;
  struct rcu_head rcu_head;
#endif;
  bool supplier_preactivated;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">supplier</span></code></dt>
<dd>The device on the supplier end of the link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_node</span></code></dt>
<dd>Hook to the supplier device’s list of links to consumers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer</span></code></dt>
<dd>The device on the consumer end of the link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_node</span></code></dt>
<dd>Hook to the consumer device’s list of links to suppliers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt>
<dd>The state of the link (with respect to the presence of drivers).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Link flags.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rpm_active</span></code></dt>
<dd>Whether or not the consumer device is runtime-PM-active.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt>
<dd>Count repeated addition of the same link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_head</span></code></dt>
<dd>An RCU head to use for deferred execution of SRCU callbacks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supplier_preactivated</span></code></dt>
<dd>Supplier has been made active before consumer probe.</dd>
</dl>
<dl class="type">
<dt id="c.dl_dev_state">
enum <code class="descname">dl_dev_state</code><a class="headerlink" href="#c.dl_dev_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Device driver presence tracking information.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_NO_DRIVER</span></code></dt>
<dd>There is no driver attached to the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_PROBING</span></code></dt>
<dd>A driver is probing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_DRIVER_BOUND</span></code></dt>
<dd>The driver has been bound to the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_UNBINDING</span></code></dt>
<dd>The driver is unbinding from the device.</dd>
</dl>
<dl class="type">
<dt id="c.dev_links_info">
struct <code class="descname">dev_links_info</code><a class="headerlink" href="#c.dev_links_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Device data related to device links.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_links_info {
  struct list_head suppliers;
  struct list_head consumers;
  struct list_head needs_suppliers;
  struct list_head defer_sync;
  bool need_for_probe;
  enum dl_dev_state status;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">suppliers</span></code></dt>
<dd>List of links to supplier devices.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumers</span></code></dt>
<dd>List of links to consumer devices.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_suppliers</span></code></dt>
<dd>Hook to global list of devices waiting for suppliers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">defer_sync</span></code></dt>
<dd>Hook to global list of devices that have deferred sync_state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">need_for_probe</span></code></dt>
<dd>If needs_suppliers is on a list, this indicates if the
suppliers are needed for probe or not.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt>
<dd>Driver status information.</dd>
</dl>
<dl class="type">
<dt id="c.device">
struct <code class="descname">device</code><a class="headerlink" href="#c.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic device structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device {
  struct kobject kobj;
  struct device           *parent;
  struct device_private   *p;
  const char              *init_name;
  const struct device_type *type;
  struct bus_type *bus;
  struct device_driver *driver;
  void *platform_data;
  void *driver_data;
#ifdef CONFIG_PROVE_LOCKING;
  struct mutex            lockdep_mutex;
#endif;
  struct mutex            mutex;
  struct dev_links_info   links;
  struct dev_pm_info      power;
  struct dev_pm_domain    *pm_domain;
#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN;
  struct irq_domain       *msi_domain;
#endif;
#ifdef CONFIG_PINCTRL;
  struct dev_pin_info     *pins;
#endif;
#ifdef CONFIG_GENERIC_MSI_IRQ;
  struct list_head        msi_list;
#endif;
  const struct dma_map_ops *dma_ops;
  u64 *dma_mask;
  u64 coherent_dma_mask;
  u64 bus_dma_limit;
  unsigned long   dma_pfn_offset;
  struct device_dma_parameters *dma_parms;
  struct list_head        dma_pools;
#ifdef CONFIG_DMA_DECLARE_COHERENT;
  struct dma_coherent_mem *dma_mem;
#endif;
#ifdef CONFIG_DMA_CMA;
  struct cma *cma_area;
#endif;
  struct dev_archdata     archdata;
  struct device_node      *of_node;
  struct fwnode_handle    *fwnode;
#ifdef CONFIG_NUMA;
  int numa_node;
#endif;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  struct list_head        devres_head;
  struct class            *class;
  const struct attribute_group **groups;
  void (*release)(struct device *dev);
  struct iommu_group      *iommu_group;
  struct iommu_fwspec     *iommu_fwspec;
  struct iommu_param      *iommu_param;
  bool offline_disabled:1;
  bool offline:1;
  bool of_node_reused:1;
  bool state_synced:1;
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL);
  bool dma_coherent:1;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">kobj</span></code></dt>
<dd>A top-level, abstract class from which other classes are derived.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt>
<dd>The device’s “parent” device, the device to which it is attached.
In most cases, a parent device is some sort of bus or host
controller. If parent is NULL, the device, is a top-level device,
which is not usually what you want.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt>
<dd>Holds the private data of the driver core portions of the device.
See the comment of the struct device_private for detail.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_name</span></code></dt>
<dd>Initial name of the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>The type of device.
This identifies the device type and carries type-specific
information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt>
<dd>Type of bus device is on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt>
<dd>Which driver has allocated this</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt>
<dd>Platform data specific to the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt>
<dd>Private pointer for driver specific info.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lockdep_mutex</span></code></dt>
<dd>An optional debug lock that a subsystem can use as a
peer lock to gain localized lockdep coverage of the device_lock.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt>
<dd>Mutex to synchronize calls to its driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt>
<dd>Links to suppliers and consumers of this device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt>
<dd>For device power management.
See Documentation/driver-api/pm/devices.rst for details.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_domain</span></code></dt>
<dd>Provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions
along with subsystem-level and driver-level callbacks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi_domain</span></code></dt>
<dd>The generic MSI domain this device is using.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pins</span></code></dt>
<dd>For device pin management.
See Documentation/driver-api/pinctl.rst for details.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi_list</span></code></dt>
<dd>Hosts MSI descriptors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_ops</span></code></dt>
<dd>DMA mapping operations for this device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mask</span></code></dt>
<dd>Dma mask (if dma’ble device).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coherent_dma_mask</span></code></dt>
<dd>Like dma_mask, but for alloc_coherent mapping as not all
hardware supports 64-bit addresses for consistent allocations
such descriptors.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_dma_limit</span></code></dt>
<dd>Limit of an upstream bridge or bus which imposes a smaller
DMA limit than the device itself supports.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_pfn_offset</span></code></dt>
<dd>offset of DMA memory range relatively of RAM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_parms</span></code></dt>
<dd>A low level driver may set these to teach IOMMU code about
segment limitations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_pools</span></code></dt>
<dd>Dma pools (if dma’ble device).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mem</span></code></dt>
<dd>Internal for coherent mem override.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cma_area</span></code></dt>
<dd>Contiguous memory area for dma allocations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">archdata</span></code></dt>
<dd>For arch-specific additions.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt>
<dd>Associated device tree node.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt>
<dd>Associated device node supplied by platform firmware.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">numa_node</span></code></dt>
<dd>NUMA node this device is close to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devt</span></code></dt>
<dd>For creating the sysfs “dev”.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>device instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_lock</span></code></dt>
<dd>Spinlock to protect the resource of the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_head</span></code></dt>
<dd>The resources list of the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt>
<dd>The class of the device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt>
<dd>Optional attribute groups.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt>
<dd>Callback to free the device after all references have
gone away. This should be set by the allocator of the
device (i.e. the bus driver that discovered the device).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu_group</span></code></dt>
<dd>IOMMU group the device belongs to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu_fwspec</span></code></dt>
<dd>IOMMU-specific properties supplied by firmware.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu_param</span></code></dt>
<dd>Per device generic IOMMU runtime data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline_disabled</span></code></dt>
<dd>If set, the device is permanently online.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline</span></code></dt>
<dd>Set after successful invocation of bus type’s .offline().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node_reused</span></code></dt>
<dd>Set if the device-tree node is shared with an ancestor
device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_synced</span></code></dt>
<dd>The hardware state of this device has been synced to match
the software state of this device by calling the driver/bus
sync_state() callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_coherent</span></code></dt>
<dd>this particular device is dma coherent, even if the
architecture supports non-coherent devices.</dd>
</dl>
<p><strong>Example</strong></p>
<dl class="docutils">
<dt>For devices on custom boards, as typical of embedded</dt>
<dd>and SOC based hardware, Linux often uses platform_data to point
to board-specific structures describing devices and how they
are wired.  That can include what ports are available, chip
variants, which GPIO pins act in what additional roles, and so
on.  This shrinks the “Board Support Packages” (BSPs) and
minimizes board-specific #ifdefs in drivers.</dd>
</dl>
<p><strong>Description</strong></p>
<p>At the lowest level, every device in a Linux system is represented by an
instance of struct device. The device structure contains the information
that the device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As a
result, it is rare for devices to be represented by bare device structures;
instead, that structure, like kobject structures, is usually embedded within
a higher-level representation of the device.</p>
<dl class="function">
<dt id="c.device_iommu_mapped">
bool <code class="descname">device_iommu_mapped</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_iommu_mapped" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true when the device DMA is translated by an IOMMU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to perform the check on</dd>
</dl>
</div>
<div class="section" id="device-drivers-base">
<h2>Device Drivers Base<a class="headerlink" href="#device-drivers-base" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.driver_init">
void <code class="descname">driver_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.driver_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize driver model.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.</p>
<dl class="function">
<dt id="c.driver_for_each_device">
int <code class="descname">driver_for_each_device</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator for devices bound to a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>Driver we’re iterating.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to the callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>Function to call for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the <strong>drv</strong>’s list of devices calling <strong>fn</strong> for each one.</p>
<dl class="function">
<dt id="c.driver_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">driver_find_device</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, const void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>The device’s driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.driver_for_each_device" title="driver_for_each_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_for_each_device()</span></code></a> function above, but
it returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<dl class="function">
<dt id="c.driver_create_file">
int <code class="descname">driver_create_file</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em>, const struct driver_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs file for driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>driver attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.driver_remove_file">
void <code class="descname">driver_remove_file</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em>, const struct driver_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs file for driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>driver attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.driver_register">
int <code class="descname">driver_register</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver with bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>We pass off most of the work to the bus_add_driver() call,
since most of the things we have to do deal with the bus
structures.</p>
<dl class="function">
<dt id="c.driver_unregister">
void <code class="descname">driver_unregister</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove driver from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Again, we pass off most of the work to the bus-level call.</p>
<dl class="function">
<dt id="c.driver_find">
struct device_driver * <code class="descname">driver_find</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct bus_type *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find" title="Permalink to this definition">¶</a></dt>
<dd><p>locate driver on a bus by its name.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus to scan for the driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="basics.html#c.kset_find_obj" title="kset_find_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_find_obj()</span></code></a> to iterate over list of drivers on
a bus to find driver by name. Return driver if found.</p>
<p>This routine provides no locking to prevent the driver it returns
from being unregistered or unloaded while the caller is using it.
The caller is responsible for preventing this.</p>
<dl class="function">
<dt id="c.device_link_add">
struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a> * <code class="descname">device_link_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;supplier</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">consumer</span></code></dt>
<dd>Consumer end of the link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">supplier</span></code></dt>
<dd>Supplier end of the link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active metastate and reference-counted upon the creation
of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
ignored.</p>
<p>If DL_FLAG_STATELESS is set in <strong>flags</strong>, the caller of this function is
expected to release the link returned by it directly with the help of either
<a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
<p>If that flag is not set, however, the caller of this function is handing the
management of the link over to the driver core entirely and its return value
can only be used to check whether or not the link is present.  In that case,
the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
flags can be used to indicate to the driver core when the link can be safely
deleted.  Namely, setting one of them in <strong>flags</strong> indicates to the driver core
that the link is not going to be used (by the given caller of this function)
after unbinding the consumer or supplier driver, respectively, from its
device, so the link can be deleted at that point.  If none of them is set,
the link will be maintained until one of the devices pointed to by it (either
the consumer or the supplier) is unregistered.</p>
<p>Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
DL_FLAG_AUTOREMOVE_SUPPLIER are not set in <strong>flags</strong> (that is, a persistent
managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
be used to request the driver core to automaticall probe for a consmer
driver after successfully binding a driver to the supplier device.</p>
<p>The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER,
DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in <strong>flags</strong> at
the same time is invalid and will cause NULL to be returned upfront.
However, if a device link between the given <strong>consumer</strong> and <strong>supplier</strong> pair
exists already when this function is called for them, the existing link will
be returned regardless of its current type and status (the link’s flags may
be modified then).  The caller of this function is then expected to treat
the link as though it has just been created, so (in particular) if
DL_FLAG_STATELESS was passed in <strong>flags</strong>, the link needs to be released
explicitly when not needed any more (as stated above).</p>
<p>A side effect of the link creation is re-ordering of dpm_list and the
devices_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).</p>
<p>The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.</p>
<dl class="function">
<dt id="c.device_link_del">
void <code class="descname">device_link_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a> *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_del" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>Device link to delete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.  If the link was added multiple times, it needs to be deleted as often.
Care is required for hotplugged devices:  Their links are purged on removal
and calling <a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> is then no longer allowed.</p>
<dl class="function">
<dt id="c.device_link_remove">
void <code class="descname">device_link_remove</code><span class="sig-paren">(</span>void *<em>&nbsp;consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;supplier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">consumer</span></code></dt>
<dd>Consumer end of the link.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">supplier</span></code></dt>
<dd>Supplier end of the link.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.</p>
<dl class="function">
<dt id="c.dev_driver_string">
const char * <code class="descname">dev_driver_string</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_driver_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device’s driver name, if at all possible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>struct device to get the name of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the device’s driver’s name if it is bound to a device.  If
the device is not bound to a driver, it will return the name of the bus
it is attached to.  If it is not attached to a bus either, an empty
string will be returned.</p>
<dl class="function">
<dt id="c.devm_device_add_group">
int <code class="descname">devm_device_add_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group *<em>&nbsp;grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_group" title="Permalink to this definition">¶</a></dt>
<dd><p>given a device, create a managed attribute group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to create the group for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">grp</span></code></dt>
<dd>The attribute group to create</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a group for the first time.  It will explicitly
warn and error if any of the attribute files being created already exist.</p>
<p>Returns 0 on success or error code on failure.</p>
<dl class="function">
<dt id="c.devm_device_remove_group">
void <code class="descname">devm_device_remove_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group *<em>&nbsp;grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_remove_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to remove the group from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">grp</span></code></dt>
<dd>group to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a group of attributes from a device. The attributes
previously have to have been created for this group, otherwise it will fail.</p>
<dl class="function">
<dt id="c.devm_device_add_groups">
int <code class="descname">devm_device_add_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>create a bunch of managed attribute groups</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to create the group for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>The attribute groups to create, NULL terminated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a bunch of managed attribute groups.  If an error
occurs when creating a group, all previously created groups will be
removed, unwinding everything back to the original state when this
function was called.  It will explicitly warn and error if any of the
attribute files being created already exist.</p>
<p>Returns 0 on success or error code from sysfs_create_group on failure.</p>
<dl class="function">
<dt id="c.devm_device_remove_groups">
void <code class="descname">devm_device_remove_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_remove_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a list of managed groups</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device for the groups to be removed from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>NULL terminated list of groups to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>If groups is not NULL, remove the specified groups from the device.</p>
<dl class="function">
<dt id="c.device_create_file">
int <code class="descname">device_create_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs attribute file for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_file">
void <code class="descname">device_remove_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs attribute file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_file_self">
bool <code class="descname">device_remove_file_self</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file_self" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs attribute file from its own method.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See kernfs_remove_self() for details.</p>
<dl class="function">
<dt id="c.device_create_bin_file">
int <code class="descname">device_create_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs binary attribute file for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device binary attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_bin_file">
void <code class="descname">device_remove_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs binary attribute file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device binary attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_initialize">
void <code class="descname">device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>init device structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the device for use by other layers by initializing
its fields.
It is the first half of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, if called by
that function, though it can also be called separately, so one
may use <strong>dev</strong>’s fields. In particular, <a class="reference internal" href="#c.get_device" title="get_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_device()</span></code></a>/<a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>
may be used for reference counting of <strong>dev</strong> after calling this
function.</p>
<p>All fields in <strong>dev</strong> must be initialized by the caller to 0, except
for those explicitly set to some other value.  The simplest
approach is to use <a class="reference internal" href="../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> to allocate the structure containing
<strong>dev</strong>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your reference instead of freeing
<strong>dev</strong> directly once you have called this function.</p>
<dl class="function">
<dt id="c.dev_set_name">
int <code class="descname">dev_set_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set a device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string for the device’s name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<dl class="function">
<dt id="c.device_add">
int <code class="descname">device_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add device to device hierarchy.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, though may be called
separately _iff_ <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a> has been called separately.</p>
<p>This adds <strong>dev</strong> to the kobject hierarchy via <a class="reference internal" href="basics.html#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.</p>
<p>Do not call this routine or <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a> more than once for
any device structure.  The driver model core is not designed to work
with devices that get unregistered and then spring back to life.
(Among other things, it’s very hard to guarantee that all references
to the previous incarnation of <strong>dev</strong> have been dropped.)  Allocate
and register a fresh new struct device instead.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your
reference instead.</p>
<p>Rule of thumb is: if <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> succeeds, you should call
<a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a> when you want to get rid of it. If <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> has
<em>not</em> succeeded, use <em>only</em> <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to drop the reference
count.</p>
<dl class="function">
<dt id="c.device_register">
int <code class="descname">device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a device with the system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.</p>
<p>For more information, see the kerneldoc for <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a>
and <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up the
reference initialized in this function instead.</p>
<dl class="function">
<dt id="c.get_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>increment reference count for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply forwards the call to <a class="reference internal" href="basics.html#c.kobject_get" title="kobject_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_get()</span></code></a>, though
we do take care to provide for the case that we get a NULL
pointer passed in.</p>
<dl class="function">
<dt id="c.put_device">
void <code class="descname">put_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_device" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device in question.</dd>
</dl>
<dl class="function">
<dt id="c.device_del">
void <code class="descname">device_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>delete device from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>, and removes it
from the kobject hierarchy.</p>
<p><strong>NOTE</strong></p>
<p>this should be called manually _iff_ <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> was
also called manually.</p>
<dl class="function">
<dt id="c.device_unregister">
void <code class="descname">device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister device from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device going away.</dd>
</dl>
<p><strong>Description</strong></p>
<p>We do this in two parts, like we do <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. First,
we remove it from all the subsystems with <a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a>, then
we decrement the reference count via <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>. If that
is the final reference count, the device will be cleaned up
via device_release() above. Otherwise, the structure will
stick around until the final reference to the device is dropped.</p>
<dl class="function">
<dt id="c.device_for_each_child">
int <code class="descname">device_for_each_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child" title="Permalink to this definition">¶</a></dt>
<dd><p>device child iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<dl class="function">
<dt id="c.device_for_each_child_reverse">
int <code class="descname">device_for_each_child_reverse</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>device child iterator in reversed order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<dl class="function">
<dt id="c.device_find_child">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_find_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_for_each_child()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero and a reference to the
current device can be obtained, this function will return to the caller
and not iterate over any more devices.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
<dl class="function">
<dt id="c.device_find_child_by_name">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_find_child_by_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a child device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the child device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_find_child" title="device_find_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_find_child()</span></code></a> function above, but it
returns a reference to a device that has the name <strong>name</strong>.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
<dl class="function">
<dt id="c.__root_device_register">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">__root_device_register</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__root_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and register a root device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>root device name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of the root device, usually THIS_MODULE</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a root device and registers it
using <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. In order to free the returned
device, use <a class="reference internal" href="#c.root_device_unregister" title="root_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">root_device_unregister()</span></code></a>.</p>
<p>Root devices are dummy devices which allow other devices
to be grouped under /sys/devices. Use this function to
allocate a root device and then use it as the parent of
any device which should appear under /sys/devices/{name}</p>
<p>The /sys/devices/{name} directory will also contain a
‘module’ symlink which points to the <strong>owner</strong> directory
in sysfs.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>You probably want to use root_device_register().</p>
<dl class="function">
<dt id="c.root_device_unregister">
void <code class="descname">root_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.root_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and free a root device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device going away</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters and cleans up a device that was created by
root_device_register().</p>
<dl class="function">
<dt id="c.device_create_vargs">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create_vargs</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_vargs" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device’s name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>va_list for the device’s name</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to class_create().</p>
<dl class="function">
<dt id="c.device_create">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device’s name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to class_create().</p>
<dl class="function">
<dt id="c.device_create_with_groups">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create_with_groups</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const struct attribute_group **<em>&nbsp;groups</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_with_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>NULL-terminated list of attribute groups to be created</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device’s name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.
Additional attributes specified in the groups parameter will also
be created automatically.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to class_create().</p>
<dl class="function">
<dt id="c.device_destroy">
void <code class="descname">device_destroy</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, dev_t<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a device that was created with <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device was registered with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t of the device that was previously registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call unregisters and cleans up a device that was created with a
call to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
<dl class="function">
<dt id="c.device_rename">
int <code class="descname">device_rename</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>renames a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the pointer to the struct device to be renamed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new_name</span></code></dt>
<dd>the new name of the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of device_rename
on the same device to ensure that new_name is valid and
won’t conflict with other devices.</p>
<p><strong>Note</strong></p>
<p>Don’t call this function.  Currently, the networking layer calls this
function, but that will change.  The following text from Kay Sievers offers
some insight:</p>
<p>Renaming devices is racy at many levels, symlinks and other stuff are not
replaced atomically, and you get a “move” uevent, but it’s not easy to
connect the event to the old and new device. Device nodes are not renamed at
all, there isn’t even support for that in the kernel now.</p>
<p>In the meantime, during renaming, your target name might be taken by another
driver, creating conflicts. Or the old name is taken directly after you
renamed it – then you get events for the same DEVPATH, before you even see
the “move” event. It’s just a mess, and nothing new should ever rely on
kernel device renaming. Besides that, it’s not even implemented now for
other things than (driver-core wise very simple) network devices.</p>
<p>We are currently about to change network renaming in udev to completely
disallow renaming of devices in the same namespace as the kernel uses,
because we can’t solve the problems properly, that arise with swapping names
of multiple interfaces without races. Means, renaming of eth[0-9]* will only
be allowed to some other name than eth[0-9]*, for the aforementioned
reasons.</p>
<p>Make up a “real” name in the driver before you register anything, or add
some other attributes for userspace to find the device, or use udev to add
symlinks – but never rename kernel devices later, it’s a complete mess. We
don’t even want to get into that and try to implement the missing pieces in
the core. We really have other pieces to fix in the driver core mess. :)</p>
<dl class="function">
<dt id="c.device_move">
int <code class="descname">device_move</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;new_parent</em>, enum dpm_order<em>&nbsp;dpm_order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_move" title="Permalink to this definition">¶</a></dt>
<dd><p>moves a device to a new parent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the pointer to the struct device to be moved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">new_parent</span></code></dt>
<dd>the new parent of the device (can be NULL)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dpm_order</span> <span class="pre">dpm_order</span></code></dt>
<dd>how to reorder the dpm_list</dd>
</dl>
<dl class="function">
<dt id="c.set_primary_fwnode">
void <code class="descname">set_primary_fwnode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct fwnode_handle *<em>&nbsp;fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_primary_fwnode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the primary firmware node of a given device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>New primary firmware node of the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the device’s firmware node pointer to <strong>fwnode</strong>, but if a secondary
firmware node of the device is present, preserve it.</p>
<dl class="function">
<dt id="c.device_set_of_node_from_dev">
void <code class="descname">device_set_of_node_from_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_set_of_node_from_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>reuse device-tree node of another device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device whose device-tree node is being set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev2</span></code></dt>
<dd>device whose device-tree node is being reused</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes another reference to the new device-tree node after first dropping
any reference held to the old node.</p>
<dl class="function">
<dt id="c.register_syscore_ops">
void <code class="descname">register_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_syscore_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a set of system core operations.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>System core operations to register.</dd>
</dl>
<dl class="function">
<dt id="c.unregister_syscore_ops">
void <code class="descname">unregister_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_syscore_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a set of system core operations.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>System core operations to unregister.</dd>
</dl>
<dl class="function">
<dt id="c.syscore_suspend">
int <code class="descname">syscore_suspend</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute all the registered system core suspend callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
<dl class="function">
<dt id="c.syscore_resume">
void <code class="descname">syscore_resume</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute all the registered system core resume callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
<dl class="function">
<dt id="c.__class_create">
struct class * <code class="descname">__class_create</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, const char *<em>&nbsp;name</em>, struct lock_class_key *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__class_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a struct class structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>pointer to the module that is to “own” this struct class</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pointer to a string for the name of this class.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>the lock_class_key for this class; used by mutex lock debugging</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to create a struct class pointer that can then be used
in calls to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code> pointer on success, or ERR_PTR() on error.</p>
<p>Note, the pointer created here is to be destroyed when finished by
making a call to <a class="reference internal" href="#c.class_destroy" title="class_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_destroy()</span></code></a>.</p>
<dl class="function">
<dt id="c.class_destroy">
void <code class="descname">class_destroy</code><span class="sig-paren">(</span>struct class *<em>&nbsp;cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a struct class structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>pointer to the struct class that is to be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, the pointer to be destroyed must have been created with a call
to class_create().</p>
<dl class="function">
<dt id="c.class_dev_iter_init">
void <code class="descname">class_dev_iter_init</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em>, struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const struct device_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize class device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we wanna iterate over</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start iterating from, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>device_type of the devices to iterate over, NULL for all</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize class iterator <strong>iter</strong> such that it iterates over devices
of <strong>class</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
<dl class="function">
<dt id="c.class_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">class_dev_iter_next</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to proceed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won’t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into class code.</p>
<dl class="function">
<dt id="c.class_dev_iter_exit">
void <code class="descname">class_dev_iter_exit</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to finish</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
<dl class="function">
<dt id="c.class_for_each_device">
int <code class="descname">class_for_each_device</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we’re iterating</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start with in the list, if any.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>class</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.  If <strong>start</strong> is set, the list iteration will start
there, otherwise if it is NULL, the iteration starts at the
beginning of the list.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>fn</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
<dl class="function">
<dt id="c.class_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">class_find_device</code><span class="sig-paren">(</span>struct class *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, const void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we’re iterating</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the match function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt>
<dd>function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the class_for_each_dev() function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<p>Note, you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
<p><strong>match</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
<dl class="function">
<dt id="c.class_compat_register">
struct class_compat * <code class="descname">class_compat_register</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a compatibility class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the class</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility class are meant as a temporary user-space compatibility
workaround when converting a family of class devices to a bus devices.</p>
<dl class="function">
<dt id="c.class_compat_unregister">
void <code class="descname">class_compat_unregister</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a compatibility class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the class to unregister</dd>
</dl>
<dl class="function">
<dt id="c.class_compat_create_link">
int <code class="descname">class_compat_create_link</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_create_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a compatibility class device link to a bus device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the compatibility class</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the target bus device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device_link</span></code></dt>
<dd>an optional device to which a “device” link should be created</dd>
</dl>
<dl class="function">
<dt id="c.class_compat_remove_link">
void <code class="descname">class_compat_remove_link</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_remove_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a compatibility class device link to a bus device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the compatibility class</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the target bus device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device_link</span></code></dt>
<dd>an optional device to which a “device” link was previously
created</dd>
</dl>
<dl class="type">
<dt id="c.node_access_nodes">
struct <code class="descname">node_access_nodes</code><a class="headerlink" href="#c.node_access_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Access class device to hold user visible relationships to other nodes.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_access_nodes {
  struct device           dev;
  struct list_head        list_node;
  unsigned access;
#ifdef CONFIG_HMEM_REPORTING;
  struct node_hmem_attrs  hmem_attrs;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>Device for this memory access class</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_node</span></code></dt>
<dd>List element in the node’s access list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access</span></code></dt>
<dd>The access class rank</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hmem_attrs</span></code></dt>
<dd>Heterogeneous memory performance attributes</dd>
</dl>
<dl class="function">
<dt id="c.node_set_perf_attrs">
void <code class="descname">node_set_perf_attrs</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nid</em>, struct node_hmem_attrs *<em>&nbsp;hmem_attrs</em>, unsigned<em>&nbsp;access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.node_set_perf_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the performance values for given access class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>Node identifier to be set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_hmem_attrs</span> <span class="pre">*</span> <span class="pre">hmem_attrs</span></code></dt>
<dd>Heterogeneous memory performance attributes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">access</span></code></dt>
<dd>The access class the for the given attributes</dd>
</dl>
<dl class="type">
<dt id="c.node_cache_info">
struct <code class="descname">node_cache_info</code><a class="headerlink" href="#c.node_cache_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal tracking for memory node caches</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_cache_info {
  struct device dev;
  struct list_head node;
  struct node_cache_attrs cache_attrs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>Device represeting the cache level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt>
<dd>List element for tracking in the node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache_attrs</span></code></dt>
<dd>Attributes for this cache level</dd>
</dl>
<dl class="function">
<dt id="c.node_add_cache">
void <code class="descname">node_add_cache</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nid</em>, struct node_cache_attrs *<em>&nbsp;cache_attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.node_add_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>add cache attribute to a memory node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>Node identifier that has new cache attributes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_cache_attrs</span> <span class="pre">*</span> <span class="pre">cache_attrs</span></code></dt>
<dd>Attributes for the cache being added</dd>
</dl>
<dl class="function">
<dt id="c.unregister_node">
void <code class="descname">unregister_node</code><span class="sig-paren">(</span>struct node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_node" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a node device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>node going away</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a node device <strong>node</strong>.  All the devices on the node must be
unregistered before calling this function.</p>
<dl class="function">
<dt id="c.register_memory_node_under_compute_node">
int <code class="descname">register_memory_node_under_compute_node</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;mem_nid</em>, unsigned int<em>&nbsp;cpu_nid</em>, unsigned<em>&nbsp;access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_memory_node_under_compute_node" title="Permalink to this definition">¶</a></dt>
<dd><p>link memory node to its compute node for a given access class.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mem_nid</span></code></dt>
<dd>Memory node number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu_nid</span></code></dt>
<dd>Cpu  node number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">access</span></code></dt>
<dd>Access class to register</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For use with platforms that may have separate memory and compute nodes.
This function will export node relationships linking which memory
initiator nodes can access memory targets at a given ranked access
class.</div></blockquote>
<dl class="function">
<dt id="c.request_firmware">
int <code class="descname">request_firmware</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware" title="Permalink to this definition">¶</a></dt>
<dd><p>send firmware request and wait for it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>firmware_p</strong> will be used to return a firmware image by the name
of <strong>name</strong> for device <strong>device</strong>.</p>
<p>Should be called from user context where sleeping is allowed.</p>
<p><strong>name</strong> will be used as $FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<p>The function can be called safely inside device’s suspend and
resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.firmware_request_nowarn">
int <code class="descname">firmware_request_nowarn</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>request for an optional fw module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, except
it doesn’t produce warning messages when the file is not found.
The sysfs fallback mechanism is enabled if direct filesystem lookup fails,
however, however failures to find the firmware file with it are still
suppressed. It is therefore up to the driver to check for the return value
of this call and to decide when to inform the users of errors.</p>
<dl class="function">
<dt id="c.request_firmware_direct">
int <code class="descname">request_firmware_direct</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware directly without usermode helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but this doesn’t
fall back to usermode helper even if the firmware couldn’t be loaded
directly from fs.  Hence it’s useful for loading optional firmwares, which
aren’t always present, without extra long timeouts of udev.</p>
<dl class="function">
<dt id="c.firmware_request_cache">
int <code class="descname">firmware_request_cache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>cache firmware for suspend so resume can use it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware should be cached for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are some devices with an optimization that enables the device to not
require loading firmware on system reboot. This optimization may still
require the firmware present on resume from suspend. This routine can be
used to ensure the firmware is present on resume from suspend in these
situations. This helper is not compatible with drivers which use
<a class="reference internal" href="#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_into_buf()</span></code></a> or <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> with no uevent set.</p>
<dl class="function">
<dt id="c.request_firmware_into_buf">
int <code class="descname">request_firmware_into_buf</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_into_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware into a previously allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded and DMA region allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>address of buffer to load firmware into</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but it doesn’t
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by <strong>buf</strong> and the <strong>firmware_p</strong>
data member is pointed at <strong>buf</strong>.</p>
<p>This function doesn’t cache firmware either.</p>
<dl class="function">
<dt id="c.release_firmware">
void <code class="descname">release_firmware</code><span class="sig-paren">(</span>const struct firmware *<em>&nbsp;fw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_firmware" title="Permalink to this definition">¶</a></dt>
<dd><p>release the resource associated with a firmware image</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*</span> <span class="pre">fw</span></code></dt>
<dd>firmware resource to release</dd>
</dl>
<dl class="function">
<dt id="c.request_firmware_nowait">
int <code class="descname">request_firmware_nowait</code><span class="sig-paren">(</span>struct module *<em>&nbsp;module</em>, bool<em>&nbsp;uevent</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, gfp_t<em>&nbsp;gfp</em>, void *<em>&nbsp;context</em>, void (*cont) (const struct firmware<em>&nbsp;*fw</em>, void<em>&nbsp;*context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous version of request_firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module requesting the firmware</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">uevent</span></code></dt>
<dd>sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>will be passed over to <strong>cont</strong>, and
<strong>fw</strong> may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if firmware request fails.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">cont</span></code></dt>
<dd>function will be called asynchronously when the firmware
request is over.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller must hold the reference count of <strong>device</strong>.</p>
<dl class="docutils">
<dt>Asynchronous variant of request_firmware() for user contexts:</dt>
<dd><ul class="first last simple">
<li>sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -&gt;probe() methods, if
<strong>gfp</strong> is GFP_KERNEL.</li>
<li>can’t sleep at all if <strong>gfp</strong> is GFP_ATOMIC.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.transport_class_register">
int <code class="descname">transport_class_register</code><span class="sig-paren">(</span>struct transport_class *<em>&nbsp;tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register an initial transport class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*</span> <span class="pre">tclass</span></code></dt>
<dd>a pointer to the transport class structure to be initialised</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There’s a macro
DECLARE_TRANSPORT_CLASS() to do this (declared classes still must
be registered).</p>
<p>Returns 0 on success or error on failure.</p>
<dl class="function">
<dt id="c.transport_class_unregister">
void <code class="descname">transport_class_unregister</code><span class="sig-paren">(</span>struct transport_class *<em>&nbsp;tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a previously registered class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*</span> <span class="pre">tclass</span></code></dt>
<dd>The transport class to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the transport
class.</p>
<dl class="function">
<dt id="c.anon_transport_class_register">
int <code class="descname">anon_transport_class_register</code><span class="sig-paren">(</span>struct anon_transport_class *<em>&nbsp;atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register an anonymous class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*</span> <span class="pre">atc</span></code></dt>
<dd>The anon transport class to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use DECLARE_ANON_TRANSPORT_CLASS() to
initialise the anon transport class storage.</p>
<dl class="function">
<dt id="c.anon_transport_class_unregister">
void <code class="descname">anon_transport_class_unregister</code><span class="sig-paren">(</span>struct anon_transport_class *<em>&nbsp;atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an anon class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*</span> <span class="pre">atc</span></code></dt>
<dd>Pointer to the anon transport class to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the anon
transport class.</p>
<dl class="function">
<dt id="c.transport_setup_device">
void <code class="descname">transport_setup_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_setup_device" title="Permalink to this definition">¶</a></dt>
<dd><p>declare a new dev for transport class association but don’t make it visible yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the generic device representing the entity being added</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).</p>
<dl class="function">
<dt id="c.transport_add_device">
int <code class="descname">transport_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>declare a new dev for transport class association</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the generic device representing the entity being added</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.</p>
<dl class="function">
<dt id="c.transport_configure_device">
void <code class="descname">transport_configure_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_configure_device" title="Permalink to this definition">¶</a></dt>
<dd><p>configure an already set up device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>generic device representing device to be configured</dd>
</dl>
<p><strong>Description</strong></p>
<p>The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.</p>
<dl class="function">
<dt id="c.transport_remove_device">
void <code class="descname">transport_remove_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_remove_device" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the visibility of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>generic device to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don’t need to
do remove and destroy as separate operations, use
transport_unregister_device() (see transport_class.h) which will
perform both calls for you.</p>
<dl class="function">
<dt id="c.transport_destroy_device">
void <code class="descname">transport_destroy_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_destroy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a removed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to eliminate from the transport class.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.</p>
<dl class="function">
<dt id="c.device_bind_driver">
int <code class="descname">device_bind_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_bind_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a driver to one device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow manual attachment of a driver to a device.
Caller must have already set <strong>dev-&gt;driver</strong>.</p>
<p>Note that this does not modify the bus reference count
nor take the bus’s rwsem. Please verify those are accounted
for before calling this. (It is ok to call with no other effort
from a driver’s probe() method.)</p>
<p>This function must be called with the device lock held.</p>
<dl class="function">
<dt id="c.wait_for_device_probe">
void <code class="descname">wait_for_device_probe</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_device_probe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for device probing to be completed.</p>
<dl class="function">
<dt id="c.device_attach">
int <code class="descname">device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>try to attach device to a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of drivers that the bus has and call
driver_probe_device() for each pair. If a compatible
pair is found, break out and return.</p>
<p>Returns 1 if the device was bound to a driver;
0 if no matching driver was found;
-ENODEV if the device is not registered.</p>
<p>When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
<dl class="function">
<dt id="c.driver_attach">
int <code class="descname">driver_attach</code><span class="sig-paren">(</span>struct device_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>try to bind driver to devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of devices that the bus has on it and try to
match the driver with each one.  If driver_probe_device()
returns 0 and the <strong>dev-&gt;driver</strong> is set, we’ve found a
compatible pair.</p>
<dl class="function">
<dt id="c.device_release_driver">
void <code class="descname">device_release_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_release_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>manually detach device from driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually detach device from driver.
When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
<p>If this function is to be called with <strong>dev-&gt;parent</strong> lock held, ensure that
the device’s consumers are unbound in advance or that their locks can be
acquired under the <strong>dev-&gt;parent</strong> lock.</p>
<dl class="function">
<dt id="c.platform_device_register_resndata">
struct platform_device * <code class="descname">platform_device_register_resndata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_resndata" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.platform_device_register_simple">
struct platform_device * <code class="descname">platform_device_register_simple</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device and its resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>This interface is primarily intended for use with legacy drivers which
probe hardware directly.  Because such drivers create sysfs device nodes
themselves, rather than letting system infrastructure handle such device
enumeration tasks, they don’t fully conform to the Linux driver model.
In particular, when such drivers are built as modules, they can’t be
“hotplugged”.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.platform_device_register_data">
struct platform_device * <code class="descname">platform_device_register_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_data" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.platform_get_resource">
struct resource * <code class="descname">platform_get_resource</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>get a resource for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>resource type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>resource index</dd>
</dl>
<dl class="function">
<dt id="c.devm_platform_ioremap_resource">
void __iomem * <code class="descname">devm_platform_ioremap_resource</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, unsigned int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>call devm_ioremap_resource() for a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to use both for memory resource lookup as well as
resource management</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>resource index</dd>
</dl>
<dl class="function">
<dt id="c.devm_platform_ioremap_resource_byname">
void __iomem * <code class="descname">devm_platform_ioremap_resource_byname</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>call devm_ioremap_resource for a platform device, retrieve the resource by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to use both for memory resource lookup as well as
resource management</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the resource</dd>
</dl>
<dl class="function">
<dt id="c.platform_get_irq_optional">
int <code class="descname">platform_get_irq_optional</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>get an optional IRQ for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>IRQ number index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device. Device drivers should check the return
value for errors so as to not pass a negative integer value to the
<a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs. This is the same as <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, except that it
does not print an error message if an IRQ can not be obtained.</p>
<p><strong>Example</strong></p>
<blockquote>
<div><p>int irq = platform_get_irq_optional(pdev, 0);
if (irq &lt; 0)</p>
<blockquote>
<div>return irq;</div></blockquote>
</div></blockquote>
<p><strong>Return</strong></p>
<p>IRQ number on success, negative error number on failure.</p>
<dl class="function">
<dt id="c.platform_get_irq">
int <code class="descname">platform_get_irq</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>get an IRQ for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>IRQ number index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device and prints an error message if finding the
IRQ fails. Device drivers should check the return value for errors so as to
not pass a negative integer value to the <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs.</p>
<p><strong>Example</strong></p>
<blockquote>
<div><p>int irq = platform_get_irq(pdev, 0);
if (irq &lt; 0)</p>
<blockquote>
<div>return irq;</div></blockquote>
</div></blockquote>
<p><strong>Return</strong></p>
<p>IRQ number on success, negative error number on failure.</p>
<dl class="function">
<dt id="c.platform_irq_count">
int <code class="descname">platform_irq_count</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_irq_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of IRQs a platform device uses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of IRQs a platform device uses or EPROBE_DEFER</p>
<dl class="function">
<dt id="c.platform_get_resource_byname">
struct resource * <code class="descname">platform_get_resource_byname</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>get a resource for a device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>resource type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>resource name</dd>
</dl>
<dl class="function">
<dt id="c.platform_get_irq_byname">
int <code class="descname">platform_get_irq_byname</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>get an IRQ for a device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>IRQ name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an IRQ like <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, but then by name rather then by index.</p>
<p><strong>Return</strong></p>
<p>IRQ number on success, negative error number on failure.</p>
<dl class="function">
<dt id="c.platform_get_irq_byname_optional">
int <code class="descname">platform_get_irq_byname_optional</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>get an optional IRQ for a device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>IRQ name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an optional IRQ by name like <a class="reference internal" href="#c.platform_get_irq_byname" title="platform_get_irq_byname"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq_byname()</span></code></a>. Except that it
does not print an error message if an IRQ can not be obtained.</p>
<p><strong>Return</strong></p>
<p>IRQ number on success, negative error number on failure.</p>
<dl class="function">
<dt id="c.platform_add_devices">
int <code class="descname">platform_add_devices</code><span class="sig-paren">(</span>struct platform_device **<em>&nbsp;devs</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_add_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>add a numbers of platform devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">**</span> <span class="pre">devs</span></code></dt>
<dd>array of platform devices to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of platform devices in array</dd>
</dl>
<dl class="function">
<dt id="c.platform_device_put">
void <code class="descname">platform_device_put</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_put" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all memory associated with a platform device.  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
<dl class="function">
<dt id="c.platform_device_alloc">
struct platform_device * <code class="descname">platform_device_alloc</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>create a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we’re adding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a platform device object which can have other objects attached
to it, and which will have attached objects freed when it is released.</p>
<dl class="function">
<dt id="c.platform_device_add_resources">
int <code class="descname">platform_device_add_resources</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>add resources to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device allocated by platform_device_alloc to add resources to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of the resources to the platform device.  The memory
associated with the resources will be freed when the platform device is
released.</p>
<dl class="function">
<dt id="c.platform_device_add_data">
int <code class="descname">platform_device_add_data</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>add platform-specific data to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device allocated by platform_device_alloc to add resources to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of platform specific data to the platform device’s
platform_data pointer.  The memory associated with the platform data
will be freed when the platform device is released.</p>
<dl class="function">
<dt id="c.platform_device_add_properties">
int <code class="descname">platform_device_add_properties</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const struct property_entry *<em>&nbsp;properties</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>add built-in properties to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to add properties to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">property_entry</span> <span class="pre">*</span> <span class="pre">properties</span></code></dt>
<dd>null terminated array of properties to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function will take deep copy of <strong>properties</strong> and attach the copy to the
platform device. The memory associated with properties will be freed when the
platform device is released.</p>
<dl class="function">
<dt id="c.platform_device_add">
int <code class="descname">platform_device_add</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform device to device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we’re adding</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.platform_device_register" title="platform_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_register()</span></code></a>, though may be called
separately _iff_ pdev was allocated by <a class="reference internal" href="#c.platform_device_alloc" title="platform_device_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_alloc()</span></code></a>.</p>
<dl class="function">
<dt id="c.platform_device_del">
void <code class="descname">platform_device_del</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we’re removing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function will also release all memory- and port-based
resources owned by the device (<strong>dev-&gt;resource</strong>).  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
<dl class="function">
<dt id="c.platform_device_register">
int <code class="descname">platform_device_register</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we’re adding</dd>
</dl>
<dl class="function">
<dt id="c.platform_device_unregister">
void <code class="descname">platform_device_unregister</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we’re unregistering</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregistration is done in 2 steps. First we release all resources
and remove it from the subsystem, then we drop reference count by
calling <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.platform_device_register_full">
struct platform_device * <code class="descname">platform_device_register_full</code><span class="sig-paren">(</span>const struct platform_device_info *<em>&nbsp;pdevinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">platform_device_info</span> <span class="pre">*</span> <span class="pre">pdevinfo</span></code></dt>
<dd>data used to create device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.__platform_driver_register">
int <code class="descname">__platform_driver_register</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver for platform-level devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owning module/driver</dd>
</dl>
<dl class="function">
<dt id="c.platform_driver_unregister">
void <code class="descname">platform_driver_unregister</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a driver for platform-level devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
</dl>
<dl class="function">
<dt id="c.__platform_driver_probe">
int <code class="descname">__platform_driver_probe</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em>, int (*probe) (struct platform_device<em>&nbsp;*</em>, struct module *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver for non-hotpluggable device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span> <span class="pre">probe</span></code></dt>
<dd>the driver probe routine, probably from an __init section</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module which will be the owner of the driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this instead of platform_driver_register() when you know the device
is not hotpluggable and has already been registered, and you want to
remove its run-once probe() infrastructure from memory after the driver
has bound to the device.</p>
<p>One typical use for this would be with drivers for controllers integrated
into system-on-chip processors, where the controller devices have been
configured as part of board setup.</p>
<p>Note that this is incompatible with deferred probing.</p>
<p>Returns zero if the driver registered and bound to a device, else returns
a negative error code and with the driver not registered.</p>
<dl class="function">
<dt id="c.__platform_create_bundle">
struct platform_device * <code class="descname">__platform_create_bundle</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;driver</em>, int (*probe) (struct platform_device<em>&nbsp;*</em>, struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;n_res</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, struct module *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_create_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver and create corresponding device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span> <span class="pre">probe</span></code></dt>
<dd>the driver probe routine, probably from an __init section</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_res</span></code></dt>
<dd>number of resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module which will be the owner of the driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this in legacy-style modules that probe hardware directly and
register a single platform device and corresponding platform driver.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
<dl class="function">
<dt id="c.__platform_register_drivers">
int <code class="descname">__platform_register_drivers</code><span class="sig-paren">(</span>struct platform_driver *const *<em>&nbsp;drivers</em>, unsigned int<em>&nbsp;count</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_register_drivers" title="Permalink to this definition">¶</a></dt>
<dd><p>register an array of platform drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">drivers</span></code></dt>
<dd>an array of drivers to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of drivers to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module owning the drivers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers platform drivers specified by an array. On failure to register a
driver, all previously registered drivers will be unregistered. Callers of
this API should use <a class="reference internal" href="#c.platform_unregister_drivers" title="platform_unregister_drivers"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_unregister_drivers()</span></code></a> to unregister drivers in
the reverse order.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.platform_unregister_drivers">
void <code class="descname">platform_unregister_drivers</code><span class="sig-paren">(</span>struct platform_driver *const *<em>&nbsp;drivers</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_unregister_drivers" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an array of platform drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">drivers</span></code></dt>
<dd>an array of drivers to unregister</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of drivers to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unegisters platform drivers specified by an array. This is typically used
to complement an earlier call to platform_register_drivers(). Drivers are
unregistered in the reverse order in which they were registered.</p>
<dl class="function">
<dt id="c.platform_find_device_by_driver">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">platform_find_device_by_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const struct device_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_find_device_by_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a platform device with a given driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>The device to start the search from.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>The device driver to look for.</dd>
</dl>
<dl class="function">
<dt id="c.bus_for_each_dev">
int <code class="descname">bus_for_each_dev</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>device to start iterating from.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>. If <strong>start</strong> is not NULL, we use that device to
begin iterating from.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>NOTE</strong></p>
<p>The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do so, and increment the reference
count in the supplied callback.</p>
<dl class="function">
<dt id="c.bus_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">bus_find_device</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, const void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.bus_for_each_dev" title="bus_for_each_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">bus_for_each_dev()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<dl class="function">
<dt id="c.subsys_find_device_by_id">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">subsys_find_device_by_id</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;subsys</em>, unsigned int<em>&nbsp;id</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;hint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_find_device_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device with a specific enumeration number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>subsystem</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>index ‘id’ in struct device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">hint</span></code></dt>
<dd>device to check first</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the hint’s next object and if it is a match return it directly,
otherwise, fall back to a full list search. Either way a reference for
the returned object is taken.</p>
<dl class="function">
<dt id="c.bus_for_each_drv">
int <code class="descname">bus_for_each_drv</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em>, struct device_driver *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct device_driver<em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_drv" title="Permalink to this definition">¶</a></dt>
<dd><p>driver iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus we’re dealing with.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>driver to start iterating on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data to pass to the callback.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device_driver</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to call for each driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is nearly identical to the device iterator above.
We iterate over each driver that belongs to <strong>bus</strong>, and call
<strong>fn</strong> for each. If <strong>fn</strong> returns anything but 0, we break out
and return it. If <strong>start</strong> is not NULL, we use it as the head
of the list.</p>
<p><strong>NOTE</strong></p>
<p>we don’t return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn’t disappear before returning to the caller.</p>
<dl class="function">
<dt id="c.bus_rescan_devices">
int <code class="descname">bus_rescan_devices</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_rescan_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>rescan devices on the bus for possible drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the bus to scan.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling <a class="reference internal" href="#c.device_attach" title="device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_attach()</span></code></a> for the unbound devices.</p>
<dl class="function">
<dt id="c.device_reprobe">
int <code class="descname">device_reprobe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_reprobe" title="Permalink to this definition">¶</a></dt>
<dd><p>remove driver for a device and probe for a new driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to reprobe</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function detaches the attached driver (if any) for the given
device and restarts the driver probing process.  It is intended
to use if probing criteria changed during a devices lifetime and
driver attachment should change accordingly.</p>
<dl class="function">
<dt id="c.bus_register">
int <code class="descname">bus_register</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver-core subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once we have that, we register the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the subsystem.</p>
<dl class="function">
<dt id="c.bus_unregister">
void <code class="descname">bus_unregister</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a bus from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the child subsystems and the bus itself.
Finally, we call bus_put() to release the refcount</p>
<dl class="function">
<dt id="c.subsys_dev_iter_init">
void <code class="descname">subsys_dev_iter_init</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em>, struct bus_type *<em>&nbsp;subsys</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const struct device_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize subsys device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>the subsys we wanna iterate over</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start iterating from, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>device_type of the devices to iterate over, NULL for all</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize subsys iterator <strong>iter</strong> such that it iterates over devices
of <strong>subsys</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
<dl class="function">
<dt id="c.subsys_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">subsys_dev_iter_next</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to proceed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won’t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into subsys code.</p>
<dl class="function">
<dt id="c.subsys_dev_iter_exit">
void <code class="descname">subsys_dev_iter_exit</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to finish</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
<dl class="function">
<dt id="c.subsys_system_register">
int <code class="descname">subsys_system_register</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;subsys</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_system_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a subsystem at /sys/devices/system/</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>system subsystem</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>default attributes for the root device</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘system’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subsystem. The root device can carry subsystem-
wide attributes. All registered devices are below this single root
device and are named after the subsystem with a simple enumeration
number appended. The registered devices are not explicitly named;
only ‘id’ in the device needs to be set.</p>
<p>Do not use this interface for anything new, it exists for compatibility
with bad ideas only. New subsystems should use plain subsystems; and
add the subsystem-wide attributes should be added to the subsystem
directory itself and not some create fake root-device placed in
/sys/devices/system/&lt;name&gt;.</p>
<dl class="function">
<dt id="c.subsys_virtual_register">
int <code class="descname">subsys_virtual_register</code><span class="sig-paren">(</span>struct bus_type *<em>&nbsp;subsys</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_virtual_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a subsystem at /sys/devices/virtual/</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>virtual subsystem</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>default attributes for the root device</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘virtual’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subystem.  The root device can carry subsystem-wide
attributes.  All registered devices are below this single root device.
There’s no restriction on device naming.  This is for kernel software
constructs which need sysfs interface.</p>
</div>
<div class="section" id="device-drivers-dma-management">
<h2>Device Drivers DMA Management<a class="headerlink" href="#device-drivers-dma-management" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.dmam_free_coherent">
void <code class="descname">dmam_free_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_free_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed dma_free_coherent()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to free coherent memory for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>Virtual address of the memory to free</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_handle</span></code></dt>
<dd>DMA handle of the memory to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_free_coherent().</p>
<dl class="function">
<dt id="c.dmam_alloc_attrs">
void * <code class="descname">dmam_alloc_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;dma_handle</em>, gfp_t<em>&nbsp;gfp</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_alloc_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed dma_alloc_attrs()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate non_coherent memory for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">dma_handle</span></code></dt>
<dd>Out argument for allocated DMA handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>Flags in the DMA_ATTR_* namespace.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_alloc_attrs().  Memory allocated using this function will be
automatically released on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="function">
<dt id="c.dma_can_mmap">
bool <code class="descname">dma_can_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_can_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given device supports dma_mmap_*</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dev</strong> supports dma_mmap_coherent() and <a class="reference internal" href="#c.dma_mmap_attrs" title="dma_mmap_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_mmap_attrs()</span></code></a> to
map DMA allocations to userspace.</p>
<dl class="function">
<dt id="c.dma_mmap_attrs">
int <code class="descname">dma_mmap_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct vm_area_struct *<em>&nbsp;vma</em>, void *<em>&nbsp;cpu_addr</em>, dma_addr_t<em>&nbsp;dma_addr</em>, size_t<em>&nbsp;size</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_mmap_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>map a coherent DMA allocation into user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>valid struct device pointer, or NULL for ISA and EISA-like devices</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct describing requested user mapping</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">cpu_addr</span></code></dt>
<dd>kernel CPU-view address returned from dma_alloc_attrs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_addr</span></code></dt>
<dd>device-view address returned from dma_alloc_attrs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of memory originally requested in dma_alloc_attrs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>attributes of mapping properties requested in dma_alloc_attrs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map a coherent DMA buffer previously allocated by dma_alloc_attrs into user
space.  The coherent DMA buffer must not be freed by the driver until the
user space mapping has been released.</p>
</div>
<div class="section" id="device-drivers-pnp-support">
<h2>Device drivers PnP support<a class="headerlink" href="#device-drivers-pnp-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.pnp_register_protocol">
int <code class="descname">pnp_register_protocol</code><span class="sig-paren">(</span>struct pnp_protocol *<em>&nbsp;protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a pnp protocol to the pnp layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*</span> <span class="pre">protocol</span></code></dt>
<dd>pointer to the corresponding pnp_protocol structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ex protocols: ISAPNP, PNPBIOS, etc</div></blockquote>
<dl class="function">
<dt id="c.pnp_unregister_protocol">
void <code class="descname">pnp_unregister_protocol</code><span class="sig-paren">(</span>struct pnp_protocol *<em>&nbsp;protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a pnp protocol from the pnp layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*</span> <span class="pre">protocol</span></code></dt>
<dd>pointer to the corresponding pnp_protocol structure</dd>
</dl>
<dl class="function">
<dt id="c.pnp_request_card_device">
struct pnp_dev * <code class="descname">pnp_request_card_device</code><span class="sig-paren">(</span>struct pnp_card_link *<em>&nbsp;clink</em>, const char *<em>&nbsp;id</em>, struct pnp_dev *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_request_card_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for a PnP device under the specified card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_link</span> <span class="pre">*</span> <span class="pre">clink</span></code></dt>
<dd>pointer to the card link, cannot be NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to a PnP ID structure that explains the rules for finding the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Starting place to search from. If NULL it will start from the beginning.</dd>
</dl>
<dl class="function">
<dt id="c.pnp_release_card_device">
void <code class="descname">pnp_release_card_device</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_release_card_device" title="Permalink to this definition">¶</a></dt>
<dd><p>call this when the driver no longer needs the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the PnP device structure</dd>
</dl>
<dl class="function">
<dt id="c.pnp_register_card_driver">
int <code class="descname">pnp_register_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_card_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>registers a PnP card driver with the PnP Layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the driver to register</dd>
</dl>
<dl class="function">
<dt id="c.pnp_unregister_card_driver">
void <code class="descname">pnp_unregister_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_card_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregisters a PnP card driver from the PnP Layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the driver to unregister</dd>
</dl>
<dl class="function">
<dt id="c.pnp_add_id">
struct pnp_id * <code class="descname">pnp_add_id</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_add_id" title="Permalink to this definition">¶</a></dt>
<dd><p>adds an EISA id to the specified device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to an EISA id string</dd>
</dl>
<dl class="function">
<dt id="c.pnp_start_dev">
int <code class="descname">pnp_start_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_start_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>low-level start of the PnP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>assumes that resources have already been allocated</p>
<dl class="function">
<dt id="c.pnp_stop_dev">
int <code class="descname">pnp_stop_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_stop_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>low-level disable of the PnP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not free resources</p>
<dl class="function">
<dt id="c.pnp_activate_dev">
int <code class="descname">pnp_activate_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_activate_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>activates a PnP device for use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not validate or set resources so be careful.</p>
<dl class="function">
<dt id="c.pnp_disable_dev">
int <code class="descname">pnp_disable_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_disable_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>disables device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>inform the correct pnp protocol so that resources can be used by other devices</p>
<dl class="function">
<dt id="c.pnp_is_active">
int <code class="descname">pnp_is_active</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a device is active based on its current resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired PnP device</dd>
</dl>
</div>
<div class="section" id="userspace-io-devices">
<h2>Userspace IO devices<a class="headerlink" href="#userspace-io-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.uio_event_notify">
void <code class="descname">uio_event_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_event_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger an interrupt event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<dl class="function">
<dt id="c.__uio_register_device">
int <code class="descname">__uio_register_device</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__uio_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new userspace IO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module that creates the new device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
<dl class="function">
<dt id="c.uio_unregister_device">
void <code class="descname">uio_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a industrial IO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<dl class="type">
<dt id="c.uio_mem">
struct <code class="descname">uio_mem</code><a class="headerlink" href="#c.uio_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>description of a UIO memory region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_mem {
  const char              *name;
  phys_addr_t addr;
  unsigned long           offs;
  resource_size_t size;
  int memtype;
  void __iomem            *internal_addr;
  struct uio_map          *map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>name of the memory region for identification</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>address of the device’s memory rounded to page
size (phys_addr is used since addr can be
logical, virtual, or physical &amp; phys_addr_t
should always be large enough to handle any of
the address types)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offs</span></code></dt>
<dd>offset of device memory within the page</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>size of IO (multiple of page size)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memtype</span></code></dt>
<dd>type of memory addr points to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal_addr</span></code></dt>
<dd>ioremap-ped version of addr, for driver internal use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt>
<dd>for use by the UIO core only.</dd>
</dl>
<dl class="type">
<dt id="c.uio_port">
struct <code class="descname">uio_port</code><a class="headerlink" href="#c.uio_port" title="Permalink to this definition">¶</a></dt>
<dd><p>description of a UIO port region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_port {
  const char              *name;
  unsigned long           start;
  unsigned long           size;
  int porttype;
  struct uio_portio       *portio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>name of the port region for identification</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt>
<dd>start of port region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>size of port region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">porttype</span></code></dt>
<dd>type of port (see UIO_PORT_* below)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">portio</span></code></dt>
<dd>for use by the UIO core only.</dd>
</dl>
<dl class="type">
<dt id="c.uio_info">
struct <code class="descname">uio_info</code><a class="headerlink" href="#c.uio_info" title="Permalink to this definition">¶</a></dt>
<dd><p>UIO device capabilities</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_info {
  struct uio_device       *uio_dev;
  const char              *name;
  const char              *version;
  struct uio_mem          mem[MAX_UIO_MAPS];
  struct uio_port         port[MAX_UIO_PORT_REGIONS];
  long irq;
  unsigned long           irq_flags;
  void *priv;
  irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
  int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
  int (*open)(struct uio_info *info, struct inode *inode);
  int (*release)(struct uio_info *info, struct inode *inode);
  int (*irqcontrol)(struct uio_info *info, s32 irq_on);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">uio_dev</span></code></dt>
<dd>the UIO device this info belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt>
<dd>device driver version</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem</span></code></dt>
<dd>list of mappable memory regions, size==0 for end of list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>list of port regions, size==0 for end of list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt>
<dd>interrupt number or UIO_IRQ_CUSTOM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flags</span></code></dt>
<dd>flags for <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a></dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt>
<dd>optional private data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt>
<dd>the device’s irq handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt>
<dd>mmap operation for this uio device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt>
<dd>open operation for this uio device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt>
<dd>release operation for this uio device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irqcontrol</span></code></dt>
<dd>disable/enable irqs when 0/1 is written to /dev/uioX</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="early-userspace/index.html" class="btn btn-neutral float-right" title="Early Userspace" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basics.html" class="btn btn-neutral float-left" title="Driver Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>