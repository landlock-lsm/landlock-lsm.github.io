

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Security Module Development &mdash; The Linux Kernel 5.6.0-rc7+ documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Secure Attention Key (SAK) handling" href="sak.html" />
    <link rel="prev" title="Linux Security Modules: General Security Hooks for Linux" href="lsm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0-rc7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Security Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="credentials.html">Credentials in Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="IMA-templates.html">IMA Template Management Mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="keys/index.html">Kernel Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="lsm.html">Linux Security Modules: General Security Hooks for Linux</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux Security Module Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="sak.html">Linux Secure Attention Key (SAK) handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="SCTP.html">SCTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="self-protection.html">Kernel Self-Protection</a></li>
<li class="toctree-l2"><a class="reference internal" href="siphash.html">SipHash - a short input PRF</a></li>
<li class="toctree-l2"><a class="reference internal" href="siphash.html#halfsiphash-siphash-s-insecure-younger-cousin">HalfSipHash - SipHash’s insecure younger cousin</a></li>
<li class="toctree-l2"><a class="reference internal" href="tpm/index.html">Trusted Platform Module documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="landlock/index.html">Landlock LSM: unprivileged access control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Security Documentation</a> &raquo;</li>
        
      <li>Linux Security Module Development</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/security/lsm-development.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-security-module-development">
<h1>Linux Security Module Development<a class="headerlink" href="#linux-security-module-development" title="Permalink to this headline">¶</a></h1>
<p>Based on <a class="reference external" href="https://lkml.org/lkml/2007/10/26/215">https://lkml.org/lkml/2007/10/26/215</a>,
a new LSM is accepted into the kernel when its intent (a description of
what it tries to protect against and in what cases one would expect to
use it) has been appropriately documented in <code class="docutils literal notranslate"><span class="pre">Documentation/admin-guide/LSM/</span></code>.
This allows an LSM’s code to be easily compared to its goals, and so
that end users and distros can make a more informed decision about which
LSMs suit their requirements.</p>
<p>For extensive documentation on the available LSM hook interfaces, please
see <code class="docutils literal notranslate"><span class="pre">include/linux/lsm_hooks.h</span></code> and associated structures:</p>
<dl class="type">
<dt id="c.security_list_options">
union <code class="descname">security_list_options</code><a class="headerlink" href="#c.security_list_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Linux Security Module hook function list</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union security_list_options {
  int (*binder_set_context_mgr)(struct task_struct *mgr);
  int (*binder_transaction)(struct task_struct *from, struct task_struct *to);
  int (*binder_transfer_binder)(struct task_struct *from, struct task_struct *to);
  int (*binder_transfer_file)(struct task_struct *from,struct task_struct *to, struct file *file);
  int (*ptrace_access_check)(struct task_struct *child, unsigned int mode);
  int (*ptrace_traceme)(struct task_struct *parent);
  int (*capget)(struct task_struct *target, kernel_cap_t *effective, kernel_cap_t *inheritable, kernel_cap_t *permitted);
  int (*capset)(struct cred *new, const struct cred *old,const kernel_cap_t *effective,const kernel_cap_t *inheritable, const kernel_cap_t *permitted);
  int (*capable)(const struct cred *cred,struct user_namespace *ns,int cap, unsigned int opts);
  int (*quotactl)(int cmds, int type, int id, struct super_block *sb);
  int (*quota_on)(struct dentry *dentry);
  int (*syslog)(int type);
  int (*settime)(const struct timespec64 *ts, const struct timezone *tz);
  int (*vm_enough_memory)(struct mm_struct *mm, long pages);
  int (*bprm_set_creds)(struct linux_binprm *bprm);
  int (*bprm_check_security)(struct linux_binprm *bprm);
  void (*bprm_committing_creds)(struct linux_binprm *bprm);
  void (*bprm_committed_creds)(struct linux_binprm *bprm);
  int (*fs_context_dup)(struct fs_context *fc, struct fs_context *src_sc);
  int (*fs_context_parse_param)(struct fs_context *fc, struct fs_parameter *param);
  int (*sb_alloc_security)(struct super_block *sb);
  void (*sb_free_security)(struct super_block *sb);
  void (*sb_free_mnt_opts)(void *mnt_opts);
  int (*sb_eat_lsm_opts)(char *orig, void **mnt_opts);
  int (*sb_remount)(struct super_block *sb, void *mnt_opts);
  int (*sb_kern_mount)(struct super_block *sb);
  int (*sb_show_options)(struct seq_file *m, struct super_block *sb);
  int (*sb_statfs)(struct dentry *dentry);
  int (*sb_mount)(const char *dev_name, const struct path *path, const char *type, unsigned long flags, void *data);
  int (*sb_umount)(struct vfsmount *mnt, int flags);
  int (*sb_pivotroot)(const struct path *old_path, const struct path *new_path);
  int (*sb_set_mnt_opts)(struct super_block *sb,void *mnt_opts,unsigned long kern_flags, unsigned long *set_kern_flags);
  int (*sb_clone_mnt_opts)(const struct super_block *oldsb,struct super_block *newsb,unsigned long kern_flags, unsigned long *set_kern_flags);
  int (*sb_add_mnt_opt)(const char *option, const char *val, int len, void **mnt_opts);
  int (*move_mount)(const struct path *from_path, const struct path *to_path);
  int (*dentry_init_security)(struct dentry *dentry, int mode,const struct qstr *name, void **ctx, u32 *ctxlen);
  int (*dentry_create_files_as)(struct dentry *dentry, int mode,struct qstr *name,const struct cred *old, struct cred *new);
#ifdef CONFIG_SECURITY_PATH;
  int (*path_unlink)(const struct path *dir, struct dentry *dentry);
  int (*path_mkdir)(const struct path *dir, struct dentry *dentry, umode_t mode);
  int (*path_rmdir)(const struct path *dir, struct dentry *dentry);
  int (*path_mknod)(const struct path *dir, struct dentry *dentry, umode_t mode, unsigned int dev);
  int (*path_truncate)(const struct path *path);
  int (*path_symlink)(const struct path *dir, struct dentry *dentry, const char *old_name);
  int (*path_link)(struct dentry *old_dentry, const struct path *new_dir, struct dentry *new_dentry);
  int (*path_rename)(const struct path *old_dir, struct dentry *old_dentry,const struct path *new_dir, struct dentry *new_dentry);
  int (*path_chmod)(const struct path *path, umode_t mode);
  int (*path_chown)(const struct path *path, kuid_t uid, kgid_t gid);
  int (*path_chroot)(const struct path *path);
#endif;
  int (*path_notify)(const struct path *path, u64 mask, unsigned int obj_type);
  int (*inode_alloc_security)(struct inode *inode);
  void (*inode_free_security)(struct inode *inode);
  int (*inode_init_security)(struct inode *inode, struct inode *dir,const struct qstr *qstr,const char **name, void **value, size_t *len);
  int (*inode_create)(struct inode *dir, struct dentry *dentry, umode_t mode);
  int (*inode_link)(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry);
  int (*inode_unlink)(struct inode *dir, struct dentry *dentry);
  int (*inode_symlink)(struct inode *dir, struct dentry *dentry, const char *old_name);
  int (*inode_mkdir)(struct inode *dir, struct dentry *dentry, umode_t mode);
  int (*inode_rmdir)(struct inode *dir, struct dentry *dentry);
  int (*inode_mknod)(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev);
  int (*inode_rename)(struct inode *old_dir, struct dentry *old_dentry,struct inode *new_dir, struct dentry *new_dentry);
  int (*inode_readlink)(struct dentry *dentry);
  int (*inode_follow_link)(struct dentry *dentry, struct inode *inode, bool rcu);
  int (*inode_permission)(struct inode *inode, int mask);
  int (*inode_setattr)(struct dentry *dentry, struct iattr *attr);
  int (*inode_getattr)(const struct path *path);
  int (*inode_setxattr)(struct dentry *dentry, const char *name, const void *value, size_t size, int flags);
  void (*inode_post_setxattr)(struct dentry *dentry, const char *name,const void *value, size_t size, int flags);
  int (*inode_getxattr)(struct dentry *dentry, const char *name);
  int (*inode_listxattr)(struct dentry *dentry);
  int (*inode_removexattr)(struct dentry *dentry, const char *name);
  int (*inode_need_killpriv)(struct dentry *dentry);
  int (*inode_killpriv)(struct dentry *dentry);
  int (*inode_getsecurity)(struct inode *inode, const char *name, void **buffer, bool alloc);
  int (*inode_setsecurity)(struct inode *inode, const char *name,const void *value, size_t size, int flags);
  int (*inode_listsecurity)(struct inode *inode, char *buffer, size_t buffer_size);
  void (*inode_getsecid)(struct inode *inode, u32 *secid);
  int (*inode_copy_up)(struct dentry *src, struct cred **new);
  int (*inode_copy_up_xattr)(const char *name);
  int (*kernfs_init_security)(struct kernfs_node *kn_dir, struct kernfs_node *kn);
  int (*file_permission)(struct file *file, int mask);
  int (*file_alloc_security)(struct file *file);
  void (*file_free_security)(struct file *file);
  int (*file_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
  int (*mmap_addr)(unsigned long addr);
  int (*mmap_file)(struct file *file, unsigned long reqprot, unsigned long prot, unsigned long flags);
  int (*file_mprotect)(struct vm_area_struct *vma, unsigned long reqprot, unsigned long prot);
  int (*file_lock)(struct file *file, unsigned int cmd);
  int (*file_fcntl)(struct file *file, unsigned int cmd, unsigned long arg);
  void (*file_set_fowner)(struct file *file);
  int (*file_send_sigiotask)(struct task_struct *tsk, struct fown_struct *fown, int sig);
  int (*file_receive)(struct file *file);
  int (*file_open)(struct file *file);
  int (*task_alloc)(struct task_struct *task, unsigned long clone_flags);
  void (*task_free)(struct task_struct *task);
  int (*cred_alloc_blank)(struct cred *cred, gfp_t gfp);
  void (*cred_free)(struct cred *cred);
  int (*cred_prepare)(struct cred *new, const struct cred *old, gfp_t gfp);
  void (*cred_transfer)(struct cred *new, const struct cred *old);
  void (*cred_getsecid)(const struct cred *c, u32 *secid);
  int (*kernel_act_as)(struct cred *new, u32 secid);
  int (*kernel_create_files_as)(struct cred *new, struct inode *inode);
  int (*kernel_module_request)(char *kmod_name);
  int (*kernel_load_data)(enum kernel_load_data_id id);
  int (*kernel_read_file)(struct file *file, enum kernel_read_file_id id);
  int (*kernel_post_read_file)(struct file *file, char *buf, loff_t size, enum kernel_read_file_id id);
  int (*task_fix_setuid)(struct cred *new, const struct cred *old, int flags);
  int (*task_setpgid)(struct task_struct *p, pid_t pgid);
  int (*task_getpgid)(struct task_struct *p);
  int (*task_getsid)(struct task_struct *p);
  void (*task_getsecid)(struct task_struct *p, u32 *secid);
  int (*task_setnice)(struct task_struct *p, int nice);
  int (*task_setioprio)(struct task_struct *p, int ioprio);
  int (*task_getioprio)(struct task_struct *p);
  int (*task_prlimit)(const struct cred *cred, const struct cred *tcred, unsigned int flags);
  int (*task_setrlimit)(struct task_struct *p, unsigned int resource, struct rlimit *new_rlim);
  int (*task_setscheduler)(struct task_struct *p);
  int (*task_getscheduler)(struct task_struct *p);
  int (*task_movememory)(struct task_struct *p);
  int (*task_kill)(struct task_struct *p, struct kernel_siginfo *info, int sig, const struct cred *cred);
  int (*task_prctl)(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
  void (*task_to_inode)(struct task_struct *p, struct inode *inode);
  int (*ipc_permission)(struct kern_ipc_perm *ipcp, short flag);
  void (*ipc_getsecid)(struct kern_ipc_perm *ipcp, u32 *secid);
  int (*msg_msg_alloc_security)(struct msg_msg *msg);
  void (*msg_msg_free_security)(struct msg_msg *msg);
  int (*msg_queue_alloc_security)(struct kern_ipc_perm *perm);
  void (*msg_queue_free_security)(struct kern_ipc_perm *perm);
  int (*msg_queue_associate)(struct kern_ipc_perm *perm, int msqflg);
  int (*msg_queue_msgctl)(struct kern_ipc_perm *perm, int cmd);
  int (*msg_queue_msgsnd)(struct kern_ipc_perm *perm, struct msg_msg *msg, int msqflg);
  int (*msg_queue_msgrcv)(struct kern_ipc_perm *perm, struct msg_msg *msg,struct task_struct *target, long type, int mode);
  int (*shm_alloc_security)(struct kern_ipc_perm *perm);
  void (*shm_free_security)(struct kern_ipc_perm *perm);
  int (*shm_associate)(struct kern_ipc_perm *perm, int shmflg);
  int (*shm_shmctl)(struct kern_ipc_perm *perm, int cmd);
  int (*shm_shmat)(struct kern_ipc_perm *perm, char __user *shmaddr, int shmflg);
  int (*sem_alloc_security)(struct kern_ipc_perm *perm);
  void (*sem_free_security)(struct kern_ipc_perm *perm);
  int (*sem_associate)(struct kern_ipc_perm *perm, int semflg);
  int (*sem_semctl)(struct kern_ipc_perm *perm, int cmd);
  int (*sem_semop)(struct kern_ipc_perm *perm, struct sembuf *sops, unsigned nsops, int alter);
  int (*netlink_send)(struct sock *sk, struct sk_buff *skb);
  void (*d_instantiate)(struct dentry *dentry, struct inode *inode);
  int (*getprocattr)(struct task_struct *p, char *name, char **value);
  int (*setprocattr)(const char *name, void *value, size_t size);
  int (*ismaclabel)(const char *name);
  int (*secid_to_secctx)(u32 secid, char **secdata, u32 *seclen);
  int (*secctx_to_secid)(const char *secdata, u32 seclen, u32 *secid);
  void (*release_secctx)(char *secdata, u32 seclen);
  void (*inode_invalidate_secctx)(struct inode *inode);
  int (*inode_notifysecctx)(struct inode *inode, void *ctx, u32 ctxlen);
  int (*inode_setsecctx)(struct dentry *dentry, void *ctx, u32 ctxlen);
  int (*inode_getsecctx)(struct inode *inode, void **ctx, u32 *ctxlen);
#ifdef CONFIG_SECURITY_NETWORK;
  int (*unix_stream_connect)(struct sock *sock, struct sock *other, struct sock *newsk);
  int (*unix_may_send)(struct socket *sock, struct socket *other);
  int (*socket_create)(int family, int type, int protocol, int kern);
  int (*socket_post_create)(struct socket *sock, int family, int type, int protocol, int kern);
  int (*socket_socketpair)(struct socket *socka, struct socket *sockb);
  int (*socket_bind)(struct socket *sock, struct sockaddr *address, int addrlen);
  int (*socket_connect)(struct socket *sock, struct sockaddr *address, int addrlen);
  int (*socket_listen)(struct socket *sock, int backlog);
  int (*socket_accept)(struct socket *sock, struct socket *newsock);
  int (*socket_sendmsg)(struct socket *sock, struct msghdr *msg, int size);
  int (*socket_recvmsg)(struct socket *sock, struct msghdr *msg, int size, int flags);
  int (*socket_getsockname)(struct socket *sock);
  int (*socket_getpeername)(struct socket *sock);
  int (*socket_getsockopt)(struct socket *sock, int level, int optname);
  int (*socket_setsockopt)(struct socket *sock, int level, int optname);
  int (*socket_shutdown)(struct socket *sock, int how);
  int (*socket_sock_rcv_skb)(struct sock *sk, struct sk_buff *skb);
  int (*socket_getpeersec_stream)(struct socket *sock,char __user *optval, int __user *optlen, unsigned len);
  int (*socket_getpeersec_dgram)(struct socket *sock, struct sk_buff *skb, u32 *secid);
  int (*sk_alloc_security)(struct sock *sk, int family, gfp_t priority);
  void (*sk_free_security)(struct sock *sk);
  void (*sk_clone_security)(const struct sock *sk, struct sock *newsk);
  void (*sk_getsecid)(struct sock *sk, u32 *secid);
  void (*sock_graft)(struct sock *sk, struct socket *parent);
  int (*inet_conn_request)(struct sock *sk, struct sk_buff *skb, struct request_sock *req);
  void (*inet_csk_clone)(struct sock *newsk, const struct request_sock *req);
  void (*inet_conn_established)(struct sock *sk, struct sk_buff *skb);
  int (*secmark_relabel_packet)(u32 secid);
  void (*secmark_refcount_inc)(void);
  void (*secmark_refcount_dec)(void);
  void (*req_classify_flow)(const struct request_sock *req, struct flowi *fl);
  int (*tun_dev_alloc_security)(void **security);
  void (*tun_dev_free_security)(void *security);
  int (*tun_dev_create)(void);
  int (*tun_dev_attach_queue)(void *security);
  int (*tun_dev_attach)(struct sock *sk, void *security);
  int (*tun_dev_open)(void *security);
  int (*sctp_assoc_request)(struct sctp_endpoint *ep, struct sk_buff *skb);
  int (*sctp_bind_connect)(struct sock *sk, int optname, struct sockaddr *address, int addrlen);
  void (*sctp_sk_clone)(struct sctp_endpoint *ep, struct sock *sk, struct sock *newsk);
#endif ;
#ifdef CONFIG_SECURITY_INFINIBAND;
  int (*ib_pkey_access)(void *sec, u64 subnet_prefix, u16 pkey);
  int (*ib_endport_manage_subnet)(void *sec, const char *dev_name, u8 port_num);
  int (*ib_alloc_security)(void **sec);
  void (*ib_free_security)(void *sec);
#endif ;
#ifdef CONFIG_SECURITY_NETWORK_XFRM;
  int (*xfrm_policy_alloc_security)(struct xfrm_sec_ctx **ctxp,struct xfrm_user_sec_ctx *sec_ctx, gfp_t gfp);
  int (*xfrm_policy_clone_security)(struct xfrm_sec_ctx *old_ctx, struct xfrm_sec_ctx **new_ctx);
  void (*xfrm_policy_free_security)(struct xfrm_sec_ctx *ctx);
  int (*xfrm_policy_delete_security)(struct xfrm_sec_ctx *ctx);
  int (*xfrm_state_alloc)(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx);
  int (*xfrm_state_alloc_acquire)(struct xfrm_state *x,struct xfrm_sec_ctx *polsec, u32 secid);
  void (*xfrm_state_free_security)(struct xfrm_state *x);
  int (*xfrm_state_delete_security)(struct xfrm_state *x);
  int (*xfrm_policy_lookup)(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir);
  int (*xfrm_state_pol_flow_match)(struct xfrm_state *x,struct xfrm_policy *xp, const struct flowi *fl);
  int (*xfrm_decode_session)(struct sk_buff *skb, u32 *secid, int ckall);
#endif ;
#ifdef CONFIG_KEYS;
  int (*key_alloc)(struct key *key, const struct cred *cred, unsigned long flags);
  void (*key_free)(struct key *key);
  int (*key_permission)(key_ref_t key_ref, const struct cred *cred, unsigned perm);
  int (*key_getsecurity)(struct key *key, char **_buffer);
#endif ;
#ifdef CONFIG_AUDIT;
  int (*audit_rule_init)(u32 field, u32 op, char *rulestr, void **lsmrule);
  int (*audit_rule_known)(struct audit_krule *krule);
  int (*audit_rule_match)(u32 secid, u32 field, u32 op, void *lsmrule);
  void (*audit_rule_free)(void *lsmrule);
#endif ;
#ifdef CONFIG_BPF_SYSCALL;
  int (*bpf)(int cmd, union bpf_attr *attr, unsigned int size);
  int (*bpf_map)(struct bpf_map *map, fmode_t fmode);
  int (*bpf_prog)(struct bpf_prog *prog);
  int (*bpf_map_alloc_security)(struct bpf_map *map);
  void (*bpf_map_free_security)(struct bpf_map *map);
  int (*bpf_prog_alloc_security)(struct bpf_prog_aux *aux);
  void (*bpf_prog_free_security)(struct bpf_prog_aux *aux);
#endif ;
  int (*locked_down)(enum lockdown_reason what);
#ifdef CONFIG_PERF_EVENTS;
  int (*perf_event_open)(struct perf_event_attr *attr, int type);
  int (*perf_event_alloc)(struct perf_event *event);
  void (*perf_event_free)(struct perf_event *event);
  int (*perf_event_read)(struct perf_event *event);
  int (*perf_event_write)(struct perf_event *event);
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">binder_set_context_mgr</span></code></dt>
<dd>Check whether <strong>mgr</strong> is allowed to be the binder context manager.
<strong>mgr</strong> contains the task_struct for the task being registered.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binder_transaction</span></code></dt>
<dd>Check whether <strong>from</strong> is allowed to invoke a binder transaction call
to <strong>to</strong>.
<strong>from</strong> contains the task_struct for the sending task.
<strong>to</strong> contains the task_struct for the receiving task.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binder_transfer_binder</span></code></dt>
<dd>Check whether <strong>from</strong> is allowed to transfer a binder reference to <strong>to</strong>.
<strong>from</strong> contains the task_struct for the sending task.
<strong>to</strong> contains the task_struct for the receiving task.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binder_transfer_file</span></code></dt>
<dd>Check whether <strong>from</strong> is allowed to transfer <strong>file</strong> to <strong>to</strong>.
<strong>from</strong> contains the task_struct for the sending task.
<strong>file</strong> contains the struct file being transferred.
<strong>to</strong> contains the task_struct for the receiving task.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptrace_access_check</span></code></dt>
<dd>Check permission before allowing the current process to trace the
<strong>child</strong> process.
Security modules may also want to perform a process tracing check
during an execve in the set_security or apply_creds hooks of
tracing check during an execve in the bprm_set_creds hook of
binprm_security_ops if the process is being traced and its security
attributes would be changed by the execve.
<strong>child</strong> contains the task_struct structure for the target process.
<strong>mode</strong> contains the PTRACE_MODE flags indicating the form of access.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptrace_traceme</span></code></dt>
<dd>Check that the <strong>parent</strong> process has sufficient permission to trace the
current process before allowing the current process to present itself
to the <strong>parent</strong> process for tracing.
<strong>parent</strong> contains the task_struct structure for debugger process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capget</span></code></dt>
<dd>Get the <strong>effective</strong>, <strong>inheritable</strong>, and <strong>permitted</strong> capability sets for
the <strong>target</strong> process.  The hook may also perform permission checking to
determine if the current process is allowed to see the capability sets
of the <strong>target</strong> process.
<strong>target</strong> contains the task_struct structure for target process.
<strong>effective</strong> contains the effective capability set.
<strong>inheritable</strong> contains the inheritable capability set.
<strong>permitted</strong> contains the permitted capability set.
Return 0 if the capability sets were successfully obtained.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capset</span></code></dt>
<dd>Set the <strong>effective</strong>, <strong>inheritable</strong>, and <strong>permitted</strong> capability sets for
the current process.
<strong>new</strong> contains the new credentials structure for target process.
<strong>old</strong> contains the current credentials structure for target process.
<strong>effective</strong> contains the effective capability set.
<strong>inheritable</strong> contains the inheritable capability set.
<strong>permitted</strong> contains the permitted capability set.
Return 0 and update <strong>new</strong> if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capable</span></code></dt>
<dd>Check whether the <strong>tsk</strong> process has the <strong>cap</strong> capability in the indicated
credentials.
<strong>cred</strong> contains the credentials to use.
<strong>ns</strong> contains the user namespace we want the capability in
<strong>cap</strong> contains the capability &lt;include/linux/capability.h&gt;.
<strong>opts</strong> contains options for the capable check &lt;include/linux/security.h&gt;
Return 0 if the capability is granted for <strong>tsk</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syslog</span></code></dt>
<dd>Check permission before accessing the kernel message ring or changing
logging to the console.
See the syslog(2) manual page for an explanation of the <strong>type</strong> values.
<strong>type</strong> contains the SYSLOG_ACTION_* constant from &lt;include/linux/syslog.h&gt;
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settime</span></code></dt>
<dd>Check permission to change the system time.
struct timespec64 is defined in &lt;include/linux/time64.h&gt; and timezone
is defined in &lt;include/linux/time.h&gt;
<strong>ts</strong> contains new time
<strong>tz</strong> contains new timezone
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_enough_memory</span></code></dt>
<dd>Check permissions for allocating a new virtual mapping.
<strong>mm</strong> contains the mm struct it is being added to.
<strong>pages</strong> contains the number of pages.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bprm_set_creds</span></code></dt>
<dd>Save security information in the bprm-&gt;security field, typically based
on information about the bprm-&gt;file, for later use by the apply_creds
hook.  This hook may also optionally check permissions (e.g. for
transitions between security domains).
This hook may be called multiple times during a single execve, e.g. for
interpreters.  The hook can tell whether it has already been called by
checking to see if <strong>bprm-&gt;security</strong> is non-NULL.  If so, then the hook
may decide either to retain the security information saved earlier or
to replace it.  The hook must set <strong>bprm-&gt;secureexec</strong> to 1 if a “secure
exec” has happened as a result of this hook call.  The flag is used to
indicate the need for a sanitized execution environment, and is also
passed in the ELF auxiliary table on the initial stack to indicate
whether libc should enable secure mode.
<strong>bprm</strong> contains the linux_binprm structure.
Return 0 if the hook is successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bprm_check_security</span></code></dt>
<dd>This hook mediates the point when a search for a binary handler will
begin.  It allows a check the <strong>bprm-&gt;security</strong> value which is set in the
preceding set_creds call.  The primary difference from set_creds is
that the argv list and envp list are reliably available in <strong>bprm</strong>.  This
hook may be called multiple times during a single execve; and in each
pass set_creds is called first.
<strong>bprm</strong> contains the linux_binprm structure.
Return 0 if the hook is successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bprm_committing_creds</span></code></dt>
<dd>Prepare to install the new security attributes of a process being
transformed by an execve operation, based on the old credentials
pointed to by <strong>current-&gt;cred</strong> and the information set in <strong>bprm-&gt;cred</strong> by
the bprm_set_creds hook.  <strong>bprm</strong> points to the linux_binprm structure.
This hook is a good place to perform state changes on the process such
as closing open file descriptors to which access will no longer be
granted when the attributes are changed.  This is called immediately
before commit_creds().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bprm_committed_creds</span></code></dt>
<dd>Tidy up after the installation of the new security attributes of a
process being transformed by an execve operation.  The new credentials
have, by this point, been set to <strong>current-&gt;cred</strong>.  <strong>bprm</strong> points to the
linux_binprm structure.  This hook is a good place to perform state
changes on the process such as clearing out non-inheritable signal
state.  This is called immediately after commit_creds().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_context_dup</span></code></dt>
<dd>Allocate and attach a security structure to sc-&gt;security.  This pointer
is initialised to NULL by the caller.
<strong>fc</strong> indicates the new filesystem context.
<strong>src_fc</strong> indicates the original filesystem context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_context_parse_param</span></code></dt>
<dd>Userspace provided a parameter to configure a superblock.  The LSM may
reject it with an error and may use it for itself, in which case it
should return 0; otherwise it should return -ENOPARAM to pass it on to
the filesystem.
<strong>fc</strong> indicates the filesystem context.
<strong>param</strong> The parameter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the sb-&gt;s_security field.
The s_security field is initialized to NULL when the structure is
allocated.
<strong>sb</strong> contains the super_block structure to be modified.
Return 0 if operation was successful.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_free_security</span></code></dt>
<dd>Deallocate and clear the sb-&gt;s_security field.
<strong>sb</strong> contains the super_block structure to be modified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_remount</span></code></dt>
<dd>Extracts security system specific mount options and verifies no changes
are being made to those options.
<strong>sb</strong> superblock being remounted
<strong>data</strong> contains the filesystem-specific data.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_statfs</span></code></dt>
<dd>Check permission before obtaining filesystem statistics for the <strong>mnt</strong>
mountpoint.
<strong>dentry</strong> is a handle on the superblock for the filesystem.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_mount</span></code></dt>
<dd>Check permission before an object specified by <strong>dev_name</strong> is mounted on
the mount point named by <strong>nd</strong>.  For an ordinary mount, <strong>dev_name</strong>
identifies a device if the file system type requires a device.  For a
remount (<strong>flags</strong> &amp; MS_REMOUNT), <strong>dev_name</strong> is irrelevant.  For a
loopback/bind mount (<strong>flags</strong> &amp; MS_BIND), <strong>dev_name</strong> identifies the
pathname of the object being mounted.
<strong>dev_name</strong> contains the name for object being mounted.
<strong>path</strong> contains the path for mount point object.
<strong>type</strong> contains the filesystem type.
<strong>flags</strong> contains the mount flags.
<strong>data</strong> contains the filesystem-specific data.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_umount</span></code></dt>
<dd>Check permission before the <strong>mnt</strong> file system is unmounted.
<strong>mnt</strong> contains the mounted file system.
<strong>flags</strong> contains the unmount flags, e.g. MNT_FORCE.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_pivotroot</span></code></dt>
<dd>Check permission before pivoting the root filesystem.
<strong>old_path</strong> contains the path for the new location of the
current root (put_old).
<strong>new_path</strong> contains the path for the new root (new_root).
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_set_mnt_opts</span></code></dt>
<dd>Set the security relevant mount options used for a superblock
<strong>sb</strong> the superblock to set security mount options for
<strong>opts</strong> binary data structure containing all lsm mount data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sb_clone_mnt_opts</span></code></dt>
<dd>Copy all security options from a given superblock to another
<strong>oldsb</strong> old superblock which contain information to clone
<strong>newsb</strong> new superblock which needs filled in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move_mount</span></code></dt>
<dd>Check permission before a mount is moved.
<strong>from_path</strong> indicates the mount that is going to be moved.
<strong>to_path</strong> indicates the mountpoint that will be mounted upon.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dentry_init_security</span></code></dt>
<dd>Compute a context for a dentry as the inode is not yet available
since NFSv4 has no label backed by an EA anyway.
<strong>dentry</strong> dentry to use in calculating the context.
<strong>mode</strong> mode used to determine resource type.
<strong>name</strong> name of the last path component used to create file
<strong>ctx</strong> pointer to place the pointer to the resulting context in.
<strong>ctxlen</strong> point to place the length of the resulting context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dentry_create_files_as</span></code></dt>
<dd>Compute a context for a dentry as the inode is not yet available
and set that context in passed in creds so that new files are
created using that context. Context is calculated using the
passed in creds and not the creds of the caller.
<strong>dentry</strong> dentry to use in calculating the context.
<strong>mode</strong> mode used to determine resource type.
<strong>name</strong> name of the last path component used to create file
<strong>old</strong> creds which should be used for context calculation
<strong>new</strong> creds to modify</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_unlink</span></code></dt>
<dd>Check the permission to remove a hard link to a file.
<strong>dir</strong> contains the path structure of parent directory of the file.
<strong>dentry</strong> contains the dentry structure for file to be unlinked.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_mkdir</span></code></dt>
<dd>Check permissions to create a new directory in the existing directory
associated with path structure <strong>path</strong>.
<strong>dir</strong> contains the path structure of parent of the directory
to be created.
<strong>dentry</strong> contains the dentry structure of new directory.
<strong>mode</strong> contains the mode of new directory.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_rmdir</span></code></dt>
<dd>Check the permission to remove a directory.
<strong>dir</strong> contains the path structure of parent of the directory to be
removed.
<strong>dentry</strong> contains the dentry structure of directory to be removed.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_mknod</span></code></dt>
<dd>Check permissions when creating a file. Note that this hook is called
even if mknod operation is being done for a regular file.
<strong>dir</strong> contains the path structure of parent of the new file.
<strong>dentry</strong> contains the dentry structure of the new file.
<strong>mode</strong> contains the mode of the new file.
<strong>dev</strong> contains the undecoded device number. Use new_decode_dev() to get
the decoded device number.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_truncate</span></code></dt>
<dd>Check permission before truncating a file.
<strong>path</strong> contains the path structure for the file.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_symlink</span></code></dt>
<dd>Check the permission to create a symbolic link to a file.
<strong>dir</strong> contains the path structure of parent directory of
the symbolic link.
<strong>dentry</strong> contains the dentry structure of the symbolic link.
<strong>old_name</strong> contains the pathname of file.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_link</span></code></dt>
<dd>Check permission before creating a new hard link to a file.
<strong>old_dentry</strong> contains the dentry structure for an existing link
to the file.
<strong>new_dir</strong> contains the path structure of the parent directory of
the new link.
<strong>new_dentry</strong> contains the dentry structure for the new link.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_rename</span></code></dt>
<dd>Check for permission to rename a file or directory.
<strong>old_dir</strong> contains the path structure for parent of the old link.
<strong>old_dentry</strong> contains the dentry structure of the old link.
<strong>new_dir</strong> contains the path structure for parent of the new link.
<strong>new_dentry</strong> contains the dentry structure of the new link.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_chmod</span></code></dt>
<dd>Check for permission to change a mode of the file <strong>path</strong>. The new
mode is specified in <strong>mode</strong>.
<strong>path</strong> contains the path structure of the file to change the mode.
<strong>mode</strong> contains the new DAC’s permission, which is a bitmask of
constants from &lt;include/uapi/linux/stat.h&gt;
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_chown</span></code></dt>
<dd>Check for permission to change owner/group of a file or directory.
<strong>path</strong> contains the path structure.
<strong>uid</strong> contains new owner’s ID.
<strong>gid</strong> contains new group’s ID.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_chroot</span></code></dt>
<dd>Check for permission to change root directory.
<strong>path</strong> contains the path structure.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path_notify</span></code></dt>
<dd>Check permissions before setting a watch on events as defined by <strong>mask</strong>,
on an object at <strong>path</strong>, whose type is defined by <strong>obj_type</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to <strong>inode-&gt;i_security</strong>.  The
i_security field is initialized to NULL when the inode structure is
allocated.
<strong>inode</strong> contains the inode structure.
Return 0 if operation was successful.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_free_security</span></code></dt>
<dd><strong>inode</strong> contains the inode structure.
Deallocate the inode security structure and set <strong>inode-&gt;i_security</strong> to
NULL.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_init_security</span></code></dt>
<dd>Obtain the security attribute name suffix and value to set on a newly
created inode and set up the incore security field for the new inode.
This hook is called by the fs code as part of the inode creation
transaction and provides for atomic labeling of the inode, unlike
the post_create/mkdir/… hooks called by the VFS.  The hook function
is expected to allocate the name and value via kmalloc, with the caller
being responsible for calling kfree after using them.
If the security module does not use security attributes or does
not wish to put a security attribute on this particular inode,
then it should return -EOPNOTSUPP to skip this processing.
<strong>inode</strong> contains the inode structure of the newly created inode.
<strong>dir</strong> contains the inode structure of the parent directory.
<strong>qstr</strong> contains the last path component of the new object
<strong>name</strong> will be set to the allocated name suffix (e.g. selinux).
<strong>value</strong> will be set to the allocated attribute value.
<strong>len</strong> will be set to the length of the value.
Returns 0 if <strong>name</strong> and <strong>value</strong> have been successfully set,
-EOPNOTSUPP if no security attribute is needed, or
-ENOMEM on memory allocation failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_create</span></code></dt>
<dd>Check permission to create a regular file.
<strong>dir</strong> contains inode structure of the parent of the new file.
<strong>dentry</strong> contains the dentry structure for the file to be created.
<strong>mode</strong> contains the file mode of the file to be created.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_link</span></code></dt>
<dd>Check permission before creating a new hard link to a file.
<strong>old_dentry</strong> contains the dentry structure for an existing
link to the file.
<strong>dir</strong> contains the inode structure of the parent directory
of the new link.
<strong>new_dentry</strong> contains the dentry structure for the new link.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_unlink</span></code></dt>
<dd>Check the permission to remove a hard link to a file.
<strong>dir</strong> contains the inode structure of parent directory of the file.
<strong>dentry</strong> contains the dentry structure for file to be unlinked.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_symlink</span></code></dt>
<dd>Check the permission to create a symbolic link to a file.
<strong>dir</strong> contains the inode structure of parent directory of
the symbolic link.
<strong>dentry</strong> contains the dentry structure of the symbolic link.
<strong>old_name</strong> contains the pathname of file.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_mkdir</span></code></dt>
<dd>Check permissions to create a new directory in the existing directory
associated with inode structure <strong>dir</strong>.
<strong>dir</strong> contains the inode structure of parent of the directory
to be created.
<strong>dentry</strong> contains the dentry structure of new directory.
<strong>mode</strong> contains the mode of new directory.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_rmdir</span></code></dt>
<dd>Check the permission to remove a directory.
<strong>dir</strong> contains the inode structure of parent of the directory
to be removed.
<strong>dentry</strong> contains the dentry structure of directory to be removed.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_mknod</span></code></dt>
<dd>Check permissions when creating a special file (or a socket or a fifo
file created via the mknod system call).  Note that if mknod operation
is being done for a regular file, then the create hook will be called
and not this hook.
<strong>dir</strong> contains the inode structure of parent of the new file.
<strong>dentry</strong> contains the dentry structure of the new file.
<strong>mode</strong> contains the mode of the new file.
<strong>dev</strong> contains the device number.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_rename</span></code></dt>
<dd>Check for permission to rename a file or directory.
<strong>old_dir</strong> contains the inode structure for parent of the old link.
<strong>old_dentry</strong> contains the dentry structure of the old link.
<strong>new_dir</strong> contains the inode structure for parent of the new link.
<strong>new_dentry</strong> contains the dentry structure of the new link.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_readlink</span></code></dt>
<dd>Check the permission to read the symbolic link.
<strong>dentry</strong> contains the dentry structure for the file link.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_follow_link</span></code></dt>
<dd>Check permission to follow a symbolic link when looking up a pathname.
<strong>dentry</strong> contains the dentry structure for the link.
<strong>inode</strong> contains the inode, which itself is not stable in RCU-walk
<strong>rcu</strong> indicates whether we are in RCU-walk mode.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_permission</span></code></dt>
<dd>Check permission before accessing an inode.  This hook is called by the
existing Linux permission function, so a security module can use it to
provide additional checking for existing Linux permission checks.
Notice that this hook is called when a file is opened (as well as many
other operations), whereas the file_security_ops permission hook is
called when the actual read/write operations are performed.
<strong>inode</strong> contains the inode structure to check.
<strong>mask</strong> contains the permission mask.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_setattr</span></code></dt>
<dd>Check permission before setting file attributes.  Note that the kernel
call to notify_change is performed from several locations, whenever
file attributes change (such as when a file is truncated, chown/chmod
operations, transferring disk quotas, etc).
<strong>dentry</strong> contains the dentry structure for the file.
<strong>attr</strong> is the iattr structure containing the new file attributes.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_getattr</span></code></dt>
<dd>Check permission before obtaining file attributes.
<strong>path</strong> contains the path structure for the file.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_setxattr</span></code></dt>
<dd>Check permission before setting the extended attributes
<strong>value</strong> identified by <strong>name</strong> for <strong>dentry</strong>.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_post_setxattr</span></code></dt>
<dd>Update inode security field after successful setxattr operation.
<strong>value</strong> identified by <strong>name</strong> for <strong>dentry</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_getxattr</span></code></dt>
<dd>Check permission before obtaining the extended attributes
identified by <strong>name</strong> for <strong>dentry</strong>.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_listxattr</span></code></dt>
<dd>Check permission before obtaining the list of extended attribute
names for <strong>dentry</strong>.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_removexattr</span></code></dt>
<dd>Check permission before removing the extended attribute
identified by <strong>name</strong> for <strong>dentry</strong>.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_need_killpriv</span></code></dt>
<dd>Called when an inode has been changed.
<strong>dentry</strong> is the dentry being changed.
Return &lt;0 on error to abort the inode change operation.
Return 0 if inode_killpriv does not need to be called.
Return &gt;0 if inode_killpriv does need to be called.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_killpriv</span></code></dt>
<dd>The setuid bit is being removed.  Remove similar security labels.
Called with the dentry-&gt;d_inode-&gt;i_mutex held.
<strong>dentry</strong> is the dentry being changed.
Return 0 on success.  If error is returned, then the operation
causing setuid bit removal is failed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_getsecurity</span></code></dt>
<dd>Retrieve a copy of the extended attribute representation of the
security label associated with <strong>name</strong> for <strong>inode</strong> via <strong>buffer</strong>.  Note that
<strong>name</strong> is the remainder of the attribute name after the security prefix
has been removed. <strong>alloc</strong> is used to specify of the call should return a
value via the buffer or just the value length Return size of buffer on
success.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_setsecurity</span></code></dt>
<dd>Set the security label associated with <strong>name</strong> for <strong>inode</strong> from the
extended attribute value <strong>value</strong>.  <strong>size</strong> indicates the size of the
<strong>value</strong> in bytes.  <strong>flags</strong> may be XATTR_CREATE, XATTR_REPLACE, or 0.
Note that <strong>name</strong> is the remainder of the attribute name after the
security. prefix has been removed.
Return 0 on success.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_listsecurity</span></code></dt>
<dd>Copy the extended attribute names for the security labels
associated with <strong>inode</strong> into <strong>buffer</strong>.  The maximum size of <strong>buffer</strong>
is specified by <strong>buffer_size</strong>.  <strong>buffer</strong> may be NULL to request
the size of the buffer required.
Returns number of bytes used/required on success.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_getsecid</span></code></dt>
<dd>Get the secid associated with the node.
<strong>inode</strong> contains a pointer to the inode.
<strong>secid</strong> contains a pointer to the location where result will be saved.
In case of failure, <strong>secid</strong> will be set to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_copy_up</span></code></dt>
<dd>A file is about to be copied up from lower layer to upper layer of
overlay filesystem. Security module can prepare a set of new creds
and modify as need be and return new creds. Caller will switch to
new creds temporarily to create new file and release newly allocated
creds.
<strong>src</strong> indicates the union dentry of file that is being copied up.
<strong>new</strong> pointer to pointer to return newly allocated creds.
Returns 0 on success or a negative error code on error.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_copy_up_xattr</span></code></dt>
<dd>Filter the xattrs being copied up when a unioned file is copied
up from a lower layer to the union/overlay layer.
<strong>name</strong> indicates the name of the xattr.
Returns 0 to accept the xattr, 1 to discard the xattr, -EOPNOTSUPP if
security module does not know about attribute or a negative error code
to abort the copy up. Note that the caller is responsible for reading
and writing the xattrs as this hook is merely a filter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernfs_init_security</span></code></dt>
<dd>Initialize the security context of a newly created kernfs node based
on its own and its parent’s attributes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_permission</span></code></dt>
<dd>Check file permissions before accessing an open file.  This hook is
called by various operations that read or write files.  A security
module can use this hook to perform additional checking on these
operations, e.g.  to revalidate permissions on use to support privilege
bracketing or policy changes.  Notice that this hook is used when the
actual read/write operations are performed, whereas the
inode_security_ops hook is called when a file is opened (as well as
many other operations).
Caveat:  Although this hook can be used to revalidate permissions for
various system call operations that read or write files, it does not
address the revalidation of permissions for memory-mapped files.
Security modules must handle this separately if they need such
revalidation.
<strong>file</strong> contains the file structure being accessed.
<strong>mask</strong> contains the requested permissions.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the file-&gt;f_security field.
The security field is initialized to NULL when the structure is first
created.
<strong>file</strong> contains the file structure to secure.
Return 0 if the hook is successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_free_security</span></code></dt>
<dd>Deallocate and free any security structures stored in file-&gt;f_security.
<strong>file</strong> contains the file structure being modified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_ioctl</span></code></dt>
<dd><strong>file</strong> contains the file structure.
<strong>cmd</strong> contains the operation to perform.
<strong>arg</strong> contains the operational arguments.
Check permission for an ioctl operation on <strong>file</strong>.  Note that <strong>arg</strong>
sometimes represents a user space pointer; in other cases, it may be a
simple integer value.  When <strong>arg</strong> represents a user space pointer, it
should never be used by the security module.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap_addr</span></code></dt>
<dd>Check permissions for a mmap operation at <strong>addr</strong>.
<strong>addr</strong> contains virtual address that will be used for the operation.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap_file</span></code></dt>
<dd>Check permissions for a mmap operation.  The <strong>file</strong> may be NULL, e.g.
if mapping anonymous memory.
<strong>file</strong> contains the file structure for file to map (may be NULL).
<strong>reqprot</strong> contains the protection requested by the application.
<strong>prot</strong> contains the protection that will be applied by the kernel.
<strong>flags</strong> contains the operational flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_mprotect</span></code></dt>
<dd>Check permissions before changing memory access permissions.
<strong>vma</strong> contains the memory region to modify.
<strong>reqprot</strong> contains the protection requested by the application.
<strong>prot</strong> contains the protection that will be applied by the kernel.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_lock</span></code></dt>
<dd>Check permission before performing file locking operations.
Note the hook mediates both flock and fcntl style locks.
<strong>file</strong> contains the file structure.
<strong>cmd</strong> contains the posix-translated lock operation to perform
(e.g. F_RDLCK, F_WRLCK).
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_fcntl</span></code></dt>
<dd>Check permission before allowing the file operation specified by <strong>cmd</strong>
from being performed on the file <strong>file</strong>.  Note that <strong>arg</strong> sometimes
represents a user space pointer; in other cases, it may be a simple
integer value.  When <strong>arg</strong> represents a user space pointer, it should
never be used by the security module.
<strong>file</strong> contains the file structure.
<strong>cmd</strong> contains the operation to be performed.
<strong>arg</strong> contains the operational arguments.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_set_fowner</span></code></dt>
<dd>Save owner security information (typically from current-&gt;security) in
file-&gt;f_security for later use by the send_sigiotask hook.
<strong>file</strong> contains the file structure to update.
Return 0 on success.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_send_sigiotask</span></code></dt>
<dd>Check permission for the file owner <strong>fown</strong> to send SIGIO or SIGURG to the
process <strong>tsk</strong>.  Note that this hook is sometimes called from interrupt.
Note that the fown_struct, <strong>fown</strong>, is never outside the context of a
struct file, so the file structure (and associated security information)
can always be obtained: container_of(fown, struct file, f_owner)
<strong>tsk</strong> contains the structure of task receiving signal.
<strong>fown</strong> contains the file owner information.
<strong>sig</strong> is the signal that will be sent.  When 0, kernel sends SIGIO.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_receive</span></code></dt>
<dd>This hook allows security modules to control the ability of a process
to receive an open file descriptor via socket IPC.
<strong>file</strong> contains the file structure being received.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_open</span></code></dt>
<dd>Save open-time permission checking state for later use upon
file_permission, and recheck access if anything has changed
since inode_permission.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_alloc</span></code></dt>
<dd><strong>task</strong> task being allocated.
<strong>clone_flags</strong> contains the flags indicating what should be shared.
Handle allocation of task-related resources.
Returns a zero on success, negative values on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_free</span></code></dt>
<dd><strong>task</strong> task about to be freed.
Handle release of task-related resources. (Note that this can be called
from interrupt context.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cred_alloc_blank</span></code></dt>
<dd><strong>cred</strong> points to the credentials.
<strong>gfp</strong> indicates the atomicity of any memory allocations.
Only allocate sufficient memory and attach to <strong>cred</strong> such that
cred_transfer() will not get ENOMEM.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cred_free</span></code></dt>
<dd><strong>cred</strong> points to the credentials.
Deallocate and clear the cred-&gt;security field in a set of credentials.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cred_prepare</span></code></dt>
<dd><strong>new</strong> points to the new credentials.
<strong>old</strong> points to the original credentials.
<strong>gfp</strong> indicates the atomicity of any memory allocations.
Prepare a new set of credentials by copying the data from the old set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cred_transfer</span></code></dt>
<dd><strong>new</strong> points to the new credentials.
<strong>old</strong> points to the original credentials.
Transfer data from original creds to new creds</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cred_getsecid</span></code></dt>
<dd>Retrieve the security identifier of the cred structure <strong>c</strong>
<strong>c</strong> contains the credentials, secid will be placed into <strong>secid</strong>.
In case of failure, <strong>secid</strong> will be set to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_act_as</span></code></dt>
<dd>Set the credentials for a kernel service to act as (subjective context).
<strong>new</strong> points to the credentials to be modified.
<strong>secid</strong> specifies the security ID to be set
The current task must be the one that nominated <strong>secid</strong>.
Return 0 if successful.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_create_files_as</span></code></dt>
<dd>Set the file creation context in a set of credentials to be the same as
the objective context of the specified inode.
<strong>new</strong> points to the credentials to be modified.
<strong>inode</strong> points to the inode to use as a reference.
The current task must be the one that nominated <strong>inode</strong>.
Return 0 if successful.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_module_request</span></code></dt>
<dd>Ability to trigger the kernel to automatically upcall to userspace for
userspace to load a kernel module with the given name.
<strong>kmod_name</strong> name of the module requested by the kernel
Return 0 if successful.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_load_data</span></code></dt>
<dd>Load data provided by userspace.
<strong>id</strong> kernel load data identifier
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_read_file</span></code></dt>
<dd>Read a file specified by userspace.
<strong>file</strong> contains the file structure pointing to the file being read
by the kernel.
<strong>id</strong> kernel read file identifier
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_post_read_file</span></code></dt>
<dd>Read a file specified by userspace.
<strong>file</strong> contains the file structure pointing to the file being read
by the kernel.
<strong>buf</strong> pointer to buffer containing the file contents.
<strong>size</strong> length of the file contents.
<strong>id</strong> kernel read file identifier
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_fix_setuid</span></code></dt>
<dd>Update the module’s state after setting one or more of the user
identity attributes of the current process.  The <strong>flags</strong> parameter
indicates which of the set*uid system calls invoked this hook.  If
<strong>new</strong> is the set of credentials that will be installed.  Modifications
should be made to this rather than to <strong>current-&gt;cred</strong>.
<strong>old</strong> is the set of credentials that are being replaces
<strong>flags</strong> contains one of the LSM_SETID_* values.
Return 0 on success.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_setpgid</span></code></dt>
<dd>Check permission before setting the process group identifier of the
process <strong>p</strong> to <strong>pgid</strong>.
<strong>p</strong> contains the task_struct for process being modified.
<strong>pgid</strong> contains the new pgid.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_getpgid</span></code></dt>
<dd>Check permission before getting the process group identifier of the
process <strong>p</strong>.
<strong>p</strong> contains the task_struct for the process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_getsid</span></code></dt>
<dd>Check permission before getting the session identifier of the process
<strong>p</strong>.
<strong>p</strong> contains the task_struct for the process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_getsecid</span></code></dt>
<dd>Retrieve the security identifier of the process <strong>p</strong>.
<strong>p</strong> contains the task_struct for the process and place is into <strong>secid</strong>.
In case of failure, <strong>secid</strong> will be set to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_setnice</span></code></dt>
<dd>Check permission before setting the nice value of <strong>p</strong> to <strong>nice</strong>.
<strong>p</strong> contains the task_struct of process.
<strong>nice</strong> contains the new nice value.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_setioprio</span></code></dt>
<dd>Check permission before setting the ioprio value of <strong>p</strong> to <strong>ioprio</strong>.
<strong>p</strong> contains the task_struct of process.
<strong>ioprio</strong> contains the new ioprio value
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_getioprio</span></code></dt>
<dd>Check permission before getting the ioprio value of <strong>p</strong>.
<strong>p</strong> contains the task_struct of process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_prlimit</span></code></dt>
<dd>Check permission before getting and/or setting the resource limits of
another task.
<strong>cred</strong> points to the cred structure for the current task.
<strong>tcred</strong> points to the cred structure for the target task.
<strong>flags</strong> contains the LSM_PRLIMIT_* flag bits indicating whether the
resource limits are being read, modified, or both.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_setrlimit</span></code></dt>
<dd>Check permission before setting the resource limits of process <strong>p</strong>
for <strong>resource</strong> to <strong>new_rlim</strong>.  The old resource limit values can
be examined by dereferencing (p-&gt;signal-&gt;rlim + resource).
<strong>p</strong> points to the task_struct for the target task’s group leader.
<strong>resource</strong> contains the resource whose limit is being set.
<strong>new_rlim</strong> contains the new limits for <strong>resource</strong>.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_setscheduler</span></code></dt>
<dd>Check permission before setting scheduling policy and/or parameters of
process <strong>p</strong>.
<strong>p</strong> contains the task_struct for process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_getscheduler</span></code></dt>
<dd>Check permission before obtaining scheduling information for process
<strong>p</strong>.
<strong>p</strong> contains the task_struct for process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_movememory</span></code></dt>
<dd>Check permission before moving memory owned by process <strong>p</strong>.
<strong>p</strong> contains the task_struct for process.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_kill</span></code></dt>
<dd>Check permission before sending signal <strong>sig</strong> to <strong>p</strong>.  <strong>info</strong> can be NULL,
the constant 1, or a pointer to a kernel_siginfo structure.  If <strong>info</strong> is 1 or
SI_FROMKERNEL(info) is true, then the signal should be viewed as coming
from the kernel and should typically be permitted.
SIGIO signals are handled separately by the send_sigiotask hook in
file_security_ops.
<strong>p</strong> contains the task_struct for process.
<strong>info</strong> contains the signal information.
<strong>sig</strong> contains the signal value.
<strong>cred</strong> contains the cred of the process where the signal originated, or
NULL if the current task is the originator.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_prctl</span></code></dt>
<dd>Check permission before performing a process control operation on the
current process.
<strong>option</strong> contains the operation.
<strong>arg2</strong> contains a argument.
<strong>arg3</strong> contains a argument.
<strong>arg4</strong> contains a argument.
<strong>arg5</strong> contains a argument.
Return -ENOSYS if no-one wanted to handle this op, any other value to
cause prctl() to return immediately with that value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task_to_inode</span></code></dt>
<dd>Set the security attributes for an inode based on an associated task’s
security attributes, e.g. for /proc/pid inodes.
<strong>p</strong> contains the task_struct for the task.
<strong>inode</strong> contains the inode structure for the inode.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipc_permission</span></code></dt>
<dd>Check permissions for access to IPC
<strong>ipcp</strong> contains the kernel IPC permission structure
<strong>flag</strong> contains the desired (requested) permission set
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipc_getsecid</span></code></dt>
<dd>Get the secid associated with the ipc object.
<strong>ipcp</strong> contains the kernel IPC permission structure.
<strong>secid</strong> contains a pointer to the location where result will be saved.
In case of failure, <strong>secid</strong> will be set to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_msg_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the msg-&gt;security field.
The security field is initialized to NULL when the structure is first
created.
<strong>msg</strong> contains the message structure to be modified.
Return 0 if operation was successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_msg_free_security</span></code></dt>
<dd>Deallocate the security structure for this message.
<strong>msg</strong> contains the message structure to be modified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the
<strong>perm-&gt;security</strong> field. The security field is initialized to
NULL when the structure is first created.
<strong>perm</strong> contains the IPC permissions of the message queue.
Return 0 if operation was successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_free_security</span></code></dt>
<dd>Deallocate security field <strong>perm-&gt;security</strong> for the message queue.
<strong>perm</strong> contains the IPC permissions of the message queue.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_associate</span></code></dt>
<dd>Check permission when a message queue is requested through the
msgget system call. This hook is only called when returning the
message queue identifier for an existing message queue, not when a
new message queue is created.
<strong>perm</strong> contains the IPC permissions of the message queue.
<strong>msqflg</strong> contains the operation control flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_msgctl</span></code></dt>
<dd>Check permission when a message control operation specified by <strong>cmd</strong>
is to be performed on the message queue with permissions <strong>perm</strong>.
The <strong>perm</strong> may be NULL, e.g. for IPC_INFO or MSG_INFO.
<strong>perm</strong> contains the IPC permissions of the msg queue. May be NULL.
<strong>cmd</strong> contains the operation to be performed.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_msgsnd</span></code></dt>
<dd>Check permission before a message, <strong>msg</strong>, is enqueued on the message
queue with permissions <strong>perm</strong>.
<strong>perm</strong> contains the IPC permissions of the message queue.
<strong>msg</strong> contains the message to be enqueued.
<strong>msqflg</strong> contains operational flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_queue_msgrcv</span></code></dt>
<dd>Check permission before a message, <strong>msg</strong>, is removed from the message
queue. The <strong>target</strong> task structure contains a pointer to the
process that will be receiving the message (not equal to the current
process when inline receives are being performed).
<strong>perm</strong> contains the IPC permissions of the message queue.
<strong>msg</strong> contains the message destination.
<strong>target</strong> contains the task structure for recipient process.
<strong>type</strong> contains the type of message requested.
<strong>mode</strong> contains the operational flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shm_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the <strong>perm-&gt;security</strong>
field. The security field is initialized to NULL when the structure is
first created.
<strong>perm</strong> contains the IPC permissions of the shared memory structure.
Return 0 if operation was successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shm_free_security</span></code></dt>
<dd>Deallocate the security structure <strong>perm-&gt;security</strong> for the memory segment.
<strong>perm</strong> contains the IPC permissions of the shared memory structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shm_associate</span></code></dt>
<dd>Check permission when a shared memory region is requested through the
shmget system call. This hook is only called when returning the shared
memory region identifier for an existing region, not when a new shared
memory region is created.
<strong>perm</strong> contains the IPC permissions of the shared memory structure.
<strong>shmflg</strong> contains the operation control flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shm_shmctl</span></code></dt>
<dd>Check permission when a shared memory control operation specified by
<strong>cmd</strong> is to be performed on the shared memory region with permissions <strong>perm</strong>.
The <strong>perm</strong> may be NULL, e.g. for IPC_INFO or SHM_INFO.
<strong>perm</strong> contains the IPC permissions of the shared memory structure.
<strong>cmd</strong> contains the operation to be performed.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shm_shmat</span></code></dt>
<dd>Check permissions prior to allowing the shmat system call to attach the
shared memory segment with permissions <strong>perm</strong> to the data segment of the
calling process. The attaching address is specified by <strong>shmaddr</strong>.
<strong>perm</strong> contains the IPC permissions of the shared memory structure.
<strong>shmaddr</strong> contains the address to attach memory region to.
<strong>shmflg</strong> contains the operational flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sem_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the <strong>perm-&gt;security</strong>
field. The security field is initialized to NULL when the structure is
first created.
<strong>perm</strong> contains the IPC permissions of the semaphore.
Return 0 if operation was successful and permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sem_free_security</span></code></dt>
<dd>Deallocate security structure <strong>perm-&gt;security</strong> for the semaphore.
<strong>perm</strong> contains the IPC permissions of the semaphore.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sem_associate</span></code></dt>
<dd>Check permission when a semaphore is requested through the semget
system call. This hook is only called when returning the semaphore
identifier for an existing semaphore, not when a new one must be
created.
<strong>perm</strong> contains the IPC permissions of the semaphore.
<strong>semflg</strong> contains the operation control flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sem_semctl</span></code></dt>
<dd>Check permission when a semaphore operation specified by <strong>cmd</strong> is to be
performed on the semaphore. The <strong>perm</strong> may be NULL, e.g. for
IPC_INFO or SEM_INFO.
<strong>perm</strong> contains the IPC permissions of the semaphore. May be NULL.
<strong>cmd</strong> contains the operation to be performed.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sem_semop</span></code></dt>
<dd>Check permissions before performing operations on members of the
semaphore set. If the <strong>alter</strong> flag is nonzero, the semaphore set
may be modified.
<strong>perm</strong> contains the IPC permissions of the semaphore.
<strong>sops</strong> contains the operations to perform.
<strong>nsops</strong> contains the number of operations to perform.
<strong>alter</strong> contains the flag indicating whether changes are to be made.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netlink_send</span></code></dt>
<dd>Save security information for a netlink message so that permission
checking can be performed when the message is processed.  The security
information can be saved using the eff_cap field of the
netlink_skb_parms structure.  Also may be used to provide fine
grained control over message transmission.
<strong>sk</strong> associated sock of task sending the message.
<strong>skb</strong> contains the sk_buff structure for the netlink message.
Return 0 if the information was successfully saved and message
is allowed to be transmitted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ismaclabel</span></code></dt>
<dd>Check if the extended attribute specified by <strong>name</strong>
represents a MAC label. Returns 1 if name is a MAC
attribute otherwise returns 0.
<strong>name</strong> full extended attribute name to check against
LSM as a MAC label.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secid_to_secctx</span></code></dt>
<dd>Convert secid to security context.  If secdata is NULL the length of
the result will be returned in seclen, but no secdata will be returned.
This does mean that the length could change between calls to check the
length and the next call which actually allocates and returns the
secdata.
<strong>secid</strong> contains the security ID.
<strong>secdata</strong> contains the pointer that stores the converted security
context.
<strong>seclen</strong> pointer which contains the length of the data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secctx_to_secid</span></code></dt>
<dd>Convert security context to secid.
<strong>secid</strong> contains the pointer to the generated security ID.
<strong>secdata</strong> contains the security context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_secctx</span></code></dt>
<dd>Release the security context.
<strong>secdata</strong> contains the security context.
<strong>seclen</strong> contains the length of the security context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_invalidate_secctx</span></code></dt>
<dd>Notify the security module that it must revalidate the security context
of an inode.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_notifysecctx</span></code></dt>
<dd>Notify the security module of what the security context of an inode
should be.  Initializes the incore security context managed by the
security module for this inode.  Example usage:  NFS client invokes
this hook to initialize the security context in its incore inode to the
value provided by the server for the file when the server returned the
file’s attributes to the client.
Must be called with inode-&gt;i_mutex locked.
<strong>inode</strong> we wish to set the security context of.
<strong>ctx</strong> contains the string which we wish to set in the inode.
<strong>ctxlen</strong> contains the length of <strong>ctx</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_setsecctx</span></code></dt>
<dd>Change the security context of an inode.  Updates the
incore security context managed by the security module and invokes the
fs code as needed (via __vfs_setxattr_noperm) to update any backing
xattrs that represent the context.  Example usage:  NFS server invokes
this hook to change the security context in its incore inode and on the
backing filesystem to a value provided by the client on a SETATTR
operation.
Must be called with inode-&gt;i_mutex locked.
<strong>dentry</strong> contains the inode we wish to set the security context of.
<strong>ctx</strong> contains the string which we wish to set in the inode.
<strong>ctxlen</strong> contains the length of <strong>ctx</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inode_getsecctx</span></code></dt>
<dd>On success, returns 0 and fills out <strong>ctx</strong> and <strong>ctxlen</strong> with the security
context for the given <strong>inode</strong>.
<strong>inode</strong> we wish to get the security context of.
<strong>ctx</strong> is a pointer in which to place the allocated security context.
<strong>ctxlen</strong> points to the place to put the length of <strong>ctx</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unix_stream_connect</span></code></dt>
<dd>Check permissions before establishing a Unix domain stream connection
between <strong>sock</strong> and <strong>other</strong>.
<strong>sock</strong> contains the sock structure.
<strong>other</strong> contains the peer sock structure.
<strong>newsk</strong> contains the new sock structure.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unix_may_send</span></code></dt>
<dd>Check permissions before connecting or sending datagrams from <strong>sock</strong> to
<strong>other</strong>.
<strong>sock</strong> contains the socket structure.
<strong>other</strong> contains the peer socket structure.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_create</span></code></dt>
<dd>Check permissions prior to creating a new socket.
<strong>family</strong> contains the requested protocol family.
<strong>type</strong> contains the requested communications type.
<strong>protocol</strong> contains the requested protocol.
<strong>kern</strong> set to 1 if a kernel socket.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_post_create</span></code></dt>
<dd>This hook allows a module to update or allocate a per-socket security
structure. Note that the security field was not added directly to the
socket structure, but rather, the socket security information is stored
in the associated inode.  Typically, the inode alloc_security hook will
allocate and and attach security information to
SOCK_INODE(sock)-&gt;i_security.  This hook may be used to update the
SOCK_INODE(sock)-&gt;i_security field with additional information that
wasn’t available when the inode was allocated.
<strong>sock</strong> contains the newly created socket structure.
<strong>family</strong> contains the requested protocol family.
<strong>type</strong> contains the requested communications type.
<strong>protocol</strong> contains the requested protocol.
<strong>kern</strong> set to 1 if a kernel socket.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_socketpair</span></code></dt>
<dd>Check permissions before creating a fresh pair of sockets.
<strong>socka</strong> contains the first socket structure.
<strong>sockb</strong> contains the second socket structure.
Return 0 if permission is granted and the connection was established.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_bind</span></code></dt>
<dd>Check permission before socket protocol layer bind operation is
performed and the socket <strong>sock</strong> is bound to the address specified in the
<strong>address</strong> parameter.
<strong>sock</strong> contains the socket structure.
<strong>address</strong> contains the address to bind to.
<strong>addrlen</strong> contains the length of address.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_connect</span></code></dt>
<dd>Check permission before socket protocol layer connect operation
attempts to connect socket <strong>sock</strong> to a remote address, <strong>address</strong>.
<strong>sock</strong> contains the socket structure.
<strong>address</strong> contains the address of remote endpoint.
<strong>addrlen</strong> contains the length of address.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_listen</span></code></dt>
<dd>Check permission before socket protocol layer listen operation.
<strong>sock</strong> contains the socket structure.
<strong>backlog</strong> contains the maximum length for the pending connection queue.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_accept</span></code></dt>
<dd>Check permission before accepting a new connection.  Note that the new
socket, <strong>newsock</strong>, has been created and some information copied to it,
but the accept operation has not actually been performed.
<strong>sock</strong> contains the listening socket structure.
<strong>newsock</strong> contains the newly created server socket for connection.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_sendmsg</span></code></dt>
<dd>Check permission before transmitting a message to another socket.
<strong>sock</strong> contains the socket structure.
<strong>msg</strong> contains the message to be transmitted.
<strong>size</strong> contains the size of message.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_recvmsg</span></code></dt>
<dd>Check permission before receiving a message from a socket.
<strong>sock</strong> contains the socket structure.
<strong>msg</strong> contains the message structure.
<strong>size</strong> contains the size of message structure.
<strong>flags</strong> contains the operational flags.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_getsockname</span></code></dt>
<dd>Check permission before the local address (name) of the socket object
<strong>sock</strong> is retrieved.
<strong>sock</strong> contains the socket structure.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_getpeername</span></code></dt>
<dd>Check permission before the remote address (name) of a socket object
<strong>sock</strong> is retrieved.
<strong>sock</strong> contains the socket structure.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_getsockopt</span></code></dt>
<dd>Check permissions before retrieving the options associated with socket
<strong>sock</strong>.
<strong>sock</strong> contains the socket structure.
<strong>level</strong> contains the protocol level to retrieve option from.
<strong>optname</strong> contains the name of option to retrieve.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_setsockopt</span></code></dt>
<dd>Check permissions before setting the options associated with socket
<strong>sock</strong>.
<strong>sock</strong> contains the socket structure.
<strong>level</strong> contains the protocol level to set options for.
<strong>optname</strong> contains the name of the option to set.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_shutdown</span></code></dt>
<dd>Checks permission before all or part of a connection on the socket
<strong>sock</strong> is shut down.
<strong>sock</strong> contains the socket structure.
<strong>how</strong> contains the flag indicating how future sends and receives
are handled.
Return 0 if permission is granted.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_sock_rcv_skb</span></code></dt>
<dd>Check permissions on incoming network packets.  This hook is distinct
from Netfilter’s IP input hooks since it is the first time that the
incoming sk_buff <strong>skb</strong> has been associated with a particular socket, <strong>sk</strong>.
Must not sleep inside this hook because some callers hold spinlocks.
<strong>sk</strong> contains the sock (not socket) associated with the incoming sk_buff.
<strong>skb</strong> contains the incoming network data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_getpeersec_stream</span></code></dt>
<dd>This hook allows the security module to provide peer socket security
state for unix or connected tcp sockets to userspace via getsockopt
SO_GETPEERSEC.  For tcp sockets this can be meaningful if the
socket is associated with an ipsec SA.
<strong>sock</strong> is the local socket.
<strong>optval</strong> userspace memory where the security state is to be copied.
<strong>optlen</strong> userspace int where the module should copy the actual length
of the security state.
<strong>len</strong> as input is the maximum length to copy to userspace provided
by the caller.
Return 0 if all is well, otherwise, typical getsockopt return
values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">socket_getpeersec_dgram</span></code></dt>
<dd>This hook allows the security module to provide peer socket security
state for udp sockets on a per-packet basis to userspace via
getsockopt SO_GETPEERSEC. The application must first have indicated
the IP_PASSSEC option via getsockopt. It can then retrieve the
security state returned by this hook for a packet via the SCM_SECURITY
ancillary message type.
<strong>sock</strong> contains the peer socket. May be NULL.
<strong>skb</strong> is the sk_buff for the packet being queried. May be NULL.
<strong>secid</strong> pointer to store the secid of the packet.
Return 0 on success, error on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_alloc_security</span></code></dt>
<dd>Allocate and attach a security structure to the sk-&gt;sk_security field,
which is used to copy security attributes between local stream sockets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_free_security</span></code></dt>
<dd>Deallocate security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_clone_security</span></code></dt>
<dd>Clone/copy security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_getsecid</span></code></dt>
<dd>Retrieve the LSM-specific secid for the sock to enable caching
of network authorizations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sock_graft</span></code></dt>
<dd>Sets the socket’s isec sid to the sock’s sid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inet_conn_request</span></code></dt>
<dd>Sets the openreq’s sid to socket’s sid with MLS portion taken
from peer sid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inet_csk_clone</span></code></dt>
<dd>Sets the new child socket’s sid to the openreq sid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inet_conn_established</span></code></dt>
<dd>Sets the connection’s peersid to the secmark on skb.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secmark_relabel_packet</span></code></dt>
<dd>check if the process should be allowed to relabel packets to
the given secid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secmark_refcount_inc</span></code></dt>
<dd>tells the LSM to increment the number of secmark labeling rules loaded</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secmark_refcount_dec</span></code></dt>
<dd>tells the LSM to decrement the number of secmark labeling rules loaded</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_classify_flow</span></code></dt>
<dd>Sets the flow’s sid to the openreq sid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_alloc_security</span></code></dt>
<dd>This hook allows a module to allocate a security structure for a TUN
device.
<strong>security</strong> pointer to a security structure pointer.
Returns a zero on success, negative values on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_free_security</span></code></dt>
<dd>This hook allows a module to free the security structure for a TUN
device.
<strong>security</strong> pointer to the TUN device’s security structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_create</span></code></dt>
<dd>Check permissions prior to creating a new TUN device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_attach_queue</span></code></dt>
<dd>Check permissions prior to attaching to a TUN device queue.
<strong>security</strong> pointer to the TUN device’s security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_attach</span></code></dt>
<dd>This hook can be used by the module to update any security state
associated with the TUN device’s sock structure.
<strong>sk</strong> contains the existing sock structure.
<strong>security</strong> pointer to the TUN device’s security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tun_dev_open</span></code></dt>
<dd>This hook can be used by the module to update any security state
associated with the TUN device’s security structure.
<strong>security</strong> pointer to the TUN devices’s security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sctp_assoc_request</span></code></dt>
<dd>Passes the <strong>ep</strong> and <strong>chunk-&gt;skb</strong> of the association INIT packet to
the security module.
<strong>ep</strong> pointer to sctp endpoint structure.
<strong>skb</strong> pointer to skbuff of association packet.
Return 0 on success, error on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sctp_bind_connect</span></code></dt>
<dd>Validiate permissions required for each address associated with sock
<strong>sk</strong>. Depending on <strong>optname</strong>, the addresses will be treated as either
for a connect or bind service. The <strong>addrlen</strong> is calculated on each
ipv4 and ipv6 address using sizeof(struct sockaddr_in) or
sizeof(struct sockaddr_in6).
<strong>sk</strong> pointer to sock structure.
<strong>optname</strong> name of the option to validate.
<strong>address</strong> list containing one or more ipv4/ipv6 addresses.
<strong>addrlen</strong> total length of address(s).
Return 0 on success, error on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sctp_sk_clone</span></code></dt>
<dd>Called whenever a new socket is created by accept(2) (i.e. a TCP
style socket) or when a socket is ‘peeled off’ e.g userspace
calls sctp_peeloff(3).
<strong>ep</strong> pointer to current sctp endpoint structure.
<strong>sk</strong> pointer to current sock structure.
<strong>sk</strong> pointer to new sock structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_pkey_access</span></code></dt>
<dd>Check permission to access a pkey when modifing a QP.
<strong>subnet_prefix</strong> the subnet prefix of the port being used.
<strong>pkey</strong> the pkey to be accessed.
<strong>sec</strong> pointer to a security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_endport_manage_subnet</span></code></dt>
<dd>Check permissions to send and receive SMPs on a end port.
<strong>dev_name</strong> the IB device name (i.e. mlx4_0).
<strong>port_num</strong> the port number.
<strong>sec</strong> pointer to a security structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_alloc_security</span></code></dt>
<dd>Allocate a security structure for Infiniband objects.
<strong>sec</strong> pointer to a security structure pointer.
Returns 0 on success, non-zero on failure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_free_security</span></code></dt>
<dd>Deallocate an Infiniband security structure.
<strong>sec</strong> contains the security structure to be freed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_policy_alloc_security</span></code></dt>
<dd><strong>ctxp</strong> is a pointer to the xfrm_sec_ctx being added to Security Policy
Database used by the XFRM system.
<strong>sec_ctx</strong> contains the security context information being provided by
the user-level policy update program (e.g., setkey).
Allocate a security structure to the xp-&gt;security field; the security
field is initialized to NULL when the xfrm_policy is allocated.
Return 0 if operation was successful (memory to allocate, legal context)
<strong>gfp</strong> is to specify the context for the allocation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_policy_clone_security</span></code></dt>
<dd><strong>old_ctx</strong> contains an existing xfrm_sec_ctx.
<strong>new_ctxp</strong> contains a new xfrm_sec_ctx being cloned from old.
Allocate a security structure in new_ctxp that contains the
information from the old_ctx structure.
Return 0 if operation was successful (memory to allocate).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_policy_free_security</span></code></dt>
<dd><strong>ctx</strong> contains the xfrm_sec_ctx
Deallocate xp-&gt;security.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_policy_delete_security</span></code></dt>
<dd><strong>ctx</strong> contains the xfrm_sec_ctx.
Authorize deletion of xp-&gt;security.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_state_alloc</span></code></dt>
<dd><strong>x</strong> contains the xfrm_state being added to the Security Association
Database by the XFRM system.
<strong>sec_ctx</strong> contains the security context information being provided by
the user-level SA generation program (e.g., setkey or racoon).
Allocate a security structure to the x-&gt;security field; the security
field is initialized to NULL when the xfrm_state is allocated. Set the
context to correspond to sec_ctx. Return 0 if operation was successful
(memory to allocate, legal context).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_state_alloc_acquire</span></code></dt>
<dd><strong>x</strong> contains the xfrm_state being added to the Security Association
Database by the XFRM system.
<strong>polsec</strong> contains the policy’s security context.
<strong>secid</strong> contains the secid from which to take the mls portion of the
context.
Allocate a security structure to the x-&gt;security field; the security
field is initialized to NULL when the xfrm_state is allocated. Set the
context to correspond to secid. Return 0 if operation was successful
(memory to allocate, legal context).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_state_free_security</span></code></dt>
<dd><strong>x</strong> contains the xfrm_state.
Deallocate x-&gt;security.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_state_delete_security</span></code></dt>
<dd><strong>x</strong> contains the xfrm_state.
Authorize deletion of x-&gt;security.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_policy_lookup</span></code></dt>
<dd><strong>ctx</strong> contains the xfrm_sec_ctx for which the access control is being
checked.
<strong>fl_secid</strong> contains the flow security label that is used to authorize
access to the policy xp.
<strong>dir</strong> contains the direction of the flow (input or output).
Check permission when a flow selects a xfrm_policy for processing
XFRMs on a packet.  The hook is called when selecting either a
per-socket policy or a generic xfrm policy.
Return 0 if permission is granted, -ESRCH otherwise, or -errno
on other errors.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_state_pol_flow_match</span></code></dt>
<dd><strong>x</strong> contains the state to match.
<strong>xp</strong> contains the policy to check for a match.
<strong>fl</strong> contains the flow to check for a match.
Return 1 if there is a match.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrm_decode_session</span></code></dt>
<dd><strong>skb</strong> points to skb to decode.
<strong>secid</strong> points to the flow key secid to set.
<strong>ckall</strong> says if all xfrms used should be checked for same secid.
Return 0 if ckall is zero or all xfrms used have the same secid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_alloc</span></code></dt>
<dd>Permit allocation of a key and assign security data. Note that key does
not have a serial number assigned at this point.
<strong>key</strong> points to the key.
<strong>flags</strong> is the allocation flags
Return 0 if permission is granted, -ve error otherwise.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_free</span></code></dt>
<dd>Notification of destruction; free security data.
<strong>key</strong> points to the key.
No return value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_permission</span></code></dt>
<dd>See whether a specific operational right is granted to a process on a
key.
<strong>key_ref</strong> refers to the key (key pointer + possession attribute bit).
<strong>cred</strong> points to the credentials to provide the context against which to
evaluate the security data on the key.
<strong>perm</strong> describes the combination of permissions required of this key.
Return 0 if permission is granted, -ve error otherwise.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_getsecurity</span></code></dt>
<dd>Get a textual representation of the security context attached to a key
for the purposes of honouring KEYCTL_GETSECURITY.  This function
allocates the storage for the NUL-terminated string and the caller
should free it.
<strong>key</strong> points to the key to be queried.
<strong>_buffer</strong> points to a pointer that should be set to point to the
resulting string (if no label or an error occurs).
Return the length of the string (including terminating NUL) or -ve if
an error.
May also return 0 (and a NULL buffer pointer) if there is no label.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audit_rule_init</span></code></dt>
<dd>Allocate and initialize an LSM audit rule structure.
<strong>field</strong> contains the required Audit action.
Fields flags are defined in &lt;include/linux/audit.h&gt;
<strong>op</strong> contains the operator the rule uses.
<strong>rulestr</strong> contains the context where the rule will be applied to.
<strong>lsmrule</strong> contains a pointer to receive the result.
Return 0 if <strong>lsmrule</strong> has been successfully set,
-EINVAL in case of an invalid rule.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audit_rule_known</span></code></dt>
<dd>Specifies whether given <strong>krule</strong> contains any fields related to
current LSM.
<strong>krule</strong> contains the audit rule of interest.
Return 1 in case of relation found, 0 otherwise.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audit_rule_match</span></code></dt>
<dd>Determine if given <strong>secid</strong> matches a rule previously approved
by <strong>audit_rule_known</strong>.
<strong>secid</strong> contains the security id in question.
<strong>field</strong> contains the field which relates to current LSM.
<strong>op</strong> contains the operator that will be used for matching.
<strong>lrule</strong> points to the audit rule that will be checked against.
Return 1 if secid matches the rule, 0 if it does not, -ERRNO on failure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audit_rule_free</span></code></dt>
<dd>Deallocate the LSM audit rule structure previously allocated by
audit_rule_init.
<strong>lsmrule</strong> contains the allocated rule</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf</span></code></dt>
<dd>Do a initial check for all bpf syscalls after the attribute is copied
into the kernel. The actual security module can implement their own
rules to check the specific cmd they need.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_map</span></code></dt>
<dd>Do a check when the kernel generate and return a file descriptor for
eBPF maps.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_prog</span></code></dt>
<dd>Do a check when the kernel generate and return a file descriptor for
eBPF programs.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_map_alloc_security</span></code></dt>
<dd>Initialize the security field inside bpf map.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_map_free_security</span></code></dt>
<dd>Clean up the security information stored inside bpf map.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_prog_alloc_security</span></code></dt>
<dd>Initialize the security field inside bpf program.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_prog_free_security</span></code></dt>
<dd>Clean up the security information stored inside bpf prog.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Security hooks for program execution operations.</p>
<dl class="docutils">
<dt>Security hooks for mount using fs_context.</dt>
<dd>[See also Documentation/filesystems/mount_api.txt]</dd>
</dl>
<p>Security hooks for filesystem operations.</p>
<p>Security hooks for inode operations.</p>
<p>Security hooks for kernfs node operations</p>
<blockquote>
<div><strong>kn_dir</strong> the parent kernfs node
<strong>kn</strong> the new child kernfs node</div></blockquote>
<p>Security hooks for file operations</p>
<p>Security hooks for task operations.</p>
<p>Security hooks for Netlink messaging.</p>
<p>Security hooks for Unix domain networking.</p>
<p>The <strong>unix_stream_connect</strong> and <strong>unix_may_send</strong> hooks were necessary because
Linux provides an alternative to the conventional file name space for Unix
domain sockets.  Whereas binding and connecting to sockets in the file name
space is mediated by the typical file permissions (and caught by the mknod
and permission hooks in inode_security_ops), binding and connecting to
sockets in the abstract name space is completely unmediated.  Sufficient
control of Unix domain sockets in the abstract name space isn’t possible
using only the socket layer hooks, since we need to know the actual target
socket, which is not looked up until we are inside the af_unix code.</p>
<p>Security hooks for socket operations.</p>
<p>Security hooks for SCTP</p>
<p>Security hooks for Infiniband</p>
<p>Security hooks for XFRM operations.</p>
<p>Security hooks affecting all Key Management operations</p>
<p>Security hooks affecting all System V IPC operations.</p>
<p>Security hooks for individual messages held in System V IPC message queues
Security hooks for System V IPC Message Queues</p>
<p>Security hooks for System V Shared Memory Segments</p>
<p>Security hooks for System V Semaphores</p>
<p>Security hooks for Audit</p>
<p>Security hooks for using the eBPF maps and programs functionalities through
eBPF syscalls.</p>
<dl class="docutils">
<dt><strong>locked_down</strong></dt>
<dd>Determine whether a kernel feature that potentially enables arbitrary
code execution in kernel space should be permitted.</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sak.html" class="btn btn-neutral float-right" title="Linux Secure Attention Key (SAK) handling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lsm.html" class="btn btn-neutral float-left" title="Linux Security Modules: General Security Hooks for Linux" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>