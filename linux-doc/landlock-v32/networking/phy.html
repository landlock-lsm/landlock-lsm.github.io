

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>PHY Abstraction Layer &mdash; The Linux Kernel 5.12.0-rc3+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="phylink" href="sfp-phylink.html" />
    <link rel="prev" title="Page Pool API" href="page_pool.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.12.0-rc3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="netdev-FAQ.html">netdev FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="bareudp.html">Bare UDP Tunnelling Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_drivers/index.html">Hardware Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsa/index.html">Distributed Switch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devlink/index.html">Linux Devlink Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="caif/index.html">CAIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool-netlink.html">Netlink interface for ethtool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ieee802154.html">IEEE 802.15.4 Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="j1939.html">J1939 Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_dim.html">Net DIM - Generic Network Dynamic Interrupt Moderation</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_pool.html">Page Pool API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">PHY Abstraction Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-mdio-bus">The MDIO bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rg-mii-electrical-interface-considerations">(RG)MII/electrical interface considerations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-problems-with-rgmii-delay-mismatch">Common problems with RGMII delay mismatch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-to-a-phy">Connecting to a PHY</a></li>
<li class="toctree-l3"><a class="reference internal" href="#letting-the-phy-abstraction-layer-do-everything">Letting the PHY Abstraction Layer do Everything</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phy-interface-modes">PHY interface modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pause-frames-flow-control">Pause frames / flow control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#keeping-close-tabs-on-the-pal">Keeping Close Tabs on the PAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#doing-it-all-yourself">Doing it all yourself</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phy-device-drivers">PHY Device Drivers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generic-phy-driver">Generic PHY driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-a-phy-driver">Writing a PHY driver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#board-fixups">Board Fixups</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standards">Standards</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sfp-phylink.html">phylink</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
<li class="toctree-l2"><a class="reference internal" href="snmp_counter.html">SNMP counter</a></li>
<li class="toctree-l2"><a class="reference internal" href="checksum-offloads.html">Checksum Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmentation-offloads.html">Segmentation Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="scaling.html">Scaling in the Linux Networking Stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Kernel TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls-offload.html">Kernel TLS offload</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc.html">Linux NFC subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="6lowpan.html">Netdev private dataroom for 6lowpan interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="6pack.html">6pack Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet-hardware.html">ARCnet Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet.html">ARCnet</a></li>
<li class="toctree-l2"><a class="reference internal" href="atm.html">ATM</a></li>
<li class="toctree-l2"><a class="reference internal" href="ax25.html">AX.25</a></li>
<li class="toctree-l2"><a class="reference internal" href="bonding.html">Linux Ethernet Bonding Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="cdc_mbim.html">cdc_mbim - Driver for CDC MBIM Mobile Broadband modems</a></li>
<li class="toctree-l2"><a class="reference internal" href="dccp.html">DCCP protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="dctcp.html">DCTCP (DataCenter TCP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="decnet.html">Linux DECnet Networking Layer Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="dns_resolver.html">DNS Resolver Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html">Softnet Driver Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="eql.html">EQL Driver: Serial IP Load Balancing HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="fib_trie.html">LC-trie implementation notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="filter.html">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-hdlc.html">Generic HDLC layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_netlink.html">Generic Netlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_stats.html">Generic networking statistics for netlink users</a></li>
<li class="toctree-l2"><a class="reference internal" href="gtp.html">The Linux kernel GTP tunneling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ila.html">Identifier Locator Addressing (ILA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipddp.html">AppleTalk-IP Decapsulation and AppleTalk-IP Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_dynaddr.html">IP dynamic address hack-port v0.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec.html">IPsec</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip-sysctl.html">IP Sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipv6.html">IPv6</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvlan.html">IPVLAN Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvs-sysctl.html">IPvs-sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcm.html">Kernel Connection Multiplexor</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2tp.html">L2TP</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapb-module.html">The Linux LAPB Module Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mac80211-injection.html">How to use packet injection with mac80211</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpls-sysctl.html">MPLS Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="mptcp-sysctl.html">MPTCP Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiqueue.html">HOWTO for multiqueue network device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="netconsole.html">Netconsole</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdev-features.html">Netdev features mess and how to get out from it alive</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdevices.html">Network Devices, the Kernel, and You!</a></li>
<li class="toctree-l2"><a class="reference internal" href="netfilter-sysctl.html">Netfilter Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="netif-msg.html">NETIF Msg Level</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_conntrack-sysctl.html">Netfilter Conntrack Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_flowtable.html">Netfilter’s flowtable infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="openvswitch.html">Open vSwitch datapath developer documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="operstates.html">Operational States</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_mmap.html">Packet MMAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="phonet.html">Linux Phonet protocol family</a></li>
<li class="toctree-l2"><a class="reference internal" href="pktgen.html">HOWTO for the linux packet generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="plip.html">PLIP: The Parallel Line Internet Protocol Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="ppp_generic.html">PPP Generic Driver and Channel Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="proc_net_tcp.html">The proc/net/tcp and proc/net/tcp6 variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="radiotap-headers.html">How to use radiotap headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#rds-architecture">RDS Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#socket-interface">Socket Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#rdma-for-rds">RDMA for RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#congestion-notifications">Congestion Notifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#rds-protocol">RDS Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#rds-transport-layer">RDS Transport Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#rds-kernel-structures">RDS Kernel Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#connection-management">Connection management</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#the-send-path">The send path</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#the-recv-path">The recv path</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html#multipath-rds-mprds">Multipath RDS (mprds)</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulatory.html">Linux wireless regulatory documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html">RxRPC Network Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#socket-options">SOCKET OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#security">SECURITY</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#example-client-usage">EXAMPLE CLIENT USAGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="sctp.html">Linux Kernel SCTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="secid.html">LSM/SeLinux secid</a></li>
<li class="toctree-l2"><a class="reference internal" href="seg6-sysctl.html">Seg6 Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="statistics.html">Interface statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="strparser.html">Stream Parser (strparser)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchdev.html">Ethernet switch device driver model (switchdev)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysfs-tagging.html">Sysfs tagging</a></li>
<li class="toctree-l2"><a class="reference internal" href="tc-actions-env-rules.html">TC Actions - Environmental Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcp-thin.html">Thin-streams and TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="team.html">Team</a></li>
<li class="toctree-l2"><a class="reference internal" href="timestamping.html">Timestamping</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipc.html">Linux Kernel TIPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="tproxy.html">Transparent proxy support</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuntap.html">Universal TUN/TAP device driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="udplite.html">The UDP-Lite protocol (RFC 3828)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vrf.html">Virtual Routing and Forwarding (VRF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vxlan.html">Virtual eXtensible Local Area Networking documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html">Packet Layer to Device Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html#device-driver-to-packet-layer">Device Driver to Packet Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25.html">Linux X.25 Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_device.html">XFRM device - offloading the IPsec computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_proc.html">XFRM proc - /proc/net/xfrm_* files</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sync.html">XFRM</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sysctl.html">XFRM Syscall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>PHY Abstraction Layer</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/networking/phy.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="phy-abstraction-layer">
<h1>PHY Abstraction Layer<a class="headerlink" href="#phy-abstraction-layer" title="Permalink to this headline">¶</a></h1>
<div class="section" id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h2>
<p>Most network devices consist of set of registers which provide an interface
to a MAC layer, which communicates with the physical connection through a
PHY.  The PHY concerns itself with negotiating link parameters with the link
partner on the other side of the network connection (typically, an ethernet
cable), and provides a register interface to allow drivers to determine what
settings were chosen, and to configure what settings are allowed.</p>
<p>While these devices are distinct from the network devices, and conform to a
standard layout for the registers, it has been common practice to integrate
the PHY management code with the network driver.  This has resulted in large
amounts of redundant code.  Also, on embedded systems with multiple (and
sometimes quite different) ethernet controllers connected to the same
management bus, it is difficult to ensure safe use of the bus.</p>
<p>Since the PHYs are devices, and the management busses through which they are
accessed are, in fact, busses, the PHY Abstraction Layer treats them as such.
In doing so, it has these goals:</p>
<ol class="arabic simple">
<li><p>Increase code-reuse</p></li>
<li><p>Increase overall code-maintainability</p></li>
<li><p>Speed development time for new network drivers, and for new systems</p></li>
</ol>
<p>Basically, this layer is meant to provide an interface to PHY devices which
allows network driver writers to write as little code as possible, while
still providing a full feature set.</p>
</div>
<div class="section" id="the-mdio-bus">
<h2>The MDIO bus<a class="headerlink" href="#the-mdio-bus" title="Permalink to this headline">¶</a></h2>
<p>Most network devices are connected to a PHY by means of a management bus.
Different devices use different busses (though some share common interfaces).
In order to take advantage of the PAL, each bus interface needs to be
registered as a distinct device.</p>
<ol class="arabic">
<li><p>read and write functions must be implemented. Their prototypes are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int write(struct mii_bus *bus, int mii_id, int regnum, u16 value);
int read(struct mii_bus *bus, int mii_id, int regnum);
</pre></div>
</div>
<p>mii_id is the address on the bus for the PHY, and regnum is the register
number.  These functions are guaranteed not to be called from interrupt
time, so it is safe for them to block, waiting for an interrupt to signal
the operation is complete</p>
</li>
<li><p>A reset function is optional. This is used to return the bus to an
initialized state.</p></li>
<li><p>A probe function is needed.  This function should set up anything the bus
driver needs, setup the mii_bus structure, and register with the PAL using
mdiobus_register.  Similarly, there’s a remove function to undo all of
that (use mdiobus_unregister).</p></li>
<li><p>Like any driver, the device_driver structure must be configured, and init
exit functions are used to register the driver.</p></li>
<li><p>The bus must also be declared somewhere as a device, and registered.</p></li>
</ol>
<p>As an example for how one driver implemented an mdio bus driver, see
drivers/net/ethernet/freescale/fsl_pq_mdio.c and an associated DTS file
for one of the users. (e.g. “git grep fsl,.*-mdio arch/powerpc/boot/dts/”)</p>
</div>
<div class="section" id="rg-mii-electrical-interface-considerations">
<h2>(RG)MII/electrical interface considerations<a class="headerlink" href="#rg-mii-electrical-interface-considerations" title="Permalink to this headline">¶</a></h2>
<p>The Reduced Gigabit Medium Independent Interface (RGMII) is a 12-pin
electrical signal interface using a synchronous 125Mhz clock signal and several
data lines. Due to this design decision, a 1.5ns to 2ns delay must be added
between the clock line (RXC or TXC) and the data lines to let the PHY (clock
sink) have a large enough setup and hold time to sample the data lines correctly. The
PHY library offers different types of PHY_INTERFACE_MODE_RGMII* values to let
the PHY driver and optionally the MAC driver, implement the required delay. The
values of phy_interface_t must be understood from the perspective of the PHY
device itself, leading to the following:</p>
<ul class="simple">
<li><p>PHY_INTERFACE_MODE_RGMII: the PHY is not responsible for inserting any
internal delay by itself, it assumes that either the Ethernet MAC (if capable
or the PCB traces) insert the correct 1.5-2ns delay</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_TXID: the PHY should insert an internal delay
for the transmit data lines (TXD[3:0]) processed by the PHY device</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_RXID: the PHY should insert an internal delay
for the receive data lines (RXD[3:0]) processed by the PHY device</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_ID: the PHY should insert internal delays for
both transmit AND receive data lines from/to the PHY device</p></li>
</ul>
<p>Whenever possible, use the PHY side RGMII delay for these reasons:</p>
<ul class="simple">
<li><p>PHY devices may offer sub-nanosecond granularity in how they allow a
receiver/transmitter side delay (e.g: 0.5, 1.0, 1.5ns) to be specified. Such
precision may be required to account for differences in PCB trace lengths</p></li>
<li><p>PHY devices are typically qualified for a large range of applications
(industrial, medical, automotive…), and they provide a constant and
reliable delay across temperature/pressure/voltage ranges</p></li>
<li><p>PHY device drivers in PHYLIB being reusable by nature, being able to
configure correctly a specified delay enables more designs with similar delay
requirements to be operate correctly</p></li>
</ul>
<p>For cases where the PHY is not capable of providing this delay, but the
Ethernet MAC driver is capable of doing so, the correct phy_interface_t value
should be PHY_INTERFACE_MODE_RGMII, and the Ethernet MAC driver should be
configured correctly in order to provide the required transmit and/or receive
side delay from the perspective of the PHY device. Conversely, if the Ethernet
MAC driver looks at the phy_interface_t value, for any other mode but
PHY_INTERFACE_MODE_RGMII, it should make sure that the MAC-level delays are
disabled.</p>
<p>In case neither the Ethernet MAC, nor the PHY are capable of providing the
required delays, as defined per the RGMII standard, several options may be
available:</p>
<ul class="simple">
<li><p>Some SoCs may offer a pin pad/mux/controller capable of configuring a given
set of pins’strength, delays, and voltage; and it may be a suitable
option to insert the expected 2ns RGMII delay.</p></li>
<li><p>Modifying the PCB design to include a fixed delay (e.g: using a specifically
designed serpentine), which may not require software configuration at all.</p></li>
</ul>
<div class="section" id="common-problems-with-rgmii-delay-mismatch">
<h3>Common problems with RGMII delay mismatch<a class="headerlink" href="#common-problems-with-rgmii-delay-mismatch" title="Permalink to this headline">¶</a></h3>
<p>When there is a RGMII delay mismatch between the Ethernet MAC and the PHY, this
will most likely result in the clock and data line signals to be unstable when
the PHY or MAC take a snapshot of these signals to translate them into logical
1 or 0 states and reconstruct the data being transmitted/received. Typical
symptoms include:</p>
<ul class="simple">
<li><p>Transmission/reception partially works, and there is frequent or occasional
packet loss observed</p></li>
<li><p>Ethernet MAC may report some or all packets ingressing with a FCS/CRC error,
or just discard them all</p></li>
<li><p>Switching to lower speeds such as 10/100Mbits/sec makes the problem go away
(since there is enough setup/hold time in that case)</p></li>
</ul>
</div>
</div>
<div class="section" id="connecting-to-a-phy">
<h2>Connecting to a PHY<a class="headerlink" href="#connecting-to-a-phy" title="Permalink to this headline">¶</a></h2>
<p>Sometime during startup, the network driver needs to establish a connection
between the PHY device, and the network device.  At this time, the PHY’s bus
and drivers need to all have been loaded, so it is ready for the connection.
At this point, there are several ways to connect to the PHY:</p>
<ol class="arabic simple">
<li><p>The PAL handles everything, and only calls the network driver when
the link state changes, so it can react.</p></li>
<li><p>The PAL handles everything except interrupts (usually because the
controller has the interrupt registers).</p></li>
<li><p>The PAL handles everything, but checks in with the driver every second,
allowing the network driver to react first to any changes before the PAL
does.</p></li>
<li><p>The PAL serves only as a library of functions, with the network device
manually calling functions to update status, and configure the PHY</p></li>
</ol>
</div>
<div class="section" id="letting-the-phy-abstraction-layer-do-everything">
<h2>Letting the PHY Abstraction Layer do Everything<a class="headerlink" href="#letting-the-phy-abstraction-layer-do-everything" title="Permalink to this headline">¶</a></h2>
<p>If you choose option 1 (The hope is that every driver can, but to still be
useful to drivers that can’t), connecting to the PHY is simple:</p>
<p>First, you need a function to react to changes in the link state.  This
function follows this protocol:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void adjust_link(struct net_device *dev);
</pre></div>
</div>
<p>Next, you need to know the device name of the PHY connected to this device.
The name will look something like, “0:00”, where the first number is the
bus id, and the second is the PHY’s address on that bus.  Typically,
the bus is responsible for making its ID unique.</p>
<p>Now, to connect, just call this function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>phydev = phy_connect(dev, phy_name, &amp;adjust_link, interface);
</pre></div>
</div>
<p><em>phydev</em> is a pointer to the phy_device structure which represents the PHY.
If phy_connect is successful, it will return the pointer.  dev, here, is the
pointer to your net_device.  Once done, this function will have started the
PHY’s software state machine, and registered for the PHY’s interrupt, if it
has one.  The phydev structure will be populated with information about the
current state, though the PHY will not yet be truly operational at this
point.</p>
<p>PHY-specific flags should be set in phydev-&gt;dev_flags prior to the call
to <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> such that the underlying PHY driver can check for flags
and perform specific operations based on them.
This is useful if the system has put hardware restrictions on
the PHY/controller, of which the PHY needs to be aware.</p>
<p><em>interface</em> is a u32 which specifies the connection type used
between the controller and the PHY.  Examples are GMII, MII,
RGMII, and SGMII.  See “PHY interface mode” below.  For a full
list, see include/linux/phy.h</p>
<p>Now just make sure that phydev-&gt;supported and phydev-&gt;advertising have any
values pruned from them which don’t make sense for your controller (a 10/100
controller may be connected to a gigabit capable PHY, so you would need to
mask off SUPPORTED_1000baseT*).  See include/linux/ethtool.h for definitions
for these bitfields. Note that you should not SET any bits, except the
SUPPORTED_Pause and SUPPORTED_AsymPause bits (see below), or the PHY may get
put into an unsupported state.</p>
<p>Lastly, once the controller is ready to handle network traffic, you call
phy_start(phydev).  This tells the PAL that you are ready, and configures the
PHY to connect to the network. If the MAC interrupt of your network driver
also handles PHY status changes, just set phydev-&gt;irq to PHY_MAC_INTERRUPT
before you call phy_start and use <a class="reference internal" href="kapi.html#c.phy_mac_interrupt" title="phy_mac_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_mac_interrupt()</span></code></a> from the network
driver. If you don’t want to use interrupts, set phydev-&gt;irq to PHY_POLL.
<a class="reference internal" href="kapi.html#c.phy_start" title="phy_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_start()</span></code></a> enables the PHY interrupts (if applicable) and starts the
phylib state machine.</p>
<p>When you want to disconnect from the network (even if just briefly), you call
phy_stop(phydev). This function also stops the phylib state machine and
disables PHY interrupts.</p>
</div>
<div class="section" id="phy-interface-modes">
<h2>PHY interface modes<a class="headerlink" href="#phy-interface-modes" title="Permalink to this headline">¶</a></h2>
<p>The PHY interface mode supplied in the <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> family of functions
defines the initial operating mode of the PHY interface.  This is not
guaranteed to remain constant; there are PHYs which dynamically change
their interface mode without software interaction depending on the
negotiation results.</p>
<p>Some of the interface modes are described below:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEX</span></code></dt><dd><p>This defines the 1000BASE-X single-lane serdes link as defined by the
802.3 standard section 36.  The link operates at a fixed bit rate of
1.25Gbaud using a 10B/8B encoding scheme, resulting in an underlying
data rate of 1Gbps.  Embedded in the data stream is a 16-bit control
word which is used to negotiate the duplex and pause modes with the
remote end.  This does not include “up-clocked” variants such as 2.5Gbps
speeds (see below.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_2500BASEX</span></code></dt><dd><p>This defines a variant of 1000BASE-X which is clocked 2.5 times as fast
as the 802.3 standard, giving a fixed bit rate of 3.125Gbaud.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_SGMII</span></code></dt><dd><p>This is used for Cisco SGMII, which is a modification of 1000BASE-X
as defined by the 802.3 standard.  The SGMII link consists of a single
serdes lane running at a fixed bit rate of 1.25Gbaud with 10B/8B
encoding.  The underlying data rate is 1Gbps, with the slower speeds of
100Mbps and 10Mbps being achieved through replication of each data symbol.
The 802.3 control word is re-purposed to send the negotiated speed and
duplex information from to the MAC, and for the MAC to acknowledge
receipt.  This does not include “up-clocked” variants such as 2.5Gbps
speeds.</p>
<p>Note: mismatched SGMII vs 1000BASE-X configuration on a link can
successfully pass data in some circumstances, but the 16-bit control
word will not be correctly interpreted, which may cause mismatches in
duplex, pause or other settings.  This is dependent on the MAC and/or
PHY behaviour.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_5GBASER</span></code></dt><dd><p>This is the IEEE 802.3 Clause 129 defined 5GBASE-R protocol. It is
identical to the 10GBASE-R protocol defined in Clause 49, with the
exception that it operates at half the frequency. Please refer to the
IEEE standard for the definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GBASER</span></code></dt><dd><p>This is the IEEE 802.3 Clause 49 defined 10GBASE-R protocol used with
various different mediums. Please refer to the IEEE standard for a
definition of this.</p>
<p>Note: 10GBASE-R is just one protocol that can be used with XFI and SFI.
XFI and SFI permit multiple protocols over a single SERDES lane, and
also defines the electrical characteristics of the signals with a host
compliance board plugged into the host XFP/SFP connector. Therefore,
XFI and SFI are not PHY interface types in their own right.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GKR</span></code></dt><dd><p>This is the IEEE 802.3 Clause 49 defined 10GBASE-R with Clause 73
autonegotiation. Please refer to the IEEE standard for further
information.</p>
<p>Note: due to legacy usage, some 10GBASE-R usage incorrectly makes
use of this definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_100BASEX</span></code></dt><dd><p>This defines IEEE 802.3 Clause 24.  The link operates at a fixed data
rate of 125Mpbs using a 4B/5B encoding scheme, resulting in an underlying
data rate of 100Mpbs.</p>
</dd>
</dl>
</div>
<div class="section" id="pause-frames-flow-control">
<h2>Pause frames / flow control<a class="headerlink" href="#pause-frames-flow-control" title="Permalink to this headline">¶</a></h2>
<p>The PHY does not participate directly in flow control/pause frames except by
making sure that the SUPPORTED_Pause and SUPPORTED_AsymPause bits are set in
MII_ADVERTISE to indicate towards the link partner that the Ethernet MAC
controller supports such a thing. Since flow control/pause frames generation
involves the Ethernet MAC driver, it is recommended that this driver takes care
of properly indicating advertisement and support for such features by setting
the SUPPORTED_Pause and SUPPORTED_AsymPause bits accordingly. This can be done
either before or after <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> and/or as a result of implementing the
ethtool::set_pauseparam feature.</p>
</div>
<div class="section" id="keeping-close-tabs-on-the-pal">
<h2>Keeping Close Tabs on the PAL<a class="headerlink" href="#keeping-close-tabs-on-the-pal" title="Permalink to this headline">¶</a></h2>
<p>It is possible that the PAL’s built-in state machine needs a little help to
keep your network device and the PHY properly in sync.  If so, you can
register a helper function when connecting to the PHY, which will be called
every second before the state machine reacts to any changes.  To do this, you
need to manually call <a class="reference internal" href="kapi.html#c.phy_attach" title="phy_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach()</span></code></a> and <a class="reference internal" href="kapi.html#c.phy_prepare_link" title="phy_prepare_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_prepare_link()</span></code></a>, and then call
<a class="reference internal" href="kapi.html#c.phy_start_machine" title="phy_start_machine"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_start_machine()</span></code></a> with the second argument set to point to your special
handler.</p>
<p>Currently there are no examples of how to use this functionality, and testing
on it has been limited because the author does not have any drivers which use
it (they all use option 1).  So Caveat Emptor.</p>
</div>
<div class="section" id="doing-it-all-yourself">
<h2>Doing it all yourself<a class="headerlink" href="#doing-it-all-yourself" title="Permalink to this headline">¶</a></h2>
<p>There’s a remote chance that the PAL’s built-in state machine cannot track
the complex interactions between the PHY and your network device.  If this is
so, you can simply call <a class="reference internal" href="kapi.html#c.phy_attach" title="phy_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach()</span></code></a>, and not call phy_start_machine or
<a class="reference internal" href="kapi.html#c.phy_prepare_link" title="phy_prepare_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_prepare_link()</span></code></a>.  This will mean that phydev-&gt;state is entirely yours to
handle (phy_start and phy_stop toggle between some of the states, so you
might need to avoid them).</p>
<p>An effort has been made to make sure that useful functionality can be
accessed without the state-machine running, and most of these functions are
descended from functions which did not interact with a complex state-machine.
However, again, no effort has been made so far to test running without the
state machine, so tryer beware.</p>
<p>Here is a brief rundown of the functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_read(struct phy_device *phydev, u16 regnum);
int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
</pre></div>
</div>
<p>Simple read/write primitives.  They invoke the bus’s read/write function
pointers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void phy_print_status(struct phy_device *phydev);
</pre></div>
</div>
<p>A convenience function to print out the PHY status neatly.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void phy_request_interrupt(struct phy_device *phydev);
</pre></div>
</div>
<p>Requests the IRQ for the PHY interrupts.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_device * phy_attach(struct net_device *dev, const char *phy_id,
                               phy_interface_t interface);
</pre></div>
</div>
<p>Attaches a network device to a particular PHY, binding the PHY to a generic
driver if none was found during bus initialization.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_start_aneg(struct phy_device *phydev);
</pre></div>
</div>
<p>Using variables inside the phydev structure, either configures advertising
and resets autonegotiation, or disables autonegotiation, and configures
forced settings.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int phy_read_status(struct phy_device *phydev);
</pre></div>
</div>
<p>Fills the phydev structure with up-to-date information about the current
settings in the PHY.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_ethtool_ksettings_set(struct phy_device *phydev,
                              const struct ethtool_link_ksettings *cmd);
</pre></div>
</div>
<p>Ethtool convenience functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_mii_ioctl(struct phy_device *phydev,
                  struct mii_ioctl_data *mii_data, int cmd);
</pre></div>
</div>
<p>The MII ioctl.  Note that this function will completely screw up the state
machine if you write registers like BMCR, BMSR, ADVERTISE, etc.  Best to
use this only to write registers which are not standard, and don’t set off
a renegotiation.</p>
</div>
<div class="section" id="phy-device-drivers">
<h2>PHY Device Drivers<a class="headerlink" href="#phy-device-drivers" title="Permalink to this headline">¶</a></h2>
<p>With the PHY Abstraction Layer, adding support for new PHYs is
quite easy. In some cases, no work is required at all! However,
many PHYs require a little hand-holding to get up-and-running.</p>
<div class="section" id="generic-phy-driver">
<h3>Generic PHY driver<a class="headerlink" href="#generic-phy-driver" title="Permalink to this headline">¶</a></h3>
<p>If the desired PHY doesn’t have any errata, quirks, or special
features you want to support, then it may be best to not add
support, and let the PHY Abstraction Layer’s Generic PHY Driver
do all of the work.</p>
</div>
<div class="section" id="writing-a-phy-driver">
<h3>Writing a PHY driver<a class="headerlink" href="#writing-a-phy-driver" title="Permalink to this headline">¶</a></h3>
<p>If you do need to write a PHY driver, the first thing to do is
make sure it can be matched with an appropriate PHY device.
This is done during bus initialization by reading the device’s
UID (stored in registers 2 and 3), then comparing it to each
driver’s phy_id field by ANDing it with each driver’s
phy_id_mask field.  Also, it needs a name.  Here’s an example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct phy_driver dm9161_driver = {
      .phy_id         = 0x0181b880,
      .name           = &quot;Davicom DM9161E&quot;,
      .phy_id_mask    = 0x0ffffff0,
      ...
}
</pre></div>
</div>
<p>Next, you need to specify what features (speed, duplex, autoneg,
etc) your PHY device and driver support.  Most PHYs support
PHY_BASIC_FEATURES, but you can look in include/mii.h for other
features.</p>
<p>Each driver consists of a number of function pointers, documented
in include/linux/phy.h under the phy_driver structure.</p>
<p>Of these, only config_aneg and read_status are required to be
assigned by the driver code.  The rest are optional.  Also, it is
preferred to use the generic phy driver’s versions of these two
functions if at all possible: genphy_read_status and
genphy_config_aneg.  If this is not possible, it is likely that
you only need to perform some actions before and after invoking
these functions, and so your functions will wrap the generic
ones.</p>
<p>Feel free to look at the Marvell, Cicada, and Davicom drivers in
drivers/net/phy/ for examples (the lxt and qsemi drivers have
not been tested as of this writing).</p>
<p>The PHY’s MMD register accesses are handled by the PAL framework
by default, but can be overridden by a specific PHY driver if
required. This could be the case if a PHY was released for
manufacturing before the MMD PHY register definitions were
standardized by the IEEE. Most modern PHYs will be able to use
the generic PAL framework for accessing the PHY’s MMD registers.
An example of such usage is for Energy Efficient Ethernet support,
implemented in the PAL. This support uses the PAL to access MMD
registers for EEE query and configuration if the PHY supports
the IEEE standard access mechanisms, or can use the PHY’s specific
access interfaces if overridden by the specific PHY driver. See
the Micrel driver in drivers/net/phy/ for an example of how this
can be implemented.</p>
</div>
</div>
<div class="section" id="board-fixups">
<h2>Board Fixups<a class="headerlink" href="#board-fixups" title="Permalink to this headline">¶</a></h2>
<p>Sometimes the specific interaction between the platform and the PHY requires
special handling.  For instance, to change where the PHY’s clock input is,
or to add a delay to account for latency issues in the data path.  In order
to support such contingencies, the PHY Layer allows platform code to register
fixups to be run when the PHY is brought up (or subsequently reset).</p>
<p>When the PHY Layer brings up a PHY it checks to see if there are any fixups
registered for it, matching based on UID (contained in the PHY device’s phy_id
field) and the bus identifier (contained in phydev-&gt;dev.bus_id).  Both must
match, however two constants, PHY_ANY_ID and PHY_ANY_UID, are provided as
wildcards for the bus ID and UID, respectively.</p>
<p>When a match is found, the PHY layer will invoke the run function associated
with the fixup.  This function is passed a pointer to the phy_device of
interest.  It should therefore only operate on that PHY.</p>
<p>The platform code can either register the fixup using <a class="reference internal" href="kapi.html#c.phy_register_fixup" title="phy_register_fixup"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_register_fixup()</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_register_fixup(const char *phy_id,
        u32 phy_uid, u32 phy_uid_mask,
        int (*run)(struct phy_device *));
</pre></div>
</div>
<p>Or using one of the two stubs, phy_register_fixup_for_uid() and
phy_register_fixup_for_id():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
               int (*run)(struct phy_device *));
int phy_register_fixup_for_id(const char *phy_id,
               int (*run)(struct phy_device *));
</pre></div>
</div>
<p>The stubs set one of the two matching criteria, and set the other one to
match anything.</p>
<p>When <a class="reference internal" href="kapi.html#c.phy_register_fixup" title="phy_register_fixup"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_register_fixup()</span></code></a> or *_for_uid()/*_for_id() is called at module load
time, the module needs to unregister the fixup and free allocated memory when
it’s unloaded.</p>
<p>Call one of following function before unloading module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_unregister_fixup(const char *phy_id, u32 phy_uid, u32 phy_uid_mask);
int phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask);
int phy_register_fixup_for_id(const char *phy_id);
</pre></div>
</div>
</div>
<div class="section" id="standards">
<h2>Standards<a class="headerlink" href="#standards" title="Permalink to this headline">¶</a></h2>
<p>IEEE Standard 802.3: CSMA/CD Access Method and Physical Layer Specifications, Section Two:
<a class="reference external" href="http://standards.ieee.org/getieee802/download/802.3-2008_section2.pdf">http://standards.ieee.org/getieee802/download/802.3-2008_section2.pdf</a></p>
<p>RGMII v1.3:
<a class="reference external" href="http://web.archive.org/web/20160303212629/http://www.hp.com/rnd/pdfs/RGMIIv1_3.pdf">http://web.archive.org/web/20160303212629/http://www.hp.com/rnd/pdfs/RGMIIv1_3.pdf</a></p>
<p>RGMII v2.0:
<a class="reference external" href="http://web.archive.org/web/20160303171328/http://www.hp.com/rnd/pdfs/RGMIIv2_0_final_hp.pdf">http://web.archive.org/web/20160303171328/http://www.hp.com/rnd/pdfs/RGMIIv2_0_final_hp.pdf</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="sfp-phylink.html" class="btn btn-neutral float-right" title="phylink" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="page_pool.html" class="btn btn-neutral float-left" title="Page Pool API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>