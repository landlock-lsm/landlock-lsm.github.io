

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Filesystem-level encryption (fscrypt) &mdash; The Linux Kernel 5.10.0-rc1+ documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="fs-verity: read-only file-based authenticity protection" href="fsverity.html" />
    <link rel="prev" title="The Linux Journalling API" href="journalling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="journalling.html">The Linux Journalling API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Filesystem-level encryption (fscrypt)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#threat-model">Threat model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-hierarchy">Key hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-modes-and-usage">Encryption modes and usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-api">User API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-semantics">Access semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-policy-enforcement">Encryption policy enforcement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-details">Implementation details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="fsverity.html">fs-verity: read-only file-based authenticity protection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystems">Filesystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>Filesystem-level encryption (fscrypt)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/fscrypt.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="filesystem-level-encryption-fscrypt">
<h1>Filesystem-level encryption (fscrypt)<a class="headerlink" href="#filesystem-level-encryption-fscrypt" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>fscrypt is a library which filesystems can hook into to support
transparent encryption of files and directories.</p>
<p>Note: “fscrypt” in this document refers to the kernel-level portion,
implemented in <code class="docutils literal notranslate"><span class="pre">fs/crypto/</span></code>, as opposed to the userspace tool
<a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  This document only
covers the kernel-level portion.  For command-line examples of how to
use encryption, see the documentation for the userspace tool <a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  Also, it is recommended to use
the fscrypt userspace tool, or other existing userspace tools such as
<a class="reference external" href="https://github.com/google/fscryptctl">fscryptctl</a> or <a class="reference external" href="https://source.android.com/security/encryption/file-based">Android’s key
management system</a>, over
using the kernel’s API directly.  Using existing tools reduces the
chance of introducing your own security bugs.  (Nevertheless, for
completeness this documentation covers the kernel’s API anyway.)</p>
<p>Unlike dm-crypt, fscrypt operates at the filesystem level rather than
at the block device level.  This allows it to encrypt different files
with different keys and to have unencrypted files on the same
filesystem.  This is useful for multi-user systems where each user’s
data-at-rest needs to be cryptographically isolated from the others.
However, except for filenames, fscrypt does not encrypt filesystem
metadata.</p>
<p>Unlike eCryptfs, which is a stacked filesystem, fscrypt is integrated
directly into supported filesystems — currently ext4, F2FS, and
UBIFS.  This allows encrypted files to be read and written without
caching both the decrypted and encrypted pages in the pagecache,
thereby nearly halving the memory used and bringing it in line with
unencrypted files.  Similarly, half as many dentries and inodes are
needed.  eCryptfs also limits encrypted filenames to 143 bytes,
causing application compatibility issues; fscrypt allows the full 255
bytes (NAME_MAX).  Finally, unlike eCryptfs, the fscrypt API can be
used by unprivileged users, with no need to mount anything.</p>
<p>fscrypt does not support encrypting files in-place.  Instead, it
supports marking an empty directory as encrypted.  Then, after
userspace provides the key, all regular files, directories, and
symbolic links created in that directory tree are transparently
encrypted.</p>
</div>
<div class="section" id="threat-model">
<h2>Threat model<a class="headerlink" href="#threat-model" title="Permalink to this headline">¶</a></h2>
<div class="section" id="offline-attacks">
<h3>Offline attacks<a class="headerlink" href="#offline-attacks" title="Permalink to this headline">¶</a></h3>
<p>Provided that userspace chooses a strong encryption key, fscrypt
protects the confidentiality of file contents and filenames in the
event of a single point-in-time permanent offline compromise of the
block device content.  fscrypt does not protect the confidentiality of
non-filename metadata, e.g. file sizes, file permissions, file
timestamps, and extended attributes.  Also, the existence and location
of holes (unallocated blocks which logically contain all zeroes) in
files is not protected.</p>
<p>fscrypt is not guaranteed to protect confidentiality or authenticity
if an attacker is able to manipulate the filesystem offline prior to
an authorized user later accessing the filesystem.</p>
</div>
<div class="section" id="online-attacks">
<h3>Online attacks<a class="headerlink" href="#online-attacks" title="Permalink to this headline">¶</a></h3>
<p>fscrypt (and storage encryption in general) can only provide limited
protection, if any at all, against online attacks.  In detail:</p>
<div class="section" id="side-channel-attacks">
<h4>Side-channel attacks<a class="headerlink" href="#side-channel-attacks" title="Permalink to this headline">¶</a></h4>
<p>fscrypt is only resistant to side-channel attacks, such as timing or
electromagnetic attacks, to the extent that the underlying Linux
Cryptographic API algorithms are.  If a vulnerable algorithm is used,
such as a table-based implementation of AES, it may be possible for an
attacker to mount a side channel attack against the online system.
Side channel attacks may also be mounted against applications
consuming decrypted data.</p>
</div>
<div class="section" id="unauthorized-file-access">
<h4>Unauthorized file access<a class="headerlink" href="#unauthorized-file-access" title="Permalink to this headline">¶</a></h4>
<p>After an encryption key has been added, fscrypt does not hide the
plaintext file contents or filenames from other users on the same
system.  Instead, existing access control mechanisms such as file mode
bits, POSIX ACLs, LSMs, or namespaces should be used for this purpose.</p>
<p>(For the reasoning behind this, understand that while the key is
added, the confidentiality of the data, from the perspective of the
system itself, is <em>not</em> protected by the mathematical properties of
encryption but rather only by the correctness of the kernel.
Therefore, any encryption-specific access control checks would merely
be enforced by kernel <em>code</em> and therefore would be largely redundant
with the wide variety of access control mechanisms already available.)</p>
</div>
<div class="section" id="kernel-memory-compromise">
<h4>Kernel memory compromise<a class="headerlink" href="#kernel-memory-compromise" title="Permalink to this headline">¶</a></h4>
<p>An attacker who compromises the system enough to read from arbitrary
memory, e.g. by mounting a physical attack or by exploiting a kernel
security vulnerability, can compromise all encryption keys that are
currently in use.</p>
<p>However, fscrypt allows encryption keys to be removed from the kernel,
which may protect them from later compromise.</p>
<p>In more detail, the FS_IOC_REMOVE_ENCRYPTION_KEY ioctl (or the
FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS ioctl) can wipe a master
encryption key from kernel memory.  If it does so, it will also try to
evict all cached inodes which had been “unlocked” using the key,
thereby wiping their per-file keys and making them once again appear
“locked”, i.e. in ciphertext or encrypted form.</p>
<p>However, these ioctls have some limitations:</p>
<ul class="simple">
<li><p>Per-file keys for in-use files will <em>not</em> be removed or wiped.
Therefore, for maximum effect, userspace should close the relevant
encrypted files and directories before removing a master key, as
well as kill any processes whose working directory is in an affected
encrypted directory.</p></li>
<li><p>The kernel cannot magically wipe copies of the master key(s) that
userspace might have as well.  Therefore, userspace must wipe all
copies of the master key(s) it makes as well; normally this should
be done immediately after FS_IOC_ADD_ENCRYPTION_KEY, without waiting
for FS_IOC_REMOVE_ENCRYPTION_KEY.  Naturally, the same also applies
to all higher levels in the key hierarchy.  Userspace should also
follow other security precautions such as mlock()ing memory
containing keys to prevent it from being swapped out.</p></li>
<li><p>In general, decrypted contents and filenames in the kernel VFS
caches are freed but not wiped.  Therefore, portions thereof may be
recoverable from freed memory, even after the corresponding key(s)
were wiped.  To partially solve this, you can set
CONFIG_PAGE_POISONING=y in your kernel config and add page_poison=1
to your kernel command line.  However, this has a performance cost.</p></li>
<li><p>Secret keys might still exist in CPU registers, in crypto
accelerator hardware (if used by the crypto API to implement any of
the algorithms), or in other places not explicitly considered here.</p></li>
</ul>
</div>
<div class="section" id="limitations-of-v1-policies">
<h4>Limitations of v1 policies<a class="headerlink" href="#limitations-of-v1-policies" title="Permalink to this headline">¶</a></h4>
<p>v1 encryption policies have some weaknesses with respect to online
attacks:</p>
<ul class="simple">
<li><p>There is no verification that the provided master key is correct.
Therefore, a malicious user can temporarily associate the wrong key
with another user’s encrypted files to which they have read-only
access.  Because of filesystem caching, the wrong key will then be
used by the other user’s accesses to those files, even if the other
user has the correct key in their own keyring.  This violates the
meaning of “read-only access”.</p></li>
<li><p>A compromise of a per-file key also compromises the master key from
which it was derived.</p></li>
<li><p>Non-root users cannot securely remove encryption keys.</p></li>
</ul>
<p>All the above problems are fixed with v2 encryption policies.  For
this reason among others, it is recommended to use v2 encryption
policies on all new encrypted directories.</p>
</div>
</div>
</div>
<div class="section" id="key-hierarchy">
<h2>Key hierarchy<a class="headerlink" href="#key-hierarchy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="master-keys">
<h3>Master Keys<a class="headerlink" href="#master-keys" title="Permalink to this headline">¶</a></h3>
<p>Each encrypted directory tree is protected by a <em>master key</em>.  Master
keys can be up to 64 bytes long, and must be at least as long as the
greater of the key length needed by the contents and filenames
encryption modes being used.  For example, if AES-256-XTS is used for
contents encryption, the master key must be 64 bytes (512 bits).  Note
that the XTS mode is defined to require a key twice as long as that
required by the underlying block cipher.</p>
<p>To “unlock” an encrypted directory tree, userspace must provide the
appropriate master key.  There can be any number of master keys, each
of which protects any number of directory trees on any number of
filesystems.</p>
<p>Master keys must be real cryptographic keys, i.e. indistinguishable
from random bytestrings of the same length.  This implies that users
<strong>must not</strong> directly use a password as a master key, zero-pad a
shorter key, or repeat a shorter key.  Security cannot be guaranteed
if userspace makes any such error, as the cryptographic proofs and
analysis would no longer apply.</p>
<p>Instead, users should generate master keys either using a
cryptographically secure random number generator, or by using a KDF
(Key Derivation Function).  The kernel does not do any key stretching;
therefore, if userspace derives the key from a low-entropy secret such
as a passphrase, it is critical that a KDF designed for this purpose
be used, such as scrypt, PBKDF2, or Argon2.</p>
</div>
<div class="section" id="key-derivation-function">
<h3>Key derivation function<a class="headerlink" href="#key-derivation-function" title="Permalink to this headline">¶</a></h3>
<p>With one exception, fscrypt never uses the master key(s) for
encryption directly.  Instead, they are only used as input to a KDF
(Key Derivation Function) to derive the actual keys.</p>
<p>The KDF used for a particular master key differs depending on whether
the key is used for v1 encryption policies or for v2 encryption
policies.  Users <strong>must not</strong> use the same key for both v1 and v2
encryption policies.  (No real-world attack is currently known on this
specific case of key reuse, but its security cannot be guaranteed
since the cryptographic proofs and analysis would no longer apply.)</p>
<p>For v1 encryption policies, the KDF only supports deriving per-file
encryption keys.  It works by encrypting the master key with
AES-128-ECB, using the file’s 16-byte nonce as the AES key.  The
resulting ciphertext is used as the derived key.  If the ciphertext is
longer than needed, then it is truncated to the needed length.</p>
<p>For v2 encryption policies, the KDF is HKDF-SHA512.  The master key is
passed as the “input keying material”, no salt is used, and a distinct
“application-specific information string” is used for each distinct
key to be derived.  For example, when a per-file encryption key is
derived, the application-specific information string is the file’s
nonce prefixed with “fscrypt\0” and a context byte.  Different
context bytes are used for other types of derived keys.</p>
<p>HKDF-SHA512 is preferred to the original AES-128-ECB based KDF because
HKDF is more flexible, is nonreversible, and evenly distributes
entropy from the master key.  HKDF is also standardized and widely
used by other software, whereas the AES-128-ECB based KDF is ad-hoc.</p>
</div>
<div class="section" id="per-file-encryption-keys">
<h3>Per-file encryption keys<a class="headerlink" href="#per-file-encryption-keys" title="Permalink to this headline">¶</a></h3>
<p>Since each master key can protect many files, it is necessary to
“tweak” the encryption of each file so that the same plaintext in two
files doesn’t map to the same ciphertext, or vice versa.  In most
cases, fscrypt does this by deriving per-file keys.  When a new
encrypted inode (regular file, directory, or symlink) is created,
fscrypt randomly generates a 16-byte nonce and stores it in the
inode’s encryption xattr.  Then, it uses a KDF (as described in <a class="reference internal" href="#key-derivation-function">Key
derivation function</a>) to derive the file’s key from the master key
and nonce.</p>
<p>Key derivation was chosen over key wrapping because wrapped keys would
require larger xattrs which would be less likely to fit in-line in the
filesystem’s inode table, and there didn’t appear to be any
significant advantages to key wrapping.  In particular, currently
there is no requirement to support unlocking a file with multiple
alternative master keys or to support rotating master keys.  Instead,
the master keys may be wrapped in userspace, e.g. as is done by the
<a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a> tool.</p>
</div>
<div class="section" id="direct-key-policies">
<h3>DIRECT_KEY policies<a class="headerlink" href="#direct-key-policies" title="Permalink to this headline">¶</a></h3>
<p>The Adiantum encryption mode (see <a class="reference internal" href="#encryption-modes-and-usage">Encryption modes and usage</a>) is
suitable for both contents and filenames encryption, and it accepts
long IVs — long enough to hold both an 8-byte logical block number
and a 16-byte per-file nonce.  Also, the overhead of each Adiantum key
is greater than that of an AES-256-XTS key.</p>
<p>Therefore, to improve performance and save memory, for Adiantum a
“direct key” configuration is supported.  When the user has enabled
this by setting FSCRYPT_POLICY_FLAG_DIRECT_KEY in the fscrypt policy,
per-file encryption keys are not used.  Instead, whenever any data
(contents or filenames) is encrypted, the file’s 16-byte nonce is
included in the IV.  Moreover:</p>
<ul class="simple">
<li><p>For v1 encryption policies, the encryption is done directly with the
master key.  Because of this, users <strong>must not</strong> use the same master
key for any other purpose, even for other v1 policies.</p></li>
<li><p>For v2 encryption policies, the encryption is done with a per-mode
key derived using the KDF.  Users may use the same master key for
other v2 encryption policies.</p></li>
</ul>
</div>
<div class="section" id="iv-ino-lblk-64-policies">
<h3>IV_INO_LBLK_64 policies<a class="headerlink" href="#iv-ino-lblk-64-policies" title="Permalink to this headline">¶</a></h3>
<p>When FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64 is set in the fscrypt policy,
the encryption keys are derived from the master key, encryption mode
number, and filesystem UUID.  This normally results in all files
protected by the same master key sharing a single contents encryption
key and a single filenames encryption key.  To still encrypt different
files’ data differently, inode numbers are included in the IVs.
Consequently, shrinking the filesystem may not be allowed.</p>
<p>This format is optimized for use with inline encryption hardware
compliant with the UFS standard, which supports only 64 IV bits per
I/O request and may have only a small number of keyslots.</p>
</div>
<div class="section" id="iv-ino-lblk-32-policies">
<h3>IV_INO_LBLK_32 policies<a class="headerlink" href="#iv-ino-lblk-32-policies" title="Permalink to this headline">¶</a></h3>
<p>IV_INO_LBLK_32 policies work like IV_INO_LBLK_64, except that for
IV_INO_LBLK_32, the inode number is hashed with SipHash-2-4 (where the
SipHash key is derived from the master key) and added to the file
logical block number mod 2^32 to produce a 32-bit IV.</p>
<p>This format is optimized for use with inline encryption hardware
compliant with the eMMC v5.2 standard, which supports only 32 IV bits
per I/O request and may have only a small number of keyslots.  This
format results in some level of IV reuse, so it should only be used
when necessary due to hardware limitations.</p>
</div>
<div class="section" id="key-identifiers">
<h3>Key identifiers<a class="headerlink" href="#key-identifiers" title="Permalink to this headline">¶</a></h3>
<p>For master keys used for v2 encryption policies, a unique 16-byte “key
identifier” is also derived using the KDF.  This value is stored in
the clear, since it is needed to reliably identify the key itself.</p>
</div>
<div class="section" id="dirhash-keys">
<h3>Dirhash keys<a class="headerlink" href="#dirhash-keys" title="Permalink to this headline">¶</a></h3>
<p>For directories that are indexed using a secret-keyed dirhash over the
plaintext filenames, the KDF is also used to derive a 128-bit
SipHash-2-4 key per directory in order to hash filenames.  This works
just like deriving a per-file encryption key, except that a different
KDF context is used.  Currently, only casefolded (“case-insensitive”)
encrypted directories use this style of hashing.</p>
</div>
</div>
<div class="section" id="encryption-modes-and-usage">
<h2>Encryption modes and usage<a class="headerlink" href="#encryption-modes-and-usage" title="Permalink to this headline">¶</a></h2>
<p>fscrypt allows one encryption mode to be specified for file contents
and one encryption mode to be specified for filenames.  Different
directory trees are permitted to use different encryption modes.
Currently, the following pairs of encryption modes are supported:</p>
<ul class="simple">
<li><p>AES-256-XTS for contents and AES-256-CTS-CBC for filenames</p></li>
<li><p>AES-128-CBC for contents and AES-128-CTS-CBC for filenames</p></li>
<li><p>Adiantum for both contents and filenames</p></li>
</ul>
<p>If unsure, you should use the (AES-256-XTS, AES-256-CTS-CBC) pair.</p>
<p>AES-128-CBC was added only for low-powered embedded devices with
crypto accelerators such as CAAM or CESA that do not support XTS.  To
use AES-128-CBC, CONFIG_CRYPTO_ESSIV and CONFIG_CRYPTO_SHA256 (or
another SHA-256 implementation) must be enabled so that ESSIV can be
used.</p>
<p>Adiantum is a (primarily) stream cipher-based mode that is fast even
on CPUs without dedicated crypto instructions.  It’s also a true
wide-block mode, unlike XTS.  It can also eliminate the need to derive
per-file encryption keys.  However, it depends on the security of two
primitives, XChaCha12 and AES-256, rather than just one.  See the
paper “Adiantum: length-preserving encryption for entry-level
processors” (<a class="reference external" href="https://eprint.iacr.org/2018/720.pdf">https://eprint.iacr.org/2018/720.pdf</a>) for more details.
To use Adiantum, CONFIG_CRYPTO_ADIANTUM must be enabled.  Also, fast
implementations of ChaCha and NHPoly1305 should be enabled, e.g.
CONFIG_CRYPTO_CHACHA20_NEON and CONFIG_CRYPTO_NHPOLY1305_NEON for ARM.</p>
<p>New encryption modes can be added relatively easily, without changes
to individual filesystems.  However, authenticated encryption (AE)
modes are not currently supported because of the difficulty of dealing
with ciphertext expansion.</p>
<div class="section" id="contents-encryption">
<h3>Contents encryption<a class="headerlink" href="#contents-encryption" title="Permalink to this headline">¶</a></h3>
<p>For file contents, each filesystem block is encrypted independently.
Starting from Linux kernel 5.5, encryption of filesystems with block
size less than system’s page size is supported.</p>
<p>Each block’s IV is set to the logical block number within the file as
a little endian number, except that:</p>
<ul class="simple">
<li><p>With CBC mode encryption, ESSIV is also used.  Specifically, each IV
is encrypted with AES-256 where the AES-256 key is the SHA-256 hash
of the file’s data encryption key.</p></li>
<li><p>With <a class="reference internal" href="#direct-key-policies">DIRECT_KEY policies</a>, the file’s nonce is appended to the IV.
Currently this is only allowed with the Adiantum encryption mode.</p></li>
<li><p>With <a class="reference internal" href="#iv-ino-lblk-64-policies">IV_INO_LBLK_64 policies</a>, the logical block number is limited
to 32 bits and is placed in bits 0-31 of the IV.  The inode number
(which is also limited to 32 bits) is placed in bits 32-63.</p></li>
<li><p>With <a class="reference internal" href="#iv-ino-lblk-32-policies">IV_INO_LBLK_32 policies</a>, the logical block number is limited
to 32 bits and is placed in bits 0-31 of the IV.  The inode number
is then hashed and added mod 2^32.</p></li>
</ul>
<p>Note that because file logical block numbers are included in the IVs,
filesystems must enforce that blocks are never shifted around within
encrypted files, e.g. via “collapse range” or “insert range”.</p>
</div>
<div class="section" id="filenames-encryption">
<h3>Filenames encryption<a class="headerlink" href="#filenames-encryption" title="Permalink to this headline">¶</a></h3>
<p>For filenames, each full filename is encrypted at once.  Because of
the requirements to retain support for efficient directory lookups and
filenames of up to 255 bytes, the same IV is used for every filename
in a directory.</p>
<p>However, each encrypted directory still uses a unique key, or
alternatively has the file’s nonce (for <a class="reference internal" href="#direct-key-policies">DIRECT_KEY policies</a>) or
inode number (for <a class="reference internal" href="#iv-ino-lblk-64-policies">IV_INO_LBLK_64 policies</a>) included in the IVs.
Thus, IV reuse is limited to within a single directory.</p>
<p>With CTS-CBC, the IV reuse means that when the plaintext filenames
share a common prefix at least as long as the cipher block size (16
bytes for AES), the corresponding encrypted filenames will also share
a common prefix.  This is undesirable.  Adiantum does not have this
weakness, as it is a wide-block encryption mode.</p>
<p>All supported filenames encryption modes accept any plaintext length
&gt;= 16 bytes; cipher block alignment is not required.  However,
filenames shorter than 16 bytes are NUL-padded to 16 bytes before
being encrypted.  In addition, to reduce leakage of filename lengths
via their ciphertexts, all filenames are NUL-padded to the next 4, 8,
16, or 32-byte boundary (configurable).  32 is recommended since this
provides the best confidentiality, at the cost of making directory
entries consume slightly more space.  Note that since NUL (<code class="docutils literal notranslate"><span class="pre">\0</span></code>) is
not otherwise a valid character in filenames, the padding will never
produce duplicate plaintexts.</p>
<p>Symbolic link targets are considered a type of filename and are
encrypted in the same way as filenames in directory entries, except
that IV reuse is not a problem as each symlink has its own inode.</p>
</div>
</div>
<div class="section" id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setting-an-encryption-policy">
<h3>Setting an encryption policy<a class="headerlink" href="#setting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<div class="section" id="fs-ioc-set-encryption-policy">
<h4>FS_IOC_SET_ENCRYPTION_POLICY<a class="headerlink" href="#fs-ioc-set-encryption-policy" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_SET_ENCRYPTION_POLICY ioctl sets an encryption policy on an
empty directory or verifies that a directory or regular file already
has the specified encryption policy.  It takes in a pointer to
struct fscrypt_policy_v1 or struct fscrypt_policy_v2, defined as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FSCRYPT_POLICY_V1               0
#define FSCRYPT_KEY_DESCRIPTOR_SIZE     8
struct fscrypt_policy_v1 {
        __u8 version;
        __u8 contents_encryption_mode;
        __u8 filenames_encryption_mode;
        __u8 flags;
        __u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
};
#define fscrypt_policy  fscrypt_policy_v1

#define FSCRYPT_POLICY_V2               2
#define FSCRYPT_KEY_IDENTIFIER_SIZE     16
struct fscrypt_policy_v2 {
        __u8 version;
        __u8 contents_encryption_mode;
        __u8 filenames_encryption_mode;
        __u8 flags;
        __u8 __reserved[4];
        __u8 master_key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
};
</pre></div>
</div>
<p>This structure must be initialized as follows:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> must be FSCRYPT_POLICY_V1 (0) if
struct fscrypt_policy_v1 is used or FSCRYPT_POLICY_V2 (2) if
struct fscrypt_policy_v2 is used. (Note: we refer to the original
policy version as “v1”, though its version code is really 0.)
For new encrypted directories, use v2 policies.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">contents_encryption_mode</span></code> and <code class="docutils literal notranslate"><span class="pre">filenames_encryption_mode</span></code> must
be set to constants from <code class="docutils literal notranslate"><span class="pre">&lt;linux/fscrypt.h&gt;</span></code> which identify the
encryption modes to use.  If unsure, use FSCRYPT_MODE_AES_256_XTS
(1) for <code class="docutils literal notranslate"><span class="pre">contents_encryption_mode</span></code> and FSCRYPT_MODE_AES_256_CTS
(4) for <code class="docutils literal notranslate"><span class="pre">filenames_encryption_mode</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code> contains optional flags from <code class="docutils literal notranslate"><span class="pre">&lt;linux/fscrypt.h&gt;</span></code>:</p>
<ul class="simple">
<li><p>FSCRYPT_POLICY_FLAGS_PAD_*: The amount of NUL padding to use when
encrypting filenames.  If unsure, use FSCRYPT_POLICY_FLAGS_PAD_32
(0x3).</p></li>
<li><p>FSCRYPT_POLICY_FLAG_DIRECT_KEY: See <a class="reference internal" href="#direct-key-policies">DIRECT_KEY policies</a>.</p></li>
<li><p>FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64: See <a class="reference internal" href="#iv-ino-lblk-64-policies">IV_INO_LBLK_64
policies</a>.</p></li>
<li><p>FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32: See <a class="reference internal" href="#iv-ino-lblk-32-policies">IV_INO_LBLK_32
policies</a>.</p></li>
</ul>
<p>v1 encryption policies only support the PAD_* and DIRECT_KEY flags.
The other flags are only supported by v2 encryption policies.</p>
<p>The DIRECT_KEY, IV_INO_LBLK_64, and IV_INO_LBLK_32 flags are
mutually exclusive.</p>
</li>
<li><p>For v2 encryption policies, <code class="docutils literal notranslate"><span class="pre">__reserved</span></code> must be zeroed.</p></li>
<li><p>For v1 encryption policies, <code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> specifies how
to find the master key in a keyring; see <a class="reference internal" href="#adding-keys">Adding keys</a>.  It is up
to userspace to choose a unique <code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> for each
master key.  The e4crypt and fscrypt tools use the first 8 bytes of
<code class="docutils literal notranslate"><span class="pre">SHA-512(SHA-512(master_key))</span></code>, but this particular scheme is not
required.  Also, the master key need not be in the keyring yet when
FS_IOC_SET_ENCRYPTION_POLICY is executed.  However, it must be added
before any files can be created in the encrypted directory.</p>
<p>For v2 encryption policies, <code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> has been
replaced with <code class="docutils literal notranslate"><span class="pre">master_key_identifier</span></code>, which is longer and cannot
be arbitrarily chosen.  Instead, the key must first be added using
<a class="reference internal" href="#fs-ioc-add-encryption-key">FS_IOC_ADD_ENCRYPTION_KEY</a>.  Then, the <code class="docutils literal notranslate"><span class="pre">key_spec.u.identifier</span></code>
the kernel returned in the struct fscrypt_add_key_arg must
be used as the <code class="docutils literal notranslate"><span class="pre">master_key_identifier</span></code> in
struct fscrypt_policy_v2.</p>
</li>
</ul>
<p>If the file is not yet encrypted, then FS_IOC_SET_ENCRYPTION_POLICY
verifies that the file is an empty directory.  If so, the specified
encryption policy is assigned to the directory, turning it into an
encrypted directory.  After that, and after providing the
corresponding master key as described in <a class="reference internal" href="#adding-keys">Adding keys</a>, all regular
files, directories (recursively), and symlinks created in the
directory will be encrypted, inheriting the same encryption policy.
The filenames in the directory’s entries will be encrypted as well.</p>
<p>Alternatively, if the file is already encrypted, then
FS_IOC_SET_ENCRYPTION_POLICY validates that the specified encryption
policy exactly matches the actual one.  If they match, then the ioctl
returns 0.  Otherwise, it fails with EEXIST.  This works on both
regular files and directories, including nonempty directories.</p>
<p>When a v2 encryption policy is assigned to a directory, it is also
required that either the specified key has been added by the current
user or that the caller has CAP_FOWNER in the initial user namespace.
(This is needed to prevent a user from encrypting their data with
another user’s key.)  The key must remain added while
FS_IOC_SET_ENCRYPTION_POLICY is executing.  However, if the new
encrypted directory does not need to be accessed immediately, then the
key can be removed right away afterwards.</p>
<p>Note that the ext4 filesystem does not allow the root directory to be
encrypted, even if it is empty.  Users who want to encrypt an entire
filesystem with one key should consider using dm-crypt instead.</p>
<p>FS_IOC_SET_ENCRYPTION_POLICY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: the file is not owned by the process’s uid, nor does the
process have the CAP_FOWNER capability in a namespace with the file
owner’s uid mapped</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EEXIST</span></code>: the file is already encrypted with an encryption policy
different from the one specified</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: an invalid encryption policy was specified (invalid
version, mode(s), or flags; or reserved bits were set); or a v1
encryption policy was specified but the directory has the casefold
flag enabled (casefolding is incompatible with v1 policies).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOKEY</span></code>: a v2 encryption policy was specified, but the key with
the specified <code class="docutils literal notranslate"><span class="pre">master_key_identifier</span></code> has not been added, nor does
the process have the CAP_FOWNER capability in the initial user
namespace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTDIR</span></code>: the file is unencrypted and is a regular file, not a
directory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTEMPTY</span></code>: the file is unencrypted and is a nonempty directory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for filesystems, or the filesystem superblock has not
had encryption enabled on it.  (For example, to use encryption on an
ext4 filesystem, CONFIG_FS_ENCRYPTION must be enabled in the
kernel config, and the superblock must have had the “encrypt”
feature flag enabled using <code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">encrypt</span></code> or <code class="docutils literal notranslate"><span class="pre">mkfs.ext4</span> <span class="pre">-O</span>
<span class="pre">encrypt</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EPERM</span></code>: this directory may not be encrypted, e.g. because it is
the root directory of an ext4 filesystem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EROFS</span></code>: the filesystem is readonly</p></li>
</ul>
</div>
</div>
<div class="section" id="getting-an-encryption-policy">
<h3>Getting an encryption policy<a class="headerlink" href="#getting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<p>Two ioctls are available to get a file’s encryption policy:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#fs-ioc-get-encryption-policy-ex">FS_IOC_GET_ENCRYPTION_POLICY_EX</a></p></li>
<li><p><a class="reference internal" href="#fs-ioc-get-encryption-policy">FS_IOC_GET_ENCRYPTION_POLICY</a></p></li>
</ul>
<p>The extended (_EX) version of the ioctl is more general and is
recommended to use when possible.  However, on older kernels only the
original ioctl is available.  Applications should try the extended
version, and if it fails with ENOTTY fall back to the original
version.</p>
<div class="section" id="fs-ioc-get-encryption-policy-ex">
<h4>FS_IOC_GET_ENCRYPTION_POLICY_EX<a class="headerlink" href="#fs-ioc-get-encryption-policy-ex" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_GET_ENCRYPTION_POLICY_EX ioctl retrieves the encryption
policy, if any, for a directory or regular file.  No additional
permissions are required beyond the ability to open the file.  It
takes in a pointer to struct fscrypt_get_policy_ex_arg,
defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscrypt_get_policy_ex_arg {
        __u64 policy_size; /* input/output */
        union {
                __u8 version;
                struct fscrypt_policy_v1 v1;
                struct fscrypt_policy_v2 v2;
        } policy; /* output */
};
</pre></div>
</div>
<p>The caller must initialize <code class="docutils literal notranslate"><span class="pre">policy_size</span></code> to the size available for
the policy struct, i.e. <code class="docutils literal notranslate"><span class="pre">sizeof(arg.policy)</span></code>.</p>
<p>On success, the policy struct is returned in <code class="docutils literal notranslate"><span class="pre">policy</span></code>, and its
actual size is returned in <code class="docutils literal notranslate"><span class="pre">policy_size</span></code>.  <code class="docutils literal notranslate"><span class="pre">policy.version</span></code> should
be checked to determine the version of policy returned.  Note that the
version code for the “v1” policy is actually 0 (FSCRYPT_POLICY_V1).</p>
<p>FS_IOC_GET_ENCRYPTION_POLICY_EX can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: the file is encrypted, but it uses an unrecognized
encryption policy version</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENODATA</span></code>: the file is not encrypted</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption,
or this kernel is too old to support FS_IOC_GET_ENCRYPTION_POLICY_EX
(try FS_IOC_GET_ENCRYPTION_POLICY instead)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOVERFLOW</span></code>: the file is encrypted and uses a recognized
encryption policy version, but the policy struct does not fit into
the provided buffer</p></li>
</ul>
<p>Note: if you only need to know whether a file is encrypted or not, on
most filesystems it is also possible to use the FS_IOC_GETFLAGS ioctl
and check for FS_ENCRYPT_FL, or to use the statx() system call and
check for STATX_ATTR_ENCRYPTED in stx_attributes.</p>
</div>
<div class="section" id="fs-ioc-get-encryption-policy">
<h4>FS_IOC_GET_ENCRYPTION_POLICY<a class="headerlink" href="#fs-ioc-get-encryption-policy" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_GET_ENCRYPTION_POLICY ioctl can also retrieve the
encryption policy, if any, for a directory or regular file.  However,
unlike <a class="reference internal" href="#fs-ioc-get-encryption-policy-ex">FS_IOC_GET_ENCRYPTION_POLICY_EX</a>,
FS_IOC_GET_ENCRYPTION_POLICY only supports the original policy
version.  It takes in a pointer directly to struct fscrypt_policy_v1
rather than struct fscrypt_get_policy_ex_arg.</p>
<p>The error codes for FS_IOC_GET_ENCRYPTION_POLICY are the same as those
for FS_IOC_GET_ENCRYPTION_POLICY_EX, except that
FS_IOC_GET_ENCRYPTION_POLICY also returns <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> if the file is
encrypted using a newer encryption policy version.</p>
</div>
</div>
<div class="section" id="getting-the-per-filesystem-salt">
<h3>Getting the per-filesystem salt<a class="headerlink" href="#getting-the-per-filesystem-salt" title="Permalink to this headline">¶</a></h3>
<p>Some filesystems, such as ext4 and F2FS, also support the deprecated
ioctl FS_IOC_GET_ENCRYPTION_PWSALT.  This ioctl retrieves a randomly
generated 16-byte value stored in the filesystem superblock.  This
value is intended to used as a salt when deriving an encryption key
from a passphrase or other low-entropy user credential.</p>
<p>FS_IOC_GET_ENCRYPTION_PWSALT is deprecated.  Instead, prefer to
generate and manage any needed salt(s) in userspace.</p>
</div>
<div class="section" id="getting-a-file-s-encryption-nonce">
<h3>Getting a file’s encryption nonce<a class="headerlink" href="#getting-a-file-s-encryption-nonce" title="Permalink to this headline">¶</a></h3>
<p>Since Linux v5.7, the ioctl FS_IOC_GET_ENCRYPTION_NONCE is supported.
On encrypted files and directories it gets the inode’s 16-byte nonce.
On unencrypted files and directories, it fails with ENODATA.</p>
<p>This ioctl can be useful for automated tests which verify that the
encryption is being done correctly.  It is not needed for normal use
of fscrypt.</p>
</div>
<div class="section" id="adding-keys">
<h3>Adding keys<a class="headerlink" href="#adding-keys" title="Permalink to this headline">¶</a></h3>
<div class="section" id="fs-ioc-add-encryption-key">
<h4>FS_IOC_ADD_ENCRYPTION_KEY<a class="headerlink" href="#fs-ioc-add-encryption-key" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_ADD_ENCRYPTION_KEY ioctl adds a master encryption key to
the filesystem, making all files on the filesystem which were
encrypted using that key appear “unlocked”, i.e. in plaintext form.
It can be executed on any file or directory on the target filesystem,
but using the filesystem’s root directory is recommended.  It takes in
a pointer to struct fscrypt_add_key_arg, defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscrypt_add_key_arg {
        struct fscrypt_key_specifier key_spec;
        __u32 raw_size;
        __u32 key_id;
        __u32 __reserved[8];
        __u8 raw[];
};

#define FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR        1
#define FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER        2

struct fscrypt_key_specifier {
        __u32 type;     /* one of FSCRYPT_KEY_SPEC_TYPE_* */
        __u32 __reserved;
        union {
                __u8 __reserved[32]; /* reserve some extra space */
                __u8 descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
                __u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
        } u;
};

struct fscrypt_provisioning_key_payload {
        __u32 type;
        __u32 __reserved;
        __u8 raw[];
};
</pre></div>
</div>
<p>struct fscrypt_add_key_arg must be zeroed, then initialized
as follows:</p>
<ul>
<li><p>If the key is being added for use by v1 encryption policies, then
<code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> must contain FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR, and
<code class="docutils literal notranslate"><span class="pre">key_spec.u.descriptor</span></code> must contain the descriptor of the key
being added, corresponding to the value in the
<code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> field of struct fscrypt_policy_v1.
To add this type of key, the calling process must have the
CAP_SYS_ADMIN capability in the initial user namespace.</p>
<p>Alternatively, if the key is being added for use by v2 encryption
policies, then <code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> must contain
FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER, and <code class="docutils literal notranslate"><span class="pre">key_spec.u.identifier</span></code> is
an <em>output</em> field which the kernel fills in with a cryptographic
hash of the key.  To add this type of key, the calling process does
not need any privileges.  However, the number of keys that can be
added is limited by the user’s quota for the keyrings service (see
<code class="docutils literal notranslate"><span class="pre">Documentation/security/keys/core.rst</span></code>).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">raw_size</span></code> must be the size of the <code class="docutils literal notranslate"><span class="pre">raw</span></code> key provided, in bytes.
Alternatively, if <code class="docutils literal notranslate"><span class="pre">key_id</span></code> is nonzero, this field must be 0, since
in that case the size is implied by the specified Linux keyring key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">key_id</span></code> is 0 if the raw key is given directly in the <code class="docutils literal notranslate"><span class="pre">raw</span></code>
field.  Otherwise <code class="docutils literal notranslate"><span class="pre">key_id</span></code> is the ID of a Linux keyring key of
type “fscrypt-provisioning” whose payload is
struct fscrypt_provisioning_key_payload whose <code class="docutils literal notranslate"><span class="pre">raw</span></code> field contains
the raw key and whose <code class="docutils literal notranslate"><span class="pre">type</span></code> field matches <code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code>.
Since <code class="docutils literal notranslate"><span class="pre">raw</span></code> is variable-length, the total size of this key’s
payload must be <code class="docutils literal notranslate"><span class="pre">sizeof(struct</span> <span class="pre">fscrypt_provisioning_key_payload)</span></code>
plus the raw key size.  The process must have Search permission on
this key.</p>
<p>Most users should leave this 0 and specify the raw key directly.
The support for specifying a Linux keyring key is intended mainly to
allow re-adding keys after a filesystem is unmounted and re-mounted,
without having to store the raw keys in userspace memory.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">raw</span></code> is a variable-length field which must contain the actual
key, <code class="docutils literal notranslate"><span class="pre">raw_size</span></code> bytes long.  Alternatively, if <code class="docutils literal notranslate"><span class="pre">key_id</span></code> is
nonzero, then this field is unused.</p></li>
</ul>
<p>For v2 policy keys, the kernel keeps track of which user (identified
by effective user ID) added the key, and only allows the key to be
removed by that user — or by “root”, if they use
<a class="reference internal" href="#fs-ioc-remove-encryption-key-all-users">FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS</a>.</p>
<p>However, if another user has added the key, it may be desirable to
prevent that other user from unexpectedly removing it.  Therefore,
FS_IOC_ADD_ENCRYPTION_KEY may also be used to add a v2 policy key
<em>again</em>, even if it’s already added by other user(s).  In this case,
FS_IOC_ADD_ENCRYPTION_KEY will just install a claim to the key for the
current user, rather than actually add the key again (but the raw key
must still be provided, as a proof of knowledge).</p>
<p>FS_IOC_ADD_ENCRYPTION_KEY returns 0 if either the key or a claim to
the key was either added or already exists.</p>
<p>FS_IOC_ADD_ENCRYPTION_KEY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR was specified, but the
caller does not have the CAP_SYS_ADMIN capability in the initial
user namespace; or the raw key was specified by Linux key ID but the
process lacks Search permission on the key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EDQUOT</span></code>: the key quota for this user would be exceeded by adding
the key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: invalid key size or key specifier type, or reserved bits
were set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EKEYREJECTED</span></code>: the raw key was specified by Linux key ID, but the
key has the wrong type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOKEY</span></code>: the raw key was specified by Linux key ID, but no key
exists with that ID</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it</p></li>
</ul>
</div>
<div class="section" id="legacy-method">
<h4>Legacy method<a class="headerlink" href="#legacy-method" title="Permalink to this headline">¶</a></h4>
<p>For v1 encryption policies, a master encryption key can also be
provided by adding it to a process-subscribed keyring, e.g. to a
session keyring, or to a user keyring if the user keyring is linked
into the session keyring.</p>
<p>This method is deprecated (and not supported for v2 encryption
policies) for several reasons.  First, it cannot be used in
combination with FS_IOC_REMOVE_ENCRYPTION_KEY (see <a class="reference internal" href="#removing-keys">Removing keys</a>),
so for removing a key a workaround such as keyctl_unlink() in
combination with <code class="docutils literal notranslate"><span class="pre">sync;</span> <span class="pre">echo</span> <span class="pre">2</span> <span class="pre">&gt;</span> <span class="pre">/proc/sys/vm/drop_caches</span></code> would
have to be used.  Second, it doesn’t match the fact that the
locked/unlocked status of encrypted files (i.e. whether they appear to
be in plaintext form or in ciphertext form) is global.  This mismatch
has caused much confusion as well as real problems when processes
running under different UIDs, such as a <code class="docutils literal notranslate"><span class="pre">sudo</span></code> command, need to
access encrypted files.</p>
<p>Nevertheless, to add a key to one of the process-subscribed keyrings,
the add_key() system call can be used (see:
<code class="docutils literal notranslate"><span class="pre">Documentation/security/keys/core.rst</span></code>).  The key type must be
“logon”; keys of this type are kept in kernel memory and cannot be
read back by userspace.  The key description must be “fscrypt:”
followed by the 16-character lower case hex representation of the
<code class="docutils literal notranslate"><span class="pre">master_key_descriptor</span></code> that was set in the encryption policy.  The
key payload must conform to the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FSCRYPT_MAX_KEY_SIZE            64

struct fscrypt_key {
        __u32 mode;
        __u8 raw[FSCRYPT_MAX_KEY_SIZE];
        __u32 size;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mode</span></code> is ignored; just set it to 0.  The actual key is provided in
<code class="docutils literal notranslate"><span class="pre">raw</span></code> with <code class="docutils literal notranslate"><span class="pre">size</span></code> indicating its size in bytes.  That is, the
bytes <code class="docutils literal notranslate"><span class="pre">raw[0..size-1]</span></code> (inclusive) are the actual key.</p>
<p>The key description prefix “fscrypt:” may alternatively be replaced
with a filesystem-specific prefix such as “ext4:”.  However, the
filesystem-specific prefixes are deprecated and should not be used in
new programs.</p>
</div>
</div>
<div class="section" id="removing-keys">
<h3>Removing keys<a class="headerlink" href="#removing-keys" title="Permalink to this headline">¶</a></h3>
<p>Two ioctls are available for removing a key that was added by
<a class="reference internal" href="#fs-ioc-add-encryption-key">FS_IOC_ADD_ENCRYPTION_KEY</a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#fs-ioc-remove-encryption-key">FS_IOC_REMOVE_ENCRYPTION_KEY</a></p></li>
<li><p><a class="reference internal" href="#fs-ioc-remove-encryption-key-all-users">FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS</a></p></li>
</ul>
<p>These two ioctls differ only in cases where v2 policy keys are added
or removed by non-root users.</p>
<p>These ioctls don’t work on keys that were added via the legacy
process-subscribed keyrings mechanism.</p>
<p>Before using these ioctls, read the <a class="reference internal" href="#kernel-memory-compromise">Kernel memory compromise</a>
section for a discussion of the security goals and limitations of
these ioctls.</p>
<div class="section" id="fs-ioc-remove-encryption-key">
<h4>FS_IOC_REMOVE_ENCRYPTION_KEY<a class="headerlink" href="#fs-ioc-remove-encryption-key" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_REMOVE_ENCRYPTION_KEY ioctl removes a claim to a master
encryption key from the filesystem, and possibly removes the key
itself.  It can be executed on any file or directory on the target
filesystem, but using the filesystem’s root directory is recommended.
It takes in a pointer to struct fscrypt_remove_key_arg, defined
as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscrypt_remove_key_arg {
        struct fscrypt_key_specifier key_spec;
#define FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY      0x00000001
#define FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS     0x00000002
        __u32 removal_status_flags;     /* output */
        __u32 __reserved[5];
};
</pre></div>
</div>
<p>This structure must be zeroed, then initialized as follows:</p>
<ul>
<li><p>The key to remove is specified by <code class="docutils literal notranslate"><span class="pre">key_spec</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>To remove a key used by v1 encryption policies, set
<code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> to FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR and fill
in <code class="docutils literal notranslate"><span class="pre">key_spec.u.descriptor</span></code>.  To remove this type of key, the
calling process must have the CAP_SYS_ADMIN capability in the
initial user namespace.</p></li>
<li><p>To remove a key used by v2 encryption policies, set
<code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> to FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER and fill
in <code class="docutils literal notranslate"><span class="pre">key_spec.u.identifier</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>For v2 policy keys, this ioctl is usable by non-root users.  However,
to make this possible, it actually just removes the current user’s
claim to the key, undoing a single call to FS_IOC_ADD_ENCRYPTION_KEY.
Only after all claims are removed is the key really removed.</p>
<p>For example, if FS_IOC_ADD_ENCRYPTION_KEY was called with uid 1000,
then the key will be “claimed” by uid 1000, and
FS_IOC_REMOVE_ENCRYPTION_KEY will only succeed as uid 1000.  Or, if
both uids 1000 and 2000 added the key, then for each uid
FS_IOC_REMOVE_ENCRYPTION_KEY will only remove their own claim.  Only
once <em>both</em> are removed is the key really removed.  (Think of it like
unlinking a file that may have hard links.)</p>
<p>If FS_IOC_REMOVE_ENCRYPTION_KEY really removes the key, it will also
try to “lock” all files that had been unlocked with the key.  It won’t
lock files that are still in-use, so this ioctl is expected to be used
in cooperation with userspace ensuring that none of the files are
still open.  However, if necessary, this ioctl can be executed again
later to retry locking any remaining files.</p>
<p>FS_IOC_REMOVE_ENCRYPTION_KEY returns 0 if either the key was removed
(but may still have files remaining to be locked), the user’s claim to
the key was removed, or the key was already removed but had files
remaining to be the locked so the ioctl retried locking them.  In any
of these cases, <code class="docutils literal notranslate"><span class="pre">removal_status_flags</span></code> is filled in with the
following informational status flags:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY</span></code>: set if some file(s)
are still in-use.  Not guaranteed to be set in the case where only
the user’s claim to the key was removed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS</span></code>: set if only the
user’s claim to the key was removed, not the key itself</p></li>
</ul>
<p>FS_IOC_REMOVE_ENCRYPTION_KEY can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: The FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR key specifier type
was specified, but the caller does not have the CAP_SYS_ADMIN
capability in the initial user namespace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: invalid key specifier type, or reserved bits were set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOKEY</span></code>: the key object was not found at all, i.e. it was never
added in the first place or was already fully removed including all
files locked; or, the user does not have a claim to the key (but
someone else does).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it</p></li>
</ul>
</div>
<div class="section" id="fs-ioc-remove-encryption-key-all-users">
<h4>FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS<a class="headerlink" href="#fs-ioc-remove-encryption-key-all-users" title="Permalink to this headline">¶</a></h4>
<p>FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS is exactly the same as
<a class="reference internal" href="#fs-ioc-remove-encryption-key">FS_IOC_REMOVE_ENCRYPTION_KEY</a>, except that for v2 policy keys, the
ALL_USERS version of the ioctl will remove all users’ claims to the
key, not just the current user’s.  I.e., the key itself will always be
removed, no matter how many users have added it.  This difference is
only meaningful if non-root users are adding and removing keys.</p>
<p>Because of this, FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS also requires
“root”, namely the CAP_SYS_ADMIN capability in the initial user
namespace.  Otherwise it will fail with EACCES.</p>
</div>
</div>
<div class="section" id="getting-key-status">
<h3>Getting key status<a class="headerlink" href="#getting-key-status" title="Permalink to this headline">¶</a></h3>
<div class="section" id="fs-ioc-get-encryption-key-status">
<h4>FS_IOC_GET_ENCRYPTION_KEY_STATUS<a class="headerlink" href="#fs-ioc-get-encryption-key-status" title="Permalink to this headline">¶</a></h4>
<p>The FS_IOC_GET_ENCRYPTION_KEY_STATUS ioctl retrieves the status of a
master encryption key.  It can be executed on any file or directory on
the target filesystem, but using the filesystem’s root directory is
recommended.  It takes in a pointer to
struct fscrypt_get_key_status_arg, defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscrypt_get_key_status_arg {
        /* input */
        struct fscrypt_key_specifier key_spec;
        __u32 __reserved[6];

        /* output */
#define FSCRYPT_KEY_STATUS_ABSENT               1
#define FSCRYPT_KEY_STATUS_PRESENT              2
#define FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED 3
        __u32 status;
#define FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF   0x00000001
        __u32 status_flags;
        __u32 user_count;
        __u32 __out_reserved[13];
};
</pre></div>
</div>
<p>The caller must zero all input fields, then fill in <code class="docutils literal notranslate"><span class="pre">key_spec</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>To get the status of a key for v1 encryption policies, set
<code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> to FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR and fill
in <code class="docutils literal notranslate"><span class="pre">key_spec.u.descriptor</span></code>.</p></li>
<li><p>To get the status of a key for v2 encryption policies, set
<code class="docutils literal notranslate"><span class="pre">key_spec.type</span></code> to FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER and fill
in <code class="docutils literal notranslate"><span class="pre">key_spec.u.identifier</span></code>.</p></li>
</ul>
</div></blockquote>
<p>On success, 0 is returned and the kernel fills in the output fields:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">status</span></code> indicates whether the key is absent, present, or
incompletely removed.  Incompletely removed means that the master
secret has been removed, but some files are still in use; i.e.,
<a class="reference internal" href="#fs-ioc-remove-encryption-key">FS_IOC_REMOVE_ENCRYPTION_KEY</a> returned 0 but set the informational
status flag FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">status_flags</span></code> can contain the following flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF</span></code> indicates that the key
has added by the current user.  This is only set for keys
identified by <code class="docutils literal notranslate"><span class="pre">identifier</span></code> rather than by <code class="docutils literal notranslate"><span class="pre">descriptor</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">user_count</span></code> specifies the number of users who have added the key.
This is only set for keys identified by <code class="docutils literal notranslate"><span class="pre">identifier</span></code> rather than
by <code class="docutils literal notranslate"><span class="pre">descriptor</span></code>.</p></li>
</ul>
<p>FS_IOC_GET_ENCRYPTION_KEY_STATUS can fail with the following errors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: invalid key specifier type, or reserved bits were set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it</p></li>
</ul>
<p>Among other use cases, FS_IOC_GET_ENCRYPTION_KEY_STATUS can be useful
for determining whether the key for a given encrypted directory needs
to be added before prompting the user for the passphrase needed to
derive the key.</p>
<p>FS_IOC_GET_ENCRYPTION_KEY_STATUS can only get the status of keys in
the filesystem-level keyring, i.e. the keyring managed by
<a class="reference internal" href="#fs-ioc-add-encryption-key">FS_IOC_ADD_ENCRYPTION_KEY</a> and <a class="reference internal" href="#fs-ioc-remove-encryption-key">FS_IOC_REMOVE_ENCRYPTION_KEY</a>.  It
cannot get the status of a key that has only been added for use by v1
encryption policies using the legacy mechanism involving
process-subscribed keyrings.</p>
</div>
</div>
</div>
<div class="section" id="access-semantics">
<h2>Access semantics<a class="headerlink" href="#access-semantics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="with-the-key">
<h3>With the key<a class="headerlink" href="#with-the-key" title="Permalink to this headline">¶</a></h3>
<p>With the encryption key, encrypted regular files, directories, and
symlinks behave very similarly to their unencrypted counterparts —
after all, the encryption is intended to be transparent.  However,
astute users may notice some differences in behavior:</p>
<ul>
<li><p>Unencrypted files, or files encrypted with a different encryption
policy (i.e. different key, modes, or flags), cannot be renamed or
linked into an encrypted directory; see <a class="reference internal" href="#encryption-policy-enforcement">Encryption policy
enforcement</a>.  Attempts to do so will fail with EXDEV.  However,
encrypted files can be renamed within an encrypted directory, or
into an unencrypted directory.</p>
<p>Note: “moving” an unencrypted file into an encrypted directory, e.g.
with the <cite>mv</cite> program, is implemented in userspace by a copy
followed by a delete.  Be aware that the original unencrypted data
may remain recoverable from free space on the disk; prefer to keep
all files encrypted from the very beginning.  The <cite>shred</cite> program
may be used to overwrite the source files but isn’t guaranteed to be
effective on all filesystems and storage devices.</p>
</li>
<li><p>Direct I/O is not supported on encrypted files.  Attempts to use
direct I/O on such files will fall back to buffered I/O.</p></li>
<li><p>The fallocate operations FALLOC_FL_COLLAPSE_RANGE and
FALLOC_FL_INSERT_RANGE are not supported on encrypted files and will
fail with EOPNOTSUPP.</p></li>
<li><p>Online defragmentation of encrypted files is not supported.  The
EXT4_IOC_MOVE_EXT and F2FS_IOC_MOVE_RANGE ioctls will fail with
EOPNOTSUPP.</p></li>
<li><p>The ext4 filesystem does not support data journaling with encrypted
regular files.  It will fall back to ordered data mode instead.</p></li>
<li><p>DAX (Direct Access) is not supported on encrypted files.</p></li>
<li><p>The st_size of an encrypted symlink will not necessarily give the
length of the symlink target as required by POSIX.  It will actually
give the length of the ciphertext, which will be slightly longer
than the plaintext due to NUL-padding and an extra 2-byte overhead.</p></li>
<li><p>The maximum length of an encrypted symlink is 2 bytes shorter than
the maximum length of an unencrypted symlink.  For example, on an
EXT4 filesystem with a 4K block size, unencrypted symlinks can be up
to 4095 bytes long, while encrypted symlinks can only be up to 4093
bytes long (both lengths excluding the terminating null).</p></li>
</ul>
<p>Note that mmap <em>is</em> supported.  This is possible because the pagecache
for an encrypted file contains the plaintext, not the ciphertext.</p>
</div>
<div class="section" id="without-the-key">
<h3>Without the key<a class="headerlink" href="#without-the-key" title="Permalink to this headline">¶</a></h3>
<p>Some filesystem operations may be performed on encrypted regular
files, directories, and symlinks even before their encryption key has
been added, or after their encryption key has been removed:</p>
<ul>
<li><p>File metadata may be read, e.g. using stat().</p></li>
<li><p>Directories may be listed, in which case the filenames will be
listed in an encoded form derived from their ciphertext.  The
current encoding algorithm is described in <a class="reference internal" href="#filename-hashing-and-encoding">Filename hashing and
encoding</a>.  The algorithm is subject to change, but it is
guaranteed that the presented filenames will be no longer than
NAME_MAX bytes, will not contain the <code class="docutils literal notranslate"><span class="pre">/</span></code> or <code class="docutils literal notranslate"><span class="pre">\0</span></code> characters, and
will uniquely identify directory entries.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.</span></code> and <code class="docutils literal notranslate"><span class="pre">..</span></code> directory entries are special.  They are always
present and are not encrypted or encoded.</p>
</li>
<li><p>Files may be deleted.  That is, nondirectory files may be deleted
with unlink() as usual, and empty directories may be deleted with
rmdir() as usual.  Therefore, <code class="docutils literal notranslate"><span class="pre">rm</span></code> and <code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-r</span></code> will work as
expected.</p></li>
<li><p>Symlink targets may be read and followed, but they will be presented
in encrypted form, similar to filenames in directories.  Hence, they
are unlikely to point to anywhere useful.</p></li>
</ul>
<p>Without the key, regular files cannot be opened or truncated.
Attempts to do so will fail with ENOKEY.  This implies that any
regular file operations that require a file descriptor, such as
read(), write(), mmap(), fallocate(), and ioctl(), are also forbidden.</p>
<p>Also without the key, files of any type (including directories) cannot
be created or linked into an encrypted directory, nor can a name in an
encrypted directory be the source or target of a rename, nor can an
O_TMPFILE temporary file be created in an encrypted directory.  All
such operations will fail with ENOKEY.</p>
<p>It is not currently possible to backup and restore encrypted files
without the encryption key.  This would require special APIs which
have not yet been implemented.</p>
</div>
</div>
<div class="section" id="encryption-policy-enforcement">
<h2>Encryption policy enforcement<a class="headerlink" href="#encryption-policy-enforcement" title="Permalink to this headline">¶</a></h2>
<p>After an encryption policy has been set on a directory, all regular
files, directories, and symbolic links created in that directory
(recursively) will inherit that encryption policy.  Special files —
that is, named pipes, device nodes, and UNIX domain sockets — will
not be encrypted.</p>
<p>Except for those special files, it is forbidden to have unencrypted
files, or files encrypted with a different encryption policy, in an
encrypted directory tree.  Attempts to link or rename such a file into
an encrypted directory will fail with EXDEV.  This is also enforced
during -&gt;lookup() to provide limited protection against offline
attacks that try to disable or downgrade encryption in known locations
where applications may later write sensitive data.  It is recommended
that systems implementing a form of “verified boot” take advantage of
this by validating all top-level encryption policies prior to access.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="encryption-context">
<h3>Encryption context<a class="headerlink" href="#encryption-context" title="Permalink to this headline">¶</a></h3>
<p>An encryption policy is represented on-disk by
struct fscrypt_context_v1 or struct fscrypt_context_v2.  It is up to
individual filesystems to decide where to store it, but normally it
would be stored in a hidden extended attribute.  It should <em>not</em> be
exposed by the xattr-related system calls such as getxattr() and
setxattr() because of the special semantics of the encryption xattr.
(In particular, there would be much confusion if an encryption policy
were to be added to or removed from anything other than an empty
directory.)  These structs are defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define FSCRYPT_FILE_NONCE_SIZE 16

#define FSCRYPT_KEY_DESCRIPTOR_SIZE  8
struct fscrypt_context_v1 {
        u8 version;
        u8 contents_encryption_mode;
        u8 filenames_encryption_mode;
        u8 flags;
        u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
        u8 nonce[FSCRYPT_FILE_NONCE_SIZE];
};

#define FSCRYPT_KEY_IDENTIFIER_SIZE  16
struct fscrypt_context_v2 {
        u8 version;
        u8 contents_encryption_mode;
        u8 filenames_encryption_mode;
        u8 flags;
        u8 __reserved[4];
        u8 master_key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
        u8 nonce[FSCRYPT_FILE_NONCE_SIZE];
};
</pre></div>
</div>
<p>The context structs contain the same information as the corresponding
policy structs (see <a class="reference internal" href="#setting-an-encryption-policy">Setting an encryption policy</a>), except that the
context structs also contain a nonce.  The nonce is randomly generated
by the kernel and is used as KDF input or as a tweak to cause
different files to be encrypted differently; see <a class="reference internal" href="#per-file-encryption-keys">Per-file encryption
keys</a> and <a class="reference internal" href="#direct-key-policies">DIRECT_KEY policies</a>.</p>
</div>
<div class="section" id="data-path-changes">
<h3>Data path changes<a class="headerlink" href="#data-path-changes" title="Permalink to this headline">¶</a></h3>
<p>For the read path (-&gt;readpage()) of regular files, filesystems can
read the ciphertext into the page cache and decrypt it in-place.  The
page lock must be held until decryption has finished, to prevent the
page from becoming visible to userspace prematurely.</p>
<p>For the write path (-&gt;writepage()) of regular files, filesystems
cannot encrypt data in-place in the page cache, since the cached
plaintext must be preserved.  Instead, filesystems must encrypt into a
temporary buffer or “bounce page”, then write out the temporary
buffer.  Some filesystems, such as UBIFS, already use temporary
buffers regardless of encryption.  Other filesystems, such as ext4 and
F2FS, have to allocate bounce pages specially for encryption.</p>
<p>Fscrypt is also able to use inline encryption hardware instead of the
kernel crypto API for en/decryption of file contents.  When possible,
and if directed to do so (by specifying the ‘inlinecrypt’ mount option
for an ext4/F2FS filesystem), it adds encryption contexts to bios and
uses blk-crypto to perform the en/decryption instead of making use of
the above read/write path changes.  Of course, even if directed to
make use of inline encryption, fscrypt will only be able to do so if
either hardware inline encryption support is available for the
selected encryption algorithm or CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK
is selected.  If neither is the case, fscrypt will fall back to using
the above mentioned read/write path changes for en/decryption.</p>
</div>
<div class="section" id="filename-hashing-and-encoding">
<h3>Filename hashing and encoding<a class="headerlink" href="#filename-hashing-and-encoding" title="Permalink to this headline">¶</a></h3>
<p>Modern filesystems accelerate directory lookups by using indexed
directories.  An indexed directory is organized as a tree keyed by
filename hashes.  When a -&gt;lookup() is requested, the filesystem
normally hashes the filename being looked up so that it can quickly
find the corresponding directory entry, if any.</p>
<p>With encryption, lookups must be supported and efficient both with and
without the encryption key.  Clearly, it would not work to hash the
plaintext filenames, since the plaintext filenames are unavailable
without the key.  (Hashing the plaintext filenames would also make it
impossible for the filesystem’s fsck tool to optimize encrypted
directories.)  Instead, filesystems hash the ciphertext filenames,
i.e. the bytes actually stored on-disk in the directory entries.  When
asked to do a -&gt;lookup() with the key, the filesystem just encrypts
the user-supplied name to get the ciphertext.</p>
<p>Lookups without the key are more complicated.  The raw ciphertext may
contain the <code class="docutils literal notranslate"><span class="pre">\0</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> characters, which are illegal in
filenames.  Therefore, readdir() must base64-encode the ciphertext for
presentation.  For most filenames, this works fine; on -&gt;lookup(), the
filesystem just base64-decodes the user-supplied name to get back to
the raw ciphertext.</p>
<p>However, for very long filenames, base64 encoding would cause the
filename length to exceed NAME_MAX.  To prevent this, readdir()
actually presents long filenames in an abbreviated form which encodes
a strong “hash” of the ciphertext filename, along with the optional
filesystem-specific hash(es) needed for directory lookups.  This
allows the filesystem to still, with a high degree of confidence, map
the filename given in -&gt;lookup() back to a particular directory entry
that was previously listed by readdir().  See
struct fscrypt_nokey_name in the source for more details.</p>
<p>Note that the precise way that filenames are presented to userspace
without the key is subject to change in the future.  It is only meant
as a way to temporarily present valid filenames so that commands like
<code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-r</span></code> work as expected on encrypted directories.</p>
</div>
</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>To test fscrypt, use xfstests, which is Linux’s de facto standard
filesystem test suite.  First, run all the tests in the “encrypt”
group on the relevant filesystem(s).  One can also run the tests
with the ‘inlinecrypt’ mount option to test the implementation for
inline encryption support.  For example, to test ext4 and
f2fs encryption using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/kvm-quickstart.md">kvm-xfstests</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4,f2fs -g encrypt
kvm-xfstests -c ext4,f2fs -g encrypt -m inlinecrypt
</pre></div>
</div>
<p>UBIFS encryption can also be tested this way, but it should be done in
a separate command, and it takes some time for kvm-xfstests to set up
emulated UBI volumes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ubifs -g encrypt
</pre></div>
</div>
<p>No tests should fail.  However, tests that use non-default encryption
modes (e.g. generic/549 and generic/550) will be skipped if the needed
algorithms were not built into the kernel’s crypto API.  Also, tests
that access the raw block device (e.g. generic/399, generic/548,
generic/549, generic/550) will be skipped on UBIFS.</p>
<p>Besides running the “encrypt” group tests, for ext4 and f2fs it’s also
possible to run most xfstests with the “test_dummy_encryption” mount
option.  This option causes all new files to be automatically
encrypted with a dummy key, without having to make any API calls.
This tests the encrypted I/O paths more thoroughly.  To do this with
kvm-xfstests, use the “encrypt” filesystem configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-xfstests -c ext4/encrypt,f2fs/encrypt -g auto
kvm-xfstests -c ext4/encrypt,f2fs/encrypt -g auto -m inlinecrypt
</pre></div>
</div>
<p>Because this runs many more tests than “-g encrypt” does, it takes
much longer to run; so also consider using <a class="reference external" href="https://github.com/tytso/xfstests-bld/blob/master/Documentation/gce-xfstests.md">gce-xfstests</a>
instead of kvm-xfstests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gce-xfstests -c ext4/encrypt,f2fs/encrypt -g auto
gce-xfstests -c ext4/encrypt,f2fs/encrypt -g auto -m inlinecrypt
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="fsverity.html" class="btn btn-neutral float-right" title="fs-verity: read-only file-based authenticity protection" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="journalling.html" class="btn btn-neutral float-left" title="The Linux Journalling API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>